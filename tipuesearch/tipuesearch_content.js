var tipuesearch = {"pages":[{"title":" CABLE ","text":"CABLE The Community Atmosphere Biosphere Land Exchange (CABLE) model is developed by a community of users under the CSIRO - MIT BSD license. In particular, CABLE is used as the land surface model for the ACCESS coupled climate model supported in Australia for the Australian research community. Developer Info CABLE community","tags":"home","loc":"index.html"},{"title":"soilin_type – CABLE ","text":"type, public :: soilin_type Contents Variables desc silt clay sand swilt sfc ssat bch hyds sucs rhosoil css c3 Components Type Visibility Attributes Name Initial character(len=70), public :: desc (nsoil_max) real, public, DIMENSION(nsoil_max) :: silt real, public, DIMENSION(nsoil_max) :: clay real, public, DIMENSION(nsoil_max) :: sand real, public, DIMENSION(nsoil_max) :: swilt real, public, DIMENSION(nsoil_max) :: sfc real, public, DIMENSION(nsoil_max) :: ssat real, public, DIMENSION(nsoil_max) :: bch real, public, DIMENSION(nsoil_max) :: hyds real, public, DIMENSION(nsoil_max) :: sucs real, public, DIMENSION(nsoil_max) :: rhosoil real, public, DIMENSION(nsoil_max) :: css real, public, DIMENSION(nsoil_max) :: c3","tags":"","loc":"type/soilin_type.html"},{"title":"CRU_MET_TYPE – CABLE ","text":"type, public :: CRU_MET_TYPE Contents Variables METVALS Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), ALLOCATABLE :: METVALS","tags":"","loc":"type/cru_met_type.html"},{"title":"CRU_TYPE – CABLE ","text":"type, public :: CRU_TYPE Contents Variables mland NMET xdimsize ydimsize tdimsize CYEAR MetStart MetEnd CTSTEP DTsecs ktau F_ID V_ID AVG_LWDN CO2VALS DirectRead LeapYears LandMask Run CO2 Ndep Forcing BasePath MetPath LandMaskFile VAR_NAME MetFile MET NdepVALS NdepF_ID NdepV_ID Ndep_CTSTEP Components Type Visibility Attributes Name Initial integer, public :: mland integer, public :: NMET integer, public :: xdimsize integer, public :: ydimsize integer, public :: tdimsize integer, public :: CYEAR integer, public :: MetStart integer, public :: MetEnd integer, public :: CTSTEP integer, public :: DTsecs integer, public :: ktau integer, public, DIMENSION(9) :: F_ID integer, public, DIMENSION(9) :: V_ID real, public, DIMENSION(:), ALLOCATABLE :: AVG_LWDN real, public, DIMENSION(:), ALLOCATABLE :: CO2VALS logical, public :: DirectRead logical, public :: LeapYears logical, public, DIMENSION(:,:), ALLOCATABLE :: LandMask character(len=30), public :: Run character(len=15), public :: CO2 character(len=15), public :: Ndep character(len=15), public :: Forcing character(len=200), public :: BasePath character(len=200), public :: MetPath character(len=200), public :: LandMaskFile character(len=30), public, DIMENSION(9) :: VAR_NAME character(len=200), public, DIMENSION(9) :: MetFile type( CRU_MET_TYPE ), public, DIMENSION(11) :: MET real, public, DIMENSION(:), ALLOCATABLE :: NdepVALS integer, public :: NdepF_ID integer, public :: NdepV_ID integer, public :: Ndep_CTSTEP","tags":"","loc":"type/cru_type.html"},{"title":"patch_type – CABLE ","text":"type, public :: patch_type Contents Variables frac latitude longitude Components Type Visibility Attributes Name Initial real, public :: frac real, public :: latitude real, public :: longitude","tags":"","loc":"type/patch_type.html"},{"title":"land_type – CABLE ","text":"type, public :: land_type Contents Variables nap cstart cend ilat ilon Components Type Visibility Attributes Name Initial integer, public :: nap integer, public :: cstart integer, public :: cend integer, public :: ilat integer, public :: ilon","tags":"","loc":"type/land_type.html"},{"title":"globalMet_type – CABLE ","text":"type, public :: globalMet_type Contents Variables l_gpcc l_gswp l_ncar l_access rainf snowf LWdown SWdown PSurf Qair Tair wind Components Type Visibility Attributes Name Initial logical, public :: l_gpcc logical, public :: l_gswp logical, public :: l_ncar logical, public :: l_access character(len=99), public :: rainf character(len=99), public :: snowf character(len=99), public :: LWdown character(len=99), public :: SWdown character(len=99), public :: PSurf character(len=99), public :: Qair character(len=99), public :: Tair character(len=99), public :: wind","tags":"","loc":"type/globalmet_type.html"},{"title":"gswp_type – CABLE ","text":"type, public :: gswp_type Contents Variables rainf snowf LWdown SWdown PSurf Qair Tair wind mask Components Type Visibility Attributes Name Initial character(len=200), public :: rainf character(len=200), public :: snowf character(len=200), public :: LWdown character(len=200), public :: SWdown character(len=200), public :: PSurf character(len=200), public :: Qair character(len=200), public :: Tair character(len=200), public :: wind character(len=200), public :: mask","tags":"","loc":"type/gswp_type.html"},{"title":"parID_type – CABLE ","text":"type, public :: parID_type Contents Variables bch latitude clay css rhosoil hyds rs20 sand sfc silt ssat sucs swilt froot zse canst1 dleaf meth za_tq za_uv ejmax frac4 hc lai rp20 rpcoef shelrb vbeta xalbnir vcmax xfang ratecp ratecs refsbare isoil iveg albsoil taul refl tauw refw wai vegcf extkn tminvj tmaxvj veg_class soil_class mvtype mstype patchfrac WatSat GWWatSat SoilMatPotSat GWSoilMatPotSat HkSat GWHkSat FrcSand FrcClay Clappb Watr GWWatr sfc_vec forg swilt_vec slope slope_std GWdz SatFracmax Qhmax QhmaxEfold HKefold HKdepth ishorizon nhorizons clitt zeta fsatmax gamma ZR F10 g0 g1 Components Type Visibility Attributes Name Initial integer, public :: bch integer, public :: latitude integer, public :: clay integer, public :: css integer, public :: rhosoil integer, public :: hyds integer, public :: rs20 integer, public :: sand integer, public :: sfc integer, public :: silt integer, public :: ssat integer, public :: sucs integer, public :: swilt integer, public :: froot integer, public :: zse integer, public :: canst1 integer, public :: dleaf integer, public :: meth integer, public :: za_tq integer, public :: za_uv integer, public :: ejmax integer, public :: frac4 integer, public :: hc integer, public :: lai integer, public :: rp20 integer, public :: rpcoef integer, public :: shelrb integer, public :: vbeta integer, public :: xalbnir integer, public :: vcmax integer, public :: xfang integer, public :: ratecp integer, public :: ratecs integer, public :: refsbare integer, public :: isoil integer, public :: iveg integer, public :: albsoil integer, public :: taul integer, public :: refl integer, public :: tauw integer, public :: refw integer, public :: wai integer, public :: vegcf integer, public :: extkn integer, public :: tminvj integer, public :: tmaxvj integer, public :: veg_class integer, public :: soil_class integer, public :: mvtype integer, public :: mstype integer, public :: patchfrac integer, public :: WatSat integer, public :: GWWatSat integer, public :: SoilMatPotSat integer, public :: GWSoilMatPotSat integer, public :: HkSat integer, public :: GWHkSat integer, public :: FrcSand integer, public :: FrcClay integer, public :: Clappb integer, public :: Watr integer, public :: GWWatr integer, public :: sfc_vec integer, public :: forg integer, public :: swilt_vec integer, public :: slope integer, public :: slope_std integer, public :: GWdz integer, public :: SatFracmax integer, public :: Qhmax integer, public :: QhmaxEfold integer, public :: HKefold integer, public :: HKdepth integer, public :: ishorizon integer, public :: nhorizons integer, public :: clitt integer, public :: zeta integer, public :: fsatmax integer, public :: gamma integer, public :: ZR integer, public :: F10 integer, public :: g0 integer, public :: g1","tags":"","loc":"type/parid_type.html"},{"title":"input_details_type – CABLE ","text":"type, public :: input_details_type Contents Variables Wind LWdown CO2air PSurf Snowf avPrecip LAI LAI_T LAI_M LAI_P parameters initial patch laiPatch Components Type Visibility Attributes Name Initial logical, public :: Wind logical, public :: LWdown logical, public :: CO2air logical, public :: PSurf logical, public :: Snowf logical, public :: avPrecip logical, public :: LAI logical, public :: LAI_T logical, public :: LAI_M logical, public :: LAI_P logical, public :: parameters logical, public :: initial logical, public :: patch logical, public :: laiPatch","tags":"","loc":"type/input_details_type.html"},{"title":"output_inclusion_type – CABLE ","text":"type, public :: output_inclusion_type Contents Variables met flux radiation carbon soil snow veg params balances restart ensemble patch casa grid averaging interval SWdown LWdown Rainf Snowf PSurf Tair Qair Tscrn Tex Qscrn CO2air Wind Wind_N Wind_E LAI Qmom Qh Qle Qg SWnet LWnet Evap Ewater ESoil TVeg ECanop PotEvap ACond SoilWet Albedo visAlbedo nirAlbedo VegT SoilTemp SoilMoist SoilMoistIce Qs Qsb DelSoilMoist DelSWE DelIntercept SnowT BaresoilT AvgSurfT RadT SWE SnowMelt RootMoist CanopInt NEE NPP GPP AutoResp LeafResp HeteroResp SnowDepth Rnet HVeg HSoil RnetSoil Ebal Wbal CanT Fwsoil Area GWMoist WatTable Qrecharge SatFrac NBP dCdt TotSoilCarb TotLivBiomass TotLittCarb SoilCarbFast SoilCarbSlow SoilCarbPassive LittCarbMetabolic LittCarbStructural LittCarbCWD PlantCarbLeaf PlantCarbFineRoot PlantCarbWood PlantTurnover PlantTurnoverLeaf PlantTurnoverFineRoot PlantTurnoverWood PlantTurnoverWoodDist PlantTurnoverWoodCrowding PlantTurnoverWoodResourceLim LandUseFlux bch latitude clay css rhosoil hyds rs20 sand sfc silt ssat sucs swilt froot zse canst1 dleaf ejmax frac4 hc rp20 g0 g1 rpcoef shelrb vcmax xfang wai vegcf extkn ratecp ratecs albsoil taul refl tminvj tmaxvj vbeta xalbnir iveg patchfrac isoil meth za slope slope_std GWdz SatFracmax Qhmax QhmaxEfold HKefold HKdepth Components Type Visibility Attributes Name Initial logical, public :: met = .FALSE. vh_js !! logical, public :: flux = .FALSE. vh_js !! logical, public :: radiation = .FALSE. vh_js !! logical, public :: carbon = .FALSE. vh_js !! logical, public :: soil = .FALSE. vh_js !! logical, public :: snow = .FALSE. vh_js !! logical, public :: veg = .FALSE. vh_js !! logical, public :: params = .FALSE. vh_js !! logical, public :: balances = .FALSE. vh_js !! logical, public :: restart = .FALSE. vh_js !! logical, public :: ensemble = .FALSE. vh_js !! logical, public :: patch = .FALSE. vh_js !! logical, public :: casa = .FALSE. vh_js !! character(len=7), public :: grid = 'default' character(len=7), public :: averaging = 'all' integer, public :: interval logical, public :: SWdown = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LWdown = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Rainf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Snowf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PSurf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Tair = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qair = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Tscrn = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Tex = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qscrn = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: CO2air = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Wind = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Wind_N = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Wind_E = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LAI = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qmom = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qh = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qle = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qg = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SWnet = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LWnet = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Evap = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Ewater = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ESoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: TVeg = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ECanop = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PotEvap = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ACond = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilWet = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Albedo = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: visAlbedo = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: nirAlbedo = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: VegT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilTemp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilMoist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilMoistIce = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qs = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qsb = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: DelSoilMoist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: DelSWE = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: DelIntercept = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SnowT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: BaresoilT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: AvgSurfT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: RadT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SWE = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SnowMelt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: RootMoist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: CanopInt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: NEE = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: NPP = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: GPP = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: AutoResp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LeafResp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HeteroResp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SnowDepth = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Rnet = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HVeg = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HSoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: RnetSoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Ebal = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Wbal = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: CanT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Fwsoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Area = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: GWMoist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: WatTable = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qrecharge = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SatFrac = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: NBP = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: dCdt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: TotSoilCarb = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: TotLivBiomass = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: TotLittCarb = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilCarbFast = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilCarbSlow = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilCarbPassive = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LittCarbMetabolic = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LittCarbStructural = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LittCarbCWD = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantCarbLeaf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantCarbFineRoot = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantCarbWood = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnover = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverLeaf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverFineRoot = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverWood = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverWoodDist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverWoodCrowding = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverWoodResourceLim = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LandUseFlux = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: bch = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: latitude = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: clay = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: css = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: rhosoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: hyds = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: rs20 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: sand = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: sfc = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: silt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ssat = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: sucs = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: swilt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: froot = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: zse = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: canst1 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: dleaf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ejmax = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: frac4 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: hc = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: rp20 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: g0 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: g1 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: rpcoef = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: shelrb = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: vcmax = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: xfang = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: wai = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: vegcf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: extkn = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ratecp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ratecs = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: albsoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: taul = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: refl = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: tminvj = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: tmaxvj = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: vbeta = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: xalbnir = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: iveg = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: patchfrac = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: isoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: meth = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: za = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: slope = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: slope_std = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: GWdz = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SatFracmax = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qhmax = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: QhmaxEfold = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HKefold = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HKdepth vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables","tags":"","loc":"type/output_inclusion_type.html"},{"title":"checks_type – CABLE ","text":"type, public :: checks_type Contents Variables ranges energy_bal mass_bal Components Type Visibility Attributes Name Initial logical, public :: ranges logical, public :: energy_bal logical, public :: mass_bal","tags":"","loc":"type/checks_type.html"},{"title":"vegin_type – CABLE ","text":"type, public :: vegin_type Contents Variables desc canst1 length width vcmax ejmax hc xfang rp20 rpcoef rs20 wai rootbeta shelrb vegcf frac4 xalbnir extkn tminvj tmaxvj vbeta a1gs d0gs alpha convex cfrd gswmin conkc0 conko0 ekc eko g0 g1 zr clitt froot1 froot2 froot3 froot4 froot5 froot6 csoil1 csoil2 ratecs1 ratecs2 cplant1 cplant2 cplant3 ratecp1 ratecp2 ratecp3 refl1 refl2 refl3 taul1 taul2 taul3 dleaf lai Components Type Visibility Attributes Name Initial character(len=70), public :: desc (ntype_max) real, public :: canst1 (ntype_max) real, public :: length (ntype_max) real, public :: width (ntype_max) real, public :: vcmax (ntype_max) real, public :: ejmax (ntype_max) real, public :: hc (ntype_max) real, public :: xfang (ntype_max) real, public :: rp20 (ntype_max) real, public :: rpcoef (ntype_max) real, public :: rs20 (ntype_max) real, public :: wai (ntype_max) real, public :: rootbeta (ntype_max) real, public :: shelrb (ntype_max) real, public :: vegcf (ntype_max) real, public :: frac4 (ntype_max) real, public :: xalbnir (ntype_max) real, public :: extkn (ntype_max) real, public :: tminvj (ntype_max) real, public :: tmaxvj (ntype_max) real, public :: vbeta (ntype_max) real, public :: a1gs (ntype_max) real, public :: d0gs (ntype_max) real, public :: alpha (ntype_max) real, public :: convex (ntype_max) real, public :: cfrd (ntype_max) real, public :: gswmin (ntype_max) real, public :: conkc0 (ntype_max) real, public :: conko0 (ntype_max) real, public :: ekc (ntype_max) real, public :: eko (ntype_max) real, public :: g0 (ntype_max) real, public :: g1 (ntype_max) real, public :: zr (ntype_max) real, public :: clitt (ntype_max) real, public :: froot1 (ntype_max) real, public :: froot2 (ntype_max) real, public :: froot3 (ntype_max) real, public :: froot4 (ntype_max) real, public :: froot5 (ntype_max) real, public :: froot6 (ntype_max) real, public :: csoil1 (ntype_max) real, public :: csoil2 (ntype_max) real, public :: ratecs1 (ntype_max) real, public :: ratecs2 (ntype_max) real, public :: cplant1 (ntype_max) real, public :: cplant2 (ntype_max) real, public :: cplant3 (ntype_max) real, public :: ratecp1 (ntype_max) real, public :: ratecp2 (ntype_max) real, public :: ratecp3 (ntype_max) real, public :: refl1 (ntype_max) real, public :: refl2 (ntype_max) real, public :: refl3 (ntype_max) real, public :: taul1 (ntype_max) real, public :: taul2 (ntype_max) real, public :: taul3 (ntype_max) real, public :: dleaf (ntype_max) real, public :: lai (ntype_max)","tags":"","loc":"type/vegin_type.html"},{"title":"input_netcdf_names – CABLE ","text":"type, public :: input_netcdf_names Contents Variables LatNames LonNames MaskNames TimeNames SWdownNames TairNames QairNames WindNames RainNames LWdownNames PSurfNames ElevNames CO2Names SnowNames LAINames APrecipNames IVegNames PFracNames ISoilNames Components Type Visibility Attributes Name Initial character(len=8), public, DIMENSION(3) :: LatNames = (/'latitude', 'nav_lat ', 'lat     '/) character(len=9), public, DIMENSION(3) :: LonNames = (/'longitude', 'nav_lon  ', 'lon      '/) character(len=7), public, DIMENSION(2) :: MaskNames = (/'mask   ', 'landsea'/) character(len=4), public, DIMENSION(1) :: TimeNames = (/'time'/) character(len=6), public, DIMENSION(4) :: SWdownNames = (/'dswrf ', 'rsds  ', 'FSDS  ', 'SWdown'/) character(len=4), public, DIMENSION(3) :: TairNames = (/'tas ', 'TBOT', 'Tair'/) character(len=4), public, DIMENSION(4) :: QairNames = (/'shum', 'huss', 'QBOT', 'Qair'/) character(len=4), public, DIMENSION(3) :: WindNames = (/'wind', 'Wind', 'WIND'/) character(len=8), public, DIMENSION(5) :: RainNames = (/'prcp    ', 'pr      ', 'RAIN    ', 'Rainf   ', 'Precip  '/) character(len=6), public, DIMENSION(4) :: LWdownNames = (/'dlwrf ', 'rlds  ', 'FLDS  ', 'LWdown'/) character(len=5), public, DIMENSION(5) :: PSurfNames = (/'pres ', 'ps   ', 'PBOT ', 'PSurf', 'Psurf'/) character(len=9), public, DIMENSION(1) :: ElevNames = (/'Elevation'/) character(len=6), public, DIMENSION(1) :: CO2Names = (/'CO2air'/) character(len=5), public, DIMENSION(1) :: SnowNames = (/'Snowf'/) character(len=3), public, DIMENSION(1) :: LAINames = (/'LAI'/) character(len=8), public, DIMENSION(1) :: APrecipNames = (/'avPrecip'/) character(len=4), public, DIMENSION(1) :: IVegNames = (/'iveg'/) character(len=9), public, DIMENSION(1) :: PFracNames = (/'patchfrac'/) character(len=5), public, DIMENSION(1) :: ISoilNames = (/'isoil'/)","tags":"","loc":"type/input_netcdf_names.html"},{"title":"site_TYPE – CABLE ","text":"type, public :: site_TYPE Contents Variables RunType CO2VALS NdepVALS PdepVALS mland CO2NdepFile spinstartyear spinendyear spinCO2 spinNdep spinPdep CO2 Ndep Pdep Components Type Visibility Attributes Name Initial character(len=15), public :: RunType real, public, DIMENSION(:), ALLOCATABLE :: CO2VALS real, public, DIMENSION(:), ALLOCATABLE :: NdepVALS real, public, DIMENSION(:), ALLOCATABLE :: PdepVALS integer, public :: mland character(len=200), public :: CO2NdepFile integer, public :: spinstartyear integer, public :: spinendyear real, public :: spinCO2 real, public :: spinNdep real, public :: spinPdep real, public :: CO2 real, public :: Ndep real, public :: Pdep","tags":"","loc":"type/site_type.html"},{"title":"WEATHER_GENERATOR_TYPE – CABLE ","text":"type, public :: WEATHER_GENERATOR_TYPE Contents Variables np ndtime delT LatDeg WindDay TempMinDay TempMaxDay TempMinDayNext TempMaxDayPrev SolarMJDay DecRad WindDark WindLite SolarNorm LatRad DayLength TimeSunsetPrev TimeSunrise TimeMaxTemp TimeSunset TempSunsetPrev TempSunset TempNightRate TempNightRatePrev TempRangeDay TempRangeAft PrecipDay SnowDay PmbDay PhiSd PhiLd Precip Snow Wind Temp VapPmb Pmb coszen Components Type Visibility Attributes Name Initial integer, public :: np integer, public :: ndtime real, public :: delT real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: LatDeg real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: WindDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempMinDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempMaxDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempMinDayNext real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempMaxDayPrev real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: SolarMJDay real(kind=sp), public :: DecRad real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: WindDark real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: WindLite real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: SolarNorm real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: LatRad real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: DayLength real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TimeSunsetPrev real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TimeSunrise real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TimeMaxTemp real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TimeSunset real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempSunsetPrev real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempSunset real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempNightRate real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempNightRatePrev real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempRangeDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempRangeAft real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: PrecipDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: SnowDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: PmbDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: PhiSd real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: PhiLd real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Precip real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Snow real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Wind real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Temp real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: VapPmb real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Pmb real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: coszen","tags":"","loc":"type/weather_generator_type.html"},{"title":"PLUME_MET_TYPE – CABLE ","text":"type, public :: PLUME_MET_TYPE Contents Variables VAL Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), ALLOCATABLE :: VAL","tags":"","loc":"type/plume_met_type.html"},{"title":"PLUME_MIP_TYPE – CABLE ","text":"type, public :: PLUME_MIP_TYPE Contents Variables mland NMET xdimsize ydimsize tdimsize CYEAR MetStart MetEnd CTSTEP DT ktau F_ID V_ID AVG_LWDN CO2VALS DirectRead LeapYears LandMask Run Forcing RCP CO2 NDEP RCPdir BasePath MetPath LandMaskFile VAR_NAME MetFile MET Components Type Visibility Attributes Name Initial integer, public :: mland integer, public :: NMET integer, public :: xdimsize integer, public :: ydimsize integer, public :: tdimsize integer, public :: CYEAR integer, public :: MetStart integer, public :: MetEnd integer, public :: CTSTEP integer, public :: DT integer, public :: ktau integer, public, DIMENSION(9) :: F_ID integer, public, DIMENSION(9) :: V_ID real, public, DIMENSION(:), ALLOCATABLE :: AVG_LWDN real, public, DIMENSION(:), ALLOCATABLE :: CO2VALS logical, public :: DirectRead logical, public :: LeapYears logical, public, DIMENSION(:,:), ALLOCATABLE :: LandMask character(len=15), public :: Run character(len=15), public :: Forcing character(len=15), public :: RCP character(len=15), public :: CO2 character(len=15), public :: NDEP character(len=15), public :: RCPdir character(len=200), public :: BasePath character(len=200), public :: MetPath character(len=200), public :: LandMaskFile character(len=12), public, DIMENSION(9) :: VAR_NAME character(len=200), public, DIMENSION(9) :: MetFile type( PLUME_MET_TYPE ), public, DIMENSION(11) :: MET","tags":"","loc":"type/plume_mip_type.html"},{"title":"lpdecomp_t – CABLE ","text":"type, public :: lpdecomp_t Contents Variables landp0 nland patch0 npatch npop_iwood iwood Components Type Visibility Attributes Name Initial integer, public :: landp0 integer, public :: nland integer, public :: patch0 integer, public :: npatch integer, public :: npop_iwood integer, public, ALLOCATABLE :: iwood (:)","tags":"","loc":"type/lpdecomp_t.html"},{"title":"balances_type – CABLE ","text":"type, public :: balances_type Contents Variables drybal ebal ebal_tot ebal_cncheck ebal_tot_cncheck ebaltr ebal_tottr evap_tot osnowd0 precip_tot rnoff_tot wbal wbal_tot wbtot0 wetbal cansto0 owbtot evapc_tot evaps_tot rnof1_tot rnof2_tot snowdc_tot wbal_tot1 delwc_tot qasrf_tot qfsrf_tot qssrf_tot Radbal EbalSoil Ebalveg Radbalsum Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: drybal real, public, DIMENSION(:), POINTER :: ebal real, public, DIMENSION(:), POINTER :: ebal_tot real, public, DIMENSION(:), POINTER :: ebal_cncheck real, public, DIMENSION(:), POINTER :: ebal_tot_cncheck real, public, DIMENSION(:), POINTER :: ebaltr real, public, DIMENSION(:), POINTER :: ebal_tottr real, public, DIMENSION(:), POINTER :: evap_tot real, public, DIMENSION(:), POINTER :: osnowd0 real, public, DIMENSION(:), POINTER :: precip_tot real, public, DIMENSION(:), POINTER :: rnoff_tot real, public, DIMENSION(:), POINTER :: wbal real, public, DIMENSION(:), POINTER :: wbal_tot real, public, DIMENSION(:), POINTER :: wbtot0 real, public, DIMENSION(:), POINTER :: wetbal real, public, DIMENSION(:), POINTER :: cansto0 real, public, DIMENSION(:), POINTER :: owbtot real, public, DIMENSION(:), POINTER :: evapc_tot real, public, DIMENSION(:), POINTER :: evaps_tot real, public, DIMENSION(:), POINTER :: rnof1_tot real, public, DIMENSION(:), POINTER :: rnof2_tot real, public, DIMENSION(:), POINTER :: snowdc_tot real, public, DIMENSION(:), POINTER :: wbal_tot1 real, public, DIMENSION(:), POINTER :: delwc_tot real, public, DIMENSION(:), POINTER :: qasrf_tot real, public, DIMENSION(:), POINTER :: qfsrf_tot real, public, DIMENSION(:), POINTER :: qssrf_tot real, public, DIMENSION(:), POINTER :: Radbal real, public, DIMENSION(:), POINTER :: EbalSoil real, public, DIMENSION(:), POINTER :: Ebalveg real, public, DIMENSION(:), POINTER :: Radbalsum","tags":"","loc":"type/balances_type.html"},{"title":"soil_parameter_type – CABLE ","text":"type, public :: soil_parameter_type Contents Variables isoilm bch c3 clay css hsbh hyds i2bp3 ibp2 rhosoil sand sfc silt ssat sucs swilt zse zshh soilcol albsoilf heat_cap_lower_limit zse_vec css_vec cnsd_vec cnsd pwb_min albsoil sucs_vec hyds_vec bch_vec clay_vec sand_vec silt_vec org_vec rhosoil_vec ssat_vec watr sfc_vec swilt_vec drain_dens elev elev_std slope slope_std GWsucs_vec GWhyds_vec GWbch_vec GWssat_vec GWwatr GWz GWdz GWrhosoil_vec nhorizons ishorizon clitt zeta fsatmax Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), POINTER :: isoilm real, public, DIMENSION(:), POINTER :: bch real, public, DIMENSION(:), POINTER :: c3 real, public, DIMENSION(:), POINTER :: clay real, public, DIMENSION(:), POINTER :: css real, public, DIMENSION(:), POINTER :: hsbh real, public, DIMENSION(:), POINTER :: hyds real, public, DIMENSION(:), POINTER :: i2bp3 real, public, DIMENSION(:), POINTER :: ibp2 real, public, DIMENSION(:), POINTER :: rhosoil real, public, DIMENSION(:), POINTER :: sand real, public, DIMENSION(:), POINTER :: sfc real, public, DIMENSION(:), POINTER :: silt real, public, DIMENSION(:), POINTER :: ssat real, public, DIMENSION(:), POINTER :: sucs real, public, DIMENSION(:), POINTER :: swilt real, public, DIMENSION(:), POINTER :: zse real, public, DIMENSION(:), POINTER :: zshh real, public, DIMENSION(:), POINTER :: soilcol real, public, DIMENSION(:), POINTER :: albsoilf real(kind=r_2), public, DIMENSION(:,:), POINTER :: heat_cap_lower_limit real(kind=r_2), public, DIMENSION(:,:), POINTER :: zse_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: css_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: cnsd_vec real(kind=r_2), public, DIMENSION(:), POINTER :: cnsd real(kind=r_2), public, DIMENSION(:), POINTER :: pwb_min real, public, DIMENSION(:,:), POINTER :: albsoil real(kind=r_2), public, DIMENSION(:,:), POINTER :: sucs_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: hyds_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: bch_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: clay_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: sand_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: silt_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: org_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: rhosoil_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: ssat_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: watr real(kind=r_2), public, DIMENSION(:,:), POINTER :: sfc_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: swilt_vec real(kind=r_2), public, DIMENSION(:), POINTER :: drain_dens real(kind=r_2), public, DIMENSION(:), POINTER :: elev real(kind=r_2), public, DIMENSION(:), POINTER :: elev_std real(kind=r_2), public, DIMENSION(:), POINTER :: slope real(kind=r_2), public, DIMENSION(:), POINTER :: slope_std real(kind=r_2), public, DIMENSION(:), POINTER :: GWsucs_vec real(kind=r_2), public, DIMENSION(:), POINTER :: GWhyds_vec real(kind=r_2), public, DIMENSION(:), POINTER :: GWbch_vec real(kind=r_2), public, DIMENSION(:), POINTER :: GWssat_vec real(kind=r_2), public, DIMENSION(:), POINTER :: GWwatr real(kind=r_2), public, DIMENSION(:), POINTER :: GWz real(kind=r_2), public, DIMENSION(:), POINTER :: GWdz real(kind=r_2), public, DIMENSION(:), POINTER :: GWrhosoil_vec integer, public, DIMENSION(:), POINTER :: nhorizons integer, public, DIMENSION(:,:), POINTER :: ishorizon real(kind=r_2), public, DIMENSION(:), POINTER :: clitt real(kind=r_2), public, DIMENSION(:), POINTER :: zeta real(kind=r_2), public, DIMENSION(:), POINTER :: fsatmax","tags":"","loc":"type/soil_parameter_type.html"},{"title":"soil_snow_type – CABLE ","text":"type, public :: soil_snow_type Contents Variables isflag iantrct pudsto pudsmx cls dfn_dtg dfh_dtg dfe_ddq ddq_dtg dfe_dtg evapsn fwtop fwtop1 fwtop2 fwtop3 osnowd potev runoff rnof1 rnof2 rtsoil wbtot1 wbtot2 wb_lake totwblake sinfil qstss wetfac owetfac t_snwlr tggav otgg otss otss_0 tprecip tevap trnoff totenbal totenbal2 fland ifland qasrf qfsrf qssrf snage snowd smelt ssdnn tss tss_p deltss owb1 sconds sdepth smass ssdn tgg tggsn dtmlt albsoilsn evapfbl tilefrac wbtot gammzz wb wbice wblf wbfice GWwb GWhk GWdhkdw GWdsmpdw wtd GWsmp GWwbeq GWzq qhz satfrac Qrecharge rh_srf rtevap_sat rtevap_unsat rt_qh_sublayer wbeq zq icefrac fracice hk smp dhkdw dsmpdw wbliq wmliq wmice wmtot qhlev S Tsoil SL TL h0 rex wflux delwcol zdelta kth Tsurface lE evap ciso cisoL rlitt thetai snowliq nsteps TsurfaceFR Ta_daily nsnow Qadv_daily G0_daily Qevap_daily Qprec_daily Qprec_snow_daily Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), POINTER :: isflag real, public, DIMENSION(:), POINTER :: iantrct real, public, DIMENSION(:), POINTER :: pudsto real, public, DIMENSION(:), POINTER :: pudsmx real, public, DIMENSION(:), POINTER :: cls real, public, DIMENSION(:), POINTER :: dfn_dtg real, public, DIMENSION(:), POINTER :: dfh_dtg real, public, DIMENSION(:), POINTER :: dfe_ddq real, public, DIMENSION(:), POINTER :: ddq_dtg real, public, DIMENSION(:), POINTER :: dfe_dtg real, public, DIMENSION(:), POINTER :: evapsn real, public, DIMENSION(:), POINTER :: fwtop real, public, DIMENSION(:), POINTER :: fwtop1 real, public, DIMENSION(:), POINTER :: fwtop2 real, public, DIMENSION(:), POINTER :: fwtop3 real, public, DIMENSION(:), POINTER :: osnowd real, public, DIMENSION(:), POINTER :: potev real, public, DIMENSION(:), POINTER :: runoff real, public, DIMENSION(:), POINTER :: rnof1 real, public, DIMENSION(:), POINTER :: rnof2 real, public, DIMENSION(:), POINTER :: rtsoil real, public, DIMENSION(:), POINTER :: wbtot1 real, public, DIMENSION(:), POINTER :: wbtot2 real, public, DIMENSION(:), POINTER :: wb_lake real, public, DIMENSION(:), POINTER :: totwblake real, public, DIMENSION(:), POINTER :: sinfil real, public, DIMENSION(:), POINTER :: qstss real, public, DIMENSION(:), POINTER :: wetfac real, public, DIMENSION(:), POINTER :: owetfac real, public, DIMENSION(:), POINTER :: t_snwlr real, public, DIMENSION(:), POINTER :: tggav real, public, DIMENSION(:), POINTER :: otgg real, public, DIMENSION(:), POINTER :: otss real, public, DIMENSION(:), POINTER :: otss_0 real, public, DIMENSION(:), POINTER :: tprecip real, public, DIMENSION(:), POINTER :: tevap real, public, DIMENSION(:), POINTER :: trnoff real, public, DIMENSION(:), POINTER :: totenbal real, public, DIMENSION(:), POINTER :: totenbal2 real, public, DIMENSION(:), POINTER :: fland real, public, DIMENSION(:), POINTER :: ifland real, public, DIMENSION(:), POINTER :: qasrf real, public, DIMENSION(:), POINTER :: qfsrf real, public, DIMENSION(:), POINTER :: qssrf real, public, DIMENSION(:), POINTER :: snage real, public, DIMENSION(:), POINTER :: snowd real, public, DIMENSION(:), POINTER :: smelt real, public, DIMENSION(:), POINTER :: ssdnn real, public, DIMENSION(:), POINTER :: tss real, public, DIMENSION(:), POINTER :: tss_p real, public, DIMENSION(:), POINTER :: deltss real, public, DIMENSION(:), POINTER :: owb1 real, public, DIMENSION(:,:), POINTER :: sconds real, public, DIMENSION(:,:), POINTER :: sdepth real, public, DIMENSION(:,:), POINTER :: smass real, public, DIMENSION(:,:), POINTER :: ssdn real, public, DIMENSION(:,:), POINTER :: tgg real, public, DIMENSION(:,:), POINTER :: tggsn real, public, DIMENSION(:,:), POINTER :: dtmlt real, public, DIMENSION(:,:), POINTER :: albsoilsn real, public, DIMENSION(:,:), POINTER :: evapfbl real, public, DIMENSION(:,:), POINTER :: tilefrac real(kind=r_2), public, DIMENSION(:), POINTER :: wbtot real(kind=r_2), public, DIMENSION(:,:), POINTER :: gammzz real(kind=r_2), public, DIMENSION(:,:), POINTER :: wb real(kind=r_2), public, DIMENSION(:,:), POINTER :: wbice real(kind=r_2), public, DIMENSION(:,:), POINTER :: wblf real(kind=r_2), public, DIMENSION(:,:), POINTER :: wbfice real(kind=r_2), public, DIMENSION(:), POINTER :: GWwb real(kind=r_2), public, DIMENSION(:), POINTER :: GWhk real(kind=r_2), public, DIMENSION(:), POINTER :: GWdhkdw real(kind=r_2), public, DIMENSION(:), POINTER :: GWdsmpdw real(kind=r_2), public, DIMENSION(:), POINTER :: wtd real(kind=r_2), public, DIMENSION(:), POINTER :: GWsmp real(kind=r_2), public, DIMENSION(:), POINTER :: GWwbeq real(kind=r_2), public, DIMENSION(:), POINTER :: GWzq real(kind=r_2), public, DIMENSION(:), POINTER :: qhz real(kind=r_2), public, DIMENSION(:), POINTER :: satfrac real(kind=r_2), public, DIMENSION(:), POINTER :: Qrecharge real(kind=r_2), public, DIMENSION(:), POINTER :: rh_srf real(kind=r_2), public, DIMENSION(:), POINTER :: rtevap_sat real(kind=r_2), public, DIMENSION(:), POINTER :: rtevap_unsat real(kind=r_2), public, DIMENSION(:), POINTER :: rt_qh_sublayer real(kind=r_2), public, DIMENSION(:,:), POINTER :: wbeq real(kind=r_2), public, DIMENSION(:,:), POINTER :: zq real(kind=r_2), public, DIMENSION(:,:), POINTER :: icefrac real(kind=r_2), public, DIMENSION(:,:), POINTER :: fracice real(kind=r_2), public, DIMENSION(:,:), POINTER :: hk real(kind=r_2), public, DIMENSION(:,:), POINTER :: smp real(kind=r_2), public, DIMENSION(:,:), POINTER :: dhkdw real(kind=r_2), public, DIMENSION(:,:), POINTER :: dsmpdw real(kind=r_2), public, DIMENSION(:,:), POINTER :: wbliq real(kind=r_2), public, DIMENSION(:,:), POINTER :: wmliq real(kind=r_2), public, DIMENSION(:,:), POINTER :: wmice real(kind=r_2), public, DIMENSION(:,:), POINTER :: wmtot real(kind=r_2), public, DIMENSION(:,:), POINTER :: qhlev real(kind=r_2), public, DIMENSION(:,:), POINTER :: S real(kind=r_2), public, DIMENSION(:,:), POINTER :: Tsoil real(kind=r_2), public, DIMENSION(:), POINTER :: SL real(kind=r_2), public, DIMENSION(:), POINTER :: TL real(kind=r_2), public, DIMENSION(:), POINTER :: h0 real(kind=r_2), public, DIMENSION(:,:), POINTER :: rex real(kind=r_2), public, DIMENSION(:,:), POINTER :: wflux real(kind=r_2), public, DIMENSION(:), POINTER :: delwcol real(kind=r_2), public, DIMENSION(:), POINTER :: zdelta real(kind=r_2), public, DIMENSION(:,:), POINTER :: kth real(kind=r_2), public, DIMENSION(:), POINTER :: Tsurface real(kind=r_2), public, DIMENSION(:), POINTER :: lE real(kind=r_2), public, DIMENSION(:), POINTER :: evap real(kind=r_2), public, DIMENSION(:,:), POINTER :: ciso real(kind=r_2), public, DIMENSION(:), POINTER :: cisoL real(kind=r_2), public, DIMENSION(:), POINTER :: rlitt real(kind=r_2), public, DIMENSION(:,:), POINTER :: thetai real(kind=r_2), public, DIMENSION(:,:), POINTER :: snowliq real(kind=r_2), public, DIMENSION(:), POINTER :: nsteps real(kind=r_2), public, DIMENSION(:), POINTER :: TsurfaceFR real(kind=r_2), public, DIMENSION(:,:), POINTER :: Ta_daily integer, public, DIMENSION(:), POINTER :: nsnow real(kind=r_2), public, DIMENSION(:), POINTER :: Qadv_daily real(kind=r_2), public, DIMENSION(:), POINTER :: G0_daily real(kind=r_2), public, DIMENSION(:), POINTER :: Qevap_daily real(kind=r_2), public, DIMENSION(:), POINTER :: Qprec_daily real(kind=r_2), public, DIMENSION(:), POINTER :: Qprec_snow_daily","tags":"","loc":"type/soil_snow_type.html"},{"title":"veg_parameter_type – CABLE ","text":"type, public :: veg_parameter_type Contents Variables iveg iLU canst1 dleaf ejmax meth frac4 hc vlai xalbnir rp20 rpcoef rs20 shelrb vegcf tminvj toptvj tmaxvj vbeta vcmax xfang extkn vlaimax wai a1gs d0gs alpha convex cfrd gswmin conkc0 conko0 ekc eko g0 g1 deciduous refl taul froot rootbeta gamma ZR F10 clitt disturbance_interval disturbance_intensity Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), POINTER :: iveg integer, public, DIMENSION(:), POINTER :: iLU real, public, DIMENSION(:), POINTER :: canst1 real, public, DIMENSION(:), POINTER :: dleaf real, public, DIMENSION(:), POINTER :: ejmax real, public, DIMENSION(:), POINTER :: meth real, public, DIMENSION(:), POINTER :: frac4 real, public, DIMENSION(:), POINTER :: hc real, public, DIMENSION(:), POINTER :: vlai real, public, DIMENSION(:), POINTER :: xalbnir real, public, DIMENSION(:), POINTER :: rp20 real, public, DIMENSION(:), POINTER :: rpcoef real, public, DIMENSION(:), POINTER :: rs20 real, public, DIMENSION(:), POINTER :: shelrb real, public, DIMENSION(:), POINTER :: vegcf real, public, DIMENSION(:), POINTER :: tminvj real, public, DIMENSION(:), POINTER :: toptvj real, public, DIMENSION(:), POINTER :: tmaxvj real, public, DIMENSION(:), POINTER :: vbeta real, public, DIMENSION(:), POINTER :: vcmax real, public, DIMENSION(:), POINTER :: xfang real, public, DIMENSION(:), POINTER :: extkn real, public, DIMENSION(:), POINTER :: vlaimax real, public, DIMENSION(:), POINTER :: wai real, public, DIMENSION(:), POINTER :: a1gs real, public, DIMENSION(:), POINTER :: d0gs real, public, DIMENSION(:), POINTER :: alpha real, public, DIMENSION(:), POINTER :: convex real, public, DIMENSION(:), POINTER :: cfrd real, public, DIMENSION(:), POINTER :: gswmin real, public, DIMENSION(:), POINTER :: conkc0 real, public, DIMENSION(:), POINTER :: conko0 real, public, DIMENSION(:), POINTER :: ekc real, public, DIMENSION(:), POINTER :: eko real, public, DIMENSION(:), POINTER :: g0 real, public, DIMENSION(:), POINTER :: g1 logical, public, DIMENSION(:), POINTER :: deciduous real, public, DIMENSION(:,:), POINTER :: refl real, public, DIMENSION(:,:), POINTER :: taul real, public, DIMENSION(:,:), POINTER :: froot real(kind=r_2), public, DIMENSION(:), POINTER :: rootbeta real(kind=r_2), public, DIMENSION(:), POINTER :: gamma real(kind=r_2), public, DIMENSION(:), POINTER :: ZR real(kind=r_2), public, DIMENSION(:), POINTER :: F10 real(kind=r_2), public, DIMENSION(:), POINTER :: clitt integer, public, DIMENSION(:,:), POINTER :: disturbance_interval real(kind=r_2), public, DIMENSION(:,:), POINTER :: disturbance_intensity","tags":"","loc":"type/veg_parameter_type.html"},{"title":"canopy_type – CABLE ","text":"type, public :: canopy_type Contents Variables cansto cduv delwc dewmm fe fh fpn frp frpw frpr frs fnee frday fnv fev epot fnpp fevw_pot gswx_T cdtq wetfac_cs fevw fhvw oldcansto fhv fns fhs fhs_cor ga ghflux precis qscrn rnet rniso segg sghflux through through_sn spill tscrn wcint tv us uscrn vlaiw rghlai fwet fns_cor ga_cor evapfbl gswx zetar zetash fess fesp dgdtg fes fes_cor fevc ofes sublayer_dz gw ancj tlfy ecy ecx ci fwsoil kthLitt DvLitt Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: cansto real, public, DIMENSION(:), POINTER :: cduv real, public, DIMENSION(:), POINTER :: delwc real, public, DIMENSION(:), POINTER :: dewmm real, public, DIMENSION(:), POINTER :: fe real, public, DIMENSION(:), POINTER :: fh real, public, DIMENSION(:), POINTER :: fpn real, public, DIMENSION(:), POINTER :: frp real, public, DIMENSION(:), POINTER :: frpw real, public, DIMENSION(:), POINTER :: frpr real, public, DIMENSION(:), POINTER :: frs real, public, DIMENSION(:), POINTER :: fnee real, public, DIMENSION(:), POINTER :: frday real, public, DIMENSION(:), POINTER :: fnv real, public, DIMENSION(:), POINTER :: fev real, public, DIMENSION(:), POINTER :: epot real, public, DIMENSION(:), POINTER :: fnpp real, public, DIMENSION(:), POINTER :: fevw_pot real, public, DIMENSION(:), POINTER :: gswx_T real, public, DIMENSION(:), POINTER :: cdtq real, public, DIMENSION(:), POINTER :: wetfac_cs real, public, DIMENSION(:), POINTER :: fevw real, public, DIMENSION(:), POINTER :: fhvw real, public, DIMENSION(:), POINTER :: oldcansto real, public, DIMENSION(:), POINTER :: fhv real, public, DIMENSION(:), POINTER :: fns real, public, DIMENSION(:), POINTER :: fhs real, public, DIMENSION(:), POINTER :: fhs_cor real, public, DIMENSION(:), POINTER :: ga real, public, DIMENSION(:), POINTER :: ghflux real, public, DIMENSION(:), POINTER :: precis real, public, DIMENSION(:), POINTER :: qscrn real, public, DIMENSION(:), POINTER :: rnet real, public, DIMENSION(:), POINTER :: rniso real, public, DIMENSION(:), POINTER :: segg real, public, DIMENSION(:), POINTER :: sghflux real, public, DIMENSION(:), POINTER :: through real, public, DIMENSION(:), POINTER :: through_sn real, public, DIMENSION(:), POINTER :: spill real, public, DIMENSION(:), POINTER :: tscrn real, public, DIMENSION(:), POINTER :: wcint real, public, DIMENSION(:), POINTER :: tv real, public, DIMENSION(:), POINTER :: us real, public, DIMENSION(:), POINTER :: uscrn real, public, DIMENSION(:), POINTER :: vlaiw real, public, DIMENSION(:), POINTER :: rghlai real, public, DIMENSION(:), POINTER :: fwet real, public, DIMENSION(:), POINTER :: fns_cor real, public, DIMENSION(:), POINTER :: ga_cor real, public, DIMENSION(:,:), POINTER :: evapfbl vh_js !! real, public, DIMENSION(:,:), POINTER :: gswx vh_js !! real, public, DIMENSION(:,:), POINTER :: zetar vh_js !! real, public, DIMENSION(:,:), POINTER :: zetash vh_js !! real(kind=r_2), public, DIMENSION(:), POINTER :: fess real(kind=r_2), public, DIMENSION(:), POINTER :: fesp real(kind=r_2), public, DIMENSION(:), POINTER :: dgdtg real(kind=r_2), public, DIMENSION(:), POINTER :: fes real(kind=r_2), public, DIMENSION(:), POINTER :: fes_cor real(kind=r_2), public, DIMENSION(:), POINTER :: fevc real(kind=r_2), public, DIMENSION(:), POINTER :: ofes real(kind=r_2), public, DIMENSION(:), POINTER :: sublayer_dz real(kind=r_2), public, DIMENSION(:,:), POINTER :: gw real(kind=r_2), public, DIMENSION(:,:,:), POINTER :: ancj real(kind=r_2), public, DIMENSION(:,:), POINTER :: tlfy real(kind=r_2), public, DIMENSION(:,:), POINTER :: ecy real(kind=r_2), public, DIMENSION(:,:), POINTER :: ecx real(kind=r_2), public, DIMENSION(:,:,:), POINTER :: ci real(kind=r_2), public, DIMENSION(:), POINTER :: fwsoil vh_js !! !litter thermal conductivity (Wm-2K-1) and vapour diffusivity (m2s-1) real(kind=r_2), public, DIMENSION(:), POINTER :: kthLitt real(kind=r_2), public, DIMENSION(:), POINTER :: DvLitt","tags":"","loc":"type/canopy_type.html"},{"title":"radiation_type – CABLE ","text":"type, public :: radiation_type Contents Variables transb albedo_T longitude workp1 workp2 workp3 extkb extkd2 extkd flws latitude lwabv qssabs transd trad otrad fvlai rhocdf rniso scalex albedo reffdf reffbm extkbm extkdm fbeam cexpkbm cexpkdm rhocbm gradis qcan Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: transb real, public, DIMENSION(:), POINTER :: albedo_T real, public, DIMENSION(:), POINTER :: longitude real, public, DIMENSION(:), POINTER :: workp1 real, public, DIMENSION(:), POINTER :: workp2 real, public, DIMENSION(:), POINTER :: workp3 real, public, DIMENSION(:), POINTER :: extkb real, public, DIMENSION(:), POINTER :: extkd2 real, public, DIMENSION(:), POINTER :: extkd real, public, DIMENSION(:), POINTER :: flws real, public, DIMENSION(:), POINTER :: latitude real, public, DIMENSION(:), POINTER :: lwabv real, public, DIMENSION(:), POINTER :: qssabs real, public, DIMENSION(:), POINTER :: transd real, public, DIMENSION(:), POINTER :: trad real, public, DIMENSION(:), POINTER :: otrad real, public, DIMENSION(:,:), POINTER :: fvlai real, public, DIMENSION(:,:), POINTER :: rhocdf real, public, DIMENSION(:,:), POINTER :: rniso real, public, DIMENSION(:,:), POINTER :: scalex real, public, DIMENSION(:,:), POINTER :: albedo real, public, DIMENSION(:,:), POINTER :: reffdf real, public, DIMENSION(:,:), POINTER :: reffbm real, public, DIMENSION(:,:), POINTER :: extkbm real, public, DIMENSION(:,:), POINTER :: extkdm real, public, DIMENSION(:,:), POINTER :: fbeam real, public, DIMENSION(:,:), POINTER :: cexpkbm real, public, DIMENSION(:,:), POINTER :: cexpkdm real, public, DIMENSION(:,:), POINTER :: rhocbm real, public, DIMENSION(:,:), POINTER :: gradis real, public, DIMENSION(:,:,:), POINTER :: qcan","tags":"","loc":"type/radiation_type.html"},{"title":"roughness_type – CABLE ","text":"type, public :: roughness_type Contents Variables disp hruff hruff_grmx rt0us rt1usa rt1usb rt1 za_uv za_tq z0m zref_uv zref_tq zruffs z0soilsn z0soil coexp usuh term2 term3 term5 term6 term6a Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: disp real, public, DIMENSION(:), POINTER :: hruff real, public, DIMENSION(:), POINTER :: hruff_grmx real, public, DIMENSION(:), POINTER :: rt0us real, public, DIMENSION(:), POINTER :: rt1usa real, public, DIMENSION(:), POINTER :: rt1usb real, public, DIMENSION(:), POINTER :: rt1 real, public, DIMENSION(:), POINTER :: za_uv real, public, DIMENSION(:), POINTER :: za_tq real, public, DIMENSION(:), POINTER :: z0m real, public, DIMENSION(:), POINTER :: zref_uv real, public, DIMENSION(:), POINTER :: zref_tq real, public, DIMENSION(:), POINTER :: zruffs real, public, DIMENSION(:), POINTER :: z0soilsn real, public, DIMENSION(:), POINTER :: z0soil real, public, DIMENSION(:), POINTER :: coexp real, public, DIMENSION(:), POINTER :: usuh real, public, DIMENSION(:), POINTER :: term2 real, public, DIMENSION(:), POINTER :: term3 real, public, DIMENSION(:), POINTER :: term5 real, public, DIMENSION(:), POINTER :: term6 real, public, DIMENSION(:), POINTER :: term6a","tags":"","loc":"type/roughness_type.html"},{"title":"air_type – CABLE ","text":"type, public :: air_type Contents Variables rho volm rlam qsat epsi visc psyc dsatdk cmolar Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: rho real, public, DIMENSION(:), POINTER :: volm real, public, DIMENSION(:), POINTER :: rlam real, public, DIMENSION(:), POINTER :: qsat real, public, DIMENSION(:), POINTER :: epsi real, public, DIMENSION(:), POINTER :: visc real, public, DIMENSION(:), POINTER :: psyc real, public, DIMENSION(:), POINTER :: dsatdk real, public, DIMENSION(:), POINTER :: cmolar","tags":"","loc":"type/air_type.html"},{"title":"met_type – CABLE ","text":"type, public :: met_type Contents Variables year moy ca doy hod ofsd fld precip precip_sn tk tvair tvrad pmb ua qv qvair da dva coszen Ndep Pdep fsd Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), POINTER :: year integer, public, DIMENSION(:), POINTER :: moy real, public, DIMENSION(:), POINTER :: ca real, public, DIMENSION(:), POINTER :: doy real, public, DIMENSION(:), POINTER :: hod real, public, DIMENSION(:), POINTER :: ofsd real, public, DIMENSION(:), POINTER :: fld real, public, DIMENSION(:), POINTER :: precip real, public, DIMENSION(:), POINTER :: precip_sn real, public, DIMENSION(:), POINTER :: tk real, public, DIMENSION(:), POINTER :: tvair real, public, DIMENSION(:), POINTER :: tvrad real, public, DIMENSION(:), POINTER :: pmb real, public, DIMENSION(:), POINTER :: ua real, public, DIMENSION(:), POINTER :: qv real, public, DIMENSION(:), POINTER :: qvair real, public, DIMENSION(:), POINTER :: da real, public, DIMENSION(:), POINTER :: dva real, public, DIMENSION(:), POINTER :: coszen real, public, DIMENSION(:), POINTER :: Ndep real, public, DIMENSION(:), POINTER :: Pdep real, public, DIMENSION(:,:), POINTER :: fsd","tags":"","loc":"type/met_type.html"},{"title":"climate_type – CABLE ","text":"type, public :: climate_type Contents Variables nyear_average nday_average nyears doy chilldays iveg biome dtemp dmoist mtemp qtemp mmoist mtemp_min mtemp_max qtemp_max qtemp_max_last_year mtemp_min20 mtemp_max20 atemp_mean AGDD5 GDD5 AGDD0 GDD0 alpha_PT evap_PT aevap alpha_PT20 mtemp_min_20 mtemp_max_20 dtemp_31 dmoist_31 alpha_PT_20 dtemp_91 Components Type Visibility Attributes Name Initial integer, public :: nyear_average = 20 integer, public :: nday_average = 31 integer, public :: nyears integer, public :: doy integer, public, DIMENSION(:), POINTER :: chilldays integer, public, DIMENSION(:), POINTER :: iveg integer, public, DIMENSION(:), POINTER :: biome real, public, DIMENSION(:), POINTER :: dtemp real, public, DIMENSION(:), POINTER :: dmoist real, public, DIMENSION(:), POINTER :: mtemp real, public, DIMENSION(:), POINTER :: qtemp real, public, DIMENSION(:), POINTER :: mmoist real, public, DIMENSION(:), POINTER :: mtemp_min real, public, DIMENSION(:), POINTER :: mtemp_max real, public, DIMENSION(:), POINTER :: qtemp_max real, public, DIMENSION(:), POINTER :: qtemp_max_last_year real, public, DIMENSION(:), POINTER :: mtemp_min20 real, public, DIMENSION(:), POINTER :: mtemp_max20 real, public, DIMENSION(:), POINTER :: atemp_mean real, public, DIMENSION(:), POINTER :: AGDD5 real, public, DIMENSION(:), POINTER :: GDD5 real, public, DIMENSION(:), POINTER :: AGDD0 real, public, DIMENSION(:), POINTER :: GDD0 real, public, DIMENSION(:), POINTER :: alpha_PT real, public, DIMENSION(:), POINTER :: evap_PT real, public, DIMENSION(:), POINTER :: aevap real, public, DIMENSION(:), POINTER :: alpha_PT20 real, public, DIMENSION(:,:), POINTER :: mtemp_min_20 real, public, DIMENSION(:,:), POINTER :: mtemp_max_20 real, public, DIMENSION(:,:), POINTER :: dtemp_31 real, public, DIMENSION(:,:), POINTER :: dmoist_31 real, public, DIMENSION(:,:), POINTER :: alpha_PT_20 real, public, DIMENSION(:,:), POINTER :: dtemp_91","tags":"","loc":"type/climate_type.html"},{"title":"sum_flux_type – CABLE ","text":"type, public :: sum_flux_type Contents Variables sumpn sumrp sumrpw sumrpr sumrs sumrd dsumpn dsumrp dsumrs dsumrd sumxrp sumxrs Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: sumpn real, public, DIMENSION(:), POINTER :: sumrp real, public, DIMENSION(:), POINTER :: sumrpw real, public, DIMENSION(:), POINTER :: sumrpr real, public, DIMENSION(:), POINTER :: sumrs real, public, DIMENSION(:), POINTER :: sumrd real, public, DIMENSION(:), POINTER :: dsumpn real, public, DIMENSION(:), POINTER :: dsumrp real, public, DIMENSION(:), POINTER :: dsumrs real, public, DIMENSION(:), POINTER :: dsumrd real, public, DIMENSION(:), POINTER :: sumxrp real, public, DIMENSION(:), POINTER :: sumxrs","tags":"","loc":"type/sum_flux_type.html"},{"title":"bgc_pool_type – CABLE ","text":"type, public :: bgc_pool_type Contents Variables cplant csoil ratecp ratecs Components Type Visibility Attributes Name Initial real, public, DIMENSION(:,:), POINTER :: cplant real, public, DIMENSION(:,:), POINTER :: csoil real, public, DIMENSION(ncp) :: ratecp real, public, DIMENSION(ncs) :: ratecs","tags":"","loc":"type/bgc_pool_type.html"},{"title":"LUC_INPUT_TYPE – CABLE ","text":"type, public :: LUC_INPUT_TYPE Contents Variables VAL Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), ALLOCATABLE :: VAL","tags":"","loc":"type/luc_input_type.html"},{"title":"LUC_EXPT_TYPE – CABLE ","text":"type, public :: LUC_EXPT_TYPE Contents Variables TransitionFilePath ClimateFile Run DirectRead READrst WRITErst prim_only ptos ptog stog gtos ivegp biome YearStart YearEnd nfile CTSTEP primaryf mtemp_min20 grass secdf TransFile VAR_NAME F_ID V_ID INPUT YEAR ydimsize xdimsize nrec FirstYear Components Type Visibility Attributes Name Initial character(len=200), public :: TransitionFilePath character(len=200), public :: ClimateFile character(len=200), public :: Run logical, public :: DirectRead logical, public :: READrst logical, public :: WRITErst logical, public, ALLOCATABLE :: prim_only (:) logical, public, ALLOCATABLE :: ptos (:) logical, public, ALLOCATABLE :: ptog (:) logical, public, ALLOCATABLE :: stog (:) logical, public, ALLOCATABLE :: gtos (:) integer, public, ALLOCATABLE :: ivegp (:) integer, public, ALLOCATABLE :: biome (:) integer, public :: YearStart integer, public :: YearEnd integer, public :: nfile integer, public :: CTSTEP real, public, ALLOCATABLE :: primaryf (:) real, public, ALLOCATABLE :: mtemp_min20 (:) real, public, ALLOCATABLE :: grass (:) real, public, ALLOCATABLE :: secdf (:) character(len=200), public, DIMENSION(9) :: TransFile character(len=12), public, DIMENSION(9) :: VAR_NAME integer, public, DIMENSION(9) :: F_ID integer, public, DIMENSION(9) :: V_ID type( LUC_INPUT_TYPE ), public, DIMENSION(9) :: INPUT integer, public :: YEAR integer, public :: ydimsize integer, public :: xdimsize integer, public :: nrec integer, public :: FirstYear","tags":"","loc":"type/luc_expt_type.html"},{"title":"prepareFiles – CABLE","text":"subroutine prepareFiles(ncciy) Uses cable_IO_vars_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncciy Contents None","tags":"","loc":"proc/preparefiles.html"},{"title":"renameFiles – CABLE","text":"subroutine renameFiles(logn, inFile, ncciy, inName) Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn character(len=200), intent(inout) :: inFile integer, intent(in) :: ncciy character(len=*), intent(in) :: inName Contents None","tags":"","loc":"proc/renamefiles.html"},{"title":"LUCdriver – CABLE","text":"subroutine LUCdriver(casabiome, casapool, casaflux, POP, LUC_EXPT, POPLUC, veg) Uses casaparm POPLUC_Module casadimension POPLUC_Types casavariable POPMODULE TypeDef cable_carbon_module CABLE_LUC_EXPT cable_IO_vars_module POP_Types cable_common_module casa_ncdf_module cable_def_types_mod Arguments Type Intent Optional Attributes Name type(casa_biome), intent(inout) :: casabiome type(casa_pool), intent(inout) :: casapool type(casa_flux), intent(inout) :: casaflux type(POP_TYPE), intent(inout) :: POP type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT type(POPLUC_TYPE), intent(inout) :: POPLUC type( veg_parameter_type ), intent(in) :: veg Contents None","tags":"","loc":"proc/lucdriver.html"},{"title":"landuse_data – CABLE","text":"subroutine landuse_data(mlon, mlat, landmask, arealand, luc_atransit, luc_fharvw, luc_xluh2cable) Uses netcdf landuse_constant cable_common_module cable_def_types_mod cable_abort_module Arguments Type Intent Optional Attributes Name integer :: mlon integer :: mlat integer, dimension(mlon,mlat) :: landmask real(kind=r_2), dimension(mland) :: arealand real(kind=r_2), dimension(mland,mvmax,mvmax) :: luc_atransit real(kind=r_2), dimension(mland,mharvw) :: luc_fharvw real(kind=r_2), dimension(mland,mvmax,mstate) :: luc_xluh2cable Contents None","tags":"","loc":"proc/landuse_data.html"},{"title":"landuse_getxluh2 – CABLE","text":"subroutine landuse_getxluh2(mlat, mlon, landmask, fxluh2cable, luc_xluh2cable) Uses netcdf cable_def_types_mod landuse_constant Arguments Type Intent Optional Attributes Name integer :: mlat integer :: mlon integer, dimension(mlon,mlat) :: landmask character(len=500) :: fxluh2cable real(kind=r_2), dimension(mland,mvmax,mstate) :: luc_xluh2cable Contents None","tags":"","loc":"proc/landuse_getxluh2.html"},{"title":"landuse_getdata – CABLE","text":"subroutine landuse_getdata(mlat, mlon, landmask, fxpft, luc_atransit, luc_fharvw) Uses netcdf cable_def_types_mod landuse_constant Arguments Type Intent Optional Attributes Name integer :: mlat integer :: mlon integer, dimension(mlon,mlat) :: landmask character(len=500) :: fxpft real(kind=r_2), dimension(mland,mvmax,mvmax) :: luc_atransit real(kind=r_2), dimension(mland,mharvw) :: luc_fharvw Contents None","tags":"","loc":"proc/landuse_getdata.html"},{"title":"create_new_gridinfo – CABLE","text":"subroutine create_new_gridinfo(fgridold, fgridnew, mlon, mlat, landmask, patchfrac_new) Uses netcdf cable_IO_vars_module landuse_constant cable_common_module cable_def_types_mod cable_abort_module Arguments Type Intent Optional Attributes Name character(len=500) :: fgridold character(len=500) :: fgridnew integer :: mlon integer :: mlat integer, dimension(mlon,mlat) :: landmask real(kind=r_2), dimension(mlon,mlat,mvmax) :: patchfrac_new Contents None","tags":"","loc":"proc/create_new_gridinfo.html"},{"title":"rangechk2 – CABLE","text":"subroutine rangechk2(mlon, mlat, landmask, varx2, xmin, xmax) Uses cable_def_types_mod Arguments Type Intent Optional Attributes Name integer :: mlon integer :: mlat integer, dimension(mlon,mlat) :: landmask real(kind=r_2), dimension(mlon,mlat) :: varx2 real :: xmin real :: xmax Contents None","tags":"","loc":"proc/rangechk2.html"},{"title":"rangechk3 – CABLE","text":"subroutine rangechk3(mlon, mlat, nx3, landmask, varx3, xmin, xmax) Uses cable_def_types_mod Arguments Type Intent Optional Attributes Name integer :: mlon integer :: mlat integer :: nx3 integer, dimension(mlon,mlat) :: landmask real(kind=r_2), dimension(mlon,mlat,nx3) :: varx3 real :: xmin real :: xmax Contents None","tags":"","loc":"proc/rangechk3.html"},{"title":"sort – CABLE","text":"subroutine sort(mvmax, tmpx, tmpint) Uses cable_def_types_mod Arguments Type Intent Optional Attributes Name integer :: mvmax real(kind=r_2), dimension(mvmax) :: tmpx integer, dimension(mvmax) :: tmpint Contents None","tags":"","loc":"proc/sort.html"},{"title":"WRITE_LANDUSE_CASA_RESTART_NC – CABLE","text":"subroutine WRITE_LANDUSE_CASA_RESTART_NC(mpx, lucmp, CASAONLY) Uses netcdf casavariable cable_IO_vars_module landuse_variable cable_common_module casa_ncdf_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: mpx type(landuse_mp) :: lucmp logical :: CASAONLY Contents None","tags":"","loc":"proc/write_landuse_casa_restart_nc.html"},{"title":"create_landuse_cable_restart – CABLE","text":"subroutine create_landuse_cable_restart(logn, dels, ktau, soil, mpx, lucmp, cstart, cend, nap) Uses cable_write_module netcdf cable_IO_vars_module cable_checks_module landuse_variable cable_common_module cable_def_types_mod cable_abort_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn real, intent(in) :: dels integer, intent(in) :: ktau type( soil_parameter_type ) :: soil integer, intent(in) :: mpx type(landuse_mp) :: lucmp integer, intent(in), DIMENSION(mland) :: cstart integer, intent(in), DIMENSION(mland) :: cend integer, intent(in), DIMENSION(mland) :: nap Contents None","tags":"","loc":"proc/create_landuse_cable_restart.html"},{"title":"get_default_inits – CABLE","text":"public subroutine get_default_inits(met, soil, ssnow, canopy, logn, EMSOIL) Arguments Type Intent Optional Attributes Name type( met_type ), intent(in) :: met type( soil_parameter_type ), intent(in) :: soil type( soil_snow_type ), intent(inout) :: ssnow type( canopy_type ), intent(out) :: canopy integer, intent(in) :: logn real, intent(in) :: EMSOIL Contents None","tags":"","loc":"proc/get_default_inits.html"},{"title":"get_restart_data – CABLE","text":"public subroutine get_restart_data(logn, ssnow, canopy, rough, bgc, bal, veg, soil, rad, vegparmnew, EMSOIL) (BP Nov 2009)\n$   IF(cable_user%SOIL_STRUC=='sli'.or.cable_user%FWSOIL_SWITCH=='Haverd2013') THEN\n$      CALL readpar(ncid_rin,'gamma',dummy,veg%gamma,filename%restart_in,           &\n$           max_vegpatches,'def',from_restart,mp)\n$   ENDIF $       CALL readpar(ncid_rin,'ZR',dummy,veg%ZR, &\n$            filename%restart_in,max_vegpatches,'def',from_restart,mp)\n$       CALL readpar(ncid_rin,'F10',dummy,veg%F10, &\n$            filename%restart_in,max_vegpatches,'def',from_restart,mp)\n$       CALL readpar(ncid_rin,'zeta',dummy,soil%zeta,filename%restart_in,           &\n$            max_vegpatches,'def',from_restart,mp)\n$       CALL readpar(ncid_rin,'fsatmax',dummy,soil%fsatmax,filename%restart_in,           &\n$            max_vegpatches,'def',from_restart,mp)\n$       CALL readpar(ncid_rin,'nhorizons',dummy,soil%nhorizons,filename%restart_in,           &\n$            max_vegpatches,'def',from_restart,mp)\n$       ALLOCATE(var_r2(mp,ms))\n$       CALL readpar(ncid_rin,'ishorizon',dummy,var_r2,filename%restart_in,           &\n$            max_vegpatches,'ms',from_restart,mp)\n$       soil%ishorizon = int(var_r2)\n$       DEALLOCATE(var_r2)\n$       CALL readpar(ncid_rin,'clitt',dummy,veg%clitt,filename%restart_in,           &\n$            max_vegpatches,'def',from_restart,mp)\n getting rid of spurious veg types in Antarctica from the CCAM2Mk3L process\n Doing it once will fix the problem in the restart file in subsequent runs end of fix to spurious veg types Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn type( soil_snow_type ), intent(inout) :: ssnow type( canopy_type ), intent(inout) :: canopy type( roughness_type ), intent(inout) :: rough type( bgc_pool_type ), intent(inout) :: bgc type( balances_type ), intent(inout) :: bal type( veg_parameter_type ), intent(inout) :: veg type( soil_parameter_type ), intent(inout) :: soil type( radiation_type ), intent(inout) :: rad logical, intent(in) :: vegparmnew real, intent(in) :: EMSOIL Contents None","tags":"","loc":"proc/get_restart_data.html"},{"title":"cable_soil_params – CABLE","text":"public subroutine cable_soil_params() Uses cable_def_types_mod Arguments None Contents None","tags":"","loc":"proc/cable_soil_params.html"},{"title":"CRU_INIT – CABLE","text":"public subroutine CRU_INIT(CRU) Uses cable_IO_vars_module cable_def_types_mod Arguments Type Intent Optional Attributes Name type( CRU_TYPE ) :: CRU Contents None","tags":"","loc":"proc/cru_init.html"},{"title":"CRU_GET_FILENAME – CABLE","text":"public subroutine CRU_GET_FILENAME(CRU, cyear, par, FN) $    SELECT CASE ( par )\n$    CASE(rain) ; FN = TRIM(FN)//\"/rain/cruncep2015_1_rain_\"//cy//\".daymean.nc\"\n$    CASE(lwdn) ; FN = TRIM(FN)//\"/lwdown/cruncep2015_1_lwdown_\"//cy//\".daymean.nc\"\n$    CASE(swdn) ; FN = TRIM(FN)//\"/swdown/cruncep2015_1_swdown_\"//cy//\".daymean.nc\"\n$    CASE(pres) ; FN = TRIM(FN)//\"/press/cruncep2015_1_press_\"//cy//\".daymean.nc\"\n$    CASE(qair) ; FN = TRIM(FN)//\"/qair/cruncep2015_1_qair_\"//cy//\".daymean.nc\"\n$    CASE(tmax,PrevTmax) ; FN = TRIM(FN)//\"/tmax/cruncep2015_1_tair_\"//cy//\".daymax.nc\"\n$    CASE(tmin,NextTmin) ; FN = TRIM(FN)//\"/tmin/cruncep2015_1_tair_\"//cy//\".daymin.nc\"\n$    CASE(uwind) ; FN = TRIM(FN)//\"/uwind/cruncep2015_1_uwind_\"//cy//\".daymean.nc\"\n$    CASE(vwind) ; FN = TRIM(FN)//\"/vwind/cruncep2015_1_vwind_\"//cy//\".daymean.nc\"\n$    END SELECT Arguments Type Intent Optional Attributes Name type( CRU_TYPE ), intent(inout) :: CRU integer, intent(in) :: cyear integer, intent(in) :: par character(len=200), intent(out) :: FN Contents None","tags":"","loc":"proc/cru_get_filename.html"},{"title":"GET_CRU_CO2 – CABLE","text":"public subroutine GET_CRU_CO2(CRU, CO2air) Arguments Type Intent Optional Attributes Name type( CRU_TYPE ) :: CRU real, intent(out) :: CO2air Contents None","tags":"","loc":"proc/get_cru_co2.html"},{"title":"GET_CRU_Ndep – CABLE","text":"public subroutine GET_CRU_Ndep(CRU) Arguments Type Intent Optional Attributes Name type( CRU_TYPE ), intent(inout) :: CRU Contents None","tags":"","loc":"proc/get_cru_ndep.html"},{"title":"OPEN_CRU_MET – CABLE","text":"public subroutine OPEN_CRU_MET(CRU) Uses cable_IO_vars_module $    IF ( TRIM(CRU%Run) .EQ. 'S0_TRENDY' .OR.  ( TRIM(CRU%Run) .EQ. 'S1_TRENDY' )) THEN\n$      MetYear = 1901 + MOD(CRU%CYEAR-RunStartYear,30)\n$    ELSE IF ( TRIM(CRU%Run) .EQ. 'S2_TRENDY' ) THEN\n$      MetYear = CRU%CYEAR\n$    ENDIF Arguments Type Intent Optional Attributes Name type( CRU_TYPE ), intent(inout) :: CRU Contents None","tags":"","loc":"proc/open_cru_met.html"},{"title":"CRU_GET_DAILY_MET – CABLE","text":"public subroutine CRU_GET_DAILY_MET(CRU, LastDayOfYear, LastYearOfMet) $  IF ( TRIM(CRU%Run) .EQ. 'S0_TRENDY' .OR.  ( TRIM(CRU%Run) .EQ. 'S1_TRENDY' )) THEN\n$    MetYear = 1901 + MOD(CRU%CYEAR-RunStartYear,30)\n$  ELSE IF ( TRIM(CRU%Run) .EQ. 'S2_TRENDY' ) THEN\n$    MetYear = CRU%CYEAR\n$  ELSE\n$    STOP 'Error in cable_cru.F90: CRU%Run not S0_TRENDY, S1_TRENDY, or 1901-2015'\n$  ENDIF $          IF ( TRIM(CRU%Run) .EQ. 'S0_TRENDY' .OR.  ( TRIM(CRU%Run) .EQ. 'S1_TRENDY' )) THEN\n$            NextMetYear = 1901 + MOD(CRU%CYEAR + 1 - RunStartYear,30)\n$          ELSE IF ( TRIM(CRU%Run) .EQ. 'S2_TRENDY' ) THEN\n$            NextMetYear = CRU%CYEAR + 1\n$          ENDIF Arguments Type Intent Optional Attributes Name type( CRU_TYPE ) :: CRU logical, intent(in) :: LastDayOfYear logical, intent(in) :: LastYearOfMet Contents None","tags":"","loc":"proc/cru_get_daily_met.html"},{"title":"CRU_GET_SUBDIURNAL_MET – CABLE","text":"public subroutine CRU_GET_SUBDIURNAL_MET(CRU, MET, CurYear, ktau, kend, LastYearOfMet) Uses CABLE_WEATHERGENERATOR cable_IO_vars_module cable_checks_module casa_ncdf_module cable_def_types_mod !!  this only works with CANBERRA cable_driver, as ktau    !!!!\n!!  restarts on Jan 1                                      !!!! $    if (WG%Temp(iland) > 2.5) then\n$       met%precip_sn(is:ie) = 0.0\n$    elseif ((WG%Temp(iland) <= 2.5) .and. (WG%Temp(iland) > 2.0)) then\n$       met%precip_sn(is:ie) = 0.6 met%precip(is:ie)\n$    elseif ((WG%Temp(iland) <= 2.0) .and. (WG%Temp(iland) > 0.0)) then\n$       met%precip_sn(is:ie) = (1.0 - (54.62 - 0.2 (WG%Temp(iland) + 273.15)))* met%precip(is:ie) ! this facr can be > 1 !!!\n$    elseif (WG%Temp(iland) <= 0.0) then\n$       met%precip_sn(is:ie) = met%precip(is:ie)\n$    endif Arguments Type Intent Optional Attributes Name type( CRU_TYPE ) :: CRU type( met_type ) :: MET integer, intent(in) :: CurYear integer, intent(in) :: ktau integer, intent(in) :: kend logical, intent(in) :: LastYearOfMet Contents None","tags":"","loc":"proc/cru_get_subdiurnal_met.html"},{"title":"redistr_i – CABLE","text":"public subroutine redistr_i(INpatch, nap, in_i, out_i, parname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) integer, intent(in) :: in_i (INpatch) integer, intent(out) :: out_i (mp) character(len=*), intent(in) :: parname Contents None","tags":"","loc":"proc/redistr_i.html"},{"title":"redistr_r – CABLE","text":"public subroutine redistr_r(INpatch, nap, in_r, out_r, parname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) real, intent(in) :: in_r (INpatch) real, intent(out) :: out_r (mp) character(len=*), intent(in) :: parname Contents None","tags":"","loc":"proc/redistr_r.html"},{"title":"redistr_rd – CABLE","text":"public subroutine redistr_rd(INpatch, nap, in_rd, out_rd, parname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) real(kind=r_2), intent(in) :: in_rd (INpatch) real(kind=r_2), intent(out) :: out_rd (mp) character(len=*), intent(in) :: parname Contents None","tags":"","loc":"proc/redistr_rd.html"},{"title":"redistr_r2 – CABLE","text":"public subroutine redistr_r2(INpatch, nap, in_r2, out_r2, parname, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) real, intent(in) :: in_r2 (INpatch,dim2) real, intent(out) :: out_r2 (mp,dim2) character(len=*), intent(in) :: parname integer, intent(in) :: dim2 Contents None","tags":"","loc":"proc/redistr_r2.html"},{"title":"redistr_r2d – CABLE","text":"public subroutine redistr_r2d(INpatch, nap, in_r2d, out_r2d, parname, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) real(kind=r_2), intent(in) :: in_r2d (INpatch,dim2) real(kind=r_2), intent(out) :: out_r2d (mp,dim2) character(len=*), intent(in) :: parname integer, intent(in) :: dim2 Contents None","tags":"","loc":"proc/redistr_r2d.html"},{"title":"readpar – CABLE","text":"public interface readpar Contents Module Procedures readpar_i readpar_r readpar_rd readpar_r2 readpar_r2d Module Procedures private subroutine readpar_i(ncid, parname, completeSet, var_i, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet integer, intent(inout), DIMENSION(:) :: var_i character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch private subroutine readpar_r(ncid, parname, completeSet, var_r, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet real(kind=4), intent(inout), DIMENSION(:) :: var_r character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch private subroutine readpar_rd(ncid, parname, completeSet, var_rd, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet real(kind=r_2), intent(inout), DIMENSION(:) :: var_rd character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch private subroutine readpar_r2(ncid, parname, completeSet, var_r2, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet real(kind=4), intent(inout), DIMENSION(:,:) :: var_r2 character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch private subroutine readpar_r2d(ncid, parname, completeSet, var_r2d, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet real(kind=r_2), intent(inout), DIMENSION(:, :) :: var_r2d character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch","tags":"","loc":"interface/readpar.html"},{"title":"mpidrv_master – CABLE","text":"public subroutine mpidrv_master(comm) Uses casadimension POP_Constants cable_namelist_util POP_Types cable_input_module landuse_constant phenvariable cable_def_types_mod casavariable cable_climate_mod CABLE_CRU landuse_variable casa_cable mpi casa_inout_module cable_write_module cable_output_module cable_cbm_module cable_common_module casa_ncdf_module CABLE_PLUME_MIP cable_phys_constants_mod POPLUC_Module POPLUC_Types CABLE_LUC_EXPT cable_IO_vars_module vh_js !!\n vh_js !! suggest LALLOC should ulitmately be a switch in the .nml file\n vh_js !!\n$             IF ( CASAONLY .AND. IS_CASA_TIME(\"dread\", yyyy, iktau, kstart, koffset, &\n$                  kend, ktauday, logn) )  THEN\n$                ! CLN READ FROM FILE INSTEAD !\n$                WRITE(CYEAR,FMT=\"(I4)\")CurYear + INT((ktau-kstart+koffset)/(LOY*ktauday))\n$                ncfile  = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc'\n$                casa_it = NINT( REAL(iktau / ktauday) )\n$                CALL read_casa_dump( ncfile, casamet, casaflux, casa_it, kend, .FALSE. )\n$             ENDIF $             ! At first time step of year, set tile area according to updated LU areas\n$             IF (ktau == 1 .and. CABLE_USER%POPLUC) THEN\n$               CALL POPLUC_set_patchfrac(POPLUC,LUC_EXPT)\n$            ENDIF $                IF ( ((.NOT.spinup).OR.(spinup.AND.spinConv)) .AND.   &\n$                     ( IS_CASA_TIME(\"dwrit\", yyyy, oktau, kstart, &\n$                        koffset, kend, ktauday, logn) ) ) THEN\n$                   WRITE(CYEAR,FMT=\"(I4)\") CurYear + INT((ktau-kstart)/(LOY*ktauday))\n$                   ncfile = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc'\n$                   CALL write_casa_dump( ncfile, casamet , casaflux, idoy, &\n$                        kend/ktauday )\n$\n$                ENDIF $                    if (ktau == kend-1) PRINT , \"time-space-averaged energy & water balances\"\n$                    if (ktau == kend-1) PRINT ,\"Ebal_tot[Wm-2], Wbal_tot[mm]\", &\n$                         sum(bal%ebal_tot)/mp/count_bal, sum(bal%wbal_tot)/mp/count_bal\n$                    if (ktau == kend-1) PRINT , \"time-space-averaged latent heat and net photosynthesis\"\n$                    if (ktau == kend-1) PRINT , \"sum_fe[Wm-2], sum_fpn[umol/m2/s]\",  &\n$                         new_sumfe/count_bal, new_sumfpn/count_bal $             IF ( CABLE_USER%CASA_DUMP_WRITE )  THEN\n$                !CLN CHECK FOR LEAP YEAR\n$                WRITE(CYEAR,FMT=\"(I4)\") CurYear + INT((ktau-kstart)/(LOY*ktauday))\n$                ncfile = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc'\n$                CALL write_casa_dump( ncfile, casamet , casaflux, idoy, &\n$                     kend/ktauday )\n$\n$             ENDIF $       CALL casa_poolout( ktau, veg, soil, casabiome,                           &\n$            casapool, casaflux, casamet, casabal, phen ) Arguments Type Intent Optional Attributes Name integer :: comm Contents None","tags":"","loc":"proc/mpidrv_master.html"},{"title":"cable_pft_params – CABLE","text":"public subroutine cable_pft_params() Uses cable_def_types_mod Arguments None Contents None","tags":"","loc":"proc/cable_pft_params.html"},{"title":"find_metvarid – CABLE","text":"public subroutine find_metvarid(file_id, possible_names, varid, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id character(len=*), intent(in), DIMENSION(:) :: possible_names integer, intent(out) :: varid integer, intent(out) :: status Contents None","tags":"","loc":"proc/find_metvarid.html"},{"title":"open_output_file – CABLE","text":"public subroutine open_output_file(dels, soil, veg, bgc, rough) vh_js !!\nvh_js !! Arguments Type Intent Optional Attributes Name real, intent(in) :: dels type( soil_parameter_type ), intent(in) :: soil type( veg_parameter_type ), intent(in) :: veg type( bgc_pool_type ), intent(in) :: bgc type( roughness_type ), intent(in) :: rough Contents None","tags":"","loc":"proc/open_output_file.html"},{"title":"write_output – CABLE","text":"public subroutine write_output(dels, ktau, met, canopy, casaflux, casapool, casamet, ssnow, rad, bal, air, soil, veg, SBOLTZ, EMLEAF, EMSOIL) vh_js !!\nvh_js !!\nvh_js !! Arguments Type Intent Optional Attributes Name real, intent(in) :: dels integer, intent(in) :: ktau type( met_type ), intent(in) :: met type( canopy_type ), intent(in) :: canopy type(casa_flux), intent(in) :: casaflux type(casa_pool), intent(in) :: casapool type(casa_met), intent(in) :: casamet type( soil_snow_type ), intent(in) :: ssnow type( radiation_type ), intent(in) :: rad type( balances_type ), intent(inout) :: bal type( air_type ), intent(in) :: air type( soil_parameter_type ), intent(in) :: soil type( veg_parameter_type ), intent(in) :: veg real, intent(in) :: SBOLTZ real, intent(in) :: EMLEAF real, intent(in) :: EMSOIL Contents None","tags":"","loc":"proc/write_output.html"},{"title":"close_output_file – CABLE","text":"public subroutine close_output_file(bal, air, bgc, canopy, met, rad, rough, soil, ssnow, sum_flux, veg) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: bal type( air_type ), intent(inout) :: air type( bgc_pool_type ), intent(inout) :: bgc type( canopy_type ), intent(inout) :: canopy type( met_type ), intent(inout) :: met type( radiation_type ), intent(inout) :: rad type( roughness_type ), intent(inout) :: rough type( soil_parameter_type ), intent(inout) :: soil type( soil_snow_type ), intent(inout) :: ssnow type( sum_flux_type ), intent(inout) :: sum_flux type( veg_parameter_type ), intent(inout) :: veg Contents None","tags":"","loc":"proc/close_output_file.html"},{"title":"create_restart – CABLE","text":"public subroutine create_restart(logn, dels, ktau, soil, veg, ssnow, canopy, rough, rad, bgc, bal, met) $    CALL define_ovar(ncid_restart, rpid%clay, 'clay', '-',                     &\n$                     'Fraction of soil which is clay',                         &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%sand, 'sand', '-',                     &\n$                     'Fraction of soil which is sand',                         &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%silt, 'silt', '-',                     &\n$                     'Fraction of soil which is silt',                         &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%ssat, 'ssat', '-',                     &\n$                     'Fraction of soil volume which is water @ saturation',    &\n$                    .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%sfc, 'sfc', '-',                       &\n$                    'Fraction of soil volume which is water @ field capacity', &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%swilt, 'swilt', '-',                   &\n$                     'Fraction of soil volume which is water @ wilting point', &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) $    CALL define_ovar(ncid_restart, rpid%froot, 'froot', '-',                   &\n$                     'Fraction of roots in each soil layer',                   &\n$                      .TRUE., soilID, 'soil', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%bch, 'bch', '-',                       &\n$                     'Parameter b, Campbell eqn 1985',                         &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%hyds, 'hyds', 'm/s',                   &\n$                     'Hydraulic conductivity @ saturation',                    &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%sucs, 'sucs', 'm',                     &\n$                     'Suction @ saturation', .TRUE.,                           &\n$                     'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%css, 'css', 'J/kg/C',                  &\n$                     'Heat capacity of soil minerals',                         &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%rhosoil, 'rhosoil', 'kg/m&#94;3',          &\n$                     'Density of soil minerals',                               &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%rs20, 'rs20', '-',                     &\n$                     'Soil respiration coefficient at 20C',                    &\n$                      .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%hc, 'hc', 'm',                         &\n$                     'Height of canopy', .TRUE.,                               &\n$                     'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%canst1, 'canst1', 'mm/LAI',            &\n$                     'Max water intercepted by canopy',                        &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%dleaf, 'dleaf', 'm',                   &\n$                     'Chararacteristic length of leaf',                        &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%frac4, 'frac4', '-',                   &\n$                     'Fraction of plants which are C4',                        &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%ejmax, 'ejmax', 'mol/m&#94;2/s',           &\n$                     'Max potential electron transport rate top leaf', .TRUE., &\n$                     'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%vcmax, 'vcmax', 'mol/m&#94;2/s',           &\n$                     'Maximum RuBP carboxylation rate top leaf', .TRUE.,       &\n$                     'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%rp20, 'rp20', '-',                     &\n$                     'Plant respiration coefficient at 20C', .TRUE., 'real',   &\n$                     0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%g0, 'g0', '-',                     &\n$                     'g0 term in Medlyn Stomatal Cond. Param', .TRUE.,'real',&\n$                     0, 0, 0, mpID, dummy, .TRUE.) ! Ticket #56\n$    CALL define_ovar(ncid_restart, rpid%g1, 'g1', '-',                     &\n$                     'g1 term in Medlyn Stomatal Cond. Param', .TRUE.,'real',&\n$                     0, 0, 0, mpID, dummy, .TRUE.)  ! Ticket #56\n$    CALL define_ovar(ncid_restart, rpid%rpcoef, 'rpcoef', '1/C',               &\n$                     'Temperature coef nonleaf plant respiration', .TRUE.,     &\n$                     'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%shelrb, 'shelrb', '-',                 &\n$              'Sheltering factor', .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%xfang, 'xfang', '-',                   &\n$           'Leaf angle parameter', .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%wai, 'wai', '-',                       &\n$                'Wood area index', .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%vegcf, 'vegcf', '-',                   &\n$                     'vegcf', .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%extkn, 'extkn', '-',                   &\n$                     'Extinction coef for vertical nitrogen profile',          &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%tminvj, 'tminvj', 'C',                 &\n$                     'Min temperature for the start of photosynthesis',        &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%tmaxvj, 'tmaxvj', 'C',                 &\n$                     'Max temperature for the start of photosynthesis',        &\n$                      .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%vbeta, 'vbeta', '-',                   &\n$                     'Stomatal sensitivity to soil water',                     &\n$                      .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%xalbnir, 'xalbnir', '-',               &\n$                     'modifier for albedo in near ir band',                    &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    ! ratecp (Plant carbon rate constant):\n$    ok = NF90_DEF_VAR(ncid_restart, 'ratecp', NF90_FLOAT, (/plantcarbID/),     &\n$                      rpid%ratecp)\n$    IF (ok /= NF90_NOERR) CALL nc_abort                                        &\n$                     (ok, 'Error defining ratecp variable in restart file. '// &\n$                      '(SUBROUTINE create_restart)')\n$    ok = NF90_PUT_ATT(ncid_restart, rpid%ratecp, \"long_name\",                  &\n$                      \"Plant carbon rate constant\")\n$    ok = NF90_PUT_ATT(ncid_restart, rpid%ratecp, \"units\", \"1/year\")\n$    ! ratecs (Soil carbon rate constant):\n$    ok = NF90_DEF_VAR(ncid_restart, 'ratecs', NF90_FLOAT, (/soilcarbID/),      &\n$                      rpid%ratecs)\n$    IF (ok /= NF90_NOERR) CALL nc_abort                                        &\n$                     (ok, 'Error defining ratecs variable in restart file. '// &\n$                      '(SUBROUTINE create_restart)')\n$    ok = NF90_PUT_ATT(ncid_restart, rpid%ratecs, \"long_name\",                  &\n$                      \"Soil carbon rate constant\")\n$    ok = NF90_PUT_ATT(ncid_restart, rpid%ratecs, \"units\", \"1/year\")\n$    CALL define_ovar(ncid_restart, rpid%meth, 'meth', '-',                     &\n$                     'Canopy turbulence parameterisation switch',              &\n$                     .TRUE., 'integer', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%za_uv, 'za_uv', 'm',                   &\n$                    'Reference height (lowest atm. model layer) for momentum', &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%za_tq, 'za_tq', 'm',                   &\n$                     'Reference height (lowest atm. model layer) for scalars', &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    IF(cable_user%SOIL_STRUC=='sli'.OR.cable_user%FWSOIL_SWITCH=='Haverd2013') THEN\n$      CALL define_ovar(ncid_restart,rpid%gamma,'gamma','-', &\n$            'Parameter in root efficiency function (Lai and Katul 2000)', &\n$            .TRUE.,'real',0,0,0,mpID,dummy,.TRUE.)\n$    ENDIF $       CALL define_ovar(ncid_restart,rpid%nhorizons,'nhorizons','-', &\n$            'Number of soil horizons',.TRUE.,'integer',0,0,0,mpID,dummy,.TRUE.)\n$       CALL define_ovar(ncid_restart,rpid%zeta,'zeta','[ ]', &\n$            'exponent factor in Topmodel eq',.TRUE.,'real',0,0,0,mpID,dummy,.TRUE.)\n$       CALL define_ovar(ncid_restart,rpid%fsatmax,'fsatmax','[ ]', &\n$            'param in Topmodel eq',.TRUE.,'real',0,0,0,mpID,dummy,.TRUE.)\n$       CALL define_ovar(ncid_restart,rpid%ishorizon,'ishorizon','-', &\n$            'Horizon number',.TRUE., soilID, 'soil', 0, 0, 0, mpID, dummy, .TRUE.)\n$       CALL define_ovar(ncid_restart,rpid%clitt,'clitt','tC/ha', &\n$            'Litter layer carbon content',.TRUE.,'real',0,0,0,mpID,dummy,.TRUE.)\n$       CALL define_ovar(ncid_restart,rpid%ZR,'ZR','cm', &\n$            'Maximum rooting depth',.TRUE.,'real',0,0,0,mpID,dummy,.TRUE.)\n$       CALL define_ovar(ncid_restart,rpid%F10,'F10','-', &\n$            'Fraction of roots in top 10 cm', &\n$            .TRUE.,'real',0,0,0,mpID,dummy,.TRUE.) $    CALL write_ovar (ncid_restart, rpid%bch, 'bch', REAL(soil%bch, 4),         &\n$                     ranges%bch, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%bch, 'bch', REAL(soil%bch, 4),         &\n$                     ranges%bch, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%clay, 'clay', REAL(soil%clay, 4),      &\n$                     ranges%clay, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%sand, 'sand', REAL(soil%sand, 4),      &\n$                     ranges%sand, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%silt, 'silt', REAL(soil%silt, 4),      &\n$                     ranges%silt, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%css, 'css', REAL(soil%css, 4),         &\n$                     ranges%css, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%rhosoil, 'rhosoil',                    &\n$                     REAL(soil%rhosoil,4), ranges%rhosoil, .TRUE., 'real',     &\n$                     .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%hyds, 'hyds', REAL(soil%hyds, 4),      &\n$                     ranges%hyds, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%sucs, 'sucs', REAL(soil%sucs, 4),      &\n$                     ranges%sucs, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%rs20, 'rs20', REAL(veg%rs20, 4),       &\n$                     ranges%rs20, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%ssat, 'ssat', REAL(soil%ssat, 4),      &\n$                     ranges%ssat, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%sfc, 'sfc', REAL(soil%sfc, 4),         &\n$                     ranges%sfc, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%swilt, 'swilt', REAL(soil%swilt, 4),   &\n$                     ranges%swilt, .TRUE., 'real', .TRUE.) $    CALL write_ovar (ncid_restart, rpid%froot, 'froot', REAL(veg%froot, 4),    &\n$                     ranges%froot, .TRUE., 'soil', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%canst1, 'canst1', REAL(veg%canst1, 4), &\n$                     ranges%canst1, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%dleaf, 'dleaf', REAL(veg%dleaf, 4),    &\n$                     ranges%dleaf, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%ejmax, 'ejmax', REAL(veg%ejmax, 4),    &\n$                     ranges%ejmax, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%vcmax, 'vcmax', REAL(veg%vcmax, 4),    &\n$                     ranges%vcmax, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%frac4, 'frac4', REAL(veg%frac4, 4),    &\n$                     ranges%frac4, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%hc, 'hc', REAL(veg%hc, 4),             &\n$                     ranges%hc, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%rp20, 'rp20', REAL(veg%rp20, 4),       &\n$                     ranges%rp20, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%g0, 'g0', REAL(veg%g0, 4),       &\n$                     ranges%g0, .TRUE., 'real', .TRUE.) ! Ticket #56\n$    CALL write_ovar (ncid_restart, rpid%g1, 'g1', REAL(veg%g1, 4),       &\n$                     ranges%g1, .TRUE., 'real', .TRUE.) ! Ticket #56\n$    CALL write_ovar (ncid_restart, rpid%rpcoef, 'rpcoef', REAL(veg%rpcoef, 4), &\n$                     ranges%rpcoef, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%shelrb, 'shelrb', REAL(veg%shelrb, 4), &\n$                     ranges%shelrb, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%xfang, 'xfang', REAL(veg%xfang, 4),    &\n$                     ranges%xfang, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%wai, 'wai', REAL(veg%wai, 4),          &\n$                     ranges%wai, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%vegcf, 'vegcf', REAL(veg%vegcf, 4),    &\n$                     ranges%vegcf, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%extkn, 'extkn', REAL(veg%extkn, 4),    &\n$                     ranges%extkn, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%tminvj, 'tminvj', REAL(veg%tminvj, 4), &\n$                     ranges%tminvj, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%tmaxvj, 'tmaxvj', REAL(veg%tmaxvj, 4), &\n$                     ranges%tmaxvj, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%vbeta, 'vbeta', REAL(veg%vbeta, 4),    &\n$                     ranges%vbeta, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%xalbnir, 'xalbnir',                    &\n$                     REAL(veg%xalbnir, 4), ranges%xalbnir, .TRUE.,             &\n$                     'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%tmaxvj, 'tmaxvj', REAL(veg%tmaxvj, 4), &\n$                     ranges%tmaxvj, .TRUE., 'real', .TRUE.)\n$    ok = NF90_PUT_VAR(ncid_restart, rpid%ratecp, REAL(bgc%ratecp, 4))\n$    IF(ok /= NF90_NOERR) CALL nc_abort(ok,                                     &\n$                                       'Error writing ratecp parameter to '    &\n$         //TRIM(frst_out)// '(SUBROUTINE create_restart)')\n$    ok = NF90_PUT_VAR(ncid_restart, rpid%ratecs, REAL(bgc%ratecs, 4))\n$    IF(ok /= NF90_NOERR) CALL nc_abort(ok,                                     &\n$                                       'Error writing ratecs parameter to '    &\n$         //TRIM(frst_out)// '(SUBROUTINE create_restart)')\n$    CALL write_ovar (ncid_restart, rpid%meth, 'meth', REAL(veg%meth, 4),       &\n$                     ranges%meth, .TRUE., 'integer', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%za_uv, 'za_uv', REAL(rough%za_uv, 4),  &\n$                     ranges%za, .TRUE., 'real', .TRUE.)\n$    CALL write_ovar (ncid_restart, rpid%za_tq, 'za_tq', REAL(rough%za_tq, 4),  &\n$                     ranges%za, .TRUE., 'real', .TRUE.)\n$    IF(cable_user%SOIL_STRUC=='sli'.OR.cable_user%FWSOIL_SWITCH=='Haverd2013') THEN\n$       CALL write_ovar (ncid_restart,rpid%gamma,'gamma', &\n$            REAL(veg%gamma,4),(/-99999.0,99999.0/),.TRUE.,'real',.TRUE.)\n$    ENDIF\n$ $       CALL write_ovar (ncid_restart,rpid%nhorizons,'nhorizons', &\n$            REAL(soil%nhorizons,4),(/-99999.0,99999.0/),.TRUE.,'integer',.TRUE.)\n$       CALL write_ovar (ncid_restart,rpid%ishorizon,'ishorizon', &\n$            REAL(soil%ishorizon,4),(/-99999.0,99999.0/),.TRUE.,'soil',.TRUE.)\n$       CALL write_ovar (ncid_restart,rpid%clitt,'clitt', &\n$            REAL(veg%clitt,4),(/-99999.0,99999.0/),.TRUE.,'real',.TRUE.)\n$       CALL write_ovar (ncid_restart,rpid%ZR,'ZR', &\n$            REAL(veg%ZR,4),(/-99999.0,99999.0/),.TRUE.,'real',.TRUE.)\n$       CALL write_ovar (ncid_restart,rpid%F10,'F10', &\n$            REAL(veg%F10,4),(/-99999.0,99999.0/),.TRUE.,'real',.TRUE.) Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn real, intent(in) :: dels integer, intent(in) :: ktau type( soil_parameter_type ), intent(in) :: soil type( veg_parameter_type ), intent(in) :: veg type( soil_snow_type ), intent(in) :: ssnow type( canopy_type ), intent(in) :: canopy type( roughness_type ), intent(in) :: rough type( radiation_type ), intent(in) :: rad type( bgc_pool_type ), intent(in) :: bgc type( balances_type ), intent(in) :: bal type( met_type ), intent(in) :: met Contents None","tags":"","loc":"proc/create_restart.html"},{"title":"IS_CASA_TIME – CABLE","text":"public function IS_CASA_TIME(iotype, yyyy, ktau, kstart, koffset, kend, ktauday, logn) Uses cable_common_module Arguments Type Intent Optional Attributes Name character, intent(in) :: iotype *5 integer, intent(in) :: yyyy integer, intent(in) :: ktau integer, intent(in) :: kstart integer, intent(in) :: koffset integer, intent(in) :: kend integer, intent(in) :: ktauday integer, intent(in) :: logn Return Value logical Contents None","tags":"","loc":"proc/is_casa_time.html"},{"title":"def_dims – CABLE","text":"public subroutine def_dims(nd, ncid, dimID, dim_len, dim_name) Uses netcdf Arguments Type Intent Optional Attributes Name integer, intent(in) :: nd integer, intent(in) :: ncid integer, intent(out), dimension(:) :: dimID integer, intent(in), dimension(:) :: dim_len character(len=*), intent(in), dimension(:) :: dim_name Contents None","tags":"","loc":"proc/def_dims.html"},{"title":"def_vars – CABLE","text":"public subroutine def_vars(nv, ncid, xtype, dimID, var_name, varID) Uses netcdf Arguments Type Intent Optional Attributes Name integer, intent(in) :: nv integer, intent(in) :: ncid integer, intent(in) :: xtype integer, intent(in), dimension(:) :: dimID character(len=*), intent(in), dimension(:) :: var_name integer, intent(inout), dimension(:) :: varID Contents None","tags":"","loc":"proc/def_vars.html"},{"title":"def_var_atts – CABLE","text":"public subroutine def_var_atts(ncfile_in, ncid, varID) Uses netcdf Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ncfile_in integer, intent(in) :: ncid integer, intent(in), dimension(:) :: varID Contents None","tags":"","loc":"proc/def_var_atts.html"},{"title":"put_var_ncr1 – CABLE","text":"public subroutine put_var_ncr1(ncid, var_name, var) Uses netcdf cable_def_types_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real, intent(in), dimension(:) :: var Contents None","tags":"","loc":"proc/put_var_ncr1.html"},{"title":"put_var_ncr2 – CABLE","text":"public subroutine put_var_ncr2(ncid, var_name, var, n_call) Uses netcdf cable_def_types_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(in), dimension(:) :: var integer, intent(in) :: n_call Contents None","tags":"","loc":"proc/put_var_ncr2.html"},{"title":"put_var_ncr3 – CABLE","text":"public subroutine put_var_ncr3(ncid, var_name, var, n_call, nl) Uses netcdf cable_def_types_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(in), dimension(:,:) :: var integer, intent(in) :: n_call integer, intent(in) :: nl Contents None","tags":"","loc":"proc/put_var_ncr3.html"},{"title":"get_var_ncr2 – CABLE","text":"public subroutine get_var_ncr2(ncid, var_name, var, n_call) Uses netcdf cable_def_types_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(out), dimension(:) :: var integer :: n_call Contents None","tags":"","loc":"proc/get_var_ncr2.html"},{"title":"get_var_ncr3 – CABLE","text":"public subroutine get_var_ncr3(ncid, var_name, var, n_call, nl) Uses netcdf cable_def_types_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(out), dimension(:,:) :: var integer, intent(in) :: n_call integer, intent(in) :: nl Contents None","tags":"","loc":"proc/get_var_ncr3.html"},{"title":"HANDLE_ERR – CABLE","text":"public subroutine HANDLE_ERR(status, msg) Uses netcdf Arguments Type Intent Optional Attributes Name integer :: status character(len=*), intent(in), optional :: msg Contents None","tags":"","loc":"proc/handle_err.html"},{"title":"GET_UNIT – CABLE","text":"public subroutine GET_UNIT(IUNIT) Arguments Type Intent Optional Attributes Name integer, intent(out) :: IUNIT Contents None","tags":"","loc":"proc/get_unit.html"},{"title":"stderr_nc – CABLE","text":"public subroutine stderr_nc(status, message, var) Uses netcdf Arguments Type Intent Optional Attributes Name integer, intent(in) :: status character(len=*), intent(in) :: message character(len=*), intent(in) :: var Contents None","tags":"","loc":"proc/stderr_nc.html"},{"title":"YMDHMS2DOYSOD – CABLE","text":"public subroutine YMDHMS2DOYSOD(YYYY, MM, DD, HOUR, MINUTE, SECOND, DOY, SOD) Uses cable_common_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: YYYY integer, intent(in) :: MM integer, intent(in) :: DD integer, intent(in) :: HOUR integer, intent(in) :: MINUTE integer, intent(in) :: SECOND integer, intent(out) :: DOY integer, intent(out) :: SOD Contents None","tags":"","loc":"proc/ymdhms2doysod.html"},{"title":"DOYSOD2YMDHMS – CABLE","text":"public subroutine DOYSOD2YMDHMS(YYYY, DOY, SOD, MM, DD, HOUR, MINUTE, SECOND) Uses cable_common_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: YYYY integer, intent(in) :: DOY integer, intent(in) :: SOD integer, intent(out) :: MM integer, intent(out) :: DD integer, intent(out), optional :: HOUR integer, intent(out), optional :: MINUTE integer, intent(out), optional :: SECOND Contents None","tags":"","loc":"proc/doysod2ymdhms.html"},{"title":"put_var_nc – CABLE","text":"public interface put_var_nc Contents Module Procedures put_var_ncr1 put_var_ncr2 put_var_ncr3 Module Procedures public subroutine put_var_ncr1 (ncid, var_name, var) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real, intent(in), dimension(:) :: var public subroutine put_var_ncr2 (ncid, var_name, var, n_call) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(in), dimension(:) :: var integer, intent(in) :: n_call public subroutine put_var_ncr3 (ncid, var_name, var, n_call, nl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(in), dimension(:,:) :: var integer, intent(in) :: n_call integer, intent(in) :: nl","tags":"","loc":"interface/put_var_nc.html"},{"title":"get_var_nc – CABLE","text":"public interface get_var_nc Contents Module Procedures get_var_ncr2 get_var_ncr3 Module Procedures public subroutine get_var_ncr2 (ncid, var_name, var, n_call) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(out), dimension(:) :: var integer :: n_call public subroutine get_var_ncr3 (ncid, var_name, var, n_call, nl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(out), dimension(:,:) :: var integer, intent(in) :: n_call integer, intent(in) :: nl","tags":"","loc":"interface/get_var_nc.html"},{"title":"site_INIT – CABLE","text":"public subroutine site_INIT(site) Arguments Type Intent Optional Attributes Name type( site_TYPE ) :: site Contents None","tags":"","loc":"proc/site_init.html"},{"title":"site_GET_CO2_Ndep – CABLE","text":"public subroutine site_GET_CO2_Ndep(site) Arguments Type Intent Optional Attributes Name type( site_TYPE ) :: site Contents None","tags":"","loc":"proc/site_get_co2_ndep.html"},{"title":"WGEN_INIT – CABLE","text":"public subroutine WGEN_INIT(WG, np, latitude, dels) Arguments Type Intent Optional Attributes Name type( WEATHER_GENERATOR_TYPE ) :: WG integer, intent(in) :: np real, intent(in) :: latitude (np) real, intent(in) :: dels Contents None","tags":"","loc":"proc/wgen_init.html"},{"title":"WGEN_DAILY_CONSTANTS – CABLE","text":"public subroutine WGEN_DAILY_CONSTANTS(WG, np, YearDay) $write(71, \"( 1000e16.6)\") WG%DecRad\n$   write(72, \"( 1000e16.6)\") TAN(WG%DecRad)\n$   write(73, \"( 1000e16.6)\") TAN(WG%LatRad)\n$ write(74, \"( 1000e16.6)\")  WG%DayLength Arguments Type Intent Optional Attributes Name type( WEATHER_GENERATOR_TYPE ) :: WG integer, intent(in) :: np integer, intent(in) :: YearDay Contents None","tags":"","loc":"proc/wgen_daily_constants.html"},{"title":"WGEN_SUBDIURNAL_MET – CABLE","text":"public subroutine WGEN_SUBDIURNAL_MET(WG, np, itime) Arguments Type Intent Optional Attributes Name type( WEATHER_GENERATOR_TYPE ) :: WG integer, intent(in) :: np integer, intent(in) :: itime Contents None","tags":"","loc":"proc/wgen_subdiurnal_met.html"},{"title":"get_default_params – CABLE","text":"public subroutine get_default_params(logn, vegparmnew, LUC_EXPT) Uses cable_common_module Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn logical, intent(in) :: vegparmnew type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT Contents None","tags":"","loc":"proc/get_default_params.html"},{"title":"write_default_params – CABLE","text":"public subroutine write_default_params(met, air, ssnow, veg, bgc, soil, canopy, rough, rad, logn, vegparmnew, month, TFRZ, LUC_EXPT) Uses cable_common_module vh_js !!\n I brought this in with manual merge of #199 BUT Am i bringing this back in ?\n! calculate vegin%froot from using rootbeta and soil depth\n! (Jackson et al. 1996, Oceologica, 108:389-411)\ntotdepth = 0.0\nDO is = 1, ms\n   totdepth = totdepth + soil%zse(is) * 100.0  ! unit in centimetres\n   vegin%froot(is, :) = MIN(1.0, 1.0-vegin%rootbeta(:)**totdepth)\nEND DO\nDO is = ms, 2, -1\n   vegin%froot(is, :) = vegin%froot(is, :)-vegin%froot(is-1, :)\nEND DO vh_js !! vh_js !! neeed to remove this if to enable the code below vh_js !! Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: met type( air_type ), intent(inout) :: air type( soil_snow_type ), intent(inout) :: ssnow type( veg_parameter_type ), intent(inout) :: veg type( bgc_pool_type ), intent(inout) :: bgc type( soil_parameter_type ), intent(inout) :: soil type( canopy_type ), intent(inout) :: canopy type( roughness_type ), intent(inout) :: rough type( radiation_type ), intent(inout) :: rad integer, intent(in) :: logn logical, intent(in) :: vegparmnew integer, intent(in) :: month real, intent(in) :: TFRZ type( LUC_EXPT_TYPE ), intent(in) :: LUC_EXPT Contents None","tags":"","loc":"proc/write_default_params.html"},{"title":"write_cnp_params – CABLE","text":"public subroutine write_cnp_params(veg, casaflux, casamet) Uses casaparm vh !! fluxes shouldn't be weighted by patch frac. Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(in) :: veg type(casa_flux), intent(inout) :: casaflux type(casa_met), intent(inout) :: casamet Contents None","tags":"","loc":"proc/write_cnp_params.html"},{"title":"derived_parameters – CABLE","text":"public subroutine derived_parameters(soil, sum_flux, bal, ssnow, veg, rough) vegetation dependent field capacity (point plants get stressed) and vh_js !! comment out hide% condition Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: soil type( sum_flux_type ), intent(inout) :: sum_flux type( balances_type ), intent(inout) :: bal type( soil_snow_type ), intent(inout) :: ssnow type( veg_parameter_type ), intent(in) :: veg type( roughness_type ), intent(inout) :: rough Contents None","tags":"","loc":"proc/derived_parameters.html"},{"title":"check_parameter_values – CABLE","text":"public subroutine check_parameter_values(soil, veg, ssnow) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: soil type( veg_parameter_type ), intent(inout) :: veg type( soil_snow_type ), intent(inout) :: ssnow Contents None","tags":"","loc":"proc/check_parameter_values.html"},{"title":"report_parameters – CABLE","text":"public subroutine report_parameters(logn, soil, veg, bgc, rough, ssnow, canopy, casamet, casapool, casaflux, phen, vegparmnew, verbose) Uses cable_soil_params_mod cable_pft_params_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn type( soil_parameter_type ), intent(in) :: soil type( veg_parameter_type ), intent(in) :: veg type( bgc_pool_type ), intent(in) :: bgc type( roughness_type ), intent(in) :: rough type( soil_snow_type ), intent(in) :: ssnow type( canopy_type ), intent(in) :: canopy type(casa_met), intent(in) :: casamet type(casa_pool), intent(in) :: casapool type(casa_flux), intent(in) :: casaflux type(phen_variable), intent(in) :: phen logical, intent(in) :: vegparmnew logical, intent(in) :: verbose Contents None","tags":"","loc":"proc/report_parameters.html"},{"title":"abort – CABLE","text":"public subroutine abort(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message Contents None","tags":"","loc":"proc/abort.html"},{"title":"nc_abort – CABLE","text":"public subroutine nc_abort(ok, message) Uses netcdf Arguments Type Intent Optional Attributes Name integer, intent(in) :: ok character(len=*), intent(in) :: message Contents None","tags":"","loc":"proc/nc_abort.html"},{"title":"range_abort – CABLE","text":"public subroutine range_abort(message, ktau, met, value, var_range, i, xx, yy) Uses cable_IO_vars_module cable_def_types_mod Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message integer, intent(in) :: ktau type( met_type ), intent(in) :: met real, intent(in) :: value real, intent(in), DIMENSION(2) :: var_range integer, intent(in) :: i integer, intent(in), optional :: xx integer, intent(in), optional :: yy Contents None","tags":"","loc":"proc/range_abort.html"},{"title":"FILE_SWITCH – CABLE","text":"public function FILE_SWITCH(PLUME, action) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ), intent(in) :: PLUME character(len=5), intent(in) :: action Return Value logical Contents None","tags":"","loc":"proc/file_switch.html"},{"title":"PLUME_MIP_INIT – CABLE","text":"public subroutine PLUME_MIP_INIT(PLUME) Uses cable_IO_vars_module cable_def_types_mod Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME Contents None","tags":"","loc":"proc/plume_mip_init.html"},{"title":"PLUME_GET_FILENAME – CABLE","text":"public subroutine PLUME_GET_FILENAME(PLUME, cyear, par, FN) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ), intent(inout) :: PLUME integer, intent(in) :: cyear integer, intent(in) :: par character(len=200), intent(out) :: FN Contents None","tags":"","loc":"proc/plume_get_filename.html"},{"title":"GET_PLUME_CO2 – CABLE","text":"public subroutine GET_PLUME_CO2(PLUME, CO2air) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME real, intent(out) :: CO2air Contents None","tags":"","loc":"proc/get_plume_co2.html"},{"title":"OPEN_PLUME_MET – CABLE","text":"public subroutine OPEN_PLUME_MET(PLUME) Uses cable_IO_vars_module Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME Contents None","tags":"","loc":"proc/open_plume_met.html"},{"title":"PLUME_GET_DAILY_MET – CABLE","text":"public subroutine PLUME_GET_DAILY_MET(PLUME, TminFlag, islast) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME logical, intent(in) :: TminFlag logical, intent(in) :: islast Contents None","tags":"","loc":"proc/plume_get_daily_met.html"},{"title":"PLUME_MIP_GET_MET – CABLE","text":"public subroutine PLUME_MIP_GET_MET(PLUME, MET, CurYear, ktau, kend, islast) Uses CABLE_WEATHERGENERATOR cable_IO_vars_module cable_checks_module casa_ncdf_module cable_def_types_mod !!  this only works with CANBERRA cable_driver, as ktau    !!!!\n!!  restarts on Jan 1                                      !!!! $write( , ) \"met\", met%precip(1), &\n$met%precip_sn (is:ie)  , &\n$     met%fld       (is:ie), &\n$     met%fsd       (is:ie,1), &\n$     met%fsd       (is:ie,2), &\n$     met%tk        (is:ie) , &\n$     met%ua        (is:ie)  , &\n$     met%coszen    (is:ie) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME type( met_type ) :: MET integer, intent(in) :: CurYear integer, intent(in) :: ktau integer, intent(in) :: kend logical, intent(in) :: islast Contents None","tags":"","loc":"proc/plume_mip_get_met.html"},{"title":"find_extents – CABLE","text":"public subroutine find_extents() Uses cable_def_types_mod mpi Arguments None Contents None","tags":"","loc":"proc/find_extents.html"},{"title":"decomp_types – CABLE","text":"public subroutine decomp_types(landpt_t, patch_t) Uses cable_IO_vars_module mpi Arguments Type Intent Optional Attributes Name integer, intent(out) :: landpt_t integer, intent(out) :: patch_t Contents None","tags":"","loc":"proc/decomp_types.html"},{"title":"bcast_start_time – CABLE","text":"public subroutine bcast_start_time(comm) Uses cable_IO_vars_module mpi Arguments Type Intent Optional Attributes Name integer, intent(in) :: comm Contents None","tags":"","loc":"proc/bcast_start_time.html"},{"title":"cbm – CABLE","text":"public subroutine cbm(ktau, dels, air, bgc, canopy, met, bal, rad, rough, soil, ssnow, sum_flux, veg, climate, xk, c1, rhoch) Uses cable_roughness_module sli_main_mod cbl_masks_mod cable_phys_constants_mod cable_gw_hydro_module cable_canopy_module casadimension cbl_albedo_mod cbl_soil_snow_main_module cbl_init_radiation_module snow_aging_mod cable_other_constants_mod cable_carbon_module cable_air_module cable_common_module cable_math_constants_mod cable_def_types_mod Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau real, intent(in) :: dels type( air_type ), intent(inout) :: air type( bgc_pool_type ), intent(inout) :: bgc type( canopy_type ), intent(inout) :: canopy type( met_type ), intent(inout) :: met type( balances_type ), intent(inout) :: bal type( radiation_type ), intent(inout) :: rad type( roughness_type ), intent(inout) :: rough type( soil_parameter_type ), intent(inout) :: soil type( soil_snow_type ), intent(inout) :: ssnow type( sum_flux_type ), intent(inout) :: sum_flux type( veg_parameter_type ), intent(inout) :: veg type( climate_type ), intent(in) :: climate real :: xk (mp,nrb) real :: c1 (mp,nrb) real :: rhoch (mp,nrb) Contents None","tags":"","loc":"proc/cbm.html"},{"title":"get_namelist_file_name – CABLE","text":"public subroutine get_namelist_file_name() Arguments None Contents None","tags":"","loc":"proc/get_namelist_file_name.html"},{"title":"alloc_balances_type – CABLE","text":"public subroutine alloc_balances_type(var, mp) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_balances_type.html"},{"title":"alloc_soil_parameter_type – CABLE","text":"public subroutine alloc_soil_parameter_type(var, mp) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_soil_parameter_type.html"},{"title":"alloc_soil_snow_type – CABLE","text":"public subroutine alloc_soil_snow_type(var, mp) Arguments Type Intent Optional Attributes Name type( soil_snow_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_soil_snow_type.html"},{"title":"alloc_veg_parameter_type – CABLE","text":"public subroutine alloc_veg_parameter_type(var, mp) Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_veg_parameter_type.html"},{"title":"alloc_canopy_type – CABLE","text":"public subroutine alloc_canopy_type(var, mp) vh_js !! liiter resistances to heat and vapour transfer Arguments Type Intent Optional Attributes Name type( canopy_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_canopy_type.html"},{"title":"alloc_radiation_type – CABLE","text":"public subroutine alloc_radiation_type(var, mp) Arguments Type Intent Optional Attributes Name type( radiation_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_radiation_type.html"},{"title":"alloc_roughness_type – CABLE","text":"public subroutine alloc_roughness_type(var, mp) Arguments Type Intent Optional Attributes Name type( roughness_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_roughness_type.html"},{"title":"alloc_air_type – CABLE","text":"public subroutine alloc_air_type(var, mp) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_air_type.html"},{"title":"alloc_met_type – CABLE","text":"public subroutine alloc_met_type(var, mp) Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_met_type.html"},{"title":"alloc_climate_type – CABLE","text":"public subroutine alloc_climate_type(var, mp) Arguments Type Intent Optional Attributes Name type( climate_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_climate_type.html"},{"title":"alloc_sum_flux_type – CABLE","text":"public subroutine alloc_sum_flux_type(var, mp) Arguments Type Intent Optional Attributes Name type( sum_flux_type ), intent(inout) :: var integer, intent(in) :: mp Contents None","tags":"","loc":"proc/alloc_sum_flux_type.html"},{"title":"dealloc_balances_type – CABLE","text":"public subroutine dealloc_balances_type(var) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_balances_type.html"},{"title":"dealloc_soil_parameter_type – CABLE","text":"public subroutine dealloc_soil_parameter_type(var) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_soil_parameter_type.html"},{"title":"dealloc_soil_snow_type – CABLE","text":"public subroutine dealloc_soil_snow_type(var) Arguments Type Intent Optional Attributes Name type( soil_snow_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_soil_snow_type.html"},{"title":"dealloc_veg_parameter_type – CABLE","text":"public subroutine dealloc_veg_parameter_type(var) Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_veg_parameter_type.html"},{"title":"dealloc_canopy_type – CABLE","text":"public subroutine dealloc_canopy_type(var) vh_js !! liiter resistances to heat and vapour transfer Arguments Type Intent Optional Attributes Name type( canopy_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_canopy_type.html"},{"title":"dealloc_radiation_type – CABLE","text":"public subroutine dealloc_radiation_type(var) Arguments Type Intent Optional Attributes Name type( radiation_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_radiation_type.html"},{"title":"dealloc_roughness_type – CABLE","text":"public subroutine dealloc_roughness_type(var) Arguments Type Intent Optional Attributes Name type( roughness_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_roughness_type.html"},{"title":"dealloc_air_type – CABLE","text":"public subroutine dealloc_air_type(var) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_air_type.html"},{"title":"dealloc_met_type – CABLE","text":"public subroutine dealloc_met_type(var) Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_met_type.html"},{"title":"dealloc_sum_flux_type – CABLE","text":"public subroutine dealloc_sum_flux_type(var) Arguments Type Intent Optional Attributes Name type( sum_flux_type ), intent(inout) :: var Contents None","tags":"","loc":"proc/dealloc_sum_flux_type.html"},{"title":"alloc_cbm_var – CABLE","text":"public interface alloc_cbm_var Contents Module Procedures alloc_balances_type alloc_soil_parameter_type alloc_soil_snow_type alloc_veg_parameter_type alloc_canopy_type alloc_radiation_type alloc_roughness_type alloc_air_type alloc_met_type alloc_sum_flux_type alloc_bgc_pool_type alloc_climate_type Module Procedures public subroutine alloc_balances_type (var, mp) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_soil_parameter_type (var, mp) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_soil_snow_type (var, mp) Arguments Type Intent Optional Attributes Name type( soil_snow_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_veg_parameter_type (var, mp) Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_canopy_type (var, mp) vh_js !! liiter resistances to heat and vapour transfer Arguments Type Intent Optional Attributes Name type( canopy_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_radiation_type (var, mp) Arguments Type Intent Optional Attributes Name type( radiation_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_roughness_type (var, mp) Arguments Type Intent Optional Attributes Name type( roughness_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_air_type (var, mp) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_met_type (var, mp) Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_sum_flux_type (var, mp) Arguments Type Intent Optional Attributes Name type( sum_flux_type ), intent(inout) :: var integer, intent(in) :: mp private subroutine alloc_bgc_pool_type(var, mp) Arguments Type Intent Optional Attributes Name type( bgc_pool_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_climate_type (var, mp) Arguments Type Intent Optional Attributes Name type( climate_type ), intent(inout) :: var integer, intent(in) :: mp","tags":"","loc":"interface/alloc_cbm_var.html"},{"title":"dealloc_cbm_var – CABLE","text":"public interface dealloc_cbm_var Contents Module Procedures dealloc_balances_type dealloc_soil_parameter_type dealloc_soil_snow_type dealloc_veg_parameter_type dealloc_canopy_type dealloc_radiation_type dealloc_roughness_type dealloc_air_type dealloc_met_type dealloc_sum_flux_type dealloc_bgc_pool_type Module Procedures public subroutine dealloc_balances_type (var) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: var public subroutine dealloc_soil_parameter_type (var) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: var public subroutine dealloc_soil_snow_type (var) Arguments Type Intent Optional Attributes Name type( soil_snow_type ), intent(inout) :: var public subroutine dealloc_veg_parameter_type (var) Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(inout) :: var public subroutine dealloc_canopy_type (var) vh_js !! liiter resistances to heat and vapour transfer Arguments Type Intent Optional Attributes Name type( canopy_type ), intent(inout) :: var public subroutine dealloc_radiation_type (var) Arguments Type Intent Optional Attributes Name type( radiation_type ), intent(inout) :: var public subroutine dealloc_roughness_type (var) Arguments Type Intent Optional Attributes Name type( roughness_type ), intent(inout) :: var public subroutine dealloc_air_type (var) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: var public subroutine dealloc_met_type (var) Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: var public subroutine dealloc_sum_flux_type (var) Arguments Type Intent Optional Attributes Name type( sum_flux_type ), intent(inout) :: var private subroutine dealloc_bgc_pool_type(var) Arguments Type Intent Optional Attributes Name type( bgc_pool_type ), intent(inout) :: var","tags":"","loc":"interface/dealloc_cbm_var.html"},{"title":"get_default_lai – CABLE","text":"public subroutine get_default_lai() Arguments None Contents None","tags":"","loc":"proc/get_default_lai.html"},{"title":"open_met_file – CABLE","text":"public subroutine open_met_file(dels, koffset, kend, spinup, TFRZ) Uses casa_ncdf_module CABLE_COMMON_MODULE CABLE_METUTILS_MODULE =====================VV Determine spatial details VV================= =================&#94;&#94; End spatial details &#94;&#94;======================== =========VV Determine simulation timing details VV================ * gswp input file has bug in timevar * * *\n hacking (BP feb2011) kend = 480 ! 2 months for 1986 end hacking * done bug fixing for timevar in gswp input file * * PALS met file has timevar(1)=0 while timeunits from 00:30:00 *\nCLN CRITICAL! From my point of view, the information in the file is correct...\nCLN WHY DO the input files all have bugs??? done bug fixing for timevar in PALS met file * * * * * gswp input file has bug in timeunits * * * done bug fixing for timeunits in gwsp file ****\n vh_js !!\n===================&#94;&#94; End timing details &#94;&#94;========================== ===================VV Look for met variables VV======================\n vh_js !! fixed bug in logic\n vh_js !! fixed bug in logic\n$       IF(metunits%LWdown(1:4)/='W/m2'.AND.metunits%LWdown(1:5) &\n$            /='W/m&#94;2'.AND.metunits%LWdown(1:5)/='Wm&#94;-2' &\n$            .AND.metunits%LWdown(1:4)/='Wm-2') THEN\n=================&#94;&#94; End met variables search&#94;&#94;======================= Arguments Type Intent Optional Attributes Name real, intent(out) :: dels integer, intent(inout) :: koffset integer, intent(out) :: kend logical, intent(in) :: spinup real, intent(in) :: TFRZ Contents None","tags":"","loc":"proc/open_met_file.html"},{"title":"get_met_data – CABLE","text":"public subroutine get_met_data(spinup, spinConv, met, soil, rad, veg, kend, dels, TFRZ, ktau, kstart) vh_js !! use is_leapyear function here instead of multiple conditions\nvh_js !! corrected indices of defaultLAI Arguments Type Intent Optional Attributes Name logical, intent(in) :: spinup logical, intent(in) :: spinConv type( met_type ), intent(inout) :: met type( soil_parameter_type ), intent(in) :: soil type( radiation_type ), intent(in) :: rad type( veg_parameter_type ), intent(inout) :: veg integer, intent(in) :: kend real, intent(in) :: dels real, intent(in) :: TFRZ integer, intent(in) :: ktau integer, intent(in) :: kstart Contents None","tags":"","loc":"proc/get_met_data.html"},{"title":"close_met_file – CABLE","text":"public subroutine close_met_file() Arguments None Contents None","tags":"","loc":"proc/close_met_file.html"},{"title":"load_parameters – CABLE","text":"public subroutine load_parameters(met, air, ssnow, veg, climate, bgc, soil, canopy, rough, rad, sum_flux, bal, logn, vegparmnew, casabiome, casapool, casaflux, sum_casapool, sum_casaflux, casamet, casabal, phen, POP, spinup, EMSOIL, TFRZ, LUC_EXPT, POPLUC) Uses CABLE_LUC_EXPT POPmodule POPLUC_module vh_js !!\nvh_js !! Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: met type( air_type ), intent(inout) :: air type( soil_snow_type ), intent(out) :: ssnow type( veg_parameter_type ), intent(out) :: veg type( climate_type ), intent(inout) :: climate type( bgc_pool_type ), intent(out) :: bgc type( soil_parameter_type ), intent(out) :: soil type( canopy_type ), intent(out) :: canopy type( roughness_type ), intent(out) :: rough type( radiation_type ), intent(out) :: rad type( sum_flux_type ), intent(out) :: sum_flux type( balances_type ), intent(out) :: bal integer, intent(in) :: logn logical, intent(in) :: vegparmnew vh_js !! type(casa_biome), intent(out) :: casabiome type(casa_pool), intent(out) :: casapool type(casa_flux), intent(out) :: casaflux type(casa_pool), intent(out) :: sum_casapool type(casa_flux), intent(out) :: sum_casaflux type(casa_met), intent(out) :: casamet type(casa_balance), intent(out) :: casabal type(phen_variable), intent(out) :: phen type(POP_TYPE), intent(inout) :: POP logical, intent(in) :: spinup vh_js !! real, intent(in) :: EMSOIL real, intent(in) :: TFRZ type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT type(POPLUC_TYPE), intent(inout) :: POPLUC Contents None","tags":"","loc":"proc/load_parameters.html"},{"title":"allocate_cable_vars – CABLE","text":"public subroutine allocate_cable_vars(air, bgc, canopy, met, bal, rad, rough, soil, ssnow, sum_flux, veg, arraysize) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: air type( bgc_pool_type ), intent(inout) :: bgc type( canopy_type ), intent(inout) :: canopy type( met_type ), intent(inout) :: met type( balances_type ), intent(inout) :: bal type( radiation_type ), intent(inout) :: rad type( roughness_type ), intent(inout) :: rough type( soil_parameter_type ), intent(inout) :: soil type( soil_snow_type ), intent(inout) :: ssnow type( sum_flux_type ), intent(inout) :: sum_flux type( veg_parameter_type ), intent(inout) :: veg integer, intent(in) :: arraysize Contents None","tags":"","loc":"proc/allocate_cable_vars.html"},{"title":"mpidrv_worker – CABLE","text":"public subroutine mpidrv_worker(comm) Uses POPmodule cable_output_module cable_cbm_module casadimension casavariable cable_climate_mod cbl_soil_snow_init_special_module POP_Constants cable_IO_vars_module cable_namelist_util POP_Types cable_input_module cable_common_module casa_ncdf_module phenvariable cable_def_types_mod mpi CABLE_PLUME_MIP vh_js !!\n vh_js !! suggest LALLOC should ulitmately be a switch in the .nml file\n Check for gswp run $             idoy = mod(ktau/ktauday,365)\n$             IF(idoy==0) idoy=365\n$\n$             ! needed for CASA-CNP\n$             nyear =INT((kend-kstart+1)/(365*ktauday)) jhan this is insufficient testing. condition for\nspinup=.false. & we want CASA_dump.nc (spinConv=.true.)\n see if spinup (if conducting one) has converged: Arguments Type Intent Optional Attributes Name integer :: comm Contents None","tags":"","loc":"proc/mpidrv_worker.html"},{"title":"LUC_EXPT_INIT – CABLE","text":"public subroutine LUC_EXPT_INIT(LUC_EXPT) $          STATUS = NF90_GET_VAR( Luc_expt%f_id(i), timID, tmp, &\n$               start=(/1,1,1/) )\n$          CALL HANDLE_ERR(STATUS, \"Reading from \"//LUC_EXPT%TransFile(i) ) $    WHERE (LUC_EXPT%ivegp == 14)\n$       LUC_EXPT%prim_only = .TRUE.\n$    END WHERE Arguments Type Intent Optional Attributes Name type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT Contents None","tags":"","loc":"proc/luc_expt_init.html"},{"title":"LUC_EXPT_SET_TILES – CABLE","text":"public subroutine LUC_EXPT_SET_TILES(inVeg, inPFrac, LUC_EXPT) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: inVeg (:,:,:) real, intent(inout) :: inPFrac (:,:,:) type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT Contents None","tags":"","loc":"proc/luc_expt_set_tiles.html"},{"title":"READ_ClimateFile – CABLE","text":"public subroutine READ_ClimateFile(LUC_EXPT) Uses netcdf Arguments Type Intent Optional Attributes Name type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT Contents None","tags":"","loc":"proc/read_climatefile.html"},{"title":"READ_LUH2 – CABLE","text":"public subroutine READ_LUH2(LUC_EXPT) Arguments Type Intent Optional Attributes Name type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT Contents None","tags":"","loc":"proc/read_luh2.html"},{"title":"nullify_write – CABLE","text":"public subroutine nullify_write() Arguments None Contents None","tags":"","loc":"proc/nullify_write.html"},{"title":"define_ovar – CABLE","text":"public interface define_ovar Contents Module Procedures define_output_variable_r1 define_output_variable_r2 define_output_parameter_r1 define_output_parameter_r2 Module Procedures private subroutine define_output_variable_r1(ncid, varID, vname, vunits, longname, writepatch, dimswitch, xID, yID, zID, landID, patchID, tID) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out) :: varID character(len=*), intent(in) :: vname character(len=*), intent(in) :: vunits character(len=*), intent(in) :: longname logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch integer, intent(in) :: xID integer, intent(in) :: yID integer, intent(in) :: zID integer, intent(in) :: landID integer, intent(in) :: patchID integer, intent(in) :: tID private subroutine define_output_variable_r2(ncid, varID, vname, vunits, longname, writepatch, dimswitch, xID, yID, zID, landID, patchID, othdimID, tID) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out) :: varID character(len=*), intent(in) :: vname character(len=*), intent(in) :: vunits character(len=*), intent(in) :: longname logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch integer, intent(in) :: xID integer, intent(in) :: yID integer, intent(in) :: zID integer, intent(in) :: landID integer, intent(in) :: patchID integer, intent(in) :: othdimID integer, intent(in) :: tID private subroutine define_output_parameter_r1(ncid, parID, pname, punits, longname, writepatch, dimswitch, xID, yID, zID, landID, patchID, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out) :: parID character(len=*), intent(in) :: pname character(len=*), intent(in) :: punits character(len=*), intent(in) :: longname logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch integer, intent(in) :: xID integer, intent(in) :: yID integer, intent(in) :: zID integer, intent(in) :: landID integer, intent(in) :: patchID logical, intent(in), optional :: restart private subroutine define_output_parameter_r2(ncid, parID, pname, punits, longname, writepatch, othdimID, dimswitch, xID, yID, zID, landID, patchID, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out) :: parID character(len=*), intent(in) :: pname character(len=*), intent(in) :: punits character(len=*), intent(in) :: longname logical, intent(in) :: writepatch integer, intent(in) :: othdimID character(len=*), intent(in) :: dimswitch integer, intent(in) :: xID integer, intent(in) :: yID integer, intent(in) :: zID integer, intent(in) :: landID integer, intent(in) :: patchID logical, intent(in), optional :: restart","tags":"","loc":"interface/define_ovar.html"},{"title":"write_ovar – CABLE","text":"public interface write_ovar Contents Module Procedures write_output_variable_r1 write_output_variable_r2 write_output_parameter_r1 write_output_parameter_r1d write_output_parameter_r2 write_output_parameter_r2d Module Procedures private subroutine write_output_variable_r1(ktau, ncid, varID, vname, var_r1, vrange, writepatch, dimswitch, met) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau integer, intent(in) :: ncid integer, intent(in) :: varID character(len=*), intent(in) :: vname real(kind=4), intent(in), DIMENSION(:) :: var_r1 real, intent(in), DIMENSION(2) :: vrange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch type( met_type ), intent(in) :: met private subroutine write_output_variable_r2(ktau, ncid, varID, vname, var_r2, vrange, writepatch, dimswitch, met) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau integer, intent(in) :: ncid integer, intent(in) :: varID character(len=*), intent(in) :: vname real(kind=4), intent(in), DIMENSION(:, :) :: var_r2 real, intent(in), DIMENSION(2) :: vrange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch type( met_type ), intent(in) :: met private subroutine write_output_parameter_r1(ncid, parID, pname, par_r1, prange, writepatch, dimswitch, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: parID character(len=*), intent(in) :: pname real(kind=4), intent(in), DIMENSION(:) :: par_r1 real, intent(in), DIMENSION(2) :: prange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: restart private subroutine write_output_parameter_r1d(ncid, parID, pname, par_r1d, prange, writepatch, dimswitch, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: parID character(len=*), intent(in) :: pname real(kind=r_2), intent(in), DIMENSION(:) :: par_r1d real, intent(in), DIMENSION(2) :: prange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: restart private subroutine write_output_parameter_r2(ncid, parID, pname, par_r2, prange, writepatch, dimswitch, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: parID character(len=*), intent(in) :: pname real(kind=4), intent(in), DIMENSION(:, :) :: par_r2 real, intent(in), DIMENSION(2) :: prange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: restart private subroutine write_output_parameter_r2d(ncid, parID, pname, par_r2d, prange, writepatch, dimswitch, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: parID character(len=*), intent(in) :: pname real(kind=r_2), intent(in), DIMENSION(:, :) :: par_r2d real, intent(in), DIMENSION(2) :: prange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: restart","tags":"","loc":"interface/write_ovar.html"},{"title":"cable_init_module – CABLE","text":"Uses cable_read_module netcdf cable_IO_vars_module cable_common_module cable_def_types_mod cable_abort_module Contents Subroutines get_default_inits get_restart_data Subroutines public subroutine get_default_inits (met, soil, ssnow, canopy, logn, EMSOIL) Arguments Type Intent Optional Attributes Name type( met_type ), intent(in) :: met type( soil_parameter_type ), intent(in) :: soil type( soil_snow_type ), intent(inout) :: ssnow type( canopy_type ), intent(out) :: canopy integer, intent(in) :: logn real, intent(in) :: EMSOIL public subroutine get_restart_data (logn, ssnow, canopy, rough, bgc, bal, veg, soil, rad, vegparmnew, EMSOIL) (BP Nov 2009)\n$   IF(cable_user%SOIL_STRUC=='sli'.or.cable_user%FWSOIL_SWITCH=='Haverd2013') THEN\n$      CALL readpar(ncid_rin,'gamma',dummy,veg%gamma,filename%restart_in,           &\n$           max_vegpatches,'def',from_restart,mp)\n$   ENDIF Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn type( soil_snow_type ), intent(inout) :: ssnow type( canopy_type ), intent(inout) :: canopy type( roughness_type ), intent(inout) :: rough type( bgc_pool_type ), intent(inout) :: bgc type( balances_type ), intent(inout) :: bal type( veg_parameter_type ), intent(inout) :: veg type( soil_parameter_type ), intent(inout) :: soil type( radiation_type ), intent(inout) :: rad logical, intent(in) :: vegparmnew real, intent(in) :: EMSOIL","tags":"","loc":"module/cable_init_module.html"},{"title":"cable_soil_params_mod – CABLE","text":"Uses grid_constants_mod_cbl Contents Variables soilin soil_desc Derived Types soilin_type Subroutines cable_soil_params Variables Type Visibility Attributes Name Initial type( soilin_type ), public, SAVE :: soilin character(len=70), public, DIMENSION(nsoil_max) :: soil_desc Derived Types type, public :: soilin_type Components Type Visibility Attributes Name Initial character(len=70), public :: desc (nsoil_max) real, public, DIMENSION(nsoil_max) :: silt real, public, DIMENSION(nsoil_max) :: clay real, public, DIMENSION(nsoil_max) :: sand real, public, DIMENSION(nsoil_max) :: swilt real, public, DIMENSION(nsoil_max) :: sfc real, public, DIMENSION(nsoil_max) :: ssat real, public, DIMENSION(nsoil_max) :: bch real, public, DIMENSION(nsoil_max) :: hyds real, public, DIMENSION(nsoil_max) :: sucs real, public, DIMENSION(nsoil_max) :: rhosoil real, public, DIMENSION(nsoil_max) :: css real, public, DIMENSION(nsoil_max) :: c3 Subroutines public subroutine cable_soil_params () Arguments None","tags":"","loc":"module/cable_soil_params_mod.html"},{"title":"CABLE_CRU – CABLE","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses netcdf casa_ncdf_module cable_IO_vars_module Contents Variables CRU Derived Types CRU_MET_TYPE CRU_TYPE Subroutines CRU_INIT CRU_GET_FILENAME GET_CRU_CO2 GET_CRU_Ndep OPEN_CRU_MET CRU_GET_DAILY_MET CRU_GET_SUBDIURNAL_MET Variables Type Visibility Attributes Name Initial type( CRU_TYPE ), public :: CRU Derived Types type, public :: CRU_MET_TYPE Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), ALLOCATABLE :: METVALS type, public :: CRU_TYPE Components Type Visibility Attributes Name Initial integer, public :: mland integer, public :: NMET integer, public :: xdimsize integer, public :: ydimsize integer, public :: tdimsize integer, public :: CYEAR integer, public :: MetStart integer, public :: MetEnd integer, public :: CTSTEP integer, public :: DTsecs integer, public :: ktau integer, public, DIMENSION(9) :: F_ID integer, public, DIMENSION(9) :: V_ID real, public, DIMENSION(:), ALLOCATABLE :: AVG_LWDN real, public, DIMENSION(:), ALLOCATABLE :: CO2VALS logical, public :: DirectRead logical, public :: LeapYears logical, public, DIMENSION(:,:), ALLOCATABLE :: LandMask character(len=30), public :: Run character(len=15), public :: CO2 character(len=15), public :: Ndep character(len=15), public :: Forcing character(len=200), public :: BasePath character(len=200), public :: MetPath character(len=200), public :: LandMaskFile character(len=30), public, DIMENSION(9) :: VAR_NAME character(len=200), public, DIMENSION(9) :: MetFile type( CRU_MET_TYPE ), public, DIMENSION(11) :: MET real, public, DIMENSION(:), ALLOCATABLE :: NdepVALS integer, public :: NdepF_ID integer, public :: NdepV_ID integer, public :: Ndep_CTSTEP Subroutines public subroutine CRU_INIT (CRU) Read more… Arguments Type Intent Optional Attributes Name type( CRU_TYPE ) :: CRU public subroutine CRU_GET_FILENAME (CRU, cyear, par, FN) $    SELECT CASE ( par )\n$    CASE(rain) ; FN = TRIM(FN)//\"/rain/cruncep2015_1_rain_\"//cy//\".daymean.nc\"\n$    CASE(lwdn) ; FN = TRIM(FN)//\"/lwdown/cruncep2015_1_lwdown_\"//cy//\".daymean.nc\"\n$    CASE(swdn) ; FN = TRIM(FN)//\"/swdown/cruncep2015_1_swdown_\"//cy//\".daymean.nc\"\n$    CASE(pres) ; FN = TRIM(FN)//\"/press/cruncep2015_1_press_\"//cy//\".daymean.nc\"\n$    CASE(qair) ; FN = TRIM(FN)//\"/qair/cruncep2015_1_qair_\"//cy//\".daymean.nc\"\n$    CASE(tmax,PrevTmax) ; FN = TRIM(FN)//\"/tmax/cruncep2015_1_tair_\"//cy//\".daymax.nc\"\n$    CASE(tmin,NextTmin) ; FN = TRIM(FN)//\"/tmin/cruncep2015_1_tair_\"//cy//\".daymin.nc\"\n$    CASE(uwind) ; FN = TRIM(FN)//\"/uwind/cruncep2015_1_uwind_\"//cy//\".daymean.nc\"\n$    CASE(vwind) ; FN = TRIM(FN)//\"/vwind/cruncep2015_1_vwind_\"//cy//\".daymean.nc\"\n$    END SELECT Arguments Type Intent Optional Attributes Name type( CRU_TYPE ), intent(inout) :: CRU integer, intent(in) :: cyear integer, intent(in) :: par character(len=200), intent(out) :: FN public subroutine GET_CRU_CO2 (CRU, CO2air) Arguments Type Intent Optional Attributes Name type( CRU_TYPE ) :: CRU real, intent(out) :: CO2air public subroutine GET_CRU_Ndep (CRU) Arguments Type Intent Optional Attributes Name type( CRU_TYPE ), intent(inout) :: CRU public subroutine OPEN_CRU_MET (CRU) $    IF ( TRIM(CRU%Run) .EQ. 'S0_TRENDY' .OR.  ( TRIM(CRU%Run) .EQ. 'S1_TRENDY' )) THEN\n$      MetYear = 1901 + MOD(CRU%CYEAR-RunStartYear,30)\n$    ELSE IF ( TRIM(CRU%Run) .EQ. 'S2_TRENDY' ) THEN\n$      MetYear = CRU%CYEAR\n$    ENDIF Arguments Type Intent Optional Attributes Name type( CRU_TYPE ), intent(inout) :: CRU public subroutine CRU_GET_DAILY_MET (CRU, LastDayOfYear, LastYearOfMet) $  IF ( TRIM(CRU%Run) .EQ. 'S0_TRENDY' .OR.  ( TRIM(CRU%Run) .EQ. 'S1_TRENDY' )) THEN\n$    MetYear = 1901 + MOD(CRU%CYEAR-RunStartYear,30)\n$  ELSE IF ( TRIM(CRU%Run) .EQ. 'S2_TRENDY' ) THEN\n$    MetYear = CRU%CYEAR\n$  ELSE\n$    STOP 'Error in cable_cru.F90: CRU%Run not S0_TRENDY, S1_TRENDY, or 1901-2015'\n$  ENDIF Read more… Arguments Type Intent Optional Attributes Name type( CRU_TYPE ) :: CRU logical, intent(in) :: LastDayOfYear logical, intent(in) :: LastYearOfMet public subroutine CRU_GET_SUBDIURNAL_MET (CRU, MET, CurYear, ktau, kend, LastYearOfMet) !!  this only works with CANBERRA cable_driver, as ktau    !!!!\n!!  restarts on Jan 1                                      !!!! Read more… Arguments Type Intent Optional Attributes Name type( CRU_TYPE ) :: CRU type( met_type ) :: MET integer, intent(in) :: CurYear integer, intent(in) :: ktau integer, intent(in) :: kend logical, intent(in) :: LastYearOfMet","tags":"","loc":"module/cable_cru.html"},{"title":"cable_read_module – CABLE","text":"Uses cable_IO_vars_module cable_def_types_mod netcdf cable_abort_module Contents Interfaces readpar Subroutines redistr_i redistr_r redistr_rd redistr_r2 redistr_r2d Interfaces public interface readpar private subroutine readpar_i(ncid, parname, completeSet, var_i, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet integer, intent(inout), DIMENSION(:) :: var_i character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch private subroutine readpar_r(ncid, parname, completeSet, var_r, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet real(kind=4), intent(inout), DIMENSION(:) :: var_r character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch private subroutine readpar_rd(ncid, parname, completeSet, var_rd, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet real(kind=r_2), intent(inout), DIMENSION(:) :: var_rd character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch private subroutine readpar_r2(ncid, parname, completeSet, var_r2, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet real(kind=4), intent(inout), DIMENSION(:,:) :: var_r2 character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch private subroutine readpar_r2d(ncid, parname, completeSet, var_r2d, filename, npatch, dimswitch, from_restart, INpatch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: parname logical, intent(inout) :: completeSet real(kind=r_2), intent(inout), DIMENSION(:, :) :: var_r2d character(len=*), intent(in) :: filename integer, intent(in) :: npatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: from_restart integer, intent(in), optional :: INpatch Subroutines public subroutine redistr_i (INpatch, nap, in_i, out_i, parname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) integer, intent(in) :: in_i (INpatch) integer, intent(out) :: out_i (mp) character(len=*), intent(in) :: parname public subroutine redistr_r (INpatch, nap, in_r, out_r, parname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) real, intent(in) :: in_r (INpatch) real, intent(out) :: out_r (mp) character(len=*), intent(in) :: parname public subroutine redistr_rd (INpatch, nap, in_rd, out_rd, parname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) real(kind=r_2), intent(in) :: in_rd (INpatch) real(kind=r_2), intent(out) :: out_rd (mp) character(len=*), intent(in) :: parname public subroutine redistr_r2 (INpatch, nap, in_r2, out_r2, parname, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) real, intent(in) :: in_r2 (INpatch,dim2) real, intent(out) :: out_r2 (mp,dim2) character(len=*), intent(in) :: parname integer, intent(in) :: dim2 public subroutine redistr_r2d (INpatch, nap, in_r2d, out_r2d, parname, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: INpatch integer, intent(in) :: nap (INpatch) real(kind=r_2), intent(in) :: in_r2d (INpatch,dim2) real(kind=r_2), intent(out) :: out_r2d (mp,dim2) character(len=*), intent(in) :: parname integer, intent(in) :: dim2","tags":"","loc":"module/cable_read_module.html"},{"title":"cable_mpimaster – CABLE","text":"subroutine for reading LU input data, zeroing biomass in empty secondary forest tiles\n and tranferring LUC-based age weights for secondary forest to POP structure Uses casa_inout_module cable_mpicommon casa_cable Contents Subroutines mpidrv_master Subroutines public subroutine mpidrv_master (comm) vh_js !!\n vh_js !! suggest LALLOC should ulitmately be a switch in the .nml file\n vh_js !!\n$             IF ( CASAONLY .AND. IS_CASA_TIME(\"dread\", yyyy, iktau, kstart, koffset, &\n$                  kend, ktauday, logn) )  THEN\n$                ! CLN READ FROM FILE INSTEAD !\n$                WRITE(CYEAR,FMT=\"(I4)\")CurYear + INT((ktau-kstart+koffset)/(LOY*ktauday))\n$                ncfile  = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc'\n$                casa_it = NINT( REAL(iktau / ktauday) )\n$                CALL read_casa_dump( ncfile, casamet, casaflux, casa_it, kend, .FALSE. )\n$             ENDIF Read more… Arguments Type Intent Optional Attributes Name integer :: comm","tags":"","loc":"module/cable_mpimaster.html"},{"title":"cable_IO_vars_module – CABLE","text":"Uses cable_def_types_mod Contents Variables wlogn shod sdoy smoy syear timeunits calendar time_coord timevar daysm daysml lastday lastdayl leaps latitude longitude lat_all lon_all metGrid mask land_x land_y xdimsize ydimsize ngridcells landpt patch max_vegpatches nmetpatches globalMetfile gswpfile ncciy ncid_rin logn verbose soilparmnew soiltype_metfile vegtype_metfile vegpatch_metfile exists output patchout check PrecipScale defaultLAI fixedCO2 Derived Types patch_type land_type globalMet_type gswp_type parID_type input_details_type output_inclusion_type checks_type Variables Type Visibility Attributes Name Initial integer, public :: wlogn real, public :: shod integer, public :: sdoy integer, public :: smoy integer, public :: syear character(len=200), public :: timeunits character(len=10), public :: calendar character(len=3), public :: time_coord real(kind=r_2), public, POINTER, DIMENSION(:) :: timevar integer, public, DIMENSION(12) :: daysm = (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/) integer, public, DIMENSION(12) :: daysml = (/31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/) integer, public, DIMENSION(12) :: lastday = (/31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365/) integer, public, DIMENSION(12) :: lastdayl = (/31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366/) logical, public :: leaps real, public, POINTER, DIMENSION(:) :: latitude real, public, POINTER, DIMENSION(:) :: longitude real, public, POINTER, DIMENSION(:,:) :: lat_all real, public, POINTER, DIMENSION(:,:) :: lon_all character(len=4), public :: metGrid integer, public, POINTER, DIMENSION(:,:) :: mask integer, public, POINTER, DIMENSION(:) :: land_x integer, public, POINTER, DIMENSION(:) :: land_y integer, public :: xdimsize integer, public :: ydimsize integer, public :: ngridcells type( land_type ), public, DIMENSION(:), POINTER :: landpt type( patch_type ), public, DIMENSION(:), POINTER :: patch integer, public :: max_vegpatches integer, public :: nmetpatches type( globalMet_type ), public :: globalMetfile type( gswp_type ), public :: gswpfile integer, public :: ncciy integer, public :: ncid_rin integer, public :: logn logical, public :: verbose logical, public :: soilparmnew integer, public, POINTER :: soiltype_metfile (:,:) integer, public, POINTER :: vegtype_metfile (:,:) real, public, POINTER :: vegpatch_metfile (:,:) type( input_details_type ), public :: exists type( output_inclusion_type ), public, SAVE :: output type( output_inclusion_type ), public, SAVE :: patchout type( checks_type ), public :: check real, public, POINTER, DIMENSION(:) :: PrecipScale real, public, POINTER, DIMENSION(:,:) :: defaultLAI real, public :: fixedCO2 Derived Types type, public :: patch_type Components Type Visibility Attributes Name Initial real, public :: frac real, public :: latitude real, public :: longitude type, public :: land_type Components Type Visibility Attributes Name Initial integer, public :: nap integer, public :: cstart integer, public :: cend integer, public :: ilat integer, public :: ilon type, public :: globalMet_type Components Type Visibility Attributes Name Initial logical, public :: l_gpcc logical, public :: l_gswp logical, public :: l_ncar logical, public :: l_access character(len=99), public :: rainf character(len=99), public :: snowf character(len=99), public :: LWdown character(len=99), public :: SWdown character(len=99), public :: PSurf character(len=99), public :: Qair character(len=99), public :: Tair character(len=99), public :: wind type, public :: gswp_type Components Type Visibility Attributes Name Initial character(len=200), public :: rainf character(len=200), public :: snowf character(len=200), public :: LWdown character(len=200), public :: SWdown character(len=200), public :: PSurf character(len=200), public :: Qair character(len=200), public :: Tair character(len=200), public :: wind character(len=200), public :: mask type, public :: parID_type Components Type Visibility Attributes Name Initial integer, public :: bch integer, public :: latitude integer, public :: clay integer, public :: css integer, public :: rhosoil integer, public :: hyds integer, public :: rs20 integer, public :: sand integer, public :: sfc integer, public :: silt integer, public :: ssat integer, public :: sucs integer, public :: swilt integer, public :: froot integer, public :: zse integer, public :: canst1 integer, public :: dleaf integer, public :: meth integer, public :: za_tq integer, public :: za_uv integer, public :: ejmax integer, public :: frac4 integer, public :: hc integer, public :: lai integer, public :: rp20 integer, public :: rpcoef integer, public :: shelrb integer, public :: vbeta integer, public :: xalbnir integer, public :: vcmax integer, public :: xfang integer, public :: ratecp integer, public :: ratecs integer, public :: refsbare integer, public :: isoil integer, public :: iveg integer, public :: albsoil integer, public :: taul integer, public :: refl integer, public :: tauw integer, public :: refw integer, public :: wai integer, public :: vegcf integer, public :: extkn integer, public :: tminvj integer, public :: tmaxvj integer, public :: veg_class integer, public :: soil_class integer, public :: mvtype integer, public :: mstype integer, public :: patchfrac integer, public :: WatSat integer, public :: GWWatSat integer, public :: SoilMatPotSat integer, public :: GWSoilMatPotSat integer, public :: HkSat integer, public :: GWHkSat integer, public :: FrcSand integer, public :: FrcClay integer, public :: Clappb integer, public :: Watr integer, public :: GWWatr integer, public :: sfc_vec integer, public :: forg integer, public :: swilt_vec integer, public :: slope integer, public :: slope_std integer, public :: GWdz integer, public :: SatFracmax integer, public :: Qhmax integer, public :: QhmaxEfold integer, public :: HKefold integer, public :: HKdepth integer, public :: ishorizon integer, public :: nhorizons integer, public :: clitt integer, public :: zeta integer, public :: fsatmax integer, public :: gamma integer, public :: ZR integer, public :: F10 integer, public :: g0 integer, public :: g1 type, public :: input_details_type Components Type Visibility Attributes Name Initial logical, public :: Wind logical, public :: LWdown logical, public :: CO2air logical, public :: PSurf logical, public :: Snowf logical, public :: avPrecip logical, public :: LAI logical, public :: LAI_T logical, public :: LAI_M logical, public :: LAI_P logical, public :: parameters logical, public :: initial logical, public :: patch logical, public :: laiPatch type, public :: output_inclusion_type Components Type Visibility Attributes Name Initial logical, public :: met = .FALSE. vh_js !! logical, public :: flux = .FALSE. vh_js !! logical, public :: radiation = .FALSE. vh_js !! logical, public :: carbon = .FALSE. vh_js !! logical, public :: soil = .FALSE. vh_js !! logical, public :: snow = .FALSE. vh_js !! logical, public :: veg = .FALSE. vh_js !! logical, public :: params = .FALSE. vh_js !! logical, public :: balances = .FALSE. vh_js !! logical, public :: restart = .FALSE. vh_js !! logical, public :: ensemble = .FALSE. vh_js !! logical, public :: patch = .FALSE. vh_js !! logical, public :: casa = .FALSE. vh_js !! character(len=7), public :: grid = 'default' character(len=7), public :: averaging = 'all' integer, public :: interval logical, public :: SWdown = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LWdown = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Rainf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Snowf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PSurf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Tair = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qair = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Tscrn = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Tex = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qscrn = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: CO2air = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Wind = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Wind_N = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Wind_E = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LAI = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qmom = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qh = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qle = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qg = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SWnet = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LWnet = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Evap = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Ewater = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ESoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: TVeg = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ECanop = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PotEvap = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ACond = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilWet = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Albedo = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: visAlbedo = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: nirAlbedo = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: VegT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilTemp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilMoist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilMoistIce = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qs = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qsb = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: DelSoilMoist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: DelSWE = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: DelIntercept = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SnowT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: BaresoilT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: AvgSurfT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: RadT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SWE = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SnowMelt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: RootMoist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: CanopInt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: NEE = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: NPP = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: GPP = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: AutoResp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LeafResp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HeteroResp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SnowDepth = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Rnet = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HVeg = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HSoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: RnetSoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Ebal = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Wbal = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: CanT = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Fwsoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Area = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: GWMoist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: WatTable = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qrecharge = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SatFrac = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: NBP = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: dCdt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: TotSoilCarb = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: TotLivBiomass = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: TotLittCarb = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilCarbFast = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilCarbSlow = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SoilCarbPassive = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LittCarbMetabolic = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LittCarbStructural = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LittCarbCWD = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantCarbLeaf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantCarbFineRoot = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantCarbWood = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnover = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverLeaf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverFineRoot = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverWood = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverWoodDist = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverWoodCrowding = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: PlantTurnoverWoodResourceLim = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: LandUseFlux = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: bch = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: latitude = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: clay = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: css = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: rhosoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: hyds = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: rs20 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: sand = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: sfc = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: silt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ssat = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: sucs = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: swilt = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: froot = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: zse = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: canst1 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: dleaf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ejmax = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: frac4 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: hc = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: rp20 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: g0 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: g1 = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: rpcoef = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: shelrb = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: vcmax = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: xfang = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: wai = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: vegcf = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: extkn = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ratecp = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: ratecs = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: albsoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: taul = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: refl = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: tminvj = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: tmaxvj = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: vbeta = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: xalbnir = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: iveg = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: patchfrac = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: isoil = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: meth = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: za = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: slope = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: slope_std = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: GWdz = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: SatFracmax = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: Qhmax = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: QhmaxEfold = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HKefold = .FALSE. vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables logical, public :: HKdepth vh_js ! added CanT and fwsoil to the list\nvh_js !! additional casa variables type, public :: checks_type Components Type Visibility Attributes Name Initial logical, public :: ranges logical, public :: energy_bal logical, public :: mass_bal","tags":"","loc":"module/cable_io_vars_module.html"},{"title":"cable_pft_params_mod – CABLE","text":"Uses grid_constants_mod_cbl Contents Variables vegin veg_desc Derived Types vegin_type Subroutines cable_pft_params Variables Type Visibility Attributes Name Initial type( vegin_type ), public :: vegin character(len=70), public :: veg_desc (ntype_max) Derived Types type, public :: vegin_type Components Type Visibility Attributes Name Initial character(len=70), public :: desc (ntype_max) real, public :: canst1 (ntype_max) real, public :: length (ntype_max) real, public :: width (ntype_max) real, public :: vcmax (ntype_max) real, public :: ejmax (ntype_max) real, public :: hc (ntype_max) real, public :: xfang (ntype_max) real, public :: rp20 (ntype_max) real, public :: rpcoef (ntype_max) real, public :: rs20 (ntype_max) real, public :: wai (ntype_max) real, public :: rootbeta (ntype_max) real, public :: shelrb (ntype_max) real, public :: vegcf (ntype_max) real, public :: frac4 (ntype_max) real, public :: xalbnir (ntype_max) real, public :: extkn (ntype_max) real, public :: tminvj (ntype_max) real, public :: tmaxvj (ntype_max) real, public :: vbeta (ntype_max) real, public :: a1gs (ntype_max) real, public :: d0gs (ntype_max) real, public :: alpha (ntype_max) real, public :: convex (ntype_max) real, public :: cfrd (ntype_max) real, public :: gswmin (ntype_max) real, public :: conkc0 (ntype_max) real, public :: conko0 (ntype_max) real, public :: ekc (ntype_max) real, public :: eko (ntype_max) real, public :: g0 (ntype_max) real, public :: g1 (ntype_max) real, public :: zr (ntype_max) real, public :: clitt (ntype_max) real, public :: froot1 (ntype_max) real, public :: froot2 (ntype_max) real, public :: froot3 (ntype_max) real, public :: froot4 (ntype_max) real, public :: froot5 (ntype_max) real, public :: froot6 (ntype_max) real, public :: csoil1 (ntype_max) real, public :: csoil2 (ntype_max) real, public :: ratecs1 (ntype_max) real, public :: ratecs2 (ntype_max) real, public :: cplant1 (ntype_max) real, public :: cplant2 (ntype_max) real, public :: cplant3 (ntype_max) real, public :: ratecp1 (ntype_max) real, public :: ratecp2 (ntype_max) real, public :: ratecp3 (ntype_max) real, public :: refl1 (ntype_max) real, public :: refl2 (ntype_max) real, public :: refl3 (ntype_max) real, public :: taul1 (ntype_max) real, public :: taul2 (ntype_max) real, public :: taul3 (ntype_max) real, public :: dleaf (ntype_max) real, public :: lai (ntype_max) Subroutines public subroutine cable_pft_params () Arguments None","tags":"","loc":"module/cable_pft_params_mod.html"},{"title":"CABLE_METUTILS_MODULE – CABLE","text":"Uses netcdf Contents Variables possible_varnames Derived Types input_netcdf_names Subroutines find_metvarid Variables Type Visibility Attributes Name Initial type( input_netcdf_names ), public :: possible_varnames Derived Types type, public :: input_netcdf_names Components Type Visibility Attributes Name Initial character(len=8), public, DIMENSION(3) :: LatNames = (/'latitude', 'nav_lat ', 'lat     '/) character(len=9), public, DIMENSION(3) :: LonNames = (/'longitude', 'nav_lon  ', 'lon      '/) character(len=7), public, DIMENSION(2) :: MaskNames = (/'mask   ', 'landsea'/) character(len=4), public, DIMENSION(1) :: TimeNames = (/'time'/) character(len=6), public, DIMENSION(4) :: SWdownNames = (/'dswrf ', 'rsds  ', 'FSDS  ', 'SWdown'/) character(len=4), public, DIMENSION(3) :: TairNames = (/'tas ', 'TBOT', 'Tair'/) character(len=4), public, DIMENSION(4) :: QairNames = (/'shum', 'huss', 'QBOT', 'Qair'/) character(len=4), public, DIMENSION(3) :: WindNames = (/'wind', 'Wind', 'WIND'/) character(len=8), public, DIMENSION(5) :: RainNames = (/'prcp    ', 'pr      ', 'RAIN    ', 'Rainf   ', 'Precip  '/) character(len=6), public, DIMENSION(4) :: LWdownNames = (/'dlwrf ', 'rlds  ', 'FLDS  ', 'LWdown'/) character(len=5), public, DIMENSION(5) :: PSurfNames = (/'pres ', 'ps   ', 'PBOT ', 'PSurf', 'Psurf'/) character(len=9), public, DIMENSION(1) :: ElevNames = (/'Elevation'/) character(len=6), public, DIMENSION(1) :: CO2Names = (/'CO2air'/) character(len=5), public, DIMENSION(1) :: SnowNames = (/'Snowf'/) character(len=3), public, DIMENSION(1) :: LAINames = (/'LAI'/) character(len=8), public, DIMENSION(1) :: APrecipNames = (/'avPrecip'/) character(len=4), public, DIMENSION(1) :: IVegNames = (/'iveg'/) character(len=9), public, DIMENSION(1) :: PFracNames = (/'patchfrac'/) character(len=5), public, DIMENSION(1) :: ISoilNames = (/'isoil'/) Subroutines public subroutine find_metvarid (file_id, possible_names, varid, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id character(len=*), intent(in), DIMENSION(:) :: possible_names integer, intent(out) :: varid integer, intent(out) :: status","tags":"","loc":"module/cable_metutils_module.html"},{"title":"cable_output_module – CABLE","text":"Uses cable_write_module netcdf casavariable cable_IO_vars_module cable_checks_module cable_common_module cable_def_types_mod cable_abort_module Contents Subroutines open_output_file write_output close_output_file create_restart Subroutines public subroutine open_output_file (dels, soil, veg, bgc, rough) vh_js !!\nvh_js !! Arguments Type Intent Optional Attributes Name real, intent(in) :: dels type( soil_parameter_type ), intent(in) :: soil type( veg_parameter_type ), intent(in) :: veg type( bgc_pool_type ), intent(in) :: bgc type( roughness_type ), intent(in) :: rough public subroutine write_output (dels, ktau, met, canopy, casaflux, casapool, casamet, ssnow, rad, bal, air, soil, veg, SBOLTZ, EMLEAF, EMSOIL) vh_js !!\nvh_js !!\nvh_js !! Arguments Type Intent Optional Attributes Name real, intent(in) :: dels integer, intent(in) :: ktau type( met_type ), intent(in) :: met type( canopy_type ), intent(in) :: canopy type(casa_flux), intent(in) :: casaflux type(casa_pool), intent(in) :: casapool type(casa_met), intent(in) :: casamet type( soil_snow_type ), intent(in) :: ssnow type( radiation_type ), intent(in) :: rad type( balances_type ), intent(inout) :: bal type( air_type ), intent(in) :: air type( soil_parameter_type ), intent(in) :: soil type( veg_parameter_type ), intent(in) :: veg real, intent(in) :: SBOLTZ real, intent(in) :: EMLEAF real, intent(in) :: EMSOIL public subroutine close_output_file (bal, air, bgc, canopy, met, rad, rough, soil, ssnow, sum_flux, veg) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: bal type( air_type ), intent(inout) :: air type( bgc_pool_type ), intent(inout) :: bgc type( canopy_type ), intent(inout) :: canopy type( met_type ), intent(inout) :: met type( radiation_type ), intent(inout) :: rad type( roughness_type ), intent(inout) :: rough type( soil_parameter_type ), intent(inout) :: soil type( soil_snow_type ), intent(inout) :: ssnow type( sum_flux_type ), intent(inout) :: sum_flux type( veg_parameter_type ), intent(inout) :: veg public subroutine create_restart (logn, dels, ktau, soil, veg, ssnow, canopy, rough, rad, bgc, bal, met) $    CALL define_ovar(ncid_restart, rpid%clay, 'clay', '-',                     &\n$                     'Fraction of soil which is clay',                         &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%sand, 'sand', '-',                     &\n$                     'Fraction of soil which is sand',                         &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%silt, 'silt', '-',                     &\n$                     'Fraction of soil which is silt',                         &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%ssat, 'ssat', '-',                     &\n$                     'Fraction of soil volume which is water @ saturation',    &\n$                    .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%sfc, 'sfc', '-',                       &\n$                    'Fraction of soil volume which is water @ field capacity', &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.)\n$    CALL define_ovar(ncid_restart, rpid%swilt, 'swilt', '-',                   &\n$                     'Fraction of soil volume which is water @ wilting point', &\n$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn real, intent(in) :: dels integer, intent(in) :: ktau type( soil_parameter_type ), intent(in) :: soil type( veg_parameter_type ), intent(in) :: veg type( soil_snow_type ), intent(in) :: ssnow type( canopy_type ), intent(in) :: canopy type( roughness_type ), intent(in) :: rough type( radiation_type ), intent(in) :: rad type( bgc_pool_type ), intent(in) :: bgc type( balances_type ), intent(in) :: bal type( met_type ), intent(in) :: met","tags":"","loc":"module/cable_output_module.html"},{"title":"casa_ncdf_module – CABLE","text":"Contents Interfaces put_var_nc get_var_nc Functions IS_CASA_TIME Subroutines def_dims def_vars def_var_atts put_var_ncr1 put_var_ncr2 put_var_ncr3 get_var_ncr2 get_var_ncr3 HANDLE_ERR GET_UNIT stderr_nc YMDHMS2DOYSOD DOYSOD2YMDHMS Interfaces public interface put_var_nc public subroutine put_var_ncr1 (ncid, var_name, var) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real, intent(in), dimension(:) :: var public subroutine put_var_ncr2 (ncid, var_name, var, n_call) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(in), dimension(:) :: var integer, intent(in) :: n_call public subroutine put_var_ncr3 (ncid, var_name, var, n_call, nl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(in), dimension(:,:) :: var integer, intent(in) :: n_call integer, intent(in) :: nl public interface get_var_nc public subroutine get_var_ncr2 (ncid, var_name, var, n_call) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(out), dimension(:) :: var integer :: n_call public subroutine get_var_ncr3 (ncid, var_name, var, n_call, nl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(out), dimension(:,:) :: var integer, intent(in) :: n_call integer, intent(in) :: nl Functions public function IS_CASA_TIME (iotype, yyyy, ktau, kstart, koffset, kend, ktauday, logn) Arguments Type Intent Optional Attributes Name character, intent(in) :: iotype *5 integer, intent(in) :: yyyy integer, intent(in) :: ktau integer, intent(in) :: kstart integer, intent(in) :: koffset integer, intent(in) :: kend integer, intent(in) :: ktauday integer, intent(in) :: logn Return Value logical Subroutines public subroutine def_dims (nd, ncid, dimID, dim_len, dim_name) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nd integer, intent(in) :: ncid integer, intent(out), dimension(:) :: dimID integer, intent(in), dimension(:) :: dim_len character(len=*), intent(in), dimension(:) :: dim_name public subroutine def_vars (nv, ncid, xtype, dimID, var_name, varID) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nv integer, intent(in) :: ncid integer, intent(in) :: xtype integer, intent(in), dimension(:) :: dimID character(len=*), intent(in), dimension(:) :: var_name integer, intent(inout), dimension(:) :: varID public subroutine def_var_atts (ncfile_in, ncid, varID) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ncfile_in integer, intent(in) :: ncid integer, intent(in), dimension(:) :: varID public subroutine put_var_ncr1 (ncid, var_name, var) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real, intent(in), dimension(:) :: var public subroutine put_var_ncr2 (ncid, var_name, var, n_call) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(in), dimension(:) :: var integer, intent(in) :: n_call public subroutine put_var_ncr3 (ncid, var_name, var, n_call, nl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(in), dimension(:,:) :: var integer, intent(in) :: n_call integer, intent(in) :: nl public subroutine get_var_ncr2 (ncid, var_name, var, n_call) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(out), dimension(:) :: var integer :: n_call public subroutine get_var_ncr3 (ncid, var_name, var, n_call, nl) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: var_name real(kind=r_2), intent(out), dimension(:,:) :: var integer, intent(in) :: n_call integer, intent(in) :: nl public subroutine HANDLE_ERR (status, msg) Arguments Type Intent Optional Attributes Name integer :: status character(len=*), intent(in), optional :: msg public subroutine GET_UNIT (IUNIT) Arguments Type Intent Optional Attributes Name integer, intent(out) :: IUNIT public subroutine stderr_nc (status, message, var) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status character(len=*), intent(in) :: message character(len=*), intent(in) :: var public subroutine YMDHMS2DOYSOD (YYYY, MM, DD, HOUR, MINUTE, SECOND, DOY, SOD) Arguments Type Intent Optional Attributes Name integer, intent(in) :: YYYY integer, intent(in) :: MM integer, intent(in) :: DD integer, intent(in) :: HOUR integer, intent(in) :: MINUTE integer, intent(in) :: SECOND integer, intent(out) :: DOY integer, intent(out) :: SOD public subroutine DOYSOD2YMDHMS (YYYY, DOY, SOD, MM, DD, HOUR, MINUTE, SECOND) Arguments Type Intent Optional Attributes Name integer, intent(in) :: YYYY integer, intent(in) :: DOY integer, intent(in) :: SOD integer, intent(out) :: MM integer, intent(out) :: DD integer, intent(out), optional :: HOUR integer, intent(out), optional :: MINUTE integer, intent(out), optional :: SECOND","tags":"","loc":"module/casa_ncdf_module.html"},{"title":"CABLE_site – CABLE","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses casa_ncdf_module CABLE_COMMON_MODULE cable_IO_vars_module Contents Variables site Derived Types site_TYPE Subroutines site_INIT site_GET_CO2_Ndep Variables Type Visibility Attributes Name Initial type( site_TYPE ), public :: site Derived Types type, public :: site_TYPE Components Type Visibility Attributes Name Initial character(len=15), public :: RunType real, public, DIMENSION(:), ALLOCATABLE :: CO2VALS real, public, DIMENSION(:), ALLOCATABLE :: NdepVALS real, public, DIMENSION(:), ALLOCATABLE :: PdepVALS integer, public :: mland character(len=200), public :: CO2NdepFile integer, public :: spinstartyear integer, public :: spinendyear real, public :: spinCO2 real, public :: spinNdep real, public :: spinPdep real, public :: CO2 real, public :: Ndep real, public :: Pdep Subroutines public subroutine site_INIT (site) Read more… Arguments Type Intent Optional Attributes Name type( site_TYPE ) :: site public subroutine site_GET_CO2_Ndep (site) Arguments Type Intent Optional Attributes Name type( site_TYPE ) :: site","tags":"","loc":"module/cable_site.html"},{"title":"CABLE_WEATHERGENERATOR – CABLE","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Contents Derived Types WEATHER_GENERATOR_TYPE Subroutines WGEN_INIT WGEN_DAILY_CONSTANTS WGEN_SUBDIURNAL_MET Derived Types type, public :: WEATHER_GENERATOR_TYPE Components Type Visibility Attributes Name Initial integer, public :: np integer, public :: ndtime real, public :: delT real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: LatDeg real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: WindDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempMinDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempMaxDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempMinDayNext real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempMaxDayPrev real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: SolarMJDay real(kind=sp), public :: DecRad real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: WindDark real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: WindLite real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: SolarNorm real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: LatRad real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: DayLength real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TimeSunsetPrev real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TimeSunrise real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TimeMaxTemp real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TimeSunset real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempSunsetPrev real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempSunset real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempNightRate real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempNightRatePrev real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempRangeDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: TempRangeAft real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: PrecipDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: SnowDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: PmbDay real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: PhiSd real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: PhiLd real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Precip real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Snow real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Wind real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Temp real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: VapPmb real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: Pmb real(kind=sp), public, DIMENSION(:), ALLOCATABLE :: coszen Subroutines public subroutine WGEN_INIT (WG, np, latitude, dels) Arguments Type Intent Optional Attributes Name type( WEATHER_GENERATOR_TYPE ) :: WG integer, intent(in) :: np real, intent(in) :: latitude (np) real, intent(in) :: dels public subroutine WGEN_DAILY_CONSTANTS (WG, np, YearDay) $write(71, \"( 1000e16.6)\") WG%DecRad\n$   write(72, \"( 1000e16.6)\") TAN(WG%DecRad)\n$   write(73, \"( 1000e16.6)\") TAN(WG%LatRad)\n$ write(74, \"( 1000e16.6)\")  WG%DayLength Arguments Type Intent Optional Attributes Name type( WEATHER_GENERATOR_TYPE ) :: WG integer, intent(in) :: np integer, intent(in) :: YearDay public subroutine WGEN_SUBDIURNAL_MET (WG, np, itime) Arguments Type Intent Optional Attributes Name type( WEATHER_GENERATOR_TYPE ) :: WG integer, intent(in) :: np integer, intent(in) :: itime","tags":"","loc":"module/cable_weathergenerator.html"},{"title":"cable_param_module – CABLE","text":"Uses casadimension casavariable cable_soil_params_mod cable_pft_params_mod CABLE_LUC_EXPT cable_IO_vars_module cable_common_module phenvariable cable_def_types_mod cable_abort_module Contents Subroutines get_default_params write_default_params write_cnp_params derived_parameters check_parameter_values report_parameters Subroutines public subroutine get_default_params (logn, vegparmnew, LUC_EXPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn logical, intent(in) :: vegparmnew type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT public subroutine write_default_params (met, air, ssnow, veg, bgc, soil, canopy, rough, rad, logn, vegparmnew, month, TFRZ, LUC_EXPT) vh_js !!\n I brought this in with manual merge of #199 BUT Am i bringing this back in ?\n! calculate vegin%froot from using rootbeta and soil depth\n! (Jackson et al. 1996, Oceologica, 108:389-411)\ntotdepth = 0.0\nDO is = 1, ms\n   totdepth = totdepth + soil%zse(is) * 100.0  ! unit in centimetres\n   vegin%froot(is, :) = MIN(1.0, 1.0-vegin%rootbeta(:)**totdepth)\nEND DO\nDO is = ms, 2, -1\n   vegin%froot(is, :) = vegin%froot(is, :)-vegin%froot(is-1, :)\nEND DO Read more… Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: met type( air_type ), intent(inout) :: air type( soil_snow_type ), intent(inout) :: ssnow type( veg_parameter_type ), intent(inout) :: veg type( bgc_pool_type ), intent(inout) :: bgc type( soil_parameter_type ), intent(inout) :: soil type( canopy_type ), intent(inout) :: canopy type( roughness_type ), intent(inout) :: rough type( radiation_type ), intent(inout) :: rad integer, intent(in) :: logn logical, intent(in) :: vegparmnew integer, intent(in) :: month real, intent(in) :: TFRZ type( LUC_EXPT_TYPE ), intent(in) :: LUC_EXPT public subroutine write_cnp_params (veg, casaflux, casamet) vh !! fluxes shouldn't be weighted by patch frac. Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(in) :: veg type(casa_flux), intent(inout) :: casaflux type(casa_met), intent(inout) :: casamet public subroutine derived_parameters (soil, sum_flux, bal, ssnow, veg, rough) vegetation dependent field capacity (point plants get stressed) and Read more… Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: soil type( sum_flux_type ), intent(inout) :: sum_flux type( balances_type ), intent(inout) :: bal type( soil_snow_type ), intent(inout) :: ssnow type( veg_parameter_type ), intent(in) :: veg type( roughness_type ), intent(inout) :: rough public subroutine check_parameter_values (soil, veg, ssnow) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: soil type( veg_parameter_type ), intent(inout) :: veg type( soil_snow_type ), intent(inout) :: ssnow public subroutine report_parameters (logn, soil, veg, bgc, rough, ssnow, canopy, casamet, casapool, casaflux, phen, vegparmnew, verbose) Arguments Type Intent Optional Attributes Name integer, intent(in) :: logn type( soil_parameter_type ), intent(in) :: soil type( veg_parameter_type ), intent(in) :: veg type( bgc_pool_type ), intent(in) :: bgc type( roughness_type ), intent(in) :: rough type( soil_snow_type ), intent(in) :: ssnow type( canopy_type ), intent(in) :: canopy type(casa_met), intent(in) :: casamet type(casa_pool), intent(in) :: casapool type(casa_flux), intent(in) :: casaflux type(phen_variable), intent(in) :: phen logical, intent(in) :: vegparmnew logical, intent(in) :: verbose","tags":"","loc":"module/cable_param_module.html"},{"title":"cable_abort_module – CABLE","text":"Contents Subroutines abort nc_abort range_abort Subroutines public subroutine abort (message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message public subroutine nc_abort (ok, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ok character(len=*), intent(in) :: message public subroutine range_abort (message, ktau, met, value, var_range, i, xx, yy) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message integer, intent(in) :: ktau type( met_type ), intent(in) :: met real, intent(in) :: value real, intent(in), DIMENSION(2) :: var_range integer, intent(in) :: i integer, intent(in), optional :: xx integer, intent(in), optional :: yy","tags":"","loc":"module/cable_abort_module.html"},{"title":"CABLE_PLUME_MIP – CABLE","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses netcdf CABLE_COMMON_MODULE casa_ncdf_module cable_IO_vars_module Contents Variables PLUME Derived Types PLUME_MET_TYPE PLUME_MIP_TYPE Functions FILE_SWITCH Subroutines PLUME_MIP_INIT PLUME_GET_FILENAME GET_PLUME_CO2 OPEN_PLUME_MET PLUME_GET_DAILY_MET PLUME_MIP_GET_MET Variables Type Visibility Attributes Name Initial type( PLUME_MIP_TYPE ), public :: PLUME Derived Types type, public :: PLUME_MET_TYPE Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), ALLOCATABLE :: VAL type, public :: PLUME_MIP_TYPE Components Type Visibility Attributes Name Initial integer, public :: mland integer, public :: NMET integer, public :: xdimsize integer, public :: ydimsize integer, public :: tdimsize integer, public :: CYEAR integer, public :: MetStart integer, public :: MetEnd integer, public :: CTSTEP integer, public :: DT integer, public :: ktau integer, public, DIMENSION(9) :: F_ID integer, public, DIMENSION(9) :: V_ID real, public, DIMENSION(:), ALLOCATABLE :: AVG_LWDN real, public, DIMENSION(:), ALLOCATABLE :: CO2VALS logical, public :: DirectRead logical, public :: LeapYears logical, public, DIMENSION(:,:), ALLOCATABLE :: LandMask character(len=15), public :: Run character(len=15), public :: Forcing character(len=15), public :: RCP character(len=15), public :: CO2 character(len=15), public :: NDEP character(len=15), public :: RCPdir character(len=200), public :: BasePath character(len=200), public :: MetPath character(len=200), public :: LandMaskFile character(len=12), public, DIMENSION(9) :: VAR_NAME character(len=200), public, DIMENSION(9) :: MetFile type( PLUME_MET_TYPE ), public, DIMENSION(11) :: MET Functions public function FILE_SWITCH (PLUME, action) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ), intent(in) :: PLUME character(len=5), intent(in) :: action Return Value logical Subroutines public subroutine PLUME_MIP_INIT (PLUME) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME public subroutine PLUME_GET_FILENAME (PLUME, cyear, par, FN) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ), intent(inout) :: PLUME integer, intent(in) :: cyear integer, intent(in) :: par character(len=200), intent(out) :: FN public subroutine GET_PLUME_CO2 (PLUME, CO2air) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME real, intent(out) :: CO2air public subroutine OPEN_PLUME_MET (PLUME) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME public subroutine PLUME_GET_DAILY_MET (PLUME, TminFlag, islast) Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME logical, intent(in) :: TminFlag logical, intent(in) :: islast public subroutine PLUME_MIP_GET_MET (PLUME, MET, CurYear, ktau, kend, islast) !!  this only works with CANBERRA cable_driver, as ktau    !!!!\n!!  restarts on Jan 1                                      !!!! Read more… Arguments Type Intent Optional Attributes Name type( PLUME_MIP_TYPE ) :: PLUME type( met_type ) :: MET integer, intent(in) :: CurYear integer, intent(in) :: ktau integer, intent(in) :: kend logical, intent(in) :: islast","tags":"","loc":"module/cable_plume_mip.html"},{"title":"cable_mpicommon – CABLE","text":"Uses cable_def_types_mod Contents Variables nparam nsoilnew ncasaparam ncinit ncinit2 ncinit3 ncdumprw nLUCrw npop ninput n3d nmat nvec ncasa_mat ncasa_vec nrestart nsumcasaflux nsumcasapool nclimate nphen wpatch extr1 extr2 extid extl Derived Types lpdecomp_t Subroutines find_extents decomp_types bcast_start_time Variables Type Visibility Attributes Name Initial integer, public, parameter :: nparam = 330 integer, public, parameter :: nsoilnew = 1 integer, public, parameter :: ncasaparam = 213 integer, public, parameter :: ncinit = 18 integer, public, parameter :: ncinit2 = 13 integer, public, parameter :: ncinit3 = 18 integer, public, parameter :: ncdumprw = 8 integer, public, parameter :: nLUCrw = 12 integer, public, parameter :: npop = 988 integer, public, parameter :: ninput = 16 integer, public, parameter :: n3d = 1 integer, public, parameter :: nmat = 40 integer, public, parameter :: nvec = 175 integer, public, parameter :: ncasa_mat = 37 integer, public, parameter :: ncasa_vec = 58 integer, public, parameter :: nrestart = 15 integer, public, parameter :: nsumcasaflux = 62 integer, public, parameter :: nsumcasapool = 40 integer, public, parameter :: nclimate = 30 integer, public, parameter :: nphen = 9 type( lpdecomp_t ), public :: wpatch integer, public :: extr1 integer, public :: extr2 integer, public :: extid integer, public :: extl Derived Types type, public :: lpdecomp_t Components Type Visibility Attributes Name Initial integer, public :: landp0 integer, public :: nland integer, public :: patch0 integer, public :: npatch integer, public :: npop_iwood integer, public, ALLOCATABLE :: iwood (:) Subroutines public subroutine find_extents () Arguments None public subroutine decomp_types (landpt_t, patch_t) Arguments Type Intent Optional Attributes Name integer, intent(out) :: landpt_t integer, intent(out) :: patch_t public subroutine bcast_start_time (comm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: comm","tags":"","loc":"module/cable_mpicommon.html"},{"title":"cable_cbm_module – CABLE","text":"Contents Subroutines cbm Subroutines public subroutine cbm (ktau, dels, air, bgc, canopy, met, bal, rad, rough, soil, ssnow, sum_flux, veg, climate, xk, c1, rhoch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau real, intent(in) :: dels type( air_type ), intent(inout) :: air type( bgc_pool_type ), intent(inout) :: bgc type( canopy_type ), intent(inout) :: canopy type( met_type ), intent(inout) :: met type( balances_type ), intent(inout) :: bal type( radiation_type ), intent(inout) :: rad type( roughness_type ), intent(inout) :: rough type( soil_parameter_type ), intent(inout) :: soil type( soil_snow_type ), intent(inout) :: ssnow type( sum_flux_type ), intent(inout) :: sum_flux type( veg_parameter_type ), intent(inout) :: veg type( climate_type ), intent(in) :: climate real :: xk (mp,nrb) real :: c1 (mp,nrb) real :: rhoch (mp,nrb)","tags":"","loc":"module/cable_cbm_module.html"},{"title":"cable_namelist_util – CABLE","text":"Contents Variables CABLE_NAMELIST arg_not_namelist Subroutines get_namelist_file_name Variables Type Visibility Attributes Name Initial character, public, ALLOCATABLE, SAVE :: CABLE_NAMELIST logical, public, SAVE :: arg_not_namelist Subroutines public subroutine get_namelist_file_name () Arguments None","tags":"","loc":"module/cable_namelist_util.html"},{"title":"cable_def_types_mod – CABLE","text":"Contents Variables mp mvtype mstype mland i_d r_2 n_tiles ncp ncs mf nrb msn swb niter ms n_ktherm Interfaces alloc_cbm_var dealloc_cbm_var Derived Types balances_type soil_parameter_type soil_snow_type veg_parameter_type canopy_type radiation_type roughness_type air_type met_type climate_type sum_flux_type bgc_pool_type Subroutines alloc_balances_type alloc_soil_parameter_type alloc_soil_snow_type alloc_veg_parameter_type alloc_canopy_type alloc_radiation_type alloc_roughness_type alloc_air_type alloc_met_type alloc_climate_type alloc_sum_flux_type dealloc_balances_type dealloc_soil_parameter_type dealloc_soil_snow_type dealloc_veg_parameter_type dealloc_canopy_type dealloc_radiation_type dealloc_roughness_type dealloc_air_type dealloc_met_type dealloc_sum_flux_type Variables Type Visibility Attributes Name Initial integer, public :: mp integer, public :: mvtype integer, public :: mstype integer, public :: mland integer, public, parameter :: i_d = KIND(9) integer, public, parameter :: r_2 = KIND(1.d0) integer, public, parameter :: n_tiles = 17 integer, public, parameter :: ncp = 3 integer, public, parameter :: ncs = 2 integer, public, parameter :: mf = 2 integer, public, parameter :: nrb = 3 integer, public, parameter :: msn = 3 integer, public, parameter :: swb = 2 integer, public, parameter :: niter = 4 integer, public, parameter :: ms = 6 integer, public, parameter :: n_ktherm = 3 Interfaces public interface alloc_cbm_var public subroutine alloc_balances_type (var, mp) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_soil_parameter_type (var, mp) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_soil_snow_type (var, mp) Arguments Type Intent Optional Attributes Name type( soil_snow_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_veg_parameter_type (var, mp) Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_canopy_type (var, mp) vh_js !! liiter resistances to heat and vapour transfer Arguments Type Intent Optional Attributes Name type( canopy_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_radiation_type (var, mp) Arguments Type Intent Optional Attributes Name type( radiation_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_roughness_type (var, mp) Arguments Type Intent Optional Attributes Name type( roughness_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_air_type (var, mp) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_met_type (var, mp) Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_sum_flux_type (var, mp) Arguments Type Intent Optional Attributes Name type( sum_flux_type ), intent(inout) :: var integer, intent(in) :: mp private subroutine alloc_bgc_pool_type(var, mp) Arguments Type Intent Optional Attributes Name type( bgc_pool_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_climate_type (var, mp) Arguments Type Intent Optional Attributes Name type( climate_type ), intent(inout) :: var integer, intent(in) :: mp public interface dealloc_cbm_var public subroutine dealloc_balances_type (var) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: var public subroutine dealloc_soil_parameter_type (var) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: var public subroutine dealloc_soil_snow_type (var) Arguments Type Intent Optional Attributes Name type( soil_snow_type ), intent(inout) :: var public subroutine dealloc_veg_parameter_type (var) Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(inout) :: var public subroutine dealloc_canopy_type (var) vh_js !! liiter resistances to heat and vapour transfer Arguments Type Intent Optional Attributes Name type( canopy_type ), intent(inout) :: var public subroutine dealloc_radiation_type (var) Arguments Type Intent Optional Attributes Name type( radiation_type ), intent(inout) :: var public subroutine dealloc_roughness_type (var) Arguments Type Intent Optional Attributes Name type( roughness_type ), intent(inout) :: var public subroutine dealloc_air_type (var) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: var public subroutine dealloc_met_type (var) Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: var public subroutine dealloc_sum_flux_type (var) Arguments Type Intent Optional Attributes Name type( sum_flux_type ), intent(inout) :: var private subroutine dealloc_bgc_pool_type(var) Arguments Type Intent Optional Attributes Name type( bgc_pool_type ), intent(inout) :: var Derived Types type, public :: balances_type Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: drybal real, public, DIMENSION(:), POINTER :: ebal real, public, DIMENSION(:), POINTER :: ebal_tot real, public, DIMENSION(:), POINTER :: ebal_cncheck real, public, DIMENSION(:), POINTER :: ebal_tot_cncheck real, public, DIMENSION(:), POINTER :: ebaltr real, public, DIMENSION(:), POINTER :: ebal_tottr real, public, DIMENSION(:), POINTER :: evap_tot real, public, DIMENSION(:), POINTER :: osnowd0 real, public, DIMENSION(:), POINTER :: precip_tot real, public, DIMENSION(:), POINTER :: rnoff_tot real, public, DIMENSION(:), POINTER :: wbal real, public, DIMENSION(:), POINTER :: wbal_tot real, public, DIMENSION(:), POINTER :: wbtot0 real, public, DIMENSION(:), POINTER :: wetbal real, public, DIMENSION(:), POINTER :: cansto0 real, public, DIMENSION(:), POINTER :: owbtot real, public, DIMENSION(:), POINTER :: evapc_tot real, public, DIMENSION(:), POINTER :: evaps_tot real, public, DIMENSION(:), POINTER :: rnof1_tot real, public, DIMENSION(:), POINTER :: rnof2_tot real, public, DIMENSION(:), POINTER :: snowdc_tot real, public, DIMENSION(:), POINTER :: wbal_tot1 real, public, DIMENSION(:), POINTER :: delwc_tot real, public, DIMENSION(:), POINTER :: qasrf_tot real, public, DIMENSION(:), POINTER :: qfsrf_tot real, public, DIMENSION(:), POINTER :: qssrf_tot real, public, DIMENSION(:), POINTER :: Radbal real, public, DIMENSION(:), POINTER :: EbalSoil real, public, DIMENSION(:), POINTER :: Ebalveg real, public, DIMENSION(:), POINTER :: Radbalsum type, public :: soil_parameter_type Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), POINTER :: isoilm real, public, DIMENSION(:), POINTER :: bch real, public, DIMENSION(:), POINTER :: c3 real, public, DIMENSION(:), POINTER :: clay real, public, DIMENSION(:), POINTER :: css real, public, DIMENSION(:), POINTER :: hsbh real, public, DIMENSION(:), POINTER :: hyds real, public, DIMENSION(:), POINTER :: i2bp3 real, public, DIMENSION(:), POINTER :: ibp2 real, public, DIMENSION(:), POINTER :: rhosoil real, public, DIMENSION(:), POINTER :: sand real, public, DIMENSION(:), POINTER :: sfc real, public, DIMENSION(:), POINTER :: silt real, public, DIMENSION(:), POINTER :: ssat real, public, DIMENSION(:), POINTER :: sucs real, public, DIMENSION(:), POINTER :: swilt real, public, DIMENSION(:), POINTER :: zse real, public, DIMENSION(:), POINTER :: zshh real, public, DIMENSION(:), POINTER :: soilcol real, public, DIMENSION(:), POINTER :: albsoilf real(kind=r_2), public, DIMENSION(:,:), POINTER :: heat_cap_lower_limit real(kind=r_2), public, DIMENSION(:,:), POINTER :: zse_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: css_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: cnsd_vec real(kind=r_2), public, DIMENSION(:), POINTER :: cnsd real(kind=r_2), public, DIMENSION(:), POINTER :: pwb_min real, public, DIMENSION(:,:), POINTER :: albsoil real(kind=r_2), public, DIMENSION(:,:), POINTER :: sucs_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: hyds_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: bch_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: clay_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: sand_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: silt_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: org_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: rhosoil_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: ssat_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: watr real(kind=r_2), public, DIMENSION(:,:), POINTER :: sfc_vec real(kind=r_2), public, DIMENSION(:,:), POINTER :: swilt_vec real(kind=r_2), public, DIMENSION(:), POINTER :: drain_dens real(kind=r_2), public, DIMENSION(:), POINTER :: elev real(kind=r_2), public, DIMENSION(:), POINTER :: elev_std real(kind=r_2), public, DIMENSION(:), POINTER :: slope real(kind=r_2), public, DIMENSION(:), POINTER :: slope_std real(kind=r_2), public, DIMENSION(:), POINTER :: GWsucs_vec real(kind=r_2), public, DIMENSION(:), POINTER :: GWhyds_vec real(kind=r_2), public, DIMENSION(:), POINTER :: GWbch_vec real(kind=r_2), public, DIMENSION(:), POINTER :: GWssat_vec real(kind=r_2), public, DIMENSION(:), POINTER :: GWwatr real(kind=r_2), public, DIMENSION(:), POINTER :: GWz real(kind=r_2), public, DIMENSION(:), POINTER :: GWdz real(kind=r_2), public, DIMENSION(:), POINTER :: GWrhosoil_vec integer, public, DIMENSION(:), POINTER :: nhorizons integer, public, DIMENSION(:,:), POINTER :: ishorizon real(kind=r_2), public, DIMENSION(:), POINTER :: clitt real(kind=r_2), public, DIMENSION(:), POINTER :: zeta real(kind=r_2), public, DIMENSION(:), POINTER :: fsatmax type, public :: soil_snow_type Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), POINTER :: isflag real, public, DIMENSION(:), POINTER :: iantrct real, public, DIMENSION(:), POINTER :: pudsto real, public, DIMENSION(:), POINTER :: pudsmx real, public, DIMENSION(:), POINTER :: cls real, public, DIMENSION(:), POINTER :: dfn_dtg real, public, DIMENSION(:), POINTER :: dfh_dtg real, public, DIMENSION(:), POINTER :: dfe_ddq real, public, DIMENSION(:), POINTER :: ddq_dtg real, public, DIMENSION(:), POINTER :: dfe_dtg real, public, DIMENSION(:), POINTER :: evapsn real, public, DIMENSION(:), POINTER :: fwtop real, public, DIMENSION(:), POINTER :: fwtop1 real, public, DIMENSION(:), POINTER :: fwtop2 real, public, DIMENSION(:), POINTER :: fwtop3 real, public, DIMENSION(:), POINTER :: osnowd real, public, DIMENSION(:), POINTER :: potev real, public, DIMENSION(:), POINTER :: runoff real, public, DIMENSION(:), POINTER :: rnof1 real, public, DIMENSION(:), POINTER :: rnof2 real, public, DIMENSION(:), POINTER :: rtsoil real, public, DIMENSION(:), POINTER :: wbtot1 real, public, DIMENSION(:), POINTER :: wbtot2 real, public, DIMENSION(:), POINTER :: wb_lake real, public, DIMENSION(:), POINTER :: totwblake real, public, DIMENSION(:), POINTER :: sinfil real, public, DIMENSION(:), POINTER :: qstss real, public, DIMENSION(:), POINTER :: wetfac real, public, DIMENSION(:), POINTER :: owetfac real, public, DIMENSION(:), POINTER :: t_snwlr real, public, DIMENSION(:), POINTER :: tggav real, public, DIMENSION(:), POINTER :: otgg real, public, DIMENSION(:), POINTER :: otss real, public, DIMENSION(:), POINTER :: otss_0 real, public, DIMENSION(:), POINTER :: tprecip real, public, DIMENSION(:), POINTER :: tevap real, public, DIMENSION(:), POINTER :: trnoff real, public, DIMENSION(:), POINTER :: totenbal real, public, DIMENSION(:), POINTER :: totenbal2 real, public, DIMENSION(:), POINTER :: fland real, public, DIMENSION(:), POINTER :: ifland real, public, DIMENSION(:), POINTER :: qasrf real, public, DIMENSION(:), POINTER :: qfsrf real, public, DIMENSION(:), POINTER :: qssrf real, public, DIMENSION(:), POINTER :: snage real, public, DIMENSION(:), POINTER :: snowd real, public, DIMENSION(:), POINTER :: smelt real, public, DIMENSION(:), POINTER :: ssdnn real, public, DIMENSION(:), POINTER :: tss real, public, DIMENSION(:), POINTER :: tss_p real, public, DIMENSION(:), POINTER :: deltss real, public, DIMENSION(:), POINTER :: owb1 real, public, DIMENSION(:,:), POINTER :: sconds real, public, DIMENSION(:,:), POINTER :: sdepth real, public, DIMENSION(:,:), POINTER :: smass real, public, DIMENSION(:,:), POINTER :: ssdn real, public, DIMENSION(:,:), POINTER :: tgg real, public, DIMENSION(:,:), POINTER :: tggsn real, public, DIMENSION(:,:), POINTER :: dtmlt real, public, DIMENSION(:,:), POINTER :: albsoilsn real, public, DIMENSION(:,:), POINTER :: evapfbl real, public, DIMENSION(:,:), POINTER :: tilefrac real(kind=r_2), public, DIMENSION(:), POINTER :: wbtot real(kind=r_2), public, DIMENSION(:,:), POINTER :: gammzz real(kind=r_2), public, DIMENSION(:,:), POINTER :: wb real(kind=r_2), public, DIMENSION(:,:), POINTER :: wbice real(kind=r_2), public, DIMENSION(:,:), POINTER :: wblf real(kind=r_2), public, DIMENSION(:,:), POINTER :: wbfice real(kind=r_2), public, DIMENSION(:), POINTER :: GWwb real(kind=r_2), public, DIMENSION(:), POINTER :: GWhk real(kind=r_2), public, DIMENSION(:), POINTER :: GWdhkdw real(kind=r_2), public, DIMENSION(:), POINTER :: GWdsmpdw real(kind=r_2), public, DIMENSION(:), POINTER :: wtd real(kind=r_2), public, DIMENSION(:), POINTER :: GWsmp real(kind=r_2), public, DIMENSION(:), POINTER :: GWwbeq real(kind=r_2), public, DIMENSION(:), POINTER :: GWzq real(kind=r_2), public, DIMENSION(:), POINTER :: qhz real(kind=r_2), public, DIMENSION(:), POINTER :: satfrac real(kind=r_2), public, DIMENSION(:), POINTER :: Qrecharge real(kind=r_2), public, DIMENSION(:), POINTER :: rh_srf real(kind=r_2), public, DIMENSION(:), POINTER :: rtevap_sat real(kind=r_2), public, DIMENSION(:), POINTER :: rtevap_unsat real(kind=r_2), public, DIMENSION(:), POINTER :: rt_qh_sublayer real(kind=r_2), public, DIMENSION(:,:), POINTER :: wbeq real(kind=r_2), public, DIMENSION(:,:), POINTER :: zq real(kind=r_2), public, DIMENSION(:,:), POINTER :: icefrac real(kind=r_2), public, DIMENSION(:,:), POINTER :: fracice real(kind=r_2), public, DIMENSION(:,:), POINTER :: hk real(kind=r_2), public, DIMENSION(:,:), POINTER :: smp real(kind=r_2), public, DIMENSION(:,:), POINTER :: dhkdw real(kind=r_2), public, DIMENSION(:,:), POINTER :: dsmpdw real(kind=r_2), public, DIMENSION(:,:), POINTER :: wbliq real(kind=r_2), public, DIMENSION(:,:), POINTER :: wmliq real(kind=r_2), public, DIMENSION(:,:), POINTER :: wmice real(kind=r_2), public, DIMENSION(:,:), POINTER :: wmtot real(kind=r_2), public, DIMENSION(:,:), POINTER :: qhlev real(kind=r_2), public, DIMENSION(:,:), POINTER :: S real(kind=r_2), public, DIMENSION(:,:), POINTER :: Tsoil real(kind=r_2), public, DIMENSION(:), POINTER :: SL real(kind=r_2), public, DIMENSION(:), POINTER :: TL real(kind=r_2), public, DIMENSION(:), POINTER :: h0 real(kind=r_2), public, DIMENSION(:,:), POINTER :: rex real(kind=r_2), public, DIMENSION(:,:), POINTER :: wflux real(kind=r_2), public, DIMENSION(:), POINTER :: delwcol real(kind=r_2), public, DIMENSION(:), POINTER :: zdelta real(kind=r_2), public, DIMENSION(:,:), POINTER :: kth real(kind=r_2), public, DIMENSION(:), POINTER :: Tsurface real(kind=r_2), public, DIMENSION(:), POINTER :: lE real(kind=r_2), public, DIMENSION(:), POINTER :: evap real(kind=r_2), public, DIMENSION(:,:), POINTER :: ciso real(kind=r_2), public, DIMENSION(:), POINTER :: cisoL real(kind=r_2), public, DIMENSION(:), POINTER :: rlitt real(kind=r_2), public, DIMENSION(:,:), POINTER :: thetai real(kind=r_2), public, DIMENSION(:,:), POINTER :: snowliq real(kind=r_2), public, DIMENSION(:), POINTER :: nsteps real(kind=r_2), public, DIMENSION(:), POINTER :: TsurfaceFR real(kind=r_2), public, DIMENSION(:,:), POINTER :: Ta_daily integer, public, DIMENSION(:), POINTER :: nsnow real(kind=r_2), public, DIMENSION(:), POINTER :: Qadv_daily real(kind=r_2), public, DIMENSION(:), POINTER :: G0_daily real(kind=r_2), public, DIMENSION(:), POINTER :: Qevap_daily real(kind=r_2), public, DIMENSION(:), POINTER :: Qprec_daily real(kind=r_2), public, DIMENSION(:), POINTER :: Qprec_snow_daily type, public :: veg_parameter_type Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), POINTER :: iveg integer, public, DIMENSION(:), POINTER :: iLU real, public, DIMENSION(:), POINTER :: canst1 real, public, DIMENSION(:), POINTER :: dleaf real, public, DIMENSION(:), POINTER :: ejmax real, public, DIMENSION(:), POINTER :: meth real, public, DIMENSION(:), POINTER :: frac4 real, public, DIMENSION(:), POINTER :: hc real, public, DIMENSION(:), POINTER :: vlai real, public, DIMENSION(:), POINTER :: xalbnir real, public, DIMENSION(:), POINTER :: rp20 real, public, DIMENSION(:), POINTER :: rpcoef real, public, DIMENSION(:), POINTER :: rs20 real, public, DIMENSION(:), POINTER :: shelrb real, public, DIMENSION(:), POINTER :: vegcf real, public, DIMENSION(:), POINTER :: tminvj real, public, DIMENSION(:), POINTER :: toptvj real, public, DIMENSION(:), POINTER :: tmaxvj real, public, DIMENSION(:), POINTER :: vbeta real, public, DIMENSION(:), POINTER :: vcmax real, public, DIMENSION(:), POINTER :: xfang real, public, DIMENSION(:), POINTER :: extkn real, public, DIMENSION(:), POINTER :: vlaimax real, public, DIMENSION(:), POINTER :: wai real, public, DIMENSION(:), POINTER :: a1gs real, public, DIMENSION(:), POINTER :: d0gs real, public, DIMENSION(:), POINTER :: alpha real, public, DIMENSION(:), POINTER :: convex real, public, DIMENSION(:), POINTER :: cfrd real, public, DIMENSION(:), POINTER :: gswmin real, public, DIMENSION(:), POINTER :: conkc0 real, public, DIMENSION(:), POINTER :: conko0 real, public, DIMENSION(:), POINTER :: ekc real, public, DIMENSION(:), POINTER :: eko real, public, DIMENSION(:), POINTER :: g0 real, public, DIMENSION(:), POINTER :: g1 logical, public, DIMENSION(:), POINTER :: deciduous real, public, DIMENSION(:,:), POINTER :: refl real, public, DIMENSION(:,:), POINTER :: taul real, public, DIMENSION(:,:), POINTER :: froot real(kind=r_2), public, DIMENSION(:), POINTER :: rootbeta real(kind=r_2), public, DIMENSION(:), POINTER :: gamma real(kind=r_2), public, DIMENSION(:), POINTER :: ZR real(kind=r_2), public, DIMENSION(:), POINTER :: F10 real(kind=r_2), public, DIMENSION(:), POINTER :: clitt integer, public, DIMENSION(:,:), POINTER :: disturbance_interval real(kind=r_2), public, DIMENSION(:,:), POINTER :: disturbance_intensity type, public :: canopy_type Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: cansto real, public, DIMENSION(:), POINTER :: cduv real, public, DIMENSION(:), POINTER :: delwc real, public, DIMENSION(:), POINTER :: dewmm real, public, DIMENSION(:), POINTER :: fe real, public, DIMENSION(:), POINTER :: fh real, public, DIMENSION(:), POINTER :: fpn real, public, DIMENSION(:), POINTER :: frp real, public, DIMENSION(:), POINTER :: frpw real, public, DIMENSION(:), POINTER :: frpr real, public, DIMENSION(:), POINTER :: frs real, public, DIMENSION(:), POINTER :: fnee real, public, DIMENSION(:), POINTER :: frday real, public, DIMENSION(:), POINTER :: fnv real, public, DIMENSION(:), POINTER :: fev real, public, DIMENSION(:), POINTER :: epot real, public, DIMENSION(:), POINTER :: fnpp real, public, DIMENSION(:), POINTER :: fevw_pot real, public, DIMENSION(:), POINTER :: gswx_T real, public, DIMENSION(:), POINTER :: cdtq real, public, DIMENSION(:), POINTER :: wetfac_cs real, public, DIMENSION(:), POINTER :: fevw real, public, DIMENSION(:), POINTER :: fhvw real, public, DIMENSION(:), POINTER :: oldcansto real, public, DIMENSION(:), POINTER :: fhv real, public, DIMENSION(:), POINTER :: fns real, public, DIMENSION(:), POINTER :: fhs real, public, DIMENSION(:), POINTER :: fhs_cor real, public, DIMENSION(:), POINTER :: ga real, public, DIMENSION(:), POINTER :: ghflux real, public, DIMENSION(:), POINTER :: precis real, public, DIMENSION(:), POINTER :: qscrn real, public, DIMENSION(:), POINTER :: rnet real, public, DIMENSION(:), POINTER :: rniso real, public, DIMENSION(:), POINTER :: segg real, public, DIMENSION(:), POINTER :: sghflux real, public, DIMENSION(:), POINTER :: through real, public, DIMENSION(:), POINTER :: through_sn real, public, DIMENSION(:), POINTER :: spill real, public, DIMENSION(:), POINTER :: tscrn real, public, DIMENSION(:), POINTER :: wcint real, public, DIMENSION(:), POINTER :: tv real, public, DIMENSION(:), POINTER :: us real, public, DIMENSION(:), POINTER :: uscrn real, public, DIMENSION(:), POINTER :: vlaiw real, public, DIMENSION(:), POINTER :: rghlai real, public, DIMENSION(:), POINTER :: fwet real, public, DIMENSION(:), POINTER :: fns_cor real, public, DIMENSION(:), POINTER :: ga_cor real, public, DIMENSION(:,:), POINTER :: evapfbl vh_js !! real, public, DIMENSION(:,:), POINTER :: gswx vh_js !! real, public, DIMENSION(:,:), POINTER :: zetar vh_js !! real, public, DIMENSION(:,:), POINTER :: zetash vh_js !! real(kind=r_2), public, DIMENSION(:), POINTER :: fess real(kind=r_2), public, DIMENSION(:), POINTER :: fesp real(kind=r_2), public, DIMENSION(:), POINTER :: dgdtg real(kind=r_2), public, DIMENSION(:), POINTER :: fes real(kind=r_2), public, DIMENSION(:), POINTER :: fes_cor real(kind=r_2), public, DIMENSION(:), POINTER :: fevc real(kind=r_2), public, DIMENSION(:), POINTER :: ofes real(kind=r_2), public, DIMENSION(:), POINTER :: sublayer_dz real(kind=r_2), public, DIMENSION(:,:), POINTER :: gw real(kind=r_2), public, DIMENSION(:,:,:), POINTER :: ancj real(kind=r_2), public, DIMENSION(:,:), POINTER :: tlfy real(kind=r_2), public, DIMENSION(:,:), POINTER :: ecy real(kind=r_2), public, DIMENSION(:,:), POINTER :: ecx real(kind=r_2), public, DIMENSION(:,:,:), POINTER :: ci real(kind=r_2), public, DIMENSION(:), POINTER :: fwsoil vh_js !! !litter thermal conductivity (Wm-2K-1) and vapour diffusivity (m2s-1) real(kind=r_2), public, DIMENSION(:), POINTER :: kthLitt real(kind=r_2), public, DIMENSION(:), POINTER :: DvLitt type, public :: radiation_type Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: transb real, public, DIMENSION(:), POINTER :: albedo_T real, public, DIMENSION(:), POINTER :: longitude real, public, DIMENSION(:), POINTER :: workp1 real, public, DIMENSION(:), POINTER :: workp2 real, public, DIMENSION(:), POINTER :: workp3 real, public, DIMENSION(:), POINTER :: extkb real, public, DIMENSION(:), POINTER :: extkd2 real, public, DIMENSION(:), POINTER :: extkd real, public, DIMENSION(:), POINTER :: flws real, public, DIMENSION(:), POINTER :: latitude real, public, DIMENSION(:), POINTER :: lwabv real, public, DIMENSION(:), POINTER :: qssabs real, public, DIMENSION(:), POINTER :: transd real, public, DIMENSION(:), POINTER :: trad real, public, DIMENSION(:), POINTER :: otrad real, public, DIMENSION(:,:), POINTER :: fvlai real, public, DIMENSION(:,:), POINTER :: rhocdf real, public, DIMENSION(:,:), POINTER :: rniso real, public, DIMENSION(:,:), POINTER :: scalex real, public, DIMENSION(:,:), POINTER :: albedo real, public, DIMENSION(:,:), POINTER :: reffdf real, public, DIMENSION(:,:), POINTER :: reffbm real, public, DIMENSION(:,:), POINTER :: extkbm real, public, DIMENSION(:,:), POINTER :: extkdm real, public, DIMENSION(:,:), POINTER :: fbeam real, public, DIMENSION(:,:), POINTER :: cexpkbm real, public, DIMENSION(:,:), POINTER :: cexpkdm real, public, DIMENSION(:,:), POINTER :: rhocbm real, public, DIMENSION(:,:), POINTER :: gradis real, public, DIMENSION(:,:,:), POINTER :: qcan type, public :: roughness_type Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: disp real, public, DIMENSION(:), POINTER :: hruff real, public, DIMENSION(:), POINTER :: hruff_grmx real, public, DIMENSION(:), POINTER :: rt0us real, public, DIMENSION(:), POINTER :: rt1usa real, public, DIMENSION(:), POINTER :: rt1usb real, public, DIMENSION(:), POINTER :: rt1 real, public, DIMENSION(:), POINTER :: za_uv real, public, DIMENSION(:), POINTER :: za_tq real, public, DIMENSION(:), POINTER :: z0m real, public, DIMENSION(:), POINTER :: zref_uv real, public, DIMENSION(:), POINTER :: zref_tq real, public, DIMENSION(:), POINTER :: zruffs real, public, DIMENSION(:), POINTER :: z0soilsn real, public, DIMENSION(:), POINTER :: z0soil real, public, DIMENSION(:), POINTER :: coexp real, public, DIMENSION(:), POINTER :: usuh real, public, DIMENSION(:), POINTER :: term2 real, public, DIMENSION(:), POINTER :: term3 real, public, DIMENSION(:), POINTER :: term5 real, public, DIMENSION(:), POINTER :: term6 real, public, DIMENSION(:), POINTER :: term6a type, public :: air_type Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: rho real, public, DIMENSION(:), POINTER :: volm real, public, DIMENSION(:), POINTER :: rlam real, public, DIMENSION(:), POINTER :: qsat real, public, DIMENSION(:), POINTER :: epsi real, public, DIMENSION(:), POINTER :: visc real, public, DIMENSION(:), POINTER :: psyc real, public, DIMENSION(:), POINTER :: dsatdk real, public, DIMENSION(:), POINTER :: cmolar type, public :: met_type Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), POINTER :: year integer, public, DIMENSION(:), POINTER :: moy real, public, DIMENSION(:), POINTER :: ca real, public, DIMENSION(:), POINTER :: doy real, public, DIMENSION(:), POINTER :: hod real, public, DIMENSION(:), POINTER :: ofsd real, public, DIMENSION(:), POINTER :: fld real, public, DIMENSION(:), POINTER :: precip real, public, DIMENSION(:), POINTER :: precip_sn real, public, DIMENSION(:), POINTER :: tk real, public, DIMENSION(:), POINTER :: tvair real, public, DIMENSION(:), POINTER :: tvrad real, public, DIMENSION(:), POINTER :: pmb real, public, DIMENSION(:), POINTER :: ua real, public, DIMENSION(:), POINTER :: qv real, public, DIMENSION(:), POINTER :: qvair real, public, DIMENSION(:), POINTER :: da real, public, DIMENSION(:), POINTER :: dva real, public, DIMENSION(:), POINTER :: coszen real, public, DIMENSION(:), POINTER :: Ndep real, public, DIMENSION(:), POINTER :: Pdep real, public, DIMENSION(:,:), POINTER :: fsd type, public :: climate_type Components Type Visibility Attributes Name Initial integer, public :: nyear_average = 20 integer, public :: nday_average = 31 integer, public :: nyears integer, public :: doy integer, public, DIMENSION(:), POINTER :: chilldays integer, public, DIMENSION(:), POINTER :: iveg integer, public, DIMENSION(:), POINTER :: biome real, public, DIMENSION(:), POINTER :: dtemp real, public, DIMENSION(:), POINTER :: dmoist real, public, DIMENSION(:), POINTER :: mtemp real, public, DIMENSION(:), POINTER :: qtemp real, public, DIMENSION(:), POINTER :: mmoist real, public, DIMENSION(:), POINTER :: mtemp_min real, public, DIMENSION(:), POINTER :: mtemp_max real, public, DIMENSION(:), POINTER :: qtemp_max real, public, DIMENSION(:), POINTER :: qtemp_max_last_year real, public, DIMENSION(:), POINTER :: mtemp_min20 real, public, DIMENSION(:), POINTER :: mtemp_max20 real, public, DIMENSION(:), POINTER :: atemp_mean real, public, DIMENSION(:), POINTER :: AGDD5 real, public, DIMENSION(:), POINTER :: GDD5 real, public, DIMENSION(:), POINTER :: AGDD0 real, public, DIMENSION(:), POINTER :: GDD0 real, public, DIMENSION(:), POINTER :: alpha_PT real, public, DIMENSION(:), POINTER :: evap_PT real, public, DIMENSION(:), POINTER :: aevap real, public, DIMENSION(:), POINTER :: alpha_PT20 real, public, DIMENSION(:,:), POINTER :: mtemp_min_20 real, public, DIMENSION(:,:), POINTER :: mtemp_max_20 real, public, DIMENSION(:,:), POINTER :: dtemp_31 real, public, DIMENSION(:,:), POINTER :: dmoist_31 real, public, DIMENSION(:,:), POINTER :: alpha_PT_20 real, public, DIMENSION(:,:), POINTER :: dtemp_91 type, public :: sum_flux_type Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), POINTER :: sumpn real, public, DIMENSION(:), POINTER :: sumrp real, public, DIMENSION(:), POINTER :: sumrpw real, public, DIMENSION(:), POINTER :: sumrpr real, public, DIMENSION(:), POINTER :: sumrs real, public, DIMENSION(:), POINTER :: sumrd real, public, DIMENSION(:), POINTER :: dsumpn real, public, DIMENSION(:), POINTER :: dsumrp real, public, DIMENSION(:), POINTER :: dsumrs real, public, DIMENSION(:), POINTER :: dsumrd real, public, DIMENSION(:), POINTER :: sumxrp real, public, DIMENSION(:), POINTER :: sumxrs type, public :: bgc_pool_type Components Type Visibility Attributes Name Initial real, public, DIMENSION(:,:), POINTER :: cplant real, public, DIMENSION(:,:), POINTER :: csoil real, public, DIMENSION(ncp) :: ratecp real, public, DIMENSION(ncs) :: ratecs Subroutines public subroutine alloc_balances_type (var, mp) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_soil_parameter_type (var, mp) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_soil_snow_type (var, mp) Arguments Type Intent Optional Attributes Name type( soil_snow_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_veg_parameter_type (var, mp) Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_canopy_type (var, mp) vh_js !! liiter resistances to heat and vapour transfer Arguments Type Intent Optional Attributes Name type( canopy_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_radiation_type (var, mp) Arguments Type Intent Optional Attributes Name type( radiation_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_roughness_type (var, mp) Arguments Type Intent Optional Attributes Name type( roughness_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_air_type (var, mp) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_met_type (var, mp) Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_climate_type (var, mp) Arguments Type Intent Optional Attributes Name type( climate_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine alloc_sum_flux_type (var, mp) Arguments Type Intent Optional Attributes Name type( sum_flux_type ), intent(inout) :: var integer, intent(in) :: mp public subroutine dealloc_balances_type (var) Arguments Type Intent Optional Attributes Name type( balances_type ), intent(inout) :: var public subroutine dealloc_soil_parameter_type (var) Arguments Type Intent Optional Attributes Name type( soil_parameter_type ), intent(inout) :: var public subroutine dealloc_soil_snow_type (var) Arguments Type Intent Optional Attributes Name type( soil_snow_type ), intent(inout) :: var public subroutine dealloc_veg_parameter_type (var) Arguments Type Intent Optional Attributes Name type( veg_parameter_type ), intent(inout) :: var public subroutine dealloc_canopy_type (var) vh_js !! liiter resistances to heat and vapour transfer Arguments Type Intent Optional Attributes Name type( canopy_type ), intent(inout) :: var public subroutine dealloc_radiation_type (var) Arguments Type Intent Optional Attributes Name type( radiation_type ), intent(inout) :: var public subroutine dealloc_roughness_type (var) Arguments Type Intent Optional Attributes Name type( roughness_type ), intent(inout) :: var public subroutine dealloc_air_type (var) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: var public subroutine dealloc_met_type (var) Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: var public subroutine dealloc_sum_flux_type (var) Arguments Type Intent Optional Attributes Name type( sum_flux_type ), intent(inout) :: var","tags":"","loc":"module/cable_def_types_mod.html"},{"title":"cable_input_module – CABLE","text":"vh_js !! Uses casaparm cable_param_module cbl_sinbet_mod cable_read_module casa_inout_module casadimension POPLUC_Types casavariable cable_init_module netcdf cable_IO_vars_module POP_Types cable_checks_module cable_common_module casa_ncdf_module phenvariable cable_def_types_mod cable_abort_module Contents Variables ncid_met ncid_rain ncid_snow ncid_lw ncid_sw ncid_ps ncid_qa ncid_ta ncid_wd ncid_mask Subroutines get_default_lai open_met_file get_met_data close_met_file load_parameters allocate_cable_vars Variables Type Visibility Attributes Name Initial integer, public :: ncid_met integer, public :: ncid_rain integer, public :: ncid_snow integer, public :: ncid_lw integer, public :: ncid_sw integer, public :: ncid_ps integer, public :: ncid_qa integer, public :: ncid_ta integer, public :: ncid_wd integer, public :: ncid_mask Subroutines public subroutine get_default_lai () Arguments None public subroutine open_met_file (dels, koffset, kend, spinup, TFRZ) =====================VV Determine spatial details VV================= Read more… Arguments Type Intent Optional Attributes Name real, intent(out) :: dels integer, intent(inout) :: koffset integer, intent(out) :: kend logical, intent(in) :: spinup real, intent(in) :: TFRZ public subroutine get_met_data (spinup, spinConv, met, soil, rad, veg, kend, dels, TFRZ, ktau, kstart) vh_js !! use is_leapyear function here instead of multiple conditions\nvh_js !! corrected indices of defaultLAI Arguments Type Intent Optional Attributes Name logical, intent(in) :: spinup logical, intent(in) :: spinConv type( met_type ), intent(inout) :: met type( soil_parameter_type ), intent(in) :: soil type( radiation_type ), intent(in) :: rad type( veg_parameter_type ), intent(inout) :: veg integer, intent(in) :: kend real, intent(in) :: dels real, intent(in) :: TFRZ integer, intent(in) :: ktau integer, intent(in) :: kstart public subroutine close_met_file () Arguments None public subroutine load_parameters (met, air, ssnow, veg, climate, bgc, soil, canopy, rough, rad, sum_flux, bal, logn, vegparmnew, casabiome, casapool, casaflux, sum_casapool, sum_casaflux, casamet, casabal, phen, POP, spinup, EMSOIL, TFRZ, LUC_EXPT, POPLUC) vh_js !!\nvh_js !! Arguments Type Intent Optional Attributes Name type( met_type ), intent(inout) :: met type( air_type ), intent(inout) :: air type( soil_snow_type ), intent(out) :: ssnow type( veg_parameter_type ), intent(out) :: veg type( climate_type ), intent(inout) :: climate type( bgc_pool_type ), intent(out) :: bgc type( soil_parameter_type ), intent(out) :: soil type( canopy_type ), intent(out) :: canopy type( roughness_type ), intent(out) :: rough type( radiation_type ), intent(out) :: rad type( sum_flux_type ), intent(out) :: sum_flux type( balances_type ), intent(out) :: bal integer, intent(in) :: logn logical, intent(in) :: vegparmnew vh_js !! type(casa_biome), intent(out) :: casabiome type(casa_pool), intent(out) :: casapool type(casa_flux), intent(out) :: casaflux type(casa_pool), intent(out) :: sum_casapool type(casa_flux), intent(out) :: sum_casaflux type(casa_met), intent(out) :: casamet type(casa_balance), intent(out) :: casabal type(phen_variable), intent(out) :: phen type(POP_TYPE), intent(inout) :: POP logical, intent(in) :: spinup vh_js !! real, intent(in) :: EMSOIL real, intent(in) :: TFRZ type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT type(POPLUC_TYPE), intent(inout) :: POPLUC public subroutine allocate_cable_vars (air, bgc, canopy, met, bal, rad, rough, soil, ssnow, sum_flux, veg, arraysize) Arguments Type Intent Optional Attributes Name type( air_type ), intent(inout) :: air type( bgc_pool_type ), intent(inout) :: bgc type( canopy_type ), intent(inout) :: canopy type( met_type ), intent(inout) :: met type( balances_type ), intent(inout) :: bal type( radiation_type ), intent(inout) :: rad type( roughness_type ), intent(inout) :: rough type( soil_parameter_type ), intent(inout) :: soil type( soil_snow_type ), intent(inout) :: ssnow type( sum_flux_type ), intent(inout) :: sum_flux type( veg_parameter_type ), intent(inout) :: veg integer, intent(in) :: arraysize","tags":"","loc":"module/cable_input_module.html"},{"title":"cable_mpiworker – CABLE","text":"$ Uses casa_inout_module cable_mpicommon casa_cable cable_common_module Contents Subroutines mpidrv_worker Subroutines public subroutine mpidrv_worker (comm) vh_js !!\n vh_js !! suggest LALLOC should ulitmately be a switch in the .nml file\n Check for gswp run Read more… Arguments Type Intent Optional Attributes Name integer :: comm","tags":"","loc":"module/cable_mpiworker.html"},{"title":"CABLE_LUC_EXPT – CABLE","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses CABLE_COMMON_MODULE netcdf cable_IO_vars_module casa_ncdf_module cable_def_types_mod Contents Variables LUC_EXPT ptos ptog stog gtos grassfrac primffrac pharv smharv syharv Derived Types LUC_INPUT_TYPE LUC_EXPT_TYPE Subroutines LUC_EXPT_INIT LUC_EXPT_SET_TILES READ_ClimateFile READ_LUH2 Variables Type Visibility Attributes Name Initial type( LUC_EXPT_TYPE ), public, SAVE :: LUC_EXPT integer, public, parameter :: ptos = 1 integer, public, parameter :: ptog = 2 integer, public, parameter :: stog = 3 integer, public, parameter :: gtos = 4 integer, public, parameter :: grassfrac = 5 integer, public, parameter :: primffrac = 6 integer, public, parameter :: pharv = 7 integer, public, parameter :: smharv = 8 integer, public, parameter :: syharv = 9 Derived Types type, public :: LUC_INPUT_TYPE Components Type Visibility Attributes Name Initial real, public, DIMENSION(:), ALLOCATABLE :: VAL type, public :: LUC_EXPT_TYPE Components Type Visibility Attributes Name Initial character(len=200), public :: TransitionFilePath character(len=200), public :: ClimateFile character(len=200), public :: Run logical, public :: DirectRead logical, public :: READrst logical, public :: WRITErst logical, public, ALLOCATABLE :: prim_only (:) logical, public, ALLOCATABLE :: ptos (:) logical, public, ALLOCATABLE :: ptog (:) logical, public, ALLOCATABLE :: stog (:) logical, public, ALLOCATABLE :: gtos (:) integer, public, ALLOCATABLE :: ivegp (:) integer, public, ALLOCATABLE :: biome (:) integer, public :: YearStart integer, public :: YearEnd integer, public :: nfile integer, public :: CTSTEP real, public, ALLOCATABLE :: primaryf (:) real, public, ALLOCATABLE :: mtemp_min20 (:) real, public, ALLOCATABLE :: grass (:) real, public, ALLOCATABLE :: secdf (:) character(len=200), public, DIMENSION(9) :: TransFile character(len=12), public, DIMENSION(9) :: VAR_NAME integer, public, DIMENSION(9) :: F_ID integer, public, DIMENSION(9) :: V_ID type( LUC_INPUT_TYPE ), public, DIMENSION(9) :: INPUT integer, public :: YEAR integer, public :: ydimsize integer, public :: xdimsize integer, public :: nrec integer, public :: FirstYear Subroutines public subroutine LUC_EXPT_INIT (LUC_EXPT) $          STATUS = NF90_GET_VAR( Luc_expt%f_id(i), timID, tmp, &\n$               start=(/1,1,1/) )\n$          CALL HANDLE_ERR(STATUS, \"Reading from \"//LUC_EXPT%TransFile(i) ) Read more… Arguments Type Intent Optional Attributes Name type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT public subroutine LUC_EXPT_SET_TILES (inVeg, inPFrac, LUC_EXPT) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: inVeg (:,:,:) real, intent(inout) :: inPFrac (:,:,:) type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT public subroutine READ_ClimateFile (LUC_EXPT) Arguments Type Intent Optional Attributes Name type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT public subroutine READ_LUH2 (LUC_EXPT) Arguments Type Intent Optional Attributes Name type( LUC_EXPT_TYPE ), intent(inout) :: LUC_EXPT","tags":"","loc":"module/cable_luc_expt.html"},{"title":"cable_write_module – CABLE","text":"Uses cable_IO_vars_module cable_def_types_mod netcdf cable_abort_module Contents Variables otmp1 otmp1l otmp2lt otmp2xy otmp2lp otmp2ls otmp2lpc otmp2lsc otmp2lsf otmp2lr otmp2lsn otmp3xyt otmp3lpt otmp3lst otmp3lsnt otmp3lrt otmp3lpct otmp3lsct otmp3xyp otmp3xys otmp3xypc otmp3xysc otmp3lps otmp3lppc otmp3lpsc otmp3xysf otmp3lpr otmp3lpsn otmp4xypt otmp4xyzt otmp4xyst otmp4xysnt otmp4xyrt otmp4xypct otmp4xysct otmp4lpst otmp4lpsnt otmp4lprt otmp4lpsct otmp4lppct otmp4xyps otmp4xyppc otmp4xypsc otmp5xypst otmp5xypsnt otmp5xyprt otmp5xyppct otmp5xypsct Interfaces define_ovar write_ovar Subroutines nullify_write Variables Type Visibility Attributes Name Initial real, public, POINTER, DIMENSION(:) :: otmp1 real, public, POINTER, DIMENSION(:) :: otmp1l real, public, POINTER, DIMENSION(:, :) :: otmp2lt real, public, POINTER, DIMENSION(:, :) :: otmp2xy real, public, POINTER, DIMENSION(:, :) :: otmp2lp real, public, POINTER, DIMENSION(:, :) :: otmp2ls real, public, POINTER, DIMENSION(:, :) :: otmp2lpc real, public, POINTER, DIMENSION(:, :) :: otmp2lsc real, public, POINTER, DIMENSION(:, :) :: otmp2lsf real, public, POINTER, DIMENSION(:, :) :: otmp2lr real, public, POINTER, DIMENSION(:, :) :: otmp2lsn real, public, POINTER, DIMENSION(:, :, :) :: otmp3xyt real, public, POINTER, DIMENSION(:, :, :) :: otmp3lpt real, public, POINTER, DIMENSION(:, :, :) :: otmp3lst real, public, POINTER, DIMENSION(:, :, :) :: otmp3lsnt real, public, POINTER, DIMENSION(:, :, :) :: otmp3lrt real, public, POINTER, DIMENSION(:, :, :) :: otmp3lpct real, public, POINTER, DIMENSION(:, :, :) :: otmp3lsct real, public, POINTER, DIMENSION(:, :, :) :: otmp3xyp real, public, POINTER, DIMENSION(:, :, :) :: otmp3xys real, public, POINTER, DIMENSION(:, :, :) :: otmp3xypc real, public, POINTER, DIMENSION(:, :, :) :: otmp3xysc real, public, POINTER, DIMENSION(:, :, :) :: otmp3lps real, public, POINTER, DIMENSION(:, :, :) :: otmp3lppc real, public, POINTER, DIMENSION(:, :, :) :: otmp3lpsc real, public, POINTER, DIMENSION(:, :, :) :: otmp3xysf real, public, POINTER, DIMENSION(:, :, :) :: otmp3lpr real, public, POINTER, DIMENSION(:, :, :) :: otmp3lpsn real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xypt real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xyzt real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xyst real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xysnt real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xyrt real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xypct real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xysct real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4lpst real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4lpsnt real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4lprt real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4lpsct real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4lppct real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xyps real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xyppc real, public, POINTER, DIMENSION(:, :, :, :) :: otmp4xypsc real, public, POINTER, DIMENSION(:, :, :, :, :) :: otmp5xypst real, public, POINTER, DIMENSION(:, :, :, :, :) :: otmp5xypsnt real, public, POINTER, DIMENSION(:, :, :, :, :) :: otmp5xyprt real, public, POINTER, DIMENSION(:, :, :, :, :) :: otmp5xyppct real, public, POINTER, DIMENSION(:, :, :, :, :) :: otmp5xypsct Interfaces public interface define_ovar private subroutine define_output_variable_r1(ncid, varID, vname, vunits, longname, writepatch, dimswitch, xID, yID, zID, landID, patchID, tID) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out) :: varID character(len=*), intent(in) :: vname character(len=*), intent(in) :: vunits character(len=*), intent(in) :: longname logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch integer, intent(in) :: xID integer, intent(in) :: yID integer, intent(in) :: zID integer, intent(in) :: landID integer, intent(in) :: patchID integer, intent(in) :: tID private subroutine define_output_variable_r2(ncid, varID, vname, vunits, longname, writepatch, dimswitch, xID, yID, zID, landID, patchID, othdimID, tID) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out) :: varID character(len=*), intent(in) :: vname character(len=*), intent(in) :: vunits character(len=*), intent(in) :: longname logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch integer, intent(in) :: xID integer, intent(in) :: yID integer, intent(in) :: zID integer, intent(in) :: landID integer, intent(in) :: patchID integer, intent(in) :: othdimID integer, intent(in) :: tID private subroutine define_output_parameter_r1(ncid, parID, pname, punits, longname, writepatch, dimswitch, xID, yID, zID, landID, patchID, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out) :: parID character(len=*), intent(in) :: pname character(len=*), intent(in) :: punits character(len=*), intent(in) :: longname logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch integer, intent(in) :: xID integer, intent(in) :: yID integer, intent(in) :: zID integer, intent(in) :: landID integer, intent(in) :: patchID logical, intent(in), optional :: restart private subroutine define_output_parameter_r2(ncid, parID, pname, punits, longname, writepatch, othdimID, dimswitch, xID, yID, zID, landID, patchID, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out) :: parID character(len=*), intent(in) :: pname character(len=*), intent(in) :: punits character(len=*), intent(in) :: longname logical, intent(in) :: writepatch integer, intent(in) :: othdimID character(len=*), intent(in) :: dimswitch integer, intent(in) :: xID integer, intent(in) :: yID integer, intent(in) :: zID integer, intent(in) :: landID integer, intent(in) :: patchID logical, intent(in), optional :: restart public interface write_ovar private subroutine write_output_variable_r1(ktau, ncid, varID, vname, var_r1, vrange, writepatch, dimswitch, met) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau integer, intent(in) :: ncid integer, intent(in) :: varID character(len=*), intent(in) :: vname real(kind=4), intent(in), DIMENSION(:) :: var_r1 real, intent(in), DIMENSION(2) :: vrange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch type( met_type ), intent(in) :: met private subroutine write_output_variable_r2(ktau, ncid, varID, vname, var_r2, vrange, writepatch, dimswitch, met) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ktau integer, intent(in) :: ncid integer, intent(in) :: varID character(len=*), intent(in) :: vname real(kind=4), intent(in), DIMENSION(:, :) :: var_r2 real, intent(in), DIMENSION(2) :: vrange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch type( met_type ), intent(in) :: met private subroutine write_output_parameter_r1(ncid, parID, pname, par_r1, prange, writepatch, dimswitch, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: parID character(len=*), intent(in) :: pname real(kind=4), intent(in), DIMENSION(:) :: par_r1 real, intent(in), DIMENSION(2) :: prange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: restart private subroutine write_output_parameter_r1d(ncid, parID, pname, par_r1d, prange, writepatch, dimswitch, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: parID character(len=*), intent(in) :: pname real(kind=r_2), intent(in), DIMENSION(:) :: par_r1d real, intent(in), DIMENSION(2) :: prange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: restart private subroutine write_output_parameter_r2(ncid, parID, pname, par_r2, prange, writepatch, dimswitch, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: parID character(len=*), intent(in) :: pname real(kind=4), intent(in), DIMENSION(:, :) :: par_r2 real, intent(in), DIMENSION(2) :: prange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: restart private subroutine write_output_parameter_r2d(ncid, parID, pname, par_r2d, prange, writepatch, dimswitch, restart) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: parID character(len=*), intent(in) :: pname real(kind=r_2), intent(in), DIMENSION(:, :) :: par_r2d real, intent(in), DIMENSION(2) :: prange logical, intent(in) :: writepatch character(len=*), intent(in) :: dimswitch logical, intent(in), optional :: restart Subroutines public subroutine nullify_write () Arguments None","tags":"","loc":"module/cable_write_module.html"},{"title":"mpi_driver – CABLE","text":"Uses cable_mpiworker cable_namelist_util cable_mpimaster cable_mpicommon mpi Contents Variables comm np rank ierr etime Variables Type Attributes Name Initial integer :: comm integer :: np integer :: rank integer :: ierr real :: etime","tags":"","loc":"program/mpi_driver.html"},{"title":"cable_offline_driver – CABLE","text":"Uses CABLE_site casadimension POP_Constants cable_namelist_util POP_Types cable_input_module landuse_constant phenvariable cable_def_types_mod casavariable cable_climate_mod CABLE_CRU landuse_variable casa_cable casa_inout_module cable_write_module cable_output_module cable_cbm_module cable_common_module casa_ncdf_module CABLE_PLUME_MIP cable_phys_constants_mod POPLUC_Module POPLUC_Types cbl_soil_snow_init_special_module CABLE_LUC_EXPT cable_IO_vars_module vh_js !! vh_js !!\n vh_js !!\n vh_js !! suggest LALLOC should ulitmately be a switch in the .nml file\n$   IF ( .NOT. spinup ) THEN\n$    IF ( spincasa ) THEN\n$       spincasa = .FALSE.\n$       WRITE( , )   \"spinup == .FALSE. -> spincasa set to .F.\"\n$       WRITE(logn,*)\"spinup == .FALSE. -> spincasa set to .F.\"\n$    ENDIF\n$   ENDIF\n$ !! INISTUFF $  YearStart = CABLE_USER%YearStart\n$  YearEnd = CABLE_USER%YearEnd\n$  cable_user%CASA_SPIN_ENDYEAR Checks where parameters and initialisations should be loaded from. vh_js !!\n vh_js !! $         do kk=1,mp\n$        if( canopy%fe(kk).NE.( canopy%fe(kk))) THEN\n$           write( , ) 'fe nan', kk, ktau,met%qv(kk), met%precip(kk),met%precip_sn(kk), &\n$            met%fld(kk), met%fsd(kk,:), met%tk(kk), met%ua(kk), ssnow%potev(kk), met%pmb(kk), &\n$            canopy%ga(kk), ssnow%tgg(kk,:), canopy%fwsoil(kk)\n$\n$\n$           stop\n$        endif\n$        if ( casaflux%cnpp(kk).NE. casaflux%cnpp(kk)) then\n$           write( , ) 'npp nan', kk, ktau,  casaflux%cnpp(kk)\n$           stop\n$\n$        endif\n$\n$\n$        !if (canopy%fwsoil(kk).eq.0.0) then\n$        !   write( , ) 'zero fwsoil', ktau, canopy%fpn(kk)\n$        !endif\n$\n$\n$         enddo $         IF( MOD( ktau_tot, kend ) .EQ. 0 .AND. ktau_Tot .GT. kend .AND. &\n$          YYYY.EQ. CABLE_USER%YearEnd .OR. ( NRRRR .GT. 1 .AND. &\n$          RRRR.EQ. NRRRR) ) THEN Contents Variables kstart mloop LALLOC ktau ktau_tot kend koffset koffset_met ktauday idoy nyear casa_it YYYY RYEAR RRRR NRRRR ctime LOY count_sum_casa wlogn dels GSWP_MID dum str1 str2 str3 met air canopy rad rough bal ssnow climate soil veg sum_flux bgc casabiome casapool casaflux sum_casapool sum_casaflux casamet casabal phen POP POPLUC PLUME CRU site LUC_EXPT lucmp cyear ncfile vegparmnew spinup spinConv spincasa l_casacnp l_landuse l_laiFeedbk l_vcmaxFeedbk CASAONLY CALL1 SPINon delsoilM delsoilT Metyear Y LOYtmp delgwM soilMtemp soilTtemp GWtemp etime heat_cap_lower_limit i x kk m np ivt Ftrunk_sumbal Fnew_sumbal trunk_sumbal new_sumbal new_sumfpn new_sumfe c1 rhoch xk nkend ioerror count_bal mlon mlat mpx luc_atransit luc_fharvw luc_xluh2cable arealand landmask cstart cend nap patchfrac_new Variables Type Attributes Name Initial integer, parameter :: kstart = 1 integer, parameter :: mloop = 30 integer :: LALLOC integer :: ktau integer :: ktau_tot integer :: kend integer :: koffset = 0 integer :: koffset_met = 0 integer :: ktauday integer :: idoy integer :: nyear integer :: casa_it integer :: YYYY integer :: RYEAR integer :: RRRR integer :: NRRRR integer :: ctime integer :: LOY integer :: count_sum_casa integer :: wlogn = 10001 real :: dels integer, DIMENSION(:,:), ALLOCATABLE :: GSWP_MID character :: dum *9 character :: str1 *9 character :: str2 *9 character :: str3 *9 type( met_type ) :: met type( air_type ) :: air type( canopy_type ) :: canopy type( radiation_type ) :: rad type( roughness_type ) :: rough type( balances_type ) :: bal type( soil_snow_type ) :: ssnow type( climate_type ) :: climate type( soil_parameter_type ) :: soil type( veg_parameter_type ) :: veg type( sum_flux_type ) :: sum_flux type( bgc_pool_type ) :: bgc type(casa_biome) :: casabiome type(casa_pool) :: casapool type(casa_flux) :: casaflux type(casa_pool) :: sum_casapool type(casa_flux) :: sum_casaflux type(casa_met) :: casamet type(casa_balance) :: casabal type(phen_variable) :: phen vh_js !! type(POP_TYPE) :: POP type(POPLUC_TYPE) :: POPLUC type( PLUME_MIP_TYPE ) :: PLUME type( CRU_TYPE ) :: CRU type( site_TYPE ) :: site type( LUC_EXPT_TYPE ) :: LUC_EXPT type(landuse_mp) :: lucmp character :: cyear *4 character :: ncfile *99 logical, SAVE :: vegparmnew = .FALSE. logical, SAVE :: spinup = .FALSE. logical, SAVE :: spinConv = .FALSE. logical, SAVE :: spincasa = .FALSE. logical, SAVE :: l_casacnp = .FALSE. logical, SAVE :: l_landuse = .FALSE. logical, SAVE :: l_laiFeedbk = .FALSE. logical, SAVE :: l_vcmaxFeedbk = .FALSE. logical, SAVE :: CASAONLY = .FALSE. logical, SAVE :: CALL1 = .TRUE. logical, SAVE :: SPINon = .TRUE. real :: delsoilM real :: delsoilT integer :: Metyear integer :: Y integer :: LOYtmp real :: delgwM = 1e-4 real, ALLOCATABLE, DIMENSION(:,:) :: soilMtemp real, ALLOCATABLE, DIMENSION(:,:) :: soilTtemp real, ALLOCATABLE, DIMENSION(:) :: GWtemp real :: etime real, allocatable :: heat_cap_lower_limit (:,:) integer :: i integer :: x integer :: kk integer :: m integer :: np integer :: ivt character(len=30), parameter :: Ftrunk_sumbal = \".trunk_sumbal\" character(len=30), parameter :: Fnew_sumbal = \"new_sumbal\" double precision :: trunk_sumbal = 0.0 double precision :: new_sumbal = 0.0 double precision :: new_sumfpn = 0.0 double precision :: new_sumfe = 0.0 real, ALLOCATABLE, SAVE :: c1 (:,:) real, ALLOCATABLE, SAVE :: rhoch (:,:) real, ALLOCATABLE, SAVE :: xk (:,:) integer :: nkend = 0 integer :: ioerror integer :: count_bal = 0 integer :: mlon integer :: mlat integer :: mpx real(kind=r_2), dimension(:,:,:), allocatable, save :: luc_atransit real(kind=r_2), dimension(:,:), allocatable, save :: luc_fharvw real(kind=r_2), dimension(:,:,:), allocatable, save :: luc_xluh2cable real(kind=r_2), dimension(:), allocatable, save :: arealand integer, dimension(:,:), allocatable, save :: landmask integer, dimension(:), allocatable, save :: cstart integer, dimension(:), allocatable, save :: cend integer, dimension(:), allocatable, save :: nap real(kind=r_2), dimension(:,:,:), allocatable, save :: patchfrac_new","tags":"","loc":"program/cable_offline_driver.html"},{"title":"cable_initialise.F90 – CABLE","text":"Contents Modules cable_init_module Source Code cable_initialise.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: default initialisation module for CABLE offline ! ! Contact: Bernard.Pak@csiro.au ! ! History: Developed by Gab Abramowitz !          Since 1.4b fes split into fess and fesp !          Significant changes: new routine 'extraRestart' for land-use change ! ! ! ============================================================================== ! ! MODULEs used: cable_abort_module !               cable_def_types_mod !               cable_IO_vars_module !               cable_read_module !               physical_constants !               netcdf ! !============================================================================== MODULE cable_init_module USE cable_abort_module , ONLY : abort , nc_abort USE cable_def_types_mod USE cable_IO_vars_module , ONLY : latitude , longitude , patch , & landpt , smoy , ncid_rin , max_vegpatches , & soilparmnew , ncciy , vegtype_metfile , & soiltype_metfile USE cable_read_module USE netcdf USE cable_common_module , ONLY : filename , cable_user IMPLICIT NONE PRIVATE PUBLIC get_default_inits , get_restart_data INTEGER :: ok ! netcdf status CONTAINS !============================================================================== ! ! Name: get_default_inits ! ! Purpose: Loads initialisations based on Mk3L 50 year monthly !          climatology file ! ! CALLed from: load_parameters ! ! CALLs: abort ! !============================================================================== !============================================================================== ! changes since version release on ! changes made by who on date ! !============================================================================== SUBROUTINE get_default_inits ( met , soil , ssnow , canopy , logn , EMSOIL ) IMPLICIT NONE ! Input arguments TYPE ( met_type ), INTENT ( IN ) :: met TYPE ( soil_parameter_type ), INTENT ( IN ) :: soil TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow TYPE ( canopy_type ), INTENT ( OUT ) :: canopy INTEGER , INTENT ( IN ) :: logn ! log file unit number REAL , INTENT ( IN ) :: EMSOIL ! Local variables INTEGER :: e , i , j ! do loop counter WRITE ( logn , * ) ' Initializing variables.' DO e = 1 , mp ! over all patches ! The following write statements are redundant in online runs !       ! Write to log file: !       WRITE(logn,'(A21,I8,2(A15,1X,F9.4,1X))') '     Land grid point:',e, & !            '      Latitude ',latitude(e),'Longitude',longitude(e) !       WRITE(logn,'(A46,2(1X,F8.3,1X,A3))') & !            '        is closest to default gridcell centred', & !            REAL(lat_inits(final_y)),'lat', REAL(lon_inits(final_x)),'lon' ! Only the following snow inits are necessary, ! soilsnow will update other variables. IF ( ssnow % snowd ( e ) > 0.0 ) THEN ! in cm ssnow % ssdnn ( e ) = 12 0.0 ! overall snow density (kg/m3) ssnow % ssdn ( e ,:) = 12 0.0 ! snow density per layer (kg/m3) ssnow % snage ( e ) = 0.0 ! snow age (fresh) ssnow % isflag ( e ) = 0 ELSE ssnow % ssdnn ( e ) = 14 0.0 ! overall snow density (kg/m3) ssnow % osnowd ( e ) = 0.0 ! snow depth prev timestep (mm or kg/m2) ssnow % snage ( e ) = 0.0 ! snow age ssnow % isflag ( e ) = 0 ! snow layer scheme flag ! (0 = no/little snow, 1=snow) ssnow % tggsn ( e ,:) = 27 3.1 ! snow temperature per layer (K) ssnow % ssdn ( e ,:) = 14 0.0 ! snow density per layer (kg/m3) ssnow % smass ( e ,:) = 0.0 ! snow mass per layer (kg/m&#94;2) END IF ! Soil ice: WHERE ( ssnow % tgg ( e ,:) < 27 3.15 ) ssnow % wbice ( e ,:) = ssnow % wb ( e ,:) * 0.8 ELSEWHERE ssnow % wbice ( e ,:) = 0.0 END WHERE END DO IF ( ANY ( ssnow % tgg > 35 0.0 ). OR . ANY ( ssnow % tgg < 18 0.0 )) CALL abort ( 'Soil temps nuts' ) IF ( ANY ( ssnow % albsoilsn > 1.0 ). OR . ANY ( ssnow % albsoilsn < 0.0 )) CALL abort ( 'Albedo nuts' ) ! Site independent initialisations (all gridcells): ! soil+snow albedo for infrared (other values read in below): ssnow % albsoilsn (:, 3 ) = 1.0 - emsoil !   ssnow%albsoilsn(:,3) = 0.05  ! YP Nov2009 (fix cold bias) canopy % cansto = 0.0 ! canopy water storage (mm or kg/m2) canopy % sghflux = 0.0 canopy % ghflux = 0.0 ssnow % runoff = 0.0 ! runoff total = subsurface + surface runoff ssnow % rnof1 = 0.0 ! surface runoff (mm/timestepsize) ssnow % rnof2 = 0.0 ! deep drainage (mm/timestepsize) ssnow % rtsoil = 10 0.0 ! turbulent resistance for soil canopy % ga = 0.0 ! ground heat flux (W/m2) canopy % dgdtg = 0.0 ! derivative of ground heat flux wrt soil temp canopy % fev = 0.0 ! latent heat flux from vegetation (W/m2) canopy % fes = 0.0 ! latent heat flux from soil (W/m2) canopy % fhs = 0.0 ! sensible heat flux from soil (W/m2) canopy % us = 0.1 ! friction velocity (needed in roughness before first call to canopy: should in be in restart?) END SUBROUTINE get_default_inits !============================================================================== ! ! Name: get_restart_data ! ! Purpose: Reads initialisations and parameters from restart file ! ! CALLed from: load_parameters ! ! CALLs: nc_abort !        extraRestart !        readpar !        abort ! ! Input file: [restart].nc ! !============================================================================== SUBROUTINE get_restart_data ( logn , ssnow , canopy , rough , bgc , & bal , veg , soil , rad , vegparmnew , EMSOIL ) IMPLICIT NONE ! Input arguments INTEGER , INTENT ( IN ) :: logn ! log file number TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow ! soil and snow variables TYPE ( bgc_pool_type ), INTENT ( INOUT ) :: bgc ! carbon pool variables TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy ! vegetation variables TYPE ( roughness_type ), INTENT ( INOUT ) :: rough ! roughness varibles TYPE ( balances_type ), INTENT ( INOUT ) :: bal ! energy + water balance variables TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( radiation_type ), INTENT ( INOUT ) :: rad LOGICAL , INTENT ( IN ) :: vegparmnew ! are we using the new format? REAL , INTENT ( IN ) :: EMSOIL ! Local variables REAL , POINTER , DIMENSION (:) :: & lat_restart , & lon_restart INTEGER , POINTER , DIMENSION (:) :: INvar !    REAL, POINTER,DIMENSION(:,:) :: surffrac ! fraction of each surf type INTEGER :: & mland_restart , & ! number of land points in restart file INvegt , & INsoilt , & INpatch , & mpatchID , & !     surftype_restart,      & ! number of surface types in restart file latID , lonID , & ! lat,lon variable ID mvtypeID , & ! veg type variable ID mstypeID , & ! soil type variable ID mlandID , & ! netcdf ID for land points i , & ! do loop counter !     jj,                    & ! do loop counter parID ! parameter's netcdf ID LOGICAL :: & from_restart = . TRUE ., & ! insist variables/params load dummy ! To replace completeSet in parameter read; unused REAL , ALLOCATABLE :: var_r (:) REAL , ALLOCATABLE :: var_r2 (:,:) ! Write to screen the restart file is found: WRITE ( * , * ) 'Reading restart data from: ' , TRIM ( filename % restart_in ) ! Check number of gridpoints in restart file is correct: ok = NF90_INQ_DIMID ( ncid_rin , 'mland' , mlandID ) IF ( ok /= NF90_NOERR ) THEN ok = NF90_INQ_DIMID ( ncid_rin , 'mp' , mlandID ) ! name used before sep2010 IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding mland dimension in restart file ' & // TRIM ( filename % restart_in ) // ' (SUBROUTINE get_restart)' ) END IF ok = NF90_INQUIRE_DIMENSION ( ncid_rin , mlandID , len = mland_restart ) PRINT * , 'number of land point in restart file: ' , mland_restart IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding number of land points in restart file ' & // TRIM ( filename % restart_in ) // ' (SUBROUTINE get_restart)' ) IF ( mland_restart /= mland ) CALL abort ( 'Number of land points in ' // & 'restart file ' // TRIM ( filename % restart_in ) // & ' differs from number in met file ' // TRIM ( filename % met )) ! Added the checking of mp; if not equal, redirect to another ! subroutine to get grid-based info (BP may2010) for LULUC ok = NF90_INQ_DIMID ( ncid_rin , 'mp_patch' , mpatchID ) IF ( ok /= NF90_NOERR ) THEN ok = NF90_INQ_DIMID ( ncid_rin , 'mp' , mpatchID ) ! old file before sep2010 IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding mp_patch dimension in restart file ' & // TRIM ( filename % restart_in ) // ' (SUBROUTINE get_restart)' ) ENDIF ok = NF90_INQUIRE_DIMENSION ( ncid_rin , mpatchID , len = INpatch ) PRINT * , 'total number of patches in restart file: ' , INpatch IF ( INpatch /= mp ) THEN CALL extraRestart ( INpatch , ssnow , canopy , rough , bgc , & bal , veg , soil , rad , EMSOIL ) RETURN ENDIF ! removed the following because already in IGBP types (BP apr08) !    ! Check number of surface types is correct: !    ok = NF90_INQ_DIMID(ncid_rin,'surftype',surftypeID) !    IF(ok /= NF90_NOERR) CALL nc_abort & !         (ok,'Error finding surftype dimension in restart file ' & !         //TRIM(filename%restart_in)//' (SUBROUTINE get_restart)') !    ok = NF90_INQUIRE_DIMENSION(ncid_rin,surftypeID,len=surftype_restart) !    IF(ok /= NF90_NOERR) CALL nc_abort & !         (ok,'Error finding number of surface types in restart file ' & !         //TRIM(filename%restart_in)//' (SUBROUTINE get_restart)') !    IF(surftype_restart /= 4) CALL & !         abort('Number of surface types per grid cell in '// & !         'restart file '//TRIM(filename%restart_in)// & !         ' differs from number in cable_variables.f90 ') !    ! Get surffrac variable: !    ALLOCATE(surffrac(mland,4)) !    ok = NF90_INQ_VARID(ncid_rin,'surffrac',surffracID) !    IF(ok /= NF90_NOERR) CALL nc_abort & !         (ok,'Error finding surffrac in restart file ' & !         //TRIM(filename%restart_in)//' (SUBROUTINE get_restart)') !    ok=NF90_GET_VAR(ncid_rin,surffracID,surffrac) !    IF(ok/=NF90_NOERR) CALL nc_abort(ok,'Error reading surffrac in file ' & !         //TRIM(filename%restart_in)// '(SUBROUTINE get_restart)') !    landpt(:)%veg%frac =  surffrac(:,1) !    landpt(:)%urban%frac = surffrac(:,2) !    landpt(:)%lake%frac = surffrac(:,3) !    landpt(:)%ice%frac = surffrac(:,4) !    DEALLOCATE(surffrac) ! check that lat/lon b/w run and restart are compatible: ALLOCATE ( lat_restart ( mland ), lon_restart ( mland )) ok = NF90_INQ_VARID ( ncid_rin , 'latitude' , latID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding latitude in restart file ' & // TRIM ( filename % restart_in ) // ' (SUBROUTINE get_restart)' ) ok = NF90_INQ_VARID ( ncid_rin , 'longitude' , lonID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding longitude in restart file ' & // TRIM ( filename % restart_in ) // ' (SUBROUTINE get_restart)' ) ok = NF90_GET_VAR ( ncid_rin , latID , lat_restart ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading latitude in file ' & // TRIM ( filename % restart_in ) // '(SUBROUTINE get_restart)' ) ! Removed rad%latitude from here as it is already done in write_default_params ! (BP may2010) !    ! Set rad%latitude parameter !    DO i=1,mland !       ! All patches in a single grid cell have the same latitude: !       rad%latitude(landpt(i)%cstart:landpt(i)%cend)=lat_restart(i) !    END DO ok = NF90_GET_VAR ( ncid_rin , lonID , lon_restart ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading longitude in file ' & // TRIM ( filename % restart_in ) // '(SUBROUTINE get_restart)' ) IF ( ANY ( ABS ( lat_restart - latitude ) > 0.01 )) & CALL abort ( 'Latitude of land points in ' // & 'restart file ' // TRIM ( filename % restart_in ) // & ' differs from met file ' // TRIM ( filename % met )) IF ( ANY ( ABS ( lon_restart - longitude ) > 0.01 )) & CALL abort ( 'Longitude of land points in ' // & 'restart file ' // TRIM ( filename % restart_in ) // & ' differs from met file ' // TRIM ( filename % met )) DEALLOCATE ( lat_restart , lon_restart ) ! Check that the number of vegetation types is present in restart file: ok = NF90_INQ_VARID ( ncid_rin , 'mvtype' , mvtypeID ) IF ( ok /= NF90_NOERR ) THEN ok = NF90_INQ_VARID ( ncid_rin , 'nvegt' , mvtypeID ) IF ( ok == NF90_NOERR ) THEN ok = NF90_GET_VAR ( ncid_rin , mvtypeID , INvegt ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading nvegt in file ' & // TRIM ( filename % restart_in ) // '(SUBROUTINE get_restart)' ) IF ( INvegt > 17 ) CALL nc_abort ( ok , 'Error: nvegt value in file ' & // TRIM ( filename % restart_in ) // ' out of range' ) IF ( INvegt /= mvtype ) PRINT * , 'Warning: INvegt, nvegt = ' , INvegt , mvtype ENDIF ! Removed the following as mvtype is determined earlier from ! reading in def_veg_params_xx.txt (BP may2010) !       IF(vegparmnew) THEN !          mvtype = 17 !       ELSE !          mvtype = 13 !       ENDIF ELSE ! Changed the read-in variable name so that mvtype would not be overwritten ! and added some more checking (BP may2010) ok = NF90_GET_VAR ( ncid_rin , mvtypeID , INvegt ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading mvtype in file ' & // TRIM ( filename % restart_in ) // '(SUBROUTINE get_restart)' ) IF ( INvegt > 17 ) CALL nc_abort ( ok , 'Error: mvtype value in file ' & // TRIM ( filename % restart_in ) // ' out of range' ) IF ( INvegt /= mvtype ) PRINT * , 'Warning: INvegt, mvtype = ' , INvegt , mvtype ENDIF ! Check that the number of soil types is present in restart file: ok = NF90_INQ_VARID ( ncid_rin , 'mstype' , mstypeID ) IF ( ok /= NF90_NOERR ) THEN ok = NF90_INQ_VARID ( ncid_rin , 'nsoilt' , mstypeID ) IF ( ok == NF90_NOERR ) THEN ok = NF90_GET_VAR ( ncid_rin , mstypeID , INsoilt ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading nsoilt in file ' & // TRIM ( filename % restart_in ) // '(SUBROUTINE get_restart)' ) IF ( INsoilt /= mstype ) CALL nc_abort ( ok , 'Error: nsoilt value in file ' & // TRIM ( filename % restart_in ) // ' is wrong' ) ENDIF ! Removed the following as mstype is determined earlier from ! reading in def_soil_params.txt (BP may2010) !       mstype = 9 ELSE ! Changed the read-in variable name so that mstype would not be overwritten ! (BP may2010) ok = NF90_GET_VAR ( ncid_rin , mstypeID , INsoilt ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading mstype in file ' & // TRIM ( filename % restart_in ) // '(SUBROUTINE get_restart)' ) IF ( INsoilt /= mstype ) CALL nc_abort ( ok , 'Error: mstype value in file ' & // TRIM ( filename % restart_in ) // ' is wrong' ) ENDIF dummy = . TRUE . ! initialise for completeness only - not used ! Get variable initialisations ============================= ! Arguments are: netcdf file ID; parameter name; !   complete set check; parameter value; filename for error messages; !   number of veg/soil patches in met file; switch to indicate !   size of dimensions of the parameter; an indicator to show !   we're reading from the restart file. ! Use 'defd' for single dim double precision. ! Use, e.g., 'msd' to fetch double precision 2D soil varible CALL readpar ( ncid_rin , 'tgg' , dummy , ssnow % tgg , filename % restart_in , & max_vegpatches , 'ms' , from_restart , mp ) CALL readpar ( ncid_rin , 'wb' , dummy , ssnow % wb , filename % restart_in , & max_vegpatches , 'msd' , from_restart , mp ) CALL readpar ( ncid_rin , 'wbice' , dummy , ssnow % wbice , filename % restart_in , & max_vegpatches , 'msd' , from_restart , mp ) !    WHERE (ssnow%tgg > 273.2 .AND. ssnow%wbice >0.0) ssnow%wbice=0.0 CALL readpar ( ncid_rin , 'gammzz' , dummy , ssnow % gammzz , filename % restart_in , & max_vegpatches , 'msd' , from_restart , mp ) CALL readpar ( ncid_rin , 'tss' , dummy , ssnow % tss , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'ssdnn' , dummy , ssnow % ssdnn , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'ssdn' , dummy , ssnow % ssdn , filename % restart_in , & max_vegpatches , 'snow' , from_restart , mp ) CALL readpar ( ncid_rin , 'osnowd' , dummy , ssnow % osnowd , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'smass' , dummy , ssnow % smass , filename % restart_in , & max_vegpatches , 'snow' , from_restart , mp ) CALL readpar ( ncid_rin , 'sdepth' , dummy , ssnow % sdepth , filename % restart_in , & max_vegpatches , 'snow' , from_restart , mp ) CALL readpar ( ncid_rin , 'tggsn' , dummy , ssnow % tggsn , filename % restart_in , & max_vegpatches , 'snow' , from_restart , mp ) CALL readpar ( ncid_rin , 'snage' , dummy , ssnow % snage , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'snowd' , dummy , ssnow % snowd , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'rtsoil' , dummy , ssnow % rtsoil , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'isflag' , dummy , ssnow % isflag , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'albsoilsn' , dummy , ssnow % albsoilsn , & filename % restart_in , max_vegpatches , 'nrb' , from_restart , mp ) ssnow % albsoilsn (:, 3 ) = 1.0 - emsoil !! (BP Nov 2009) CALL readpar ( ncid_rin , 'rnof1' , dummy , ssnow % rnof1 , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'rnof2' , dummy , ssnow % rnof2 , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'runoff' , dummy , ssnow % runoff , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) !MD ok = NF90_INQ_VARID ( ncid_rin , 'GWwb' , parID ) IF ( ok == NF90_NOERR ) THEN CALL readpar ( ncid_rin , 'GWwb' , dummy , ssnow % GWwb , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) ELSE ssnow % GWwb = 0.95 * soil % ssat END IF !!$   IF(cable_user%SOIL_STRUC=='sli'.or.cable_user%FWSOIL_SWITCH=='Haverd2013') THEN !!$      CALL readpar(ncid_rin,'gamma',dummy,veg%gamma,filename%restart_in,           & !!$           max_vegpatches,'def',from_restart,mp) !!$   ENDIF IF ( cable_user % SOIL_STRUC == 'sli' ) THEN CALL readpar ( ncid_rin , 'S' , dummy , ssnow % S , filename % restart_in , & max_vegpatches , 'ms' , from_restart , mp ) CALL readpar ( ncid_rin , 'Tsoil' , dummy , ssnow % Tsoil , filename % restart_in , & max_vegpatches , 'ms' , from_restart , mp ) CALL readpar ( ncid_rin , 'h0' , dummy , ssnow % h0 , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'nsnow' , dummy , ssnow % nsnow , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'Tsurface' , dummy , ssnow % Tsurface , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'snowliq' , dummy , ssnow % snowliq , filename % restart_in , & max_vegpatches , 'snow' , from_restart , mp ) CALL readpar ( ncid_rin , 'sconds' , dummy , ssnow % sconds , filename % restart_in , & max_vegpatches , 'snow' , from_restart , mp ) !!$       CALL readpar(ncid_rin,'ZR',dummy,veg%ZR, & !!$            filename%restart_in,max_vegpatches,'def',from_restart,mp) !!$       CALL readpar(ncid_rin,'F10',dummy,veg%F10, & !!$            filename%restart_in,max_vegpatches,'def',from_restart,mp) !!$       CALL readpar(ncid_rin,'zeta',dummy,soil%zeta,filename%restart_in,           & !!$            max_vegpatches,'def',from_restart,mp) !!$       CALL readpar(ncid_rin,'fsatmax',dummy,soil%fsatmax,filename%restart_in,           & !!$            max_vegpatches,'def',from_restart,mp) !!$       CALL readpar(ncid_rin,'nhorizons',dummy,soil%nhorizons,filename%restart_in,           & !!$            max_vegpatches,'def',from_restart,mp) !!$       ALLOCATE(var_r2(mp,ms)) !!$       CALL readpar(ncid_rin,'ishorizon',dummy,var_r2,filename%restart_in,           & !!$            max_vegpatches,'ms',from_restart,mp) !!$       soil%ishorizon = int(var_r2) !!$       DEALLOCATE(var_r2) !!$       CALL readpar(ncid_rin,'clitt',dummy,veg%clitt,filename%restart_in,           & !!$            max_vegpatches,'def',from_restart,mp) ENDIF CALL readpar ( ncid_rin , 'cansto' , dummy , canopy % cansto , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'sghflux' , dummy , canopy % sghflux , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'ghflux' , dummy , canopy % ghflux , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'ga' , dummy , canopy % ga , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'dgdtg' , dummy , canopy % dgdtg , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'fev' , dummy , canopy % fev , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) !jhan:hack - elimiinate call as r_2 now !    CALL readpar(ncid_rin,'fes',dummy,canopy%fes,filename%restart_in,          & !         max_vegpatches,'def',from_restart,mp) CALL readpar ( ncid_rin , 'fhs' , dummy , canopy % fhs , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'cplant' , dummy , bgc % cplant , filename % restart_in , & max_vegpatches , 'ncp' , from_restart , mp ) CALL readpar ( ncid_rin , 'csoil' , dummy , bgc % csoil , filename % restart_in , & max_vegpatches , 'ncs' , from_restart , mp ) CALL readpar ( ncid_rin , 'wbtot0' , dummy , bal % wbtot0 , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) CALL readpar ( ncid_rin , 'osnowd0' , dummy , bal % osnowd0 , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) ! The following two restart file additions are to initialise Mk3L: CALL readpar ( ncid_rin , 'albedo' , dummy , rad % albedo , filename % restart_in , & max_vegpatches , 'nrb' , from_restart , mp ) CALL readpar ( ncid_rin , 'trad' , dummy , rad % trad , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) ! Get model parameters ============================================= ! rad%latitude set above in lat/lon checking section ALLOCATE ( INvar ( mp )) CALL readpar ( ncid_rin , 'iveg' , dummy , INvar , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) IF ( ASSOCIATED ( vegtype_metfile )) THEN ! met file iveg info is now in veg%iveg IF ( ANY ( INvar /= veg % iveg )) THEN PRINT * , 'Error: veg type in restart file different from met input' PRINT * , 'Recommend not using this restart file as parameters have changed.' CALL abort ( 'Check iveg in ' // filename % restart_in ) ENDIF ELSE ! no problem with overwriting default values veg % iveg = INvar ENDIF !    CALL readpar(ncid_rin,'iveg',dummy,veg%iveg,filename%restart_in,           & !         max_vegpatches,'def',from_restart,mp) IF (. NOT . CABLE_USER % POPLUC ) THEN CALL readpar ( ncid_rin , 'patchfrac' , dummy , patch (:)% frac , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) ENDIF !    DO i=1, mland !    DO jj = landpt(i)%cstart, landpt(i)%cend !      IF (INvar(jj) /= veg%iveg(jj)) THEN !        PRINT *, 'veg type in restart file is weird.' !        PRINT *, 'mland and mp #: ', i, jj !        PRINT *, 'INvar, veg%iveg: ', INvar(jj), veg%iveg(jj) !        PRINT *, 'lon and lat: ', longitude(i), latitude(i) !      END IF !    END DO !    END DO !! getting rid of spurious veg types in Antarctica from the CCAM2Mk3L process !! Doing it once will fix the problem in the restart file in subsequent runs !    DO i=1, mland !      IF ( rad%latitude(landpt(i)%cstart) < -60.0 .AND. & !           patch(landpt(i)%cstart)%frac < 1.0 ) THEN !        IF ( veg%iveg(landpt(i)%cstart) <= 15 ) THEN !          patch(landpt(i)%cstart:landpt(i)%cend)%frac = 0.0 !          patch(landpt(i)%cstart)%frac = 1.0 !          veg%iveg(landpt(i)%cstart:landpt(i)%cend) = 15 !        END IF !      END IF !    END DO !! end of fix to spurious veg types CALL readpar ( ncid_rin , 'isoil' , dummy , INvar , filename % restart_in , & max_vegpatches , 'def' , from_restart , mp ) IF ( ASSOCIATED ( soiltype_metfile )) THEN ! met file isoil info is now in soil%isoilm IF ( ANY ( INvar /= soil % isoilm )) THEN PRINT * , 'Error: soil type in restart file different from met input' PRINT * , 'Recommend not using this restart file as parameters have changed.' CALL abort ( 'Check isoil in ' // filename % restart_in ) ENDIF ELSE ! no problem with overwriting default values soil % isoilm = INvar ENDIF !    CALL readpar(ncid_rin,'isoil',dummy,soil%isoilm,filename%restart_in,       & !         max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'clay',dummy,soil%clay,filename%restart_in,           & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'sand',dummy,soil%sand,filename%restart_in,           & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'silt',dummy,soil%silt,filename%restart_in,           & !                max_vegpatches,'def',from_restart,mp) !   IF ( .NOT. soilparmnew) THEN  ! Q.Zhang @12/20/2010 !      CALL readpar(ncid_rin,'ssat',dummy,soil%ssat,filename%restart_in,        & !                   max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'sfc',dummy,soil%sfc,filename%restart_in,          & !                   max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'swilt',dummy,soil%swilt,filename%restart_in,      & !                   max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'bch',dummy,soil%bch,filename%restart_in,          & !                   max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'hyds',dummy,soil%hyds,filename%restart_in,        & !                  max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'sucs',dummy,soil%sucs,filename%restart_in,        & !                   max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'css',dummy,soil%css,filename%restart_in,          & !                   max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'rhosoil',dummy,soil%rhosoil,filename%restart_in,  & !                   max_vegpatches,'def',from_restart,mp) !      IF (ncciy > 0 .AND. filename%restart_in(22:23) == 'HQ') THEN !         ok = NF90_INQ_VARID(ncid_rin,'albsoil',parID) !         IF(ok == NF90_NOERR) THEN !            ALLOCATE(var_r(mp)) !            ok= NF90_GET_VAR(ncid_rin,parID,var_r,start=(/1/),count=(/mp/)) !            IF(ok /= NF90_NOERR) CALL nc_abort                                 & !                 (ok,'Error reading '//'albsoil'//' in file '                  & !                 //TRIM(filename%restart_in)//' (SUBROUTINE get_restart_data)') !            soil%albsoil(:,1) = var_r / 3.0 !            soil%albsoil(:,2) = var_r * 2.0 / 3.0 !            soil%albsoil(:,3) = 0.005 !            DEALLOCATE(var_r) !         END IF !      ELSE !         CALL readpar(ncid_rin,'albsoil',dummy,soil%albsoil,filename%restart_in, & !                      max_vegpatches,'nrb',from_restart,mp) !      END IF !   END IF !    CALL readpar(ncid_rin,'rs20',dummy,soil%rs20,filename%restart_in,          & !         max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'rs20',dummy,veg%rs20,filename%restart_in,            & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'froot',dummy,veg%froot,filename%restart_in,          & !                max_vegpatches,'ms',from_restart,mp) !   CALL readpar(ncid_rin,'hc',dummy,veg%hc,filename%restart_in,                & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'canst1',dummy,veg%canst1,filename%restart_in,        & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'dleaf',dummy,veg%dleaf,filename%restart_in,          & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'frac4',dummy,veg%frac4,filename%restart_in,          & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'ejmax',dummy,veg%ejmax,filename%restart_in,          & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'vcmax',dummy,veg%vcmax,filename%restart_in,          & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'rp20',dummy,veg%rp20,filename%restart_in,            & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'rpcoef',dummy,veg%rpcoef,filename%restart_in,        & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'shelrb',dummy,veg%shelrb,filename%restart_in,        & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'xfang',dummy,veg%xfang,filename%restart_in,          & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'wai',dummy,veg%wai,filename%restart_in,              & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'vegcf',dummy,veg%vegcf,filename%restart_in,          & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'extkn',dummy,veg%extkn,filename%restart_in,          & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'tminvj',dummy,veg%tminvj,filename%restart_in,        & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'tmaxvj',dummy,veg%tmaxvj,filename%restart_in,        & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'vbeta',dummy,veg%vbeta,filename%restart_in,          & !                max_vegpatches,'def',from_restart,mp) !   CALL readpar(ncid_rin,'xalbnir',dummy,veg%xalbnir,filename%restart_in,      & !                max_vegpatches,'def',from_restart,mp) !   veg%xalbnir = 1.0   ! xalbnir will soon be removed totally !   CALL readpar(ncid_rin,'g0',dummy,veg%g0,filename%restart_in,            & !                max_vegpatches,'def',from_restart,mp) ! Ticket #56 !   CALL readpar(ncid_rin,'g1',dummy,veg%g1,filename%restart_in,            & !                max_vegpatches,'def',from_restart,mp) ! Ticket #56 !   CALL readpar(ncid_rin,'meth',dummy,veg%meth,filename%restart_in,            & !                max_vegpatches,'def',from_restart,mp) !   ! special treatment of za with the introduction of za_uv and za_tq ! in case an old restart file is used !   ok = NF90_INQ_VARID(ncid_rin,'za',parID) !   IF(ok == NF90_NOERR) THEN ! if it does exist !      CALL readpar(ncid_rin,'za',dummy,rough%za_uv,filename%restart_in,        & !                   max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'za',dummy,rough%za_tq,filename%restart_in,        & !                   max_vegpatches,'def',from_restart,mp) !   ELSE !      CALL readpar(ncid_rin,'za_uv',dummy,rough%za_uv,filename%restart_in,     & !                   max_vegpatches,'def',from_restart,mp) !      CALL readpar(ncid_rin,'za_tq',dummy,rough%za_tq,filename%restart_in,     & !                   max_vegpatches,'def',from_restart,mp) !   ENDIF CALL readpar ( ncid_rin , 'zse' , dummy , soil % zse , filename % restart_in , & max_vegpatches , 'ms' , from_restart , mp ) !   CALL readpar(ncid_rin,'ratecp',dummy,bgc%ratecp,filename%restart_in,        & !                max_vegpatches,'ncp',from_restart,mp) !   CALL readpar(ncid_rin,'ratecs',dummy,bgc%ratecs,filename%restart_in,        & !                max_vegpatches,'ncs',from_restart,mp) ! ! Close restart file: ok = NF90_CLOSE ( ncid_rin ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error closing restart file ' & // TRIM ( filename % restart_in ) // '(SUBROUTINE get_restart)' ) END SUBROUTINE get_restart_data !============================================================================== ! ! Name: extraRestart ! ! Purpose: Redistribute the patches if restart file does not match ! ! CALLed from: get_restart_data ! ! CALLs: nc_abort !        readpar !        redistr_r2d !        redistr_rd !        redistr_r !        redistr_r2 !        redistr_i ! ! Input file: [restart].nc ! !============================================================================== SUBROUTINE extraRestart ( INpatch , ssnow , canopy , rough , bgc , & bal , veg , soil , rad , EMSOIL ) ! Assume this subroutine to be used for first simulation year only, ! so do not need to read in tgg, wb, iveg, patchfrac and frac4. IMPLICIT NONE INTEGER , INTENT ( IN ) :: INpatch TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow ! soil and snow variables TYPE ( bgc_pool_type ), INTENT ( INOUT ) :: bgc ! carbon pool variables TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy ! vegetation variables TYPE ( roughness_type ), INTENT ( INOUT ) :: rough ! roughness varibles TYPE ( balances_type ), INTENT ( INOUT ) :: bal ! energy + water balance variables REAL , INTENT ( IN ) :: EMSOIL TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( radiation_type ), INTENT ( INOUT ) :: rad ! local variables INTEGER , ALLOCATABLE , DIMENSION (:) :: & nap , & var_i REAL , ALLOCATABLE , DIMENSION (:) :: var_r REAL ( r_2 ), ALLOCATABLE , DIMENSION (:) :: var_rd REAL , ALLOCATABLE , DIMENSION (:,:) :: var_r2 REAL ( r_2 ), ALLOCATABLE , DIMENSION (:,:) :: var_r2d LOGICAL :: & from_restart = . TRUE ., & ! insist variables/params load dummy = . TRUE . ! To replace completeSet in parameter read; unused INTEGER :: napID PRINT * , '***** NOTE: now in extraRestart. *****' ALLOCATE ( nap ( mland )) ok = NF90_INQ_VARID ( ncid_rin , 'nap' , napID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding number of active patches in restart file ' & // TRIM ( filename % restart_in ) // ' (SUBROUTINE extraRestart)' ) ok = NF90_GET_VAR ( ncid_rin , napID , nap ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading nap in file ' & // TRIM ( filename % restart_in ) // '(SUBROUTINE extraRestart)' ) ALLOCATE ( var_i ( INpatch )) ALLOCATE ( var_r ( INpatch )) ALLOCATE ( var_rd ( INpatch )) ALLOCATE ( var_r2 ( INpatch , msn )) ALLOCATE ( var_r2d ( INpatch , ms )) CALL readpar ( ncid_rin , 'wbice' , dummy , var_r2d , filename % restart_in , & max_vegpatches , 'msd' , from_restart , INpatch ) CALL redistr_r2d ( INpatch , nap , var_r2d , ssnow % wbice , 'wbice' , ms ) CALL readpar ( ncid_rin , 'gammzz' , dummy , var_r2d , filename % restart_in , & max_vegpatches , 'msd' , from_restart , INpatch ) CALL redistr_r2d ( INpatch , nap , var_r2d , ssnow % gammzz , 'gammzz' , ms ) CALL readpar ( ncid_rin , 'tss' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % tss , 'tss' ) CALL readpar ( ncid_rin , 'ssdnn' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % ssdnn , 'ssdnn' ) CALL readpar ( ncid_rin , 'ssdn' , dummy , var_r2 , filename % restart_in , & max_vegpatches , 'snow' , from_restart , INpatch ) CALL redistr_r2 ( INpatch , nap , var_r2 , ssnow % ssdn , 'ssdn' , msn ) CALL readpar ( ncid_rin , 'osnowd' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % osnowd , 'osnowd' ) CALL readpar ( ncid_rin , 'smass' , dummy , var_r2 , filename % restart_in , & max_vegpatches , 'snow' , from_restart , INpatch ) CALL redistr_r2 ( INpatch , nap , var_r2 , ssnow % smass , 'smass' , msn ) CALL readpar ( ncid_rin , 'sdepth' , dummy , var_r2 , filename % restart_in , & max_vegpatches , 'snow' , from_restart , INpatch ) CALL redistr_r2 ( INpatch , nap , var_r2 , ssnow % sdepth , 'sdepth' , msn ) CALL readpar ( ncid_rin , 'tggsn' , dummy , var_r2 , filename % restart_in , & max_vegpatches , 'snow' , from_restart , INpatch ) CALL redistr_r2 ( INpatch , nap , var_r2 , ssnow % tggsn , 'tggsn' , msn ) CALL readpar ( ncid_rin , 'snage' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % snage , 'snage' ) CALL readpar ( ncid_rin , 'snowd' , dummy , ssnow % snowd , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % snowd , 'snowd' ) CALL readpar ( ncid_rin , 'rtsoil' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % rtsoil , 'rtsoil' ) CALL readpar ( ncid_rin , 'isflag' , dummy , var_i , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_i ( INpatch , nap , var_i , ssnow % isflag , 'isflag' ) DEALLOCATE ( var_r2 ) ALLOCATE ( var_r2 ( INpatch , nrb )) CALL readpar ( ncid_rin , 'albsoilsn' , dummy , var_r2 , filename % restart_in , & max_vegpatches , 'nrb' , from_restart , INpatch ) CALL redistr_r2 ( INpatch , nap , var_r2 , ssnow % albsoilsn , 'albsoilsn' , nrb ) ssnow % albsoilsn (:, 3 ) = 1.0 - emsoil !! (BP Nov 2009) ! The following two restart file additions are to initialise Mk3L: CALL readpar ( ncid_rin , 'albedo' , dummy , var_r2 , filename % restart_in , & max_vegpatches , 'nrb' , from_restart , INpatch ) CALL redistr_r2 ( INpatch , nap , var_r2 , rad % albedo , 'albedo' , nrb ) CALL readpar ( ncid_rin , 'trad' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , rad % trad , 'trad' ) CALL readpar ( ncid_rin , 'rnof1' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % rnof1 , 'rnof1' ) CALL readpar ( ncid_rin , 'rnof2' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % rnof2 , 'rnof2' ) CALL readpar ( ncid_rin , 'runoff' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , ssnow % runoff , 'runoff' ) CALL readpar ( ncid_rin , 'cansto' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , canopy % cansto , 'cansto' ) CALL readpar ( ncid_rin , 'sghflux' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , canopy % sghflux , 'sghflux' ) CALL readpar ( ncid_rin , 'ghflux' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , canopy % ghflux , 'ghflux' ) CALL readpar ( ncid_rin , 'ga' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , canopy % ga , 'ga' ) CALL readpar ( ncid_rin , 'dgdtg' , dummy , var_rd , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_rd ( INpatch , nap , var_rd , canopy % dgdtg , 'dgdtg' ) CALL readpar ( ncid_rin , 'fev' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , canopy % fev , 'fev' ) !jhan:hack - elimiinate call as r_2 now !    CALL readpar(ncid_rin,'fes',dummy,var_r,filename%restart_in,               & !         max_vegpatches,'def',from_restart,INpatch) !    CALL redistr_r(INpatch,nap,var_r,canopy%fes,'fes') CALL readpar ( ncid_rin , 'fhs' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , canopy % fhs , 'fhs' ) DEALLOCATE ( var_r2 ) ALLOCATE ( var_r2 ( INpatch , ncp )) CALL readpar ( ncid_rin , 'cplant' , dummy , var_r2 , filename % restart_in , & max_vegpatches , 'ncp' , from_restart , INpatch ) CALL redistr_r2 ( INpatch , nap , var_r2 , bgc % cplant , 'cplant' , ncp ) DEALLOCATE ( var_r2 ) ALLOCATE ( var_r2 ( INpatch , ncs )) CALL readpar ( ncid_rin , 'csoil' , dummy , var_r2 , filename % restart_in , & max_vegpatches , 'ncs' , from_restart , INpatch ) CALL redistr_r2 ( INpatch , nap , var_r2 , bgc % csoil , 'csoil' , ncs ) CALL readpar ( ncid_rin , 'wbtot0' , dummy , var_r , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , bal % wbtot0 , 'wbtot0' ) CALL readpar ( ncid_rin , 'osnowd0' , dummy , bal % osnowd0 , filename % restart_in , & max_vegpatches , 'def' , from_restart , INpatch ) CALL redistr_r ( INpatch , nap , var_r , bal % osnowd0 , 'osnowd0' ) ! assume all soil and veg parameters are done in default_parameters ! therefore, no need to do it here again veg % xalbnir = 1.0 ! xalbnir will soon be removed totally PRINT * , 'Finished extraRestart' DEALLOCATE ( var_i ) DEALLOCATE ( var_r ) DEALLOCATE ( var_rd ) DEALLOCATE ( var_r2 ) DEALLOCATE ( var_r2d ) END SUBROUTINE extraRestart END MODULE cable_init_module","tags":"","loc":"sourcefile/cable_initialise.f90.html"},{"title":"cable_soil_params.F90 – CABLE","text":"Contents Modules cable_soil_params_mod Source Code cable_soil_params.F90 Source Code MODULE cable_soil_params_mod USE grid_constants_mod_cbl , ONLY : nsoil_max ! # of soil types [9] IMPLICIT NONE TYPE soilin_type CHARACTER ( LEN = 70 ) :: desc ( nsoil_max ) ! decriptns of soil type REAL , DIMENSION ( nsoil_max ) :: & silt , & ! clay , & ! sand , & ! swilt , & ! sfc , & ! ssat , & ! bch , & ! hyds , & ! sucs , & ! rhosoil , & ! css , & ! c3 ! END TYPE soilin_type TYPE ( soilin_type ), SAVE :: soilin CHARACTER ( LEN = 70 ), DIMENSION ( nsoil_max ) :: soil_desc CONTAINS subroutine cable_soil_params () ! Gets parameter values for each vegetation type and soil type. USE cable_def_types_mod , ONLY : mstype implicit none integer :: ERROR integer , parameter :: namelist_unit = 711178 integer :: j CHARACTER ( LEN =* ), parameter :: iomessage = 'something wrong with your soil params file' CHARACTER ( LEN =* ), parameter :: nml_dir = './' CHARACTER ( LEN =* ), PARAMETER :: routinename = 'cable_soil_params' NAMELIST / cable_soilparm / soilin mstype = nsoil_max !SOIL parameters are assigned as TYPE soilin% but later mapped to soil% !----------------------------------------------------------------------------- ! Read namelist !----------------------------------------------------------------------------- write ( 6 , * ) \"Reading CABLE_SOILPARM namelist...\" OPEN ( namelist_unit , FILE = ( TRIM ( nml_dir ) // '/' // 'cable_soilparm.nml' ), & STATUS = 'old' , POSITION = 'rewind' , ACTION = 'read' , IOSTAT = ERROR ) IF ( ERROR /= 0 ) write ( 6 , * ) \"Error opening  CABLE_SOILPARM namelist...\" READ ( namelist_unit , NML = cable_soilparm , IOSTAT = ERROR ) IF ( ERROR /= 0 ) write ( 6 , * ) \"Error reading  CABLE_SOILPARM namelist...\" CLOSE ( namelist_unit , IOSTAT = ERROR ) soil_desc = soilin % desc End subroutine cable_soil_params END MODULE cable_soil_params_mod","tags":"","loc":"sourcefile/cable_soil_params.f90.html"},{"title":"cable_cru_TRENDY.F90 – CABLE","text":"Contents Modules CABLE_CRU Source Code cable_cru_TRENDY.F90 Source Code MODULE CABLE_CRU USE netcdf ! Access to netcdf routines USE casa_ncdf_module , ONLY : HANDLE_ERR , GET_UNIT ! Finds an unused unit number for file opensYMDHMS2DOYSOD, DOYSOD2YMDHMS USE cable_IO_vars_module , ONLY : & ! Selected cable_iovars.F90 variables: logn , & ! Log file unit number land_x , land_y , & ! Col (x) & row (y) indices of each land point in land mask (dimension mland) exists ! Only for exists%Snowf, which we will set to .FALSE. because there is no snow ! in CRU-NCEP. Setting this ensures snow will be determined in CABLE from temperature. IMPLICIT NONE ! Define a type for CRU-NCEP information, and the subtype METVALS TYPE CRU_MET_TYPE REAL , DIMENSION (:), ALLOCATABLE :: METVALS ! Define a spatial vector of meteorology for one timestep END TYPE CRU_MET_TYPE TYPE CRU_TYPE INTEGER :: mland ! Number of land cells INTEGER :: NMET ! Number of met variable types (rain, lwdn etc) NOT INCLUDING prevTmax and nextTmin INTEGER :: xdimsize , ydimsize ! Landmask grid size dimensions (x=cols, y=rows) INTEGER :: tdimsize ! Time dimension of metfiles (met data timesteps per annual file) INTEGER :: CYEAR ! Current run year, same as CurYear, not necessarily the same as MetYear INTEGER :: MetStart ! First year of met INTEGER :: MetEnd ! Last year of met INTEGER :: CTSTEP ! Current met data timestep (1 to tdimsize, i.e. 365 for CRU-NCEP annual daily files) INTEGER :: DTsecs ! Model timestep in seconds, converted from namelist value in hours INTEGER :: ktau ! Current model timestep, reset at the start of a new year of met INTEGER , DIMENSION ( 9 ) :: F_ID , V_ID ! NetCDF object id's for files and variables (NetCDF bookkeeping stuff) REAL , DIMENSION (:) , ALLOCATABLE :: AVG_LWDN ! Avg of one day's diurnal cycle of lwdn calculated by Swinbank. AVG_LWDN ! is used to rescale the diurnal cycle to match the day's CRUNCEP lwdn. (dim=mland) REAL , DIMENSION (:) , ALLOCATABLE :: CO2VALS ! Global annual CO2 values (dim is the number of years of data, or 1 if time-invariant) LOGICAL :: DirectRead ! Flag to do with reading small numbers of points efficiently. Set true for small numbers of points LOGICAL :: LeapYears ! Flag for whether leaps years occur, required by CABLE. Always false for CRUNCEP (no Feb 29th) LOGICAL , DIMENSION (:,:), ALLOCATABLE :: LandMask ! Logical landmask, true for land, false for non-land ! CHARACTER ( len = 30 ) :: Run ! Where run type is      : \"S0_TRENDY\", \"S1_TRENDY\", \"S2_TRENDY\" CHARACTER ( len = 15 ) :: CO2 ! CO2 takes value        : \"static1860\", \"1860_1900\", \"1901_2015\" CHARACTER ( len = 15 ) :: Ndep ! Ndep takes value        : \"static1860\", \"1860_1900\", \"1901_2015\" CHARACTER ( len = 15 ) :: Forcing ! Met Forcing takes value: \"spinup\",        \"spinup\", \"1901_2015\" ! CHARACTER ( len = 200 ) :: BasePath ! Full path for the location of data used for CRU runs \"/x/y\" CHARACTER ( len = 200 ) :: MetPath ! Full path for the location of the met files \"/x/y\" CHARACTER ( len = 200 ) :: LandMaskFile ! Land mask filename, without path CHARACTER ( len = 30 ) , DIMENSION ( 9 ) :: VAR_NAME ! Netcdf variable 'Name' for each type of met (dim=# of met vars). Note: Name, not 'Title' CHARACTER ( len = 200 ), DIMENSION ( 9 ) :: MetFile ! Met file names incl metpath, constructed in CRU_GET_FILENAME (dim=# of met vars) TYPE ( CRU_MET_TYPE ), DIMENSION ( 11 ) :: MET ! Met data vectors (METVALS) for one timestep, dim=# of met vars + 2 for prev Tmax and next Tmin REAL , DIMENSION (:), ALLOCATABLE :: NdepVALS INTEGER :: NdepF_ID , NdepV_ID INTEGER :: Ndep_CTSTEP ! counter for Ndep in input file END TYPE CRU_TYPE TYPE ( CRU_TYPE ) :: CRU ! Define the variable CRU, of type CRU_TYPE ! Define local parameter names representing the position of each met var within variable MET. ! prevTmax and nextTmin are special cases of Tmax and Tmin that do not count as extra met variables per se. INTEGER , PRIVATE , PARAMETER :: & rain = 1 , & lwdn = 2 , & swdn = 3 , & pres = 4 , & qair = 5 , & tmax = 6 , & tmin = 7 , & uwind = 8 , & vwind = 9 , & ! prevTmax = 10 , & nextTmin = 11 ! Error status of various operations (mostly netcdf-related). Typically 0 means ok, > 0 means unexpected condition. INTEGER , PRIVATE :: ErrStatus REAL , PRIVATE , PARAMETER :: SecDay = 8640 0. ! Number of seconds in a day ! Filename prefix expected in the names of met files. Used by CRU_GET_FILENAME to construct met file names. CHARACTER ( len = 6 ), DIMENSION ( 9 ), PARAMETER , PRIVATE :: & PREF = ( / \"rain  \" , \"lwdown\" , \"swdown\" , \"press \" , \"qair  \" , \"tmax  \" , \"tmin  \" , \"uwind \" , \"vwind \" / ) CONTAINS !************************************************************************************************** SUBROUTINE CRU_INIT ( CRU ) ! Initialise the contents of the CRU defined type collection, from the CRU namelist file ! and by obtaining dimensions from the landmask !************************************************************************************************** USE cable_IO_vars_module , ONLY : & latitude , longitude , & ! (R) Lat and long of landcells only (?) nmetpatches , & ! (I) Size of patch dimension in met file, if it exists mask , & ! (I) Land/sea mask (1,0) metGrid , & ! (C4) Either 'land' or 'mask' for whether the data are packed or not (?) sdoy , smoy , syear , & ! (I) Start time day of year, month, year shod , & ! (R) Start time hour of day xdimsize , ydimsize , & ! (I) Size of grid dimensions lat_all , lon_all ! (R) Grids with the lat or lon of each cell (i.e. repetition along rows/cols), for CABLE. USE cable_def_types_mod , ONLY : mland ! (I) Number of land cells IMPLICIT NONE TYPE ( CRU_TYPE ) :: CRU INTEGER :: ErrStatus ! Error status returned by nc routines (zero=ok, non-zero=error) INTEGER :: nmlunit ! Unit number for reading namelist file INTEGER :: FID ! NetCDF id for the landmask file INTEGER :: latID , lonID , timID ! NetCDF ids for dimensions in the landmask file INTEGER :: landID ! NetCDF id for the landmask variable in the landmask file INTEGER :: tdimsize ! Time dimension in the met file, not used here apparently (??) INTEGER :: landcnt ! Manually incremented counter for the number of land cells INTEGER :: xcol , yrow ! Column and row position in the data file grids INTEGER :: imetvar ! loop counter through met variables ! Temporary local names for CRU% variables as they are read from the namelist file. ! Note that CRU%CO2 and CRU%Forcing are assigned based on the value of Run, not read as options from the namelist file. LOGICAL :: DirectRead = . FALSE . CHARACTER ( len = 30 ) :: Run CHARACTER ( len = 200 ) :: BasePath CHARACTER ( len = 200 ) :: MetPath CHARACTER ( len = 200 ) :: LandMaskFile REAL :: DThrs ! CABLE timestep (hrs), converted immediately to integer seconds for CRU%DTsecs REAL , DIMENSION (:) , ALLOCATABLE :: CRU_lats , CRU_lons ! Lat/long values for each grid rows/cols from landmask. INTEGER , DIMENSION (:,:), ALLOCATABLE :: landmask ! Flag for errors LOGICAL :: ERR = . FALSE . NAMELIST / CRUNML / BasePath , MetPath , LandMaskFile , Run , DThrs , DirectRead ! Read CRU namelist settings CALL GET_UNIT ( nmlunit ) ! CABLE routine finds spare unit number OPEN ( nmlunit , FILE = \"cru.nml\" , STATUS = 'OLD' , ACTION = 'READ' ) READ ( nmlunit , NML = CRUNML ) CLOSE ( nmlunit ) ! Assign namelist settings to corresponding CRU defined-type elements CRU % BasePath = BasePath CRU % MetPath = MetPath CRU % LandMaskFile = LandMaskFile CRU % Run = Run CRU % DTsecs = INT ( DThrs * 360 0. ) ! in seconds CRU % DirectRead = DirectRead ! Assign Forcing and CO2 labels based only on the value of CRU%Run SELECT CASE ( TRIM ( CRU % Run )) CASE ( \"S0_TRENDY\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"static1860\" CRU % Ndep = \"static1860\" WRITE ( * , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = 'static1860'\" WRITE ( logn , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = 'static1860'\" CASE ( \"S0_TRENDY_CO2\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"1901_2015\" CRU % Ndep = \"static1860\" WRITE ( * , * ) \"Run = 'S0_CO2': Therefore Forcing = 'S0_CO2', CO2 = '1860_2015'\" WRITE ( logn , * ) \"Run = 'S0_CO2': Therefore Forcing = 'S0_CO2', CO2 = '1860_2015'\" CASE ( \"S0_TRENDY_Ndep\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"static1860\" CRU % Ndep = \"1901_2015\" WRITE ( * , * ) \"Run = 'S0_Ndep': Therefore Forcing = 'S0_Ndep', Ndep = '1860_2015'\" WRITE ( logn , * ) \"Run = 'S0_Ndep': Therefore Forcing = 'S0_Ndep', Ndep = '1860_2015'\" CASE ( \"S0_TRENDY_Precip\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"static1860\" CRU % Ndep = \"static1860\" WRITE ( * , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = 'static1860'\" WRITE ( logn , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = 'static1860'\" CASE ( \"S0_TRENDY_Temp\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"static1860\" CRU % Ndep = \"static1860\" WRITE ( * , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = 'static1860'\" WRITE ( logn , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = 'static1860'\" CASE ( \"S0_TRENDY_Temp_Precip\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"static1860\" CRU % Ndep = \"static1860\" WRITE ( * , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = 'static1860'\" WRITE ( logn , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = 'static1860'\" CASE ( \"S0_TRENDY_CO2_Temp\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"1901_2015\" CRU % Ndep = \"static1860\" WRITE ( * , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = '1860_2015'\" WRITE ( logn , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = '1860_2015'\" CASE ( \"S0_TRENDY_CO2_Precip\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"1901_2015\" CRU % Ndep = \"static1860\" WRITE ( * , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = '1860_2015'\" WRITE ( logn , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = '1860_2015'\" CASE ( \"S0_TRENDY_CO2_Temp_Precip\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"1901_2015\" CRU % Ndep = \"static1860\" WRITE ( * , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = '1860_2015'\" WRITE ( logn , * ) \"Run = 'spinup': Therefore Forcing = 'spinup', CO2 = '1860_2015'\" CASE ( \"S1_TRENDY\" ) CRU % Forcing = \"spinup\" CRU % CO2 = \"1860_1900\" CRU % Ndep = \"1860_1900\" WRITE ( * , * ) \"Run = 'S1_TRENDY': Therefore Forcing = 'spinup', CO2 = '1860_1900'\" WRITE ( logn , * ) \"Run = 'S1_TRENDY': Therefore Forcing = 'spinup', CO2 = '1860_1900'\" CASE ( \"S2_TRENDY\" ) CRU % Forcing = \"1901_2015\" CRU % CO2 = \"1901_2015\" CRU % Ndep = \"1901_2015\" WRITE ( * , * ) \"Run = 'S2_TRENDY': Therefore Forcing = 'spinup', CO2 = '1901_2015'\" WRITE ( logn , * ) \"Run = 'S2_TRENDY': Therefore Forcing = 'spinup', CO2 = '1901_2015'\" CASE ( \"S2_TRENDY_precip\" ) CRU % Forcing = \"1901_2015\" CRU % CO2 = \"1901_2015\" CRU % Ndep = \"1901_2015\" WRITE ( * , * ) \"Run = 'S2_TRENDY': Therefore Forcing = 'spinup', CO2 = '1901_2015'\" WRITE ( logn , * ) \"Run = 'S2_TRENDY': Therefore Forcing = 'spinup', CO2 = '1901_2015'\" CASE ( \"S2_TRENDY_precip0\" ) CRU % Forcing = \"1901_2015\" CRU % CO2 = \"1901_2015\" CRU % Ndep = \"1901_2015\" WRITE ( * , * ) \"Run = 'S2_TRENDY': Therefore Forcing = 'spinup', CO2 = '1901_2015'\" WRITE ( logn , * ) \"Run = 'S2_TRENDY': Therefore Forcing = 'spinup', CO2 = '1901_2015'\" CASE default WRITE ( * , * ) \"Wrong CRU%Run: \" , CRU % Run WRITE ( * , * ) \"Use: S0_TRENDY, S1_TRENDY, or S2_TRENDY!\" WRITE ( logn , * ) \"Wrong CRU%Run: \" , CRU % Run WRITE ( logn , * ) \"Use: S0_TRENDY, S1_TRENDY, or S2_TRENDY!\" ERR = . TRUE . END SELECT ! Print settings WRITE ( * , * ) \"========================================= CRU ============\" WRITE ( * , * ) \"CRU settings chosen:\" WRITE ( * , * ) \" BasePath: \" , TRIM ( CRU % BasePath ) WRITE ( * , * ) \" LandMask: \" , TRIM ( CRU % LandMaskFile ) WRITE ( * , * ) \" Run                : \" , TRIM ( CRU % Run ) WRITE ( * , * ) \" Forcing (assigned) : \" , TRIM ( CRU % Forcing ) WRITE ( * , * ) \" CO2     (assigned) : \" , TRIM ( CRU % CO2 ) WRITE ( * , * ) \" Ndep     (assigned) : \" , TRIM ( CRU % Ndep ) WRITE ( * , * ) \" DT(secs): \" , CRU % DTsecs WRITE ( logn , * ) \"========================================= CRU ============\" WRITE ( logn , * ) \"CRU settings chosen:\" WRITE ( logn , * ) \" BasePath: \" , TRIM ( CRU % BasePath ) WRITE ( logn , * ) \" LandMask: \" , TRIM ( CRU % LandMaskFile ) WRITE ( logn , * ) \" Run                : \" , TRIM ( CRU % Run ) WRITE ( logn , * ) \" Forcing (assigned) : \" , TRIM ( CRU % Forcing ) WRITE ( logn , * ) \" CO2     (assigned) : \" , TRIM ( CRU % CO2 ) WRITE ( logn , * ) \" Ndep     (assigned) : \" , TRIM ( CRU % Ndep ) WRITE ( logn , * ) \" DT(secs): \" , CRU % DTsecs ! Error trap for bad namelist. IF ( ERR ) THEN WRITE ( logn , * ) \"Invalid settings in CRU_INIT\" STOP \"Invalid settings in CRU_INIT\" ENDIF ! If this is a S0_TRENDY run look for met data in the spinup directory instead. !IF (TRIM(CRU%Run) .EQ. \"S0_TRENDY\") THEN !   CRU%MetPath = TRIM(CRU%MetPath)//\"/spinup_data\" !ENDIF ! Set variable names to their NetCDF 'Names' (i.e. not their 'Titles') CRU % NMET = 9 CRU % VAR_NAME ( rain ) = \"Total_Precipitation\" CRU % VAR_NAME ( lwdn ) = \"Incoming_Long_Wave_Radiation\" CRU % VAR_NAME ( swdn ) = \"Incoming_Short_Wave_Radiation\" CRU % VAR_NAME ( pres ) = \"Pression\" CRU % VAR_NAME ( qair ) = \"Air_Specific_Humidity\" ! CRU%VAR_NAME(tmax)  = \"maximum_6h_air_temperature\" ! CRU%VAR_NAME(tmin)  = \"minimum_6h_air_temperature\" CRU % VAR_NAME ( tmax ) = \"maximum_air_temperature\" CRU % VAR_NAME ( tmin ) = \"minimum_air_temperature\" CRU % VAR_NAME ( uwind ) = \"U_wind_component\" CRU % VAR_NAME ( vwind ) = \"V_wind_component\" WRITE ( * , * ) \"========================================= CRU ============\" WRITE ( logn , * ) \"========================================= CRU ============\" ! Now read landmask file ! Landmask file into init! Get LAt, LON etc. from there ! LMFILE = TRIM(CRU%LandMaskFile) WRITE ( * , * ) 'Opening CRU landmask file: ' , TRIM ( LandMaskFile ) WRITE ( logn , * ) 'Opening CRU landmask file: ' , TRIM ( LandMaskFile ) ! Open the land mask file ErrStatus = NF90_OPEN ( TRIM ( LandMaskFile ), NF90_NOWRITE , FID ) CALL HANDLE_ERR ( ErrStatus , \"Opening CRU Land-mask file\" // TRIM ( LandMaskFile )) ! Latitude: Get the dimension ID, find the size of the dimension, assign it to CRU. ErrStatus = NF90_INQ_DIMID ( FID , 'latitude' , latID ) ErrStatus = NF90_INQUIRE_DIMENSION ( FID , latID , len = ydimsize ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring 'lat'\" // TRIM ( LandMaskFile )) CRU % ydimsize = ydimsize ! Collect the latitudes into CRU_lats ALLOCATE ( CRU_lats ( ydimsize ) ) ErrStatus = NF90_INQ_VARID ( FID , 'latitude' , latID ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring 'latitudes'\" // TRIM ( LandMaskFile )) ErrStatus = NF90_GET_VAR ( FID , latID , CRU_lats ) CALL HANDLE_ERR ( ErrStatus , \"Reading 'latitudes'\" // TRIM ( LandMaskFile )) ! Longitude: Get the dimension ID, find the size of the dimension, assign it to CRU. ErrStatus = NF90_INQ_DIMID ( FID , 'longitude' , lonID ) ErrStatus = NF90_INQUIRE_DIMENSION ( FID , lonID , len = xdimsize ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring 'lon'\" // TRIM ( LandMaskFile )) CRU % xdimsize = xdimsize ! Collect the longitudes into CRU_lons ALLOCATE ( CRU_lons ( xdimsize ) ) ErrStatus = NF90_INQ_VARID ( FID , 'longitude' , lonID ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring 'longitudes'\" // TRIM ( LandMaskFile )) ErrStatus = NF90_GET_VAR ( FID , lonID , CRU_lons ) CALL HANDLE_ERR ( ErrStatus , \"Reading 'longitudes'\" // TRIM ( LandMaskFile )) ! Allocate the landmask arrays for... ALLOCATE ( CRU % landmask ( xdimsize , ydimsize ) ) ! Passing out to other CRU routines (logical) ALLOCATE ( landmask ( xdimsize , ydimsize ) ) ! Local use in this routine (integer) ALLOCATE ( mask ( xdimsize , ydimsize ) ) ! Use by CABLE ! Check that the land mask variable is called \"land\" in the land mask file, ! and read it into local variable landmask ErrStatus = NF90_INQ_VARID ( FID , 'land' , landID ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring 'land' \" // TRIM ( LandMaskFile )) ErrStatus = NF90_GET_VAR ( FID , landID , landmask ) CALL HANDLE_ERR ( ErrStatus , \"Reading 'land' \" // TRIM ( LandMaskFile )) ! Convert the integer landmask into the logical CRU%landmask WHERE ( landmask . GT . 0 ) CRU % landmask = . TRUE . mask = 1 ELSEWHERE CRU % landmask = . FALSE . mask = 0 END WHERE ! Count the number of land cells -> mland CRU % mland = COUNT ( CRU % landmask ) ! Allocate CABLE land-only vectors for lat/long and row/col values/indices. ALLOCATE ( latitude ( CRU % mland ), longitude ( CRU % mland ) ) ALLOCATE ( land_y ( CRU % mland ), land_x ( CRU % mland ) ) ! Allocate vectors for each of the different met quantities, including extra ! prev/next temperatures for the Cesarracio temperature calculations in the ! weather generator. DO imetvar = 1 , CRU % NMET ALLOCATE ( CRU % MET ( imetvar )% METVALS ( CRU % mland ) ) END DO ALLOCATE ( CRU % MET ( prevTmax )% METVALS ( CRU % mland ) ) ALLOCATE ( CRU % MET ( nextTmin )% METVALS ( CRU % mland ) ) ! allocate array for Nitrogen deposition input data ALLOCATE ( CRU % NdepVALS ( CRU % mland ) ) ! Copy the col/row and lat/long positions of each land cell into the corresponding ! land only CABLE vectors. Q: We know mland at this point. Why not use landcnt to confirm ! the correct value of mland? landcnt = 1 DO yrow = 1 , ydimsize DO xcol = 1 , xdimsize IF ( . NOT . CRU % landmask ( xcol , yrow ) ) CYCLE ! Go to next iteration if not a land cell !          WRITE(6,FMT='(A15,I5,2(1X,F8.2),2(1x,I3))')\"i, lo,la, xcol,yrow\",landcnt,CRU_lons(xcol),CRU_lats(yrow),xcol, yrow ! C land_x ( landcnt ) = xcol land_y ( landcnt ) = yrow longitude ( landcnt ) = CRU_lons ( xcol ) latitude ( landcnt ) = CRU_lats ( yrow ) landcnt = landcnt + 1 END DO END DO ! Set global CABLE variables metGrid = \"mask\" ALLOCATE ( mask ( xdimsize , ydimsize ) ) mask = landmask mland = CRU % mland nmetpatches = 1 ALLOCATE ( lat_all ( xdimsize , ydimsize ), lon_all ( xdimsize , ydimsize ) ) DO xcol = 1 , xdimsize lat_all ( xcol ,:) = CRU_lats END DO DO yrow = 1 , ydimsize lon_all (:, yrow ) = CRU_lons END DO ! CABLE TIME-UNITS needed by load-parameters (only on CABLE_init) shod = 0. sdoy = 1 smoy = 1 syear = CRU % CYEAR ! Used to rescale the diurnal cycle from Swinbank calculation to match CRU-NCEP provided value. ALLOCATE ( CRU % AVG_LWDN ( mland ) ) DEALLOCATE ( landmask , CRU_lats , CRU_lons ) ErrStatus = NF90_CLOSE ( FID ) CALL HANDLE_ERR ( ErrStatus , \"Closing mask-file\" // TRIM ( LandMaskFile )) END SUBROUTINE CRU_INIT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE CRU_GET_FILENAME ( CRU , cyear , par , FN ) ! Build the filename FN: One annual file of daily met for one met quantity. IMPLICIT NONE TYPE ( CRU_TYPE ), INTENT ( INOUT ) :: CRU ! Information about CRU INTEGER , INTENT ( IN ) :: cyear ! Current year as an integer INTEGER , INTENT ( IN ) :: par ! Index (1-9) of which met quantity will be sought CHARACTER ( LEN = 200 ), INTENT ( OUT ) :: FN ! Met filename (outgoing) INTEGER :: i , idx CHARACTER ( 4 ) :: cy ! Character representation of cyear CHARACTER ( 200 ) :: mp ! Local repr of met path ! Create a character version of the year for building that part of the filename. WRITE ( cy , FMT = '(I4)' ) cyear ! Initialise the filename with the met path mp = CRU % MetPath FN = TRIM ( mp ) ! Build the rest of the filename according to the value of par, which references 11 possible ! types of met through the parameter names rain, lwdn, etc. !!$    SELECT CASE ( par ) !!$    CASE(rain) ; FN = TRIM(FN)//\"/rain/cruncep2015_1_rain_\"//cy//\".daymean.nc\" !!$    CASE(lwdn) ; FN = TRIM(FN)//\"/lwdown/cruncep2015_1_lwdown_\"//cy//\".daymean.nc\" !!$    CASE(swdn) ; FN = TRIM(FN)//\"/swdown/cruncep2015_1_swdown_\"//cy//\".daymean.nc\" !!$    CASE(pres) ; FN = TRIM(FN)//\"/press/cruncep2015_1_press_\"//cy//\".daymean.nc\" !!$    CASE(qair) ; FN = TRIM(FN)//\"/qair/cruncep2015_1_qair_\"//cy//\".daymean.nc\" !!$    CASE(tmax,PrevTmax) ; FN = TRIM(FN)//\"/tmax/cruncep2015_1_tair_\"//cy//\".daymax.nc\" !!$    CASE(tmin,NextTmin) ; FN = TRIM(FN)//\"/tmin/cruncep2015_1_tair_\"//cy//\".daymin.nc\" !!$    CASE(uwind) ; FN = TRIM(FN)//\"/uwind/cruncep2015_1_uwind_\"//cy//\".daymean.nc\" !!$    CASE(vwind) ; FN = TRIM(FN)//\"/vwind/cruncep2015_1_vwind_\"//cy//\".daymean.nc\" !!$    END SELECT SELECT CASE ( par ) CASE ( rain ) ; FN = TRIM ( FN ) // \"/rain/cruncepV8_rain_\" // cy // \".daytot.nc\" CASE ( lwdn ) ; FN = TRIM ( FN ) // \"/lwdown/cruncepV8_lwdown_\" // cy // \".daymean.nc\" CASE ( swdn ) ; FN = TRIM ( FN ) // \"/swdown/cruncepV8_swdown_\" // cy // \".daymean.nc\" CASE ( pres ) ; FN = TRIM ( FN ) // \"/press/cruncepV8_press_\" // cy // \".daymean.nc\" CASE ( qair ) ; FN = TRIM ( FN ) // \"/qair/cruncepV8_qair_\" // cy // \".daymean.nc\" CASE ( tmax , PrevTmax ) ; FN = TRIM ( FN ) // \"/tmax/cruncepV8_tmax_\" // cy // \".daymax.nc\" CASE ( tmin , NextTmin ) ; FN = TRIM ( FN ) // \"/tmin/cruncepV8_tmin_\" // cy // \".daymin.nc\" CASE ( uwind ) ; FN = TRIM ( FN ) // \"/uwind/cruncepV8_uwind_\" // cy // \".daymean.nc\" CASE ( vwind ) ; FN = TRIM ( FN ) // \"/vwind/cruncepV8_vwind_\" // cy // \".daymean.nc\" END SELECT END SUBROUTINE CRU_GET_FILENAME !************************************************************************************************** SUBROUTINE GET_CRU_CO2 ( CRU , CO2air ) ! Get CO2 values for use with a CRU-NCEP run. Assign a static 1860 value if specified otherwise ! on the first call read all the annual values from a file into the CRU%CO2VALS array. On the first ! and subsequent IMPLICIT NONE TYPE ( CRU_TYPE ) :: CRU ! All the info needed for CRU met runs REAL , INTENT ( OUT ) :: CO2air ! A single annual value of CO2air in ppm for the current year. INTEGER :: i , iunit , iyear , IOS = 0 CHARACTER :: CO2FILE * 200 LOGICAL , SAVE :: CALL1 = . TRUE . ! A *local* variable recording the first call of this routine ! For S0_TRENDY, use only static 1860 CO2 value and return immediately IF ( TRIM ( CRU % CO2 ) . EQ . \"static1860\" ) THEN CO2air = 28 6.42 ! CO2 in ppm for 1860 RETURN ! If not S0_TRENDY, varying CO2 values will be used... ELSE ! On the first call, allocate the CRU%CO2VALS array to store the entire history of annual CO2 ! values, open the (ascii) CO2 file and read the values into the array. IF ( CALL1 ) THEN ALLOCATE ( CRU % CO2VALS ( 1750 : 2016 ) ) CO2FILE = TRIM ( CRU % BasePath ) // \"/co2/1750_2015_globalCO2_time_series.csv\" CALL GET_UNIT ( iunit ) OPEN ( iunit , FILE = TRIM ( CO2FILE ), STATUS = \"OLD\" , ACTION = \"READ\" ) DO WHILE ( IOS . EQ . 0 ) READ ( iunit , FMT =* , IOSTAT = IOS ) iyear , CRU % CO2VALS ( iyear ) END DO CLOSE ( iunit ) CALL1 = . FALSE . END IF ! In all varying CO2 cases, return the element of the array for the current year ! as a single CO2 value. ! CO2air = CRU % CO2VALS ( CRU % CYEAR ) END IF END SUBROUTINE GET_CRU_CO2 !************************************************************************************************** SUBROUTINE GET_CRU_Ndep ( CRU ) ! Get Ndep values for use with a CRU-NCEP run. Assign a static 1860 value if specified otherwise ! on the first call read all the annual values from a file into the CRU%CO2VALS array. On the first ! and subsequent IMPLICIT NONE TYPE ( CRU_TYPE ), INTENT ( INOUT ) :: CRU ! All the info needed for CRU met runs REAL :: tmparr ( 720 , 360 ) ! Temporary array for reading one day of met before ! packing into CRU%NdepVALS(k) INTEGER :: i , iunit , iyear , IOS = 0 , k , t INTEGER :: xds , yds ! Ndep file dimensions of long (x), lat (y) LOGICAL , SAVE :: CALL1 = . TRUE . ! A *local* variable recording the first call of this routine CHARACTER ( 200 ) :: NdepFILE ! Abbreviate dimensions for readability. xds = CRU % xdimsize yds = CRU % ydimsize ! For S0_TRENDY, use only static 1860 CO2 value and return immediately ! On the first call, allocate the CRU%CO2VALS array to store the entire history of annual CO2 ! values, open the (ascii) CO2 file and read the values into the array. IF ( CALL1 ) THEN NdepFILE = TRIM ( CRU % BasePath ) // & \"/ndep/NOy_plus_NHx_dry_plus_wet_deposition_hist_1850_2015_annual.nc\" ! Open the NDep and access the variables by their name and variable id. WRITE ( * , * ) 'Opening ndep data file: ' , NdepFILE WRITE ( logn , * ) 'Opening ndep data file: ' , NdepFILE ErrStatus = NF90_OPEN ( TRIM ( NdepFILE ), NF90_NOWRITE , CRU % NdepF_ID ) CALL HANDLE_ERR ( ErrStatus , \"Opening CRU file \" // NdepFILE ) ErrStatus = NF90_INQ_VARID ( CRU % NdepF_ID , 'N_deposition' , CRU % NdepV_ID ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring CRU var \" // \"N_deposition\" // & \" in \" // NdepFILE ) ! Set internal counter CRU % Ndep_CTSTEP = 1 IF ( TRIM ( CRU % Ndep ) . EQ . \"static1860\" ) THEN ! read Ndep at year 1860 (noting that file starts at 1850) CRU % Ndep_CTSTEP = 11 t = CRU % Ndep_CTSTEP ErrStatus = NF90_GET_VAR ( CRU % NdepF_ID , CRU % NdepV_ID , tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // NdepFILE ) DO k = 1 , CRU % mland CRU % NdepVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO END IF CALL1 = . FALSE . END IF IF ( TRIM ( CRU % Ndep ) . NE . \"static1860\" ) THEN ! read Ndep at current year (noting that file starts at 1850 and ends in 2015) CRU % Ndep_CTSTEP = MIN ( CRU % CYEAR , 2015 ) - 1850 + 1 t = CRU % Ndep_CTSTEP ErrStatus = NF90_GET_VAR ( CRU % NdepF_ID , CRU % NdepV_ID , tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // NdepFILE ) DO k = 1 , CRU % mland CRU % NdepVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO END IF END SUBROUTINE GET_CRU_Ndep !************************************************************************************************** SUBROUTINE OPEN_CRU_MET ( CRU ) ! Opens each of the met files required for one year. This is where the distinction is made between ! the nominal run year (CYEAR) and the year of met required (MetYear), which is different for ! S0_TRENDY and S1_TRENDY than for a standard run (S2_TRENDY). USE cable_IO_vars_module , ONLY : timeunits ! (Char33) Name of time units read from nc file IMPLICIT NONE TYPE ( CRU_TYPE ), INTENT ( INOUT ) :: CRU ! All CRU-NCEP related quantities and flags INTEGER :: iVar ! Loop counter through met variables INTEGER :: tID ! Numerical variable identifier returned by NetCDF routines, ! in this case for time. Needed to retrieve the time units. INTEGER :: MetYear ! Year of met to access. Equals CYEAR for normal runs, but ! must be calculated for S0_TRENDY and initialisation runs. INTEGER , SAVE :: RunStartYear ! The value of CRU%CYEAR on the first call, also equals syear. ! Allows the calculation of MetYear during S0_TRENDY and init runs. LOGICAL , SAVE :: CALL1 = . TRUE . ! A *local* variable recording the first call of this routine ! Keep the initial value of CYEAR for calculation of different MetYear if required. !IF (CALL1) RunStartYear = 1710 ! edit vh ! IF ( CALL1 ) RunStartYear = 1691 ! edit vh ! DO iVar = 1 , CRU % NMET ! For each met variable ! For S0_TRENDY and initialisation, calculate the required met year for repeatedly cycling through the ! 30 years of 1901-1930 spinup meteorology. For normal runs 1901-2015, MetYear = CYEAR. !!$    IF ( TRIM(CRU%Run) .EQ. 'S0_TRENDY' .OR.  ( TRIM(CRU%Run) .EQ. 'S1_TRENDY' )) THEN !!$      MetYear = 1901 + MOD(CRU%CYEAR-RunStartYear,30) !!$    ELSE IF ( TRIM(CRU%Run) .EQ. 'S2_TRENDY' ) THEN !!$      MetYear = CRU%CYEAR !!$    ENDIF IF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY' . OR . ( TRIM ( CRU % Run ) . EQ . 'S1_TRENDY' ) & . OR . ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2' ) & . OR . ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Ndep' )) THEN MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSEIF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp_Precip' ) THEN IF ( iVar . EQ . 1 ) THEN MetYear = CRU % CYEAR ELSE MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF IF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp_Precip' ) THEN IF ( iVar . EQ . 6 . OR . iVar . EQ . 7 ) THEN MetYear = CRU % CYEAR ELSE MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF ENDIF ELSEIF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp' ) THEN IF ( iVar . EQ . 6 . OR . iVar . EQ . 7 ) THEN MetYear = CRU % CYEAR ELSE MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY' ) THEN MetYear = CRU % CYEAR ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY_precip0' ) THEN IF ( iVar . EQ . 1 ) THEN ! special for baseline precip MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSE MetYear = CRU % CYEAR ENDIF ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY_precip' ) THEN IF ( iVar . NE . 1 ) THEN ! special for baseline non-precip MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSE MetYear = CRU % CYEAR ENDIF ENDIF CALL CRU_GET_FILENAME ( CRU , MetYear , iVar , CRU % MetFile ( iVar ) ) ! Call routine to build the filenames. ! Open the new met files and access the variables by their name and variable id. WRITE ( * , * ) 'Opening met data file: ' , CRU % MetFile ( iVar ) WRITE ( logn , * ) 'Opening met data file: ' , CRU % MetFile ( iVar ) ErrStatus = NF90_OPEN ( TRIM ( CRU % MetFile ( iVar )), NF90_NOWRITE , CRU % F_ID ( iVar )) CALL HANDLE_ERR ( ErrStatus , \"Opening CRU file \" // CRU % MetFile ( iVar ) ) ErrStatus = NF90_INQ_VARID ( CRU % F_ID ( iVar ), TRIM ( CRU % VAR_NAME ( iVar )), CRU % V_ID ( iVar )) CALL HANDLE_ERR ( ErrStatus , \"Inquiring CRU var \" // TRIM ( CRU % VAR_NAME ( iVar )) // & \" in \" // CRU % MetFile ( iVar ) ) END DO ! Set internal counter CRU % CTSTEP = 1 CALL1 = . FALSE . ! No longer the first call (saved). END SUBROUTINE OPEN_CRU_MET !************************************************************************************************** SUBROUTINE CRU_GET_DAILY_MET ( CRU , LastDayOfYear , LastYearOfMet ) IMPLICIT NONE TYPE ( CRU_TYPE ) :: CRU LOGICAL , INTENT ( IN ) :: LastDayOfYear , LastYearOfMet REAL :: tmparr ( 720 , 360 ) ! Temporary array for reading one day of met before ! packing into CRU%MET(iVar)%METVALS(k) REAL :: tmp , stmp ( 365 ) INTEGER :: iVar , ii , k , x , y , realk INTEGER :: t , tplus1 ! The current and next timestep INTEGER :: fid , vid , tid ! Netcdf id's for file, variable, and time INTEGER :: xds , yds , tds ! Metfile dimensions of long (x), lat (y), and time (t) INTEGER :: MetYear ! Year of meteorology currently in use INTEGER :: NextMetYear ! Next met year: Where to look for the nextTmin on Dec 31st CHARACTER ( LEN = 200 ) :: filename INTEGER , SAVE :: RunStartYear ! The value of CRU%CYEAR on the first call, also equals syear. ! Allows the calculation of MetYear during S0_TRENDY and init runs. LOGICAL , SAVE :: CALL1 = . TRUE . ! A *local* variable recording the first call of this routine ! If first call... ! Keep the initial value of CYEAR for calculation of different MetYear if required. IF ( CALL1 ) THEN !RunStartYear = CRU%CYEAR RunStartYear = 1691 ! If this is not the first call, capture the existing Tmax from the previous day as the ! 'previous Tmax' before reading another one. Move the existing next day's Tmin into the current ! Tmin before reading a new 'next Tmin'. These previous and next values are required for the ! Cesaraccio et al. algorithm used by the weather generator to interpolate daily into subdiurnal ! temperatures. ELSE CRU % MET ( prevTmax )% METVALS (:) = CRU % MET ( Tmax )% METVALS (:) CRU % MET ( Tmin )% METVALS (:) = CRU % MET ( NextTmin )% METVALS (:) ENDIF ! For S0_TRENDY and initialisation, calculate the year of meteorology as mod 50, so we repeatedly cycle ! through the 50 years of 1951-2000 spinup meteorology. For normal runs 1901-2015, MetYear = CYEAR. ! Stop with error for anything else. !!$  IF ( TRIM(CRU%Run) .EQ. 'S0_TRENDY' .OR.  ( TRIM(CRU%Run) .EQ. 'S1_TRENDY' )) THEN !!$    MetYear = 1901 + MOD(CRU%CYEAR-RunStartYear,30) !!$  ELSE IF ( TRIM(CRU%Run) .EQ. 'S2_TRENDY' ) THEN !!$    MetYear = CRU%CYEAR !!$  ELSE !!$    STOP 'Error in cable_cru.F90: CRU%Run not S0_TRENDY, S1_TRENDY, or 1901-2015' !!$  ENDIF !print *, \"runstartyear, metyear\", runstartyear, metyear ! Abbreviate dimensions for readability. xds = CRU % xdimsize yds = CRU % ydimsize ! Loop through all 9 met variables (not including prevTmax and nextTmin, which are addressed ! separately as special cases of Tmax and Tmin) !print *,  \"CRU%CTSTEP, LastDayOfYear, LastYearOfMet\", CRU%CTSTEP, LastDayOfYear, LastYearOfMet DO iVar = 1 , CRU % NMET IF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY' . OR . ( TRIM ( CRU % Run ) . EQ . 'S1_TRENDY' ) & . OR . ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2' ) & . OR . ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Ndep' )) THEN MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSEIF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Precip' & . OR . TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp_Precip' ) THEN IF ( iVar . EQ . 1 ) THEN MetYear = CRU % CYEAR ELSE MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF IF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp_Precip' ) THEN IF ( iVar . EQ . 6 . OR . iVar . EQ . 7 ) THEN MetYear = CRU % CYEAR ELSE MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF ENDIF ELSEIF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp' & . OR . TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp' ) THEN IF ( iVar . EQ . 6 . OR . iVar . EQ . 7 ) THEN MetYear = CRU % CYEAR ELSE MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY' ) THEN MetYear = CRU % CYEAR ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY_precip0' ) THEN IF ( iVar . EQ . 1 ) THEN ! special for baseline precip MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSE MetYear = CRU % CYEAR ENDIF ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY_precip' ) THEN IF ( iVar . NE . 1 ) THEN ! special for baseline non-precip MetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSE MetYear = CRU % CYEAR ENDIF ENDIF SELECT CASE ( iVar ) !-------------------------------------------------------------------------------------------------- CASE ( Tmin ) ! When Tmin comes up we will jump ahead to deal with nextTmin, since we ! are assigning Tmin from the previous value of nextTmin ! Bump the variable index ii to be the value for nextTmin and the time index ahead by 1 day. ii = nextTmin t = CRU % CTSTEP tplus1 = CRU % CTSTEP + 1 ! The first call exception for Tmin is to read both the first (t) and second (t+1) timesteps. ! The first goes into Tmin, the second into nextTmin. IF ( CALL1 ) THEN ! In the case of a small number of points, it is more efficient to pull the data for each land point ! directly from the file (DirectRead) rather than reading the whole array and extracting the land ! points from that. IF ( CRU % DirectRead ) THEN ! For each land cell, read the first day value of Tmin into tmp, and copy it to the METVALS vector. DO k = 1 , CRU % mland ! t (first value) into iVar (tmin) ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmp , & start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading direct from \" // CRU % MetFile ( iVar ) ) CRU % MET ( iVar )% METVALS ( k ) = tmp ! tplus1 (second value) into ii (nextTmin) ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmp , & start = ( / land_x ( k ), land_y ( k ), tplus1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading direct from \" // CRU % MetFile ( iVar ) ) CRU % MET ( ii )% METVALS ( k ) = tmp END DO ! Not DirectRead: Read the whole spatial grid of first day Tmin into tmparr, and copy it to the ! METVALS vector. ELSE ! t (first value) into iVar (tmin) ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // CRU % MetFile ( iVar ) ) DO k = 1 , CRU % mland CRU % MET ( iVar )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ! tplus1 (second value) into ii (nextTmin) ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmparr , & start = ( / 1 , 1 , tplus1 / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // CRU % MetFile ( iVar ) ) DO k = 1 , CRU % mland CRU % MET ( ii )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF ! End of if DirectRead END IF ! End of if CALL1 ! If this is the last day of the year we will need to get the nextTmin ! value from the next year's met file. IF ( LastDayOfYear ) THEN IF ( LastYearOfMet ) THEN ! If there is no more met to open... CONTINUE ! Do nothing. The current value of nextTmin will just be reused. ELSE ! There is another year of Tmin data available t = 1 ! Time index is set to the first day of the next year ! Add one to the calculation of MetYear !!$          IF ( TRIM(CRU%Run) .EQ. 'S0_TRENDY' .OR.  ( TRIM(CRU%Run) .EQ. 'S1_TRENDY' )) THEN !!$            NextMetYear = 1901 + MOD(CRU%CYEAR + 1 - RunStartYear,30) !!$          ELSE IF ( TRIM(CRU%Run) .EQ. 'S2_TRENDY' ) THEN !!$            NextMetYear = CRU%CYEAR + 1 !!$          ENDIF IF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY' . OR . ( TRIM ( CRU % Run ) . EQ . 'S1_TRENDY' ) & . OR . ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2' ) & . OR . ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Ndep' )) THEN NextMetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSEIF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Precip' & . OR . TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp_Precip' ) THEN IF ( iVar . EQ . 1 ) THEN NextMetYear = CRU % CYEAR ELSE NextMetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF IF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp_Precip' . OR . & TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp_Precip' ) THEN IF ( iVar . EQ . 6 . OR . iVar . EQ . 7 ) THEN NextMetYear = CRU % CYEAR ELSE NextMetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF ENDIF ELSEIF ( TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_Temp' & . OR . TRIM ( CRU % Run ) . EQ . 'S0_TRENDY_CO2_Temp' ) THEN IF ( iVar . EQ . 6 . OR . iVar . EQ . 7 ) THEN NextMetYear = CRU % CYEAR ELSE NextMetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ENDIF ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY' ) THEN NextMetYear = CRU % CYEAR ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY_precip0' ) THEN IF ( iVar . EQ . 1 ) THEN ! special for baseline precip NextMetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSE NextMetYear = CRU % CYEAR ENDIF ELSE IF ( TRIM ( CRU % Run ) . EQ . 'S2_TRENDY_precip' ) THEN IF ( iVar . NE . 1 ) THEN ! special for baseline non-precip NextMetYear = 1901 + MOD ( CRU % CYEAR - RunStartYear , 30 ) ELSE NextMetYear = CRU % CYEAR ENDIF ENDIF ! Open the Tmin file for next year in preparation for reading Jan 1st... CALL CRU_GET_FILENAME ( CRU , NextMetYear , Tmin , filename ) ErrStatus = NF90_OPEN ( TRIM ( filename ), NF90_NOWRITE , fid ) CALL HANDLE_ERR ( ErrStatus , \"Opening CRU file \" // filename ) ErrStatus = NF90_INQ_VARID ( fid , TRIM ( CRU % VAR_NAME ( iVar )), vid ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring CRU var \" // filename ) ! If DirectRead is specified (small domain) pull the points directly from the file. IF ( CRU % DirectRead ) THEN DO k = 1 , CRU % mland ErrStatus = NF90_GET_VAR ( fid , vid , CRU % MET ( ii )% METVALS ( k ), & ! Values to ii (nextTmin) start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading directly from \" // filename ) END DO ! Else not DirectRead: Read full grid into temp array and extract domain from that. ELSE ErrStatus = NF90_GET_VAR ( fid , vid , tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // filename ) DO k = 1 , CRU % mland CRU % MET ( ii )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) ! Values to ii (nextTmin) END DO ENDIF ! End of If DirectRead ! Close the next year's Tmin met file ErrStatus = NF90_CLOSE ( fid ) CALL HANDLE_ERR ( ErrStatus , \"Closing CRU file \" // filename ) ENDIF ! End of If LastYearOfMet END IF ! End of If LastDayOfYear ! If this is not the first call or last day of the year (i.e. somewhere in the middle) ! Just read the next timestep (tplus1) of Tmin data (iVar) into the nextTmin (ii) variable. IF ((. NOT . CALL1 ) . AND . (. NOT . LastDayOfYear )) THEN IF ( CRU % DirectRead ) THEN DO k = 1 , CRU % mland ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), CRU % MET ( ii )% METVALS ( k ), & start = ( / land_x ( k ), land_y ( k ), tplus1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading directly from \" // CRU % MetFile ( iVar ) ) END DO ELSE ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmparr , & start = ( / 1 , 1 , tplus1 / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // CRU % MetFile ( iVar ) ) DO k = 1 , CRU % mland CRU % MET ( ii )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF END IF !-------------------------------------------------------------------------------------------------- CASE ( TMax ) ! For Tmax, we need the previous day's Tmax for the Cesaraccio et al subdiurnal ! temperature interpolation algorithm. IF ( CALL1 ) THEN ! On the first day of the run... ! Assign the met variable index to be prevTmax. iVar will still refer to Tmax. ii = prevTmax ! If the very first MetYear is more than 1901, there is a previous year of Tmax data available. ! such as during spinups, when the starting year is 1951. IF ( MetYear . GT . 1901 ) THEN ! Open the previous year's Tmax file (MetYear-1) CALL CRU_GET_FILENAME ( CRU , MetYear - 1 , iVar , filename ) ErrStatus = NF90_OPEN ( TRIM ( filename ), NF90_NOWRITE , fid ) CALL HANDLE_ERR ( ErrStatus , \"Opening CRU file \" // filename ) ! Obtain the size of the time dimension (tds), which locates the data for Dec 31st in the file. ErrStatus = NF90_INQ_DIMID ( fid , 'time' , tid ) ErrStatus = NF90_INQUIRE_DIMENSION ( fid , tid , len = tds ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring 'time'\" // TRIM ( filename )) ! Obtain the variable ID of the Tmax variable. ErrStatus = NF90_INQ_VARID ( fid , TRIM ( CRU % VAR_NAME ( iVar )), vid ) CALL HANDLE_ERR ( ErrStatus , \"Inquiring CRU var \" // filename ) ! If DirectRead is specified (small domain) pull the data for Dec 31st (tds) directly from the file. ! Otherwise, read the whole Dec 31st grid into tmparr and pack the land points from there. IF ( CRU % DirectRead ) THEN !print *,\"about to read last value of MetYear-1 \", MetYear - 1, trim(filename) DO k = 1 , CRU % mland ErrStatus = NF90_GET_VAR ( fid , vid , CRU % MET ( ii )% METVALS ( k ), & start = ( / land_x ( k ), land_y ( k ), tds / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // filename ) END DO ELSE ErrStatus = NF90_GET_VAR ( fid , vid , tmparr , & start = ( / 1 , 1 , tds / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // filename ) DO k = 1 , CRU % mland CRU % MET ( ii )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF ! End of If DirectRead ErrStatus = NF90_CLOSE ( fid ) CALL HANDLE_ERR ( ErrStatus , \"Closing CRU file \" // filename ) ! Having read the last day of the previous year's Tmax into prevTmax, and closed the file, ! now read the first day of Tmax from the current year's file (which is already open). t = CRU % CTSTEP ! CRU%CTSTEP here should be 1 (?) ! Read the current points directly into the vector for small domains, or read the whole grid into tmparr ! and extract them from there. Read the current timestep value into the iVar variable (Tmax). IF ( CRU % DirectRead ) THEN DO k = 1 , CRU % mland ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), CRU % MET ( iVar )% METVALS ( k ), & start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading directly from \" // CRU % MetFile ( iVar ) ) END DO ELSE ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // CRU % MetFile ( iVar ) ) DO k = 1 , CRU % mland CRU % MET ( iVar )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF ELSE ! MetYear = 1901 ! Where MetYear is 1901, there is no previous Tmax value available, so we read the ! Jan 1 value into Tmax, then assign it to prevTmax as well ! Open the 1901 Tmax file (MetYear) CALL CRU_GET_FILENAME ( CRU , 1901 , iVar , filename ) ErrStatus = NF90_OPEN ( TRIM ( filename ), NF90_NOWRITE , fid ) CALL HANDLE_ERR ( ErrStatus , \"Opening CRU file \" // filename ) t = CRU % CTSTEP ! CRU%CTSTEP here should be 1 (?) ! Read the current points directly into the vector for small domains, or read the whole grid into tmparr ! and extract them from there. Read the current timestep value into the iVar variable (Tmax). IF ( CRU % DirectRead ) THEN DO k = 1 , CRU % mland ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), CRU % MET ( iVar )% METVALS ( k ), & start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading directly from \" // CRU % MetFile ( iVar ) ) END DO ELSE ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // CRU % MetFile ( iVar ) ) DO k = 1 , CRU % mland CRU % MET ( iVar )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF ! Now set the value for prevTmax (ii) equal to the current value for Tmax. CRU % MET ( ii )% METVALS (:) = CRU % MET ( iVar )% METVALS (:) ENDIF ! End of If MetYear > 1901 ELSE ! Not CALL1 ! This is not the first call, so the only thing remaining to do for Tmax is read the new value. ! (Current Tmax was assigned to prevTmax at the top of the routine). ! Set the variable index to iVar (Tmax). The timestep is the current timestep. t = CRU % CTSTEP ! Read the current points directly into the vector for small domains, or read the whole grid into tmparr ! and extract them from there. IF ( CRU % DirectRead ) THEN DO k = 1 , CRU % mland ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), CRU % MET ( iVar )% METVALS ( k ), & start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading directly from \" // CRU % MetFile ( iVar ) ) END DO ELSE ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // CRU % MetFile ( iVar ) ) DO k = 1 , CRU % mland CRU % MET ( iVar )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF END IF ! End of If CALL1 !-------------------------------------------------------------------------------------------------- CASE DEFAULT ! All variables other than Tmin or Tmax... ! iVar is not Tmin or Tmax so the variable index and timestep index are unchanged. ii = iVar t = CRU % CTSTEP ! Standard read of the current variable, for the current timestep: ! Directly read the current points into the met vector (more efficient for small domains), ! or read the whole grid into tmparr and extract them from there. IF ( CRU % DirectRead ) THEN DO k = 1 , CRU % mland ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), CRU % MET ( ii )% METVALS ( k ), & start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading directly from \" // CRU % MetFile ( iVar ) ) END DO ELSE ErrStatus = NF90_GET_VAR ( CRU % F_ID ( iVar ), CRU % V_ID ( iVar ), tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( ErrStatus , \"Reading from \" // CRU % MetFile ( iVar ) ) DO k = 1 , CRU % mland CRU % MET ( ii )% METVALS ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF END SELECT END DO ! End of loop through all met variables ! Convert pressure Pa -> hPa CRU % MET ( pres )% METVALS (:) = CRU % MET ( pres )% METVALS (:) / 10 0. !print *, 'CRU%CTSTEP ', CRU%CTSTEP ! Increment the internal timestep counter CRU % CTSTEP = CRU % CTSTEP + 1 ! CALL1 can only happen once! IF ( CALL1 ) CALL1 = . FALSE . !  print *, 'CRU%MET(tmin)%METVALS(:)' !  print *, CRU%MET(tmin)%METVALS(:) !  print *, 'CRU%MET(nexttmin)%METVALS(:)' !  print *, CRU%MET(nexttmin)%METVALS(:) !  print *, 'CRU%MET(prevtmax)%METVALS(:)' !  print *, CRU%MET(prevtmax)%METVALS(:) !  print *, 'CRU%MET(tmax)%METVALS(:)' !  print *, CRU%MET(tmax)%METVALS(:) !  print *, 'CRU%MET(pres)%METVALS(:)' !  print *, CRU%MET(pres)%METVALS(:) !  print *, 'CRU%MET(rain)%METVALS(:)' !  print *, CRU%MET(rain)%METVALS(:) END SUBROUTINE CRU_GET_DAILY_MET !************************************************************************************************** SUBROUTINE CRU_GET_SUBDIURNAL_MET ( CRU , MET , CurYear , ktau , kend , LastYearOfMet ) ! Obtain one day of CRU-NCEP meteorology, subdiurnalise it using a weather ! and return the result to the CABLE driver. USE cable_def_types_mod , ONLY : MET_TYPE USE cable_IO_vars_module , ONLY : LANDPT , latitude USE casa_ncdf_module , ONLY : DOYSOD2YMDHMS USE cable_weathergenerator , ONLY : WEATHER_GENERATOR_TYPE , WGEN_INIT , & WGEN_DAILY_CONSTANTS , WGEN_SUBDIURNAL_MET USE cable_checks_module , ONLY : rh_sh IMPLICIT NONE INTEGER , INTENT ( IN ) :: CurYear , ktau , kend LOGICAL , INTENT ( IN ) :: LastYearOfMet TYPE ( CRU_TYPE ) :: CRU ! Define MET the CABLE version, different from the MET defined and used within the CRU variable. ! The structure of MET_TYPE is defined in cable_define_types.F90 TYPE ( MET_TYPE ) :: MET ! Local variables LOGICAL :: newday , LastDayOfYear ! Flags for occurence of a new day (0 hrs) and the last day of the year. INTEGER :: iland ! Loop counter through 'land' cells (cells in the spatial domain) INTEGER :: itimestep ! Loop counter through subdiurnal timesteps in a day INTEGER :: imetvar ! Loop counter through met variables INTEGER :: dM , dD ! Met date as year, month, and day returned from DOYSOD2YMDHMS INTEGER :: is , ie ! Starting and ending vegetation type per land cell REAL :: dt ! Timestep in seconds REAL :: CO2air ! CO2 concentration in ppm REAL :: etime CHARACTER :: LandMaskFile * 200 ! Name of the land mask file TYPE ( WEATHER_GENERATOR_TYPE ), SAVE :: WG LOGICAL , SAVE :: CALL1 = . TRUE . ! A *local* variable recording the first call of this routine ! Purely for readability... dt = CRU % DTsecs ! On first step read and check CRU settings and read land-mask IF ( CALL1 ) CALL WGEN_INIT ( WG , CRU % mland , latitude , dt ) ! Pass time-step information to CRU CRU % CYEAR = CurYear CRU % ktau = ktau ! ktau is the current timestep in the year. !!!!  this only works with CANBERRA cable_driver, as ktau    !!!! !!!!  restarts on Jan 1                                      !!!! ! Based on the ktau timestep, calculate date and time information (the same for the whole spatial dimension.) met % hod (:) = REAL ( MOD ( ( ktau - 1 ) * NINT ( dt ), INT ( SecDay )) ) / 360 0. ! Hour of the day met % doy (:) = INT ( REAL ( ktau - 1 ) * dt / SecDay ) + 1 ! Day of Year = days since 0 hr 1st Jan met % year (:) = CurYear ! Current year ! Using the day-of-year and seconds-of-day calculate the month and day-of-month, using the time information ! for the first land cell only (because they will be the same across the domain). !                            In      In         In        Out       Out       Optional Out ! SUBROUTINE DOYSOD2YMDHMS( Year, Yearday, SecondsOfDay, Month, DayOfMonth, [Hour, Min, Sec]) CALL DOYSOD2YMDHMS ( CurYear , INT ( met % doy ( 1 )), INT ( met % hod ( 1 )) * 3600 , dM , dD ) met % moy (:) = dM ! Record the month ! It's a new day if the hour of the day is zero. newday = ( met % hod ( landpt ( 1 )% cstart ). EQ . 0 ) ! Beginning-of-year accounting IF ( ktau . EQ . 1 ) THEN ! ktau is always reset to 1 at the start of the year. ! Read a new annual CO2 value and convert it from ppm to mol/mol CALL GET_CRU_CO2 ( CRU , CO2air ) met % ca (:) = CO2air / 1.e+6 ! CALL GET_CRU_Ndep ( CRU ) DO iland = 1 , CRU % mland met % Ndep ( landpt ( iland )% cstart : landpt ( iland )% cend ) = & CRU % NdepVALS ( iland ) * 8640000 0. ! kg/m2/s > g/m2/d (1000.*3600.*24.) END DO ! Open a new annual CRU-NCEP met file. CALL OPEN_CRU_MET ( CRU ) ENDIF ! %%%%%% PRB to add his own comments from here down for this routine. ! Now get the Met data for this day IF ( newday ) THEN !print *, CRU%CTSTEP, ktau, kend !   CALL CPU_TIME(etime) !   PRINT *, 'b4 daily ', etime, ' seconds needed ' LastDayOfYear = ( ktau . EQ . kend - (( SecDay / dt ) - 1 )) CALL CRU_GET_DAILY_MET ( CRU , LastDayOfYear , LastYearOfMet ) !   CALL CPU_TIME(etime) !   PRINT *, 'after daily ', etime, ' seconds needed ' !   STOP ! Air pressure assumed to be constant over day DO iland = 1 , CRU % mland met % pmb ( landpt ( iland )% cstart : landpt ( iland )% cend ) = CRU % MET ( pres )% METVALS ( iland ) !CLN interpolation?? END DO ! Convert wind from u and v components to wind speed by Pythagorean Theorem WG % WindDay = SQRT ( ( CRU % MET ( uwind )% METVALS * CRU % MET ( uwind )% METVALS ) + & ( CRU % MET ( vwind )% METVALS * CRU % MET ( vwind )% METVALS ) ) ! Convert all temperatures from K to C WG % TempMinDay = CRU % MET ( Tmin )% METVALS - 27 3.15 WG % TempMaxDay = CRU % MET ( Tmax )% METVALS - 27 3.15 WG % TempMinDayNext = CRU % MET ( NextTmin )% METVALS - 27 3.15 WG % TempMaxDayPrev = CRU % MET ( PrevTmax )% METVALS - 27 3.15 ! Convert solar radiation from J /m2/s to MJ/m2/d WG % SolarMJDay = CRU % MET ( swdn )% METVALS * 1.e-6 * SecDay ! ->[MJ/m2/d] ! Convert precip from mm to m/day WG % PrecipDay = CRU % MET ( rain )% METVALS / 100 0. ! ->[m/d] WG % SnowDay = 0.0 CALL WGEN_DAILY_CONSTANTS ( WG , CRU % mland , INT ( met % doy ( 1 )) + 1 ) ! To get the diurnal cycle for lwdn get whole day and scale with ! LWDN from file later CRU % AVG_LWDN (:) = 0. DO itimestep = 1 , NINT ( SecDay / dt ) CALL WGEN_SUBDIURNAL_MET ( WG , CRU % mland , itimestep - 1 ) CRU % AVG_LWDN = CRU % AVG_LWDN + WG % PhiLD END DO CRU % AVG_LWDN = CRU % AVG_LWDN / ( SecDay / dt ) END IF ! End of If newday ! Decision has been made, that first tstep of the day is at 0:01 am CALL WGEN_SUBDIURNAL_MET ( WG , CRU % mland , NINT ( met % hod ( 1 ) * 360 0. / dt ) ) ! assign to cable variables ! strangely, met% is not save over Wait all in MPI...! !  met%pmb = CRU%MET(pres)%METVALS !CLN interpolation?? ! Assign weather-generated data, or daily values, as required to CABLE variables. ! DO iland = 1 , CRU % mland is = landpt ( iland )% cstart ie = landpt ( iland )% cend met % precip ( is : ie ) = WG % Precip ( iland ) ! Cable's swdown is split into two components, visible and nir, which ! get half of the CRU-NCEP swdown each. met % fsd ( is : ie , 1 ) = WG % PhiSD ( iland ) * 0.5 ! Visible met % fsd ( is : ie , 2 ) = WG % PhiSD ( iland ) * 0.5 ! NIR ! Convert C to K for cable's tk met % tk ( is : ie ) = WG % Temp ( iland ) + 27 3.15 met % ua ( is : ie ) = WG % Wind ( iland ) met % coszen ( is : ie ) = WG % coszen ( iland ) ! For longwave down, scale the diurnal series returned by the weather generator (WG%PhiLD(iland)) ! to the daily value from CRU-NCEP. met % fld ( is : ie ) = CRU % MET ( lwdn )% METVALS ( iland ) * WG % PhiLD ( iland ) / CRU % AVG_LWDN ( iland ) ! Specific humidity (qair g/g) was not sent to the weather generator. Here we assign the ! daily value to the whole diurnal cycle met % qv ( is : ie ) = CRU % MET ( qair )% METVALS ( iland ) ! calculate snowfall based on total precip and air T !(ref Jin et al. Table II, Hyd Proc, 1999) !!$    if (WG%Temp(iland) > 2.5) then !!$       met%precip_sn(is:ie) = 0.0 !!$    elseif ((WG%Temp(iland) <= 2.5) .and. (WG%Temp(iland) > 2.0)) then !!$       met%precip_sn(is:ie) = 0.6* met%precip(is:ie) !!$    elseif ((WG%Temp(iland) <= 2.0) .and. (WG%Temp(iland) > 0.0)) then !!$       met%precip_sn(is:ie) = (1.0 - (54.62 - 0.2 *(WG%Temp(iland) + 273.15)))* met%precip(is:ie) ! this facr can be > 1 !!! !!$    elseif (WG%Temp(iland) <= 0.0) then !!$       met%precip_sn(is:ie) = met%precip(is:ie) !!$    endif IF ( WG % Temp ( iland ) <= 0.0 ) THEN met % precip_sn ( is : ie ) = met % precip ( is : ie ) ELSE met % precip_sn ( is : ie ) = 0.0 ENDIF !met%precip(is:ie) = met%precip(is:ie) -  met%precip_sn(is:ie) END DO ! initialise within canopy air temp met % tvair = met % tk met % tvrad = met % tk ! If this is the end of the year or the end of the met, close the current met files. !print *, \"ktau, kend, LastYearOfMet as close test:\", ktau, kend IF ( ktau . EQ . kend ) THEN DO imetvar = 1 , CRU % NMET !print *, 'Close CRU%MetFile(imetvar)', CRU%MetFile(imetvar) ErrStatus = NF90_CLOSE ( CRU % F_ID ( imetvar )) CALL HANDLE_ERR ( ErrStatus , \"Closing CRU file\" // CRU % MetFile ( imetvar )) END DO END IF ! CALL1 is over... CALL1 = . FALSE . END SUBROUTINE CRU_GET_SUBDIURNAL_MET END MODULE CABLE_CRU","tags":"","loc":"sourcefile/cable_cru_trendy.f90.html"},{"title":"cable_read.F90 – CABLE","text":"Contents Modules cable_read_module Source Code cable_read.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Read routines for CABLE offline ! ! Contact: Bernard.Pak@csiro.au ! ! History: New routines (redistr*) to do land use change ! ! ! ============================================================================== ! CALLed from:    cable_driver.f90 ! MODULEs used:   cable_abort_module !                 cable_IO_vars_module !                 netcdf ! ! CALLs:          readpar_i !                 readpar_r !                 readpar_rd !                 readpar_r2 !                 readpar_r2d !                 nc_abort !                 redistr* ! MODULE cable_read_module USE cable_abort_module USE cable_def_types_mod , ONLY : ms , ncp , r_2 , mland , mp , ncs , nrb , msn USE cable_IO_vars_module , ONLY : landpt , exists , land_x , land_y , metGrid USE netcdf IMPLICIT NONE PRIVATE PUBLIC readpar , redistr_i , redistr_r , redistr_rd , redistr_r2 , redistr_r2d INTEGER :: ok ! netcdf error status INTERFACE readpar ! Loads a parameter from the met file - chooses subroutine ! below depending on number/type/dimension of arguments MODULE PROCEDURE readpar_i ! for integer parameter read MODULE PROCEDURE readpar_r ! for real parameter read MODULE PROCEDURE readpar_rd ! for double precision real parameter read MODULE PROCEDURE readpar_r2 ! for 2d real parameter read MODULE PROCEDURE readpar_r2d ! for double precision 2d real parameter read END INTERFACE ! INTERFACE redistr !   MODULE PROCEDURE redistr_i !   MODULE PROCEDURE redistr_r !   MODULE PROCEDURE redistr_rd !   MODULE PROCEDURE redistr_r2 !   MODULE PROCEDURE redistr_r2d ! END INTERFACE CONTAINS SUBROUTINE readpar_i ( ncid , parname , completeSet , var_i , filename , & npatch , dimswitch , from_restart , INpatch ) ! Subroutine for loading an integer-valued parameter INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: npatch ! # of veg patches in parameter's file INTEGER , INTENT ( IN ), OPTIONAL :: INpatch INTEGER , DIMENSION (:), INTENT ( INOUT ) :: var_i ! returned parameter ! values LOGICAL , INTENT ( IN ), OPTIONAL :: from_restart ! reading from restart file? LOGICAL , INTENT ( INOUT ) :: completeSet ! has every parameter been loaded? CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter CHARACTER ( LEN =* ), INTENT ( IN ) :: filename ! file containing parameter values CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimension of ! parameter INTEGER :: parID ! parameter's netcdf ID INTEGER :: pardims ! # dimensions of parameter INTEGER :: i ! do loop counter INTEGER , DIMENSION ( 1 ) :: data1i ! temporary for ncdf read in INTEGER , DIMENSION ( 1 , 1 ) :: data2i ! temporary for ncdf read in INTEGER , DIMENSION (:, :), POINTER :: tmp2i ! temporary for ncdf read in INTEGER , DIMENSION (:, :, :), POINTER :: tmp3i ! temporary for ncdf read ! in ! Check if parameter exists: ok = NF90_INQ_VARID ( ncid , parname , parID ) IF ( ok /= NF90_NOERR ) THEN ! if it doesn't exist completeSet = . FALSE . ! If this routine is reading from the restart, abort IF ( PRESENT ( from_restart )) WRITE ( * , * ) ' Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_i)' ELSE exists % parameters = . TRUE . ! Note that pars were found in file ! Check for grid type - restart file uses land type grid IF ( metGrid == 'land' . OR . PRESENT ( from_restart )) THEN ! Collect data from land only grid in netcdf file. ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 1 ) THEN ! no patch dimension, just a single land ! dimension IF ( PRESENT ( from_restart )) THEN ok = NF90_GET_VAR ( ncid , parID , var_i , start = ( / 1 / ), & count = ( / INpatch / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_i)' ) ELSE DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , data1i , start = ( / i / ), & count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_i)' ) ! Write non-patch-specific value to all patches: var_i ( landpt ( i )% cstart : landpt ( i )% cend ) = data1i ( 1 ) END DO END IF ELSE IF ( pardims == 2 ) THEN ! i.e. parameter has a patch dimension ALLOCATE ( tmp2i ( 1 , npatch )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp2i , & start = ( / i , 1 / ), count = ( / 1 , npatch / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in met data file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_i)' ) ! Set values for this par for the # patches that exist var_i ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch - 1 )) = & tmp2i ( 1 , :) END DO DEALLOCATE ( tmp2i ) ELSE CALL abort ( 'Dimension of ' // parname // ' parameter in ' // & TRIM ( filename ) // ' unknown.' ) END IF ELSE IF ( metGrid == 'mask' ) THEN ! Get data from land/sea mask type grid: ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 2 ) THEN ! i.e. no patch dimension, just x-y grid ! dimensions DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , data2i , & start = ( / land_x ( i ), land_y ( i ) / ), count = ( / 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_i)' ) ! Set all patches to have the same value for this par: var_i ( landpt ( i )% cstart : landpt ( i )% cend ) = data2i ( 1 , 1 ) END DO ELSE IF ( pardims == 3 ) THEN ! i.e. parameter has a patch dimension ALLOCATE ( tmp3i ( 1 , 1 , npatch )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp3i , & start = ( / land_x ( i ), land_y ( i ), 1 / ), & count = ( / 1 , 1 , npatch / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_i)' ) ! Set values for this par for the # patches that exist var_i ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch - 1 )) = & tmp3i ( 1 , 1 , :) END DO DEALLOCATE ( tmp3i ) ELSE CALL abort ( 'Dimension of ' // parname // ' parameter in met file ' // & 'unknown.' ) END IF END IF ! gridtype land or mask END IF ! parameter's existence END SUBROUTINE readpar_i !============================================================================= SUBROUTINE readpar_r ( ncid , parname , completeSet , var_r , filename , & npatch , dimswitch , from_restart , INpatch ) ! Subroutine for loading a real-valued parameter INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: npatch ! # of veg patches in parameter's file INTEGER , INTENT ( IN ), OPTIONAL :: INpatch REAL ( KIND = 4 ), DIMENSION (:), INTENT ( INOUT ) :: var_r ! returned parameter ! values LOGICAL , INTENT ( IN ), OPTIONAL :: from_restart ! reading from restart file? LOGICAL , INTENT ( INOUT ) :: completeSet ! has every parameter been loaded? CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter CHARACTER ( LEN =* ), INTENT ( IN ) :: filename ! file containing parameter values CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter INTEGER :: parID ! parameter's netcdf ID INTEGER :: pardims ! # dimensions of parameter INTEGER :: i ! do loop counter REAL ( KIND = 4 ), DIMENSION ( 1 ) :: data1r ! temporary for ncdf read in REAL ( KIND = 4 ), DIMENSION ( 1 , 1 ) :: data2r ! temporary for ncdf read in REAL ( KIND = 4 ), DIMENSION (:, :), POINTER :: tmp2r ! temporary for ncdf read in REAL ( KIND = 4 ), DIMENSION (:, :, :), POINTER :: tmp3r ! temporary for ncdf read ! in ! Check if parameter exists: ok = NF90_INQ_VARID ( ncid , parname , parID ) IF ( ok /= NF90_NOERR ) THEN ! if it doesn't exist completeSet = . FALSE . ! If this routine is reading from the restart, abort IF ( PRESENT ( from_restart )) CALL nc_abort ( ok , 'Error reading ' // parname // & ' in file ' // TRIM ( filename ) // '(SUBROUTINE readpar_r)' ) ELSE exists % parameters = . TRUE . ! Note that pars were found in file ! If block to distinguish params with non-spatial dimensions: IF ( dimswitch == 'def' ) THEN ! i.e. parameters with one spatial dim ! of length mland*maxpatches ! Check for grid type - restart file uses land type grid IF ( metGrid == 'land' . OR . PRESENT ( from_restart )) THEN ! Collect data from land only grid in netcdf file. ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 1 ) THEN ! no patch dimension, just a single land ! dimension IF ( PRESENT ( from_restart )) THEN ok = NF90_GET_VAR ( ncid , parID , var_r , start = ( / 1 / ), & count = ( / INpatch / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r)' ) ELSE DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , data1r , start = ( / i / ), & count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r)' ) ! All patches set to the same value if no patch info: var_r ( landpt ( i )% cstart : landpt ( i )% cend ) = data1r ( 1 ) END DO END IF ELSE IF ( pardims == 2 ) THEN ! i.e. parameter has a patch dimension ALLOCATE ( tmp2r ( 1 , npatch )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp2r , & start = ( / i , 1 / ), count = ( / 1 , npatch / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r)' ) ! Set values for this par for the # patches that exist var_r ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch - 1 )) = & tmp2r ( 1 , :) END DO DEALLOCATE ( tmp2r ) ELSE CALL abort ( 'Dimension of ' // parname // & ' parameter in met file unknown.' ) END IF ELSE IF ( metGrid == 'mask' ) THEN ! Get data from land/sea mask type ! grid: ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 2 ) THEN ! no patch dimension, just x-y grid ! dimensions DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , data2r , & start = ( / land_x ( i ), land_y ( i ) / ), count = ( / 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r)' ) ! Set all patches to have the same value for this par: var_r ( landpt ( i )% cstart : landpt ( i )% cend ) = data2r ( 1 , 1 ) END DO ELSE IF ( pardims == 3 ) THEN ! i.e. parameter has a patch dimension ALLOCATE ( tmp3r ( 1 , 1 , npatch )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp3r , & start = ( / land_x ( i ), land_y ( i ), 1 / ), & count = ( / 1 , 1 , npatch / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r)' ) ! Set values for this par for the # patches that exist var_r ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch - 1 )) = & tmp3r ( 1 , 1 , :) END DO DEALLOCATE ( tmp3r ) ELSE CALL abort ( 'Dimension of ' // parname // & ' parameter in met file unknown.' ) END IF END IF ! gridtype land or mask ELSE IF ( dimswitch == 'ms' ) THEN ! ie par has only soil dimension, no ! spatial ! Load parameter values (e.g. zse): ok = NF90_GET_VAR ( ncid , parID , var_r , start = ( / 1 / ), count = ( / ms / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r)' ) ELSE IF ( dimswitch == 'ncp' ) THEN ! ie par has only ncp dimension e.g. ! ratecp ! Load ratecp parameter values: ok = NF90_GET_VAR ( ncid , parID , var_r , start = ( / 1 / ), count = ( / ncp / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r)' ) ELSE IF ( dimswitch == 'ncs' ) THEN ! ie par has only ncs dimension e.g. ! ratecs ! Load parameter values: ok = NF90_GET_VAR ( ncid , parID , var_r , start = ( / 1 / ), count = ( / ncs / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r)' ) ELSE CALL abort ( 'Parameter or initial state ' // parname // & ' called with unknown dimension switch - ' // dimswitch // & ' - in INTERFACE readpar' ) END IF ! dimension of parameter i.e. is this zse or ratecp or ratecs END IF ! parameter's existence END SUBROUTINE readpar_r !============================================================================= SUBROUTINE readpar_rd ( ncid , parname , completeSet , var_rd , filename , & npatch , dimswitch , from_restart , INpatch ) ! Subroutine for loading a double precision real-valued parameter INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: npatch ! # of veg patches in parameter's file REAL ( r_2 ), DIMENSION (:), INTENT ( INOUT ) :: var_rd ! returned parameter ! values LOGICAL , INTENT ( IN ), OPTIONAL :: from_restart ! reading from restart file? LOGICAL , INTENT ( INOUT ) :: completeSet ! has every parameter been loaded? CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter CHARACTER ( LEN =* ), INTENT ( IN ) :: filename ! file containing parameter values CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of ! parameter INTEGER , INTENT ( IN ), OPTIONAL :: INpatch INTEGER :: parID ! parameter's netcdf ID INTEGER :: pardims ! # dimensions of parameter INTEGER :: i ! do loop counter REAL ( 4 ), DIMENSION ( 1 ) :: data1r ! temporary for ncdf read in REAL ( 4 ), DIMENSION ( 1 , 1 ) :: data2r ! temporary for ncdf read in REAL ( 4 ), DIMENSION (:), POINTER :: tmp1r ! temporary for ncdf read in REAL ( 4 ), DIMENSION (:, :), POINTER :: tmp2r ! temporary for ncdf read in REAL ( 4 ), DIMENSION (:, :, :), POINTER :: tmp3r ! temporary for ncdf read in ! Check if parameter exists: ok = NF90_INQ_VARID ( ncid , parname , parID ) IF ( ok /= NF90_NOERR ) THEN ! if it doesn't exist completeSet = . FALSE . ! If this routine is reading from the restart, abort IF ( PRESENT ( from_restart )) CALL nc_abort ( ok , 'Error reading ' // parname // & ' in file ' // TRIM ( filename ) // '(SUBROUTINE readpar_rd)' ) ELSE exists % parameters = . TRUE . ! Note that pars were found in file ! If block to distinguish params with non-spatial dimensions: IF ( dimswitch ( 1 : 3 ) == 'def' ) THEN ! i.e. parameters with one spatial dim ! of length mland*maxpatches ! Check for grid type - restart file uses land type grid IF ( metGrid == 'land' . OR . PRESENT ( from_restart )) THEN ! Collect data from land only grid in netcdf file. ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 1 ) THEN ! no patch dimension, just a single land ! dimension IF ( PRESENT ( from_restart )) THEN !                   IF(dimswitch(1:4) == 'defd') THEN ! ie we're expecting to ! read double prec. !                      ! Read double precision data: !                      ok = NF90_GET_VAR(ncid,parID,var_rd,start=(/1/),        & !                                        count=(/INpatch/)) !                   ELSE ! ie we're reading single prec. var in netdf file ! Read single precision data: ALLOCATE ( tmp1r ( INpatch )) ok = NF90_GET_VAR ( ncid , parID , tmp1r , start = ( / 1 / ), & count = ( / INpatch / )) var_rd = REAL ( tmp1r , r_2 ) DEALLOCATE ( tmp1r ) !                   END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) ELSE ! reading from met file DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , data1r , start = ( / i / ), & count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) ! Give single value to all patches if no patch specific ! info: var_rd ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( data1r ( 1 )) END DO END IF ELSE IF ( pardims == 2 ) THEN ! i.e. parameter has a patch dimension ! NB restart file will not have a patch dimension, therefore ! all reads here are of single precision variables. ALLOCATE ( tmp2r ( 1 , npatch )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp2r , & start = ( / i , 1 / ), count = ( / 1 , npatch / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) ! Set values for this par for the # patches that exist var_rd ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch - 1 )) = & REAL ( tmp2r ( 1 , :), r_2 ) END DO DEALLOCATE ( tmp2r ) ELSE CALL abort ( 'Dimension of ' // parname // & ' parameter in met file unknown.' ) END IF ELSE IF ( metGrid == 'mask' ) THEN ! Get data from land/sea mask type ! grid: ! NB restart file will not have mask grid, therefore all reads ! here are of single precision variables in the netcdf met file ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 2 ) THEN ! no patch dimension, just x-y grid ! dimensions DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , data2r , & start = ( / land_x ( i ), land_y ( i ) / ), & count = ( / 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) ! Set all patches to have the same value for this par: var_rd ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( data2r ( 1 , 1 ), r_2 ) END DO ELSE IF ( pardims == 3 ) THEN ! i.e. parameter has a patch dimension ALLOCATE ( tmp3r ( 1 , 1 , npatch )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp3r , & start = ( / land_x ( i ), land_y ( i ), 1 / ), & count = ( / 1 , 1 , npatch / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) ! Set values for this par for the # patches that exist var_rd ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch - 1 )) & = REAL ( tmp3r ( 1 , 1 , :), r_2 ) END DO DEALLOCATE ( tmp3r ) ELSE CALL abort ( 'Dimension of ' // parname // & ' parameter in met file unknown.' ) END IF ELSE CALL abort ( 'Prescribed input grid ' // metGrid // ' unknown.' ) END IF ! gridtype land or mask ELSE IF ( dimswitch ( 1 : 2 ) == 'ms' ) THEN ! ie par has only soil dimension, ! no spatial ! Load parameter values (e.g. zse): DO i = 1 , ms ok = NF90_GET_VAR ( ncid , parID , data1r , start = ( / i / ), count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) var_rd ( i ) = REAL ( data1r ( 1 ), r_2 ) END DO ELSE IF ( dimswitch ( 1 : 3 ) == 'ncp' ) THEN ! ie par has only ncp dimension ! e.g. ratecp ! Load ratecp parameter values: DO i = 1 , ncp ok = NF90_GET_VAR ( ncid , parID , data1r , start = ( / i / ), count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) var_rd ( i ) = REAL ( data1r ( 1 ), r_2 ) END DO ELSE IF ( dimswitch ( 1 : 3 ) == 'ncs' ) THEN ! ie par has only ncs dimension ! e.g. ratecs ! Load parameter values: DO i = 1 , ncs ok = NF90_GET_VAR ( ncid , parID , data1r , start = ( / i / ), count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) var_rd ( i ) = REAL ( data1r ( 1 ), r_2 ) END DO ELSE CALL abort ( 'Parameter or initial state ' // parname // & ' called with unknown dimension switch - ' // dimswitch // & ' - in INTERFACE readpar' ) END IF ! dimension of parameter i.e. is this zse or ratecp or ratecs END IF ! parameter's existence END SUBROUTINE readpar_rd !============================================================================= SUBROUTINE readpar_r2 ( ncid , parname , completeSet , var_r2 , filename , & npatch , dimswitch , from_restart , INpatch ) ! Subroutine for loading a two dimensional real-valued parameter INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: npatch ! number of veg patches in file INTEGER , INTENT ( IN ), OPTIONAL :: INpatch REAL ( KIND = 4 ), DIMENSION (:,:), INTENT ( INOUT ) :: var_r2 ! returned parameter ! values LOGICAL , INTENT ( IN ), OPTIONAL :: from_restart ! reading from restart file? LOGICAL , INTENT ( INOUT ) :: completeSet ! has every parameter been loaded? CHARACTER ( LEN =* ), INTENT ( IN ) :: filename ! file containing parameter values CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of ! parameter CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter INTEGER :: parID ! parameter's netcdf ID INTEGER :: pardims ! # dimensions of parameter INTEGER :: dimctr ! size of non-spatial (2nd) dimension of parameter INTEGER :: i , j ! do loop counter REAL ( KIND = 4 ), DIMENSION (:, :), POINTER :: tmp2r ! temporary for ncdf ! read in REAL ( KIND = 4 ), DIMENSION (:, :, :), POINTER :: tmp3r ! temporary for ncdf ! read in REAL ( KIND = 4 ), DIMENSION (:, :, :, :), POINTER :: tmp4r ! temporary for ncdf ! read in REAL :: tmpjh ! Check if parameter exists: ok = NF90_INQ_VARID ( ncid , parname , parID ) IF ( ok /= NF90_NOERR ) THEN ! if it doesn't exist completeSet = . FALSE . ! If this routine is reading from the restart, abort IF ( PRESENT ( from_restart )) CALL nc_abort ( ok , 'Error reading ' // parname & // ' in file ' // TRIM ( filename ) // '(SUBROUTINE readpar_r2)' ) ELSE exists % parameters = . TRUE . ! Note that pars were found in file ! Decide which 2nd dimension of parameter/init state we're loading: IF ( dimswitch == 'ms' ) THEN dimctr = ms ! i.e. horizontal spatial and soil ELSE IF ( dimswitch == 'snow' ) THEN dimctr = msn ! i.e. horizontal spatial and snow ELSE IF ( dimswitch == 'nrb' ) THEN dimctr = nrb ! i.e. horizontal spatial and radiation bands ELSE IF ( dimswitch == 'ncp' ) THEN dimctr = ncp ! i.e. horizontal spatial and plant carbon pools ELSE IF ( dimswitch == 'ncs' ) THEN dimctr = ncs ! i.e. horizontal spatial and soil carbon pools ELSE CALL abort ( 'Parameter or initial state ' // parname // & ' called with unknown dimension switch - ' // dimswitch // & ' - in INTERFACE readpar SUBROUTINE readpar_r2' ) END IF ! Check for grid type - restart file uses land type grid IF ( metGrid == 'land' . OR . PRESENT ( from_restart )) THEN ! Collect data from land only grid in netcdf file. ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 2 ) THEN ! no patch dimension, just a land + other ! dimension IF ( PRESENT ( from_restart )) THEN ok = NF90_GET_VAR ( ncid , parID , var_r2 , start = ( / 1 , 1 / ), & count = ( / INpatch , dimctr / )) !    WRITE(45,*) 'Is tgg read here?' IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) ELSE ALLOCATE ( tmp2r ( 1 , dimctr )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp2r , & start = ( / i , 1 / ), count = ( / 1 , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2)' ) DO j = 1 , dimctr ! Set all patches to have the same value: var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) = tmp2r ( 1 , j ) END DO END DO DEALLOCATE ( tmp2r ) END IF ELSE IF ( pardims == 3 ) THEN ! i.e. parameter has a patch dimension ALLOCATE ( tmp3r ( 1 , npatch , dimctr )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp3r , & start = ( / i , 1 , 1 / ), count = ( / 1 , npatch , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2)' ) DO j = 1 , dimctr ! Set values for this par for the # patches that exist var_r2 ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch & - 1 ), j ) = tmp3r ( 1 ,:, j ) END DO END DO DEALLOCATE ( tmp3r ) ELSE CALL abort ( 'Dimension of ' // parname // ' parameter in met file ' // & 'unknown.' ) END IF ELSEIF ( metGrid == 'mask' ) THEN ! Get data from land/sea mask type grid: ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 3 ) THEN ! no patch dimension, just x-y + soil grid ! dimension ALLOCATE ( tmp3r ( 1 , 1 , ms )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp3r , & start = ( / land_x ( i ), land_y ( i ), 1 / ), & count = ( / 1 , 1 , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2)' ) ! Set all patches to have the same value for this par: DO j = 1 , dimctr var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) = tmp3r ( 1 , 1 , j ) END DO END DO DEALLOCATE ( tmp3r ) ELSE IF ( pardims == 4 ) THEN ! i.e. soil parameter has a patch dimension ALLOCATE ( tmp4r ( 1 , 1 , npatch , dimctr )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp4r , & start = ( / land_x ( i ), land_y ( i ), 1 , 1 / ), & count = ( / 1 , 1 , npatch , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2)' ) DO j = 1 , dimctr ! Set values for this par for the # patches that exist var_r2 ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch - 1 ), j ) & = tmp4r ( 1 , 1 , :, j ) END DO END DO DEALLOCATE ( tmp4r ) ELSE IF ( dimswitch == 'nrb' ) THEN PRINT * , 'pardims' , pardims IF ( pardims == 2 ) THEN ! no patch dimension, just a land + other ! dimension IF ( PRESENT ( from_restart )) THEN ok = NF90_GET_VAR ( ncid , parID , var_r2 , start = ( / 1 , 1 / ), & count = ( / INpatch , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file' & // TRIM ( filename ) // ' (SUBROUTINE readpar_rd)' ) ELSE DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmpjh , start = ( / i / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2)' ) ! Set all patches to have the same value: PRINT * , 'read albsoil: ' , tmpjh var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , 1 ) = tmpjh var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , 2 ) = tmpjh END DO END IF END IF ELSE CALL abort ( 'Dimension of ' // parname // ' parameter in met file ' // & 'unknown.' ) END IF END IF ! gridtype land or mask END IF ! parameter's existence END SUBROUTINE readpar_r2 !============================================================================= SUBROUTINE readpar_r2d ( ncid , parname , completeSet , var_r2d , filename , & npatch , dimswitch , from_restart , INpatch ) ! Subroutine for loading a double precision two dimensional real-valued ! soil dimensioned parameter INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: npatch ! # of veg patches in parameter's file INTEGER , INTENT ( IN ), OPTIONAL :: INpatch REAL ( r_2 ), DIMENSION (:, :), INTENT ( INOUT ) :: var_r2d ! returned parameter ! value LOGICAL , INTENT ( IN ), OPTIONAL :: from_restart ! reading from restart file? LOGICAL , INTENT ( INOUT ) :: completeSet ! has every parameter been loaded? CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter CHARACTER ( LEN =* ), INTENT ( IN ) :: filename ! file containing parameter values CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter INTEGER :: parID ! parameter's netcdf ID INTEGER :: pardims ! # dimensions of parameter INTEGER :: dimctr ! size of non-spatial (2nd) dimension of parameter INTEGER :: i , j ! do loop counter REAL ( 8 ), DIMENSION (:, :), POINTER :: tmp2rd ! temporary for ncdf ! read in REAL ( 4 ), DIMENSION (:, :), POINTER :: tmp2r ! temporary for ncdf ! read in REAL ( 4 ), DIMENSION (:, :, :), POINTER :: tmp3r ! temporary for ncdf ! read in REAL ( 4 ), DIMENSION (:, :, :, :), POINTER :: tmp4r ! temporary for ncdf ! read in ! Check if parameter exists: ok = NF90_INQ_VARID ( ncid , parname , parID ) IF ( ok /= NF90_NOERR ) THEN ! if it doesn't exist completeSet = . FALSE . ! If this routine is reading from the restart, abort IF ( PRESENT ( from_restart )) WRITE ( * , * ) ' Error reading ' // parname // ' in file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2d)' ELSE exists % parameters = . TRUE . ! Note that pars were found in file ! Decide which 2nd dimension of parameter /init state we're loading: IF ( dimswitch ( 1 : 2 ) == 'ms' ) THEN dimctr = ms ! i.e. horizontal spatial and soil ELSE IF ( dimswitch ( 1 : 4 ) == 'snow' ) THEN dimctr = msn ! i.e. horizontal spatial and snow ELSE IF ( dimswitch ( 1 : 3 ) == 'nrb' ) THEN dimctr = nrb ! i.e. horizontal spatial and radiation bands ELSE IF ( dimswitch ( 1 : 3 ) == 'ncp' ) THEN dimctr = ncp ! i.e. horizontal spatial and plant carbon pools ELSE IF ( dimswitch ( 1 : 3 ) == 'ncs' ) THEN dimctr = ncs ! i.e. horizontal spatial and soil carbon pools ELSE CALL abort ( 'Parameter or initial state ' // parname // & ' called with unknown dimension switch - ' // dimswitch // & ' - in INTERFACE readpar' ) END IF ! Check for grid type - restart file uses land type grid IF ( metGrid == 'land' . OR . PRESENT ( from_restart )) THEN ! Collect data from land only grid in netcdf file. ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 2 ) THEN ! no patch dimension, just a land+soil ! dimensions ! If we really are reading a double precision variable ! from the netcdf restart file, dimswitch will show this: ! equivalent to using \"IF(PRESENT(from_restart)) THEN\" IF ( dimswitch == 'msd' . OR . dimswitch == 'snowd' . OR . & dimswitch == 'nrbd' . OR . dimswitch == 'ncpd' & . OR . dimswitch == 'ncsd' ) THEN ALLOCATE ( tmp2rd ( INpatch , dimctr )) ok = NF90_GET_VAR ( ncid , parID , tmp2rd , & start = ( / 1 , 1 / ), count = ( / INpatch , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in met data file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2d)' ) var_r2d (:, :) = REAL ( tmp2rd (:, :), r_2 ) DEALLOCATE ( tmp2rd ) !              ALLOCATE(tmp2rd(1,dimctr)) !              DO i=1, mland ! over all land points/grid cells !                 ok= NF90_GET_VAR(ncid, parID, tmp2rd,                        & !                                  start=(/i,1/), count=(/1,dimctr/)) !                 IF(ok /= NF90_NOERR) CALL nc_abort                           & !                    (ok,'Error reading '//parname//' in met data file '       & !                      //TRIM(filename)//' (SUBROUTINE readpar_r2d)') !                 DO j=1, dimctr !                    var_r2d(landpt(i)%cstart:landpt(i)%cend,j) =              & !                      REAL(tmp2rd(1,j),r_2) !                 END DO !              END DO !              DEALLOCATE(tmp2rd) ! WRITE(45,*) 'After read-in restart values' ! WRITE(45,*) '1039_var_r2d = ', var_r2d(1039,:) ! WRITE(45,*) '1672_var_r2d = ', var_r2d(1672,:) ELSE ALLOCATE ( tmp2r ( 1 , dimctr )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp2r , & start = ( / i , 1 / ), count = ( / 1 , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in met data file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2d)' ) DO j = 1 , dimctr var_r2d ( landpt ( i )% cstart : landpt ( i )% cend , j ) = & REAL ( tmp2r ( 1 , j )) END DO END DO DEALLOCATE ( tmp2r ) END IF ! reading a d.p. var from netcdf ELSE IF ( pardims == 3 ) THEN ! i.e. parameter has a patch dimension ! Note that restart file doesn't have a patch dimension, ! so that reads below are of single precision vares from met file ALLOCATE ( tmp3r ( 1 , npatch , dimctr )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp3r , & start = ( / i , 1 , 1 / ), count = ( / 1 , npatch , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in met data file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2d)' ) DO j = 1 , dimctr ! Set values for this par for the # patches that exist var_r2d ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch - 1 ), j ) & = REAL ( tmp3r ( 1 ,:, j ), r_2 ) END DO END DO DEALLOCATE ( tmp3r ) ELSE CALL abort ( 'Dimension of ' // parname // ' parameter in met file' // & 'unknown.' ) END IF ELSEIF ( metGrid == 'mask' ) THEN ! Get data from land/sea mask type grid: ! NB restart file won't have mask grid, therefore below we are ! reading single precision variables from the met file ! First, check whether parameter has patch dimension: ok = NF90_INQUIRE_VARIABLE ( ncid , parID , ndims = pardims ) IF ( pardims == 3 ) THEN ! no patch dimension, just x-y + soil grid ! dimension ALLOCATE ( tmp3r ( 1 , 1 , dimctr )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp3r , & start = ( / land_x ( i ), land_y ( i ), 1 / ), & count = ( / 1 , 1 , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in met data file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2d)' ) ! Set all patches to have the same value for this par: DO j = 1 , dimctr var_r2d ( landpt ( i )% cstart : landpt ( i )% cend , j ) = & REAL ( tmp3r ( 1 , 1 , j ), r_2 ) END DO END DO DEALLOCATE ( tmp3r ) ELSE IF ( pardims == 4 ) THEN ! i.e. soil parameter has a patch dimension ALLOCATE ( tmp4r ( 1 , 1 , npatch , dimctr )) DO i = 1 , mland ! over all land points/grid cells ok = NF90_GET_VAR ( ncid , parID , tmp4r , & start = ( / land_x ( i ), land_y ( i ), 1 , 1 / ), & count = ( / 1 , 1 , npatch , dimctr / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading ' // parname // ' in met data file ' & // TRIM ( filename ) // ' (SUBROUTINE readpar_r2d)' ) DO j = 1 , dimctr ! Set values for this par for the # patches that exist var_r2d ( landpt ( i )% cstart :( landpt ( i )% cstart + npatch & - 1 ), j ) = REAL ( tmp4r ( 1 , 1 , :, j ), r_2 ) END DO END DO DEALLOCATE ( tmp4r ) ELSE CALL abort ( 'Dimension of ' // parname // ' parameter in met file' // & 'unknown.' ) END IF END IF ! gridtype land or mask END IF ! parameter's existence END SUBROUTINE readpar_r2d !============================================================================= SUBROUTINE redistr_i ( INpatch , nap , in_i , out_i , parname ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: INpatch INTEGER , INTENT ( IN ) :: nap ( INpatch ) INTEGER , INTENT ( IN ) :: in_i ( INpatch ) INTEGER , INTENT ( OUT ) :: out_i ( mp ) CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter ! local variables !    REAL    :: ave_r INTEGER :: ii , jj , npt npt = 0 DO ii = 1 , mland !     ave_r = 0.0 DO jj = 1 , nap ( ii ) npt = npt + 1 !       ave_r = ave_r + in_i(npt) END DO !     ave_r = ave_r / FLOAT(nap(ii)) !     out_i(landpt(ii)%cstart:landpt(ii)%cend) = INT(ave_r) ! just take the dominant one for isflag out_i ( landpt ( ii )% cstart : landpt ( ii )% cend ) = in_i ( npt - nap ( ii ) + 1 ) END DO IF ( npt /= INpatch ) THEN PRINT * , parname , ' Error: npt /= INpatch, ' , npt , INpatch STOP END IF END SUBROUTINE redistr_i SUBROUTINE redistr_r ( INpatch , nap , in_r , out_r , parname ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: INpatch INTEGER , INTENT ( IN ) :: nap ( INpatch ) REAL , INTENT ( IN ) :: in_r ( INpatch ) REAL , INTENT ( OUT ) :: out_r ( mp ) CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter ! local variables REAL :: ave_r INTEGER :: ii , jj , npt npt = 0 DO ii = 1 , mland ave_r = 0.0 DO jj = 1 , nap ( ii ) npt = npt + 1 ave_r = ave_r + in_r ( npt ) END DO ave_r = ave_r / FLOAT ( nap ( ii )) out_r ( landpt ( ii )% cstart : landpt ( ii )% cend ) = ave_r END DO IF ( npt /= INpatch ) THEN PRINT * , parname , ' Error: npt /= INpatch, ' , npt , INpatch STOP END IF END SUBROUTINE redistr_r SUBROUTINE redistr_rd ( INpatch , nap , in_rd , out_rd , parname ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: INpatch INTEGER , INTENT ( IN ) :: nap ( INpatch ) REAL ( r_2 ), INTENT ( IN ) :: in_rd ( INpatch ) REAL ( r_2 ), INTENT ( OUT ) :: out_rd ( mp ) CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter ! local variables REAL ( r_2 ) :: ave_rd INTEGER :: ii , jj , npt npt = 0 DO ii = 1 , mland ave_rd = 0.0 DO jj = 1 , nap ( ii ) npt = npt + 1 ave_rd = ave_rd + in_rd ( npt ) END DO ave_rd = ave_rd / FLOAT ( nap ( ii )) out_rd ( landpt ( ii )% cstart : landpt ( ii )% cend ) = ave_rd END DO IF ( npt /= INpatch ) THEN PRINT * , parname , ' Error: npt /= INpatch, ' , npt , INpatch STOP END IF END SUBROUTINE redistr_rd SUBROUTINE redistr_r2 ( INpatch , nap , in_r2 , out_r2 , parname , dim2 ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: INpatch INTEGER , INTENT ( IN ) :: dim2 INTEGER , INTENT ( IN ) :: nap ( INpatch ) REAL , INTENT ( IN ) :: in_r2 ( INpatch , dim2 ) REAL , INTENT ( OUT ) :: out_r2 ( mp , dim2 ) CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter ! local variables REAL :: ave_r2 ( dim2 ) INTEGER :: ii , jj , npt npt = 0 DO ii = 1 , mland ave_r2 (:) = 0.0 DO jj = 1 , nap ( ii ) npt = npt + 1 ave_r2 (:) = ave_r2 (:) + in_r2 ( npt ,:) END DO ave_r2 (:) = ave_r2 (:) / FLOAT ( nap ( ii )) DO jj = 1 , dim2 out_r2 ( landpt ( ii )% cstart : landpt ( ii )% cend , jj ) = ave_r2 ( jj ) END DO END DO IF ( npt /= INpatch ) THEN PRINT * , parname , ' Error: npt /= INpatch, ' , npt , INpatch STOP END IF END SUBROUTINE redistr_r2 SUBROUTINE redistr_r2d ( INpatch , nap , in_r2d , out_r2d , parname , dim2 ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: INpatch INTEGER , INTENT ( IN ) :: dim2 INTEGER , INTENT ( IN ) :: nap ( INpatch ) REAL ( r_2 ), INTENT ( IN ) :: in_r2d ( INpatch , dim2 ) REAL ( r_2 ), INTENT ( OUT ) :: out_r2d ( mp , dim2 ) CHARACTER ( LEN =* ), INTENT ( IN ) :: parname ! name of parameter ! local variables REAL ( r_2 ) :: ave_r2d ( dim2 ) INTEGER :: ii , jj , npt npt = 0 DO ii = 1 , mland ave_r2d (:) = 0.0 DO jj = 1 , nap ( ii ) npt = npt + 1 ave_r2d (:) = ave_r2d (:) + in_r2d ( npt ,:) END DO ave_r2d (:) = ave_r2d (:) / FLOAT ( nap ( ii )) DO jj = 1 , dim2 out_r2d ( landpt ( ii )% cstart : landpt ( ii )% cend , jj ) = ave_r2d ( jj ) END DO END DO IF ( npt /= INpatch ) THEN PRINT * , parname , ' Error: npt /= INpatch, ' , npt , INpatch STOP END IF END SUBROUTINE redistr_r2d END MODULE cable_read_module","tags":"","loc":"sourcefile/cable_read.f90.html"},{"title":"cable_mpidrv.F90 – CABLE","text":"Contents Programs mpi_driver Source Code cable_mpidrv.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Bare bones MPI driver for CABLE ! ! Contact: Bernard.Pak@csiro.au ! ! History: MPI wrapper developed by Maciej Golebiewski (2012) ! ! ============================================================================== ! PROGRAM mpi_driver USE mpi USE cable_mpicommon USE cable_mpimaster USE cable_mpiworker USE cable_namelist_util , ONLY : get_namelist_file_name ,& CABLE_NAMELIST , arg_not_namelist IMPLICIT NONE INTEGER :: comm , np , rank , ierr REAL :: etime ! Declare the type of etime() CALL MPI_Init ( ierr ) CALL MPI_Comm_dup ( MPI_COMM_WORLD , comm , ierr ) CALL MPI_Comm_size ( comm , np , ierr ) !check to see if first argument passed to cable is !the name of the namelist file !if not use cable.nml CALL get_namelist_file_name () IF ( np < 2 ) THEN WRITE ( * , * ) 'This program needs at least 2 processes to run!' CALL MPI_Abort ( comm , 0 , ierr ) END IF CALL MPI_Comm_rank ( comm , rank , ierr ) IF ( rank == 0 ) THEN CALL mpidrv_master ( comm ) ELSE CALL mpidrv_worker ( comm ) END IF CALL MPI_Finalize ( ierr ) CALL CPU_TIME ( etime ) PRINT * , 'Finished. ' , etime , ' seconds needed for ' END PROGRAM mpi_driver","tags":"","loc":"sourcefile/cable_mpidrv.f90.html"},{"title":"cable_mpimaster.F90 – CABLE","text":"Contents Modules cable_mpimaster Source Code cable_mpimaster.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Offline driver for mpi master in CABLE global run ! ! Contact: Bernard.Pak@csiro.au ! ! History: Since 1.4b, capability to run global offline (ncciy = YEAR), !          inclusion of call to CASA-CNP (icycle>0) !          soil_snow_type now ssnow (instead of ssoil) ! !          MPI wrapper developed by Maciej Golebiewski (2012) !          Modified from cable_driver.F90 in CABLE-2.0_beta r171 by B Pak ! ! ============================================================================== ! Uses:           mpi !                 cable_mpicommon !                 cable_def_types_mod !                 cable_IO_vars_module !                 cable_common_module !                 cable_input_module !                 cable_output_module !                 cable_cbm_module !                 casadimension !                 casavariable !                 phenvariable !                 casa_cable !                 casa_inout_module ! ! CALLs:       point2constants !              open_met_file !              load_parameters !              open_output_file !              get_met_data !              write_output !              casa_poolout !              casa_fluxout !              create_restart !              close_met_file !              close_output_file !              prepareFiles !              find_extents !              master_decomp !              master_cable_params !              master_casa_params !              master_intypes !              master_outtypes !              master_casa_types !              master_restart_types !              master_send_input !              master_receive !              master_end !              master_casa_dump_types !              master_casa_LUC_types ! ! input  file: [SiteName].nc !              poolcnpIn[SiteName].csv -- for CASA-CNP only !              gridinfo_CSIRO_1x1.nc !              def_veg_params.txt !              def_soil_params.txt -- nearly redundant, can be switched on !              restart_in.nc -- not strictly required ! ! output file: log_cable.txt !              out_cable.nc !              restart_out.nc !              poolcnpOut.csv -- from CASA-CNP !============================================================================== MODULE cable_mpimaster USE cable_mpicommon USE casa_cable USE casa_inout_module IMPLICIT NONE SAVE PRIVATE ! number of workers; set in master_decomp INTEGER :: wnp ! TODO: m3d_t mat_t and vec_t to be factored out from here and from ! master_outtypes ! MPI: slices of 3D arrays INTEGER , ALLOCATABLE , DIMENSION (:,:) :: m3d_t ! MPI: slices of matrices (2D) INTEGER , ALLOCATABLE , DIMENSION (:,:) :: mat_t ! MPI: parts of vectors (1D) ! MPI: vec_t dimension is wnp; as each worker gets a single hindexed ! with nvec blocks INTEGER , ALLOCATABLE , DIMENSION (:) :: vec_t ! MPI derived datatype handles for sending input data to the workers INTEGER , ALLOCATABLE , DIMENSION (:) :: inp_ts ! MPI derived datatype handles for receiving output from the workers INTEGER , ALLOCATABLE , DIMENSION (:) :: recv_ts ! master's struct for receiving restart data from the workers INTEGER , ALLOCATABLE , DIMENSION (:) :: restart_ts ! CASA related derived types ! MPI derived datatype handles for receiving casa results from the workers ! and restart values INTEGER , ALLOCATABLE , DIMENSION (:) :: casa_ts ! MPI derived datatype handles for send/receiving casa dump values from the workers INTEGER , ALLOCATABLE , DIMENSION (:) :: casa_dump_ts ! MPI derived datatype handles for send/receiving casa pool values (needed for LUC) !  from the workers INTEGER , ALLOCATABLE , DIMENSION (:) :: casa_LUC_ts !CLN  ! MPI derived datatype handles for receiving casa restart values from the workers !CLN  INTEGER, ALLOCATABLE, DIMENSION(:) :: casa_restart_ts ! climate derived type INTEGER , ALLOCATABLE , DIMENSION (:) :: climate_ts ! POP related derived types ! MPI derived datatype handles for receiving POP results from the workers INTEGER :: pop_ts ! MPI: isend request array for scattering input data to the workers INTEGER , ALLOCATABLE , DIMENSION (:) :: inp_req ! MPI: isend status array for scattering input data to the workers INTEGER , ALLOCATABLE , DIMENSION (:,:) :: inp_stats ! MPI: irecv request array for gathering results from the workers INTEGER , ALLOCATABLE , DIMENSION (:) :: recv_req ! MPI: irecv status array for gathering results from the workers INTEGER , ALLOCATABLE , DIMENSION (:,:) :: recv_stats ! MPI: landpoints decomposition; global info used by the master process TYPE ( lpdecomp_t ), ALLOCATABLE , DIMENSION (:) :: wland PUBLIC :: mpidrv_master CONTAINS SUBROUTINE mpidrv_master ( comm ) USE mpi USE cable_def_types_mod USE cable_IO_vars_module , ONLY : logn , gswpfile , ncciy , leaps , globalMetfile , & verbose , fixedCO2 , output , check , patchout , & patch_type , landpt , soilparmnew ,& defaultLAI , sdoy , smoy , syear , timeunits , exists , output , & latitude , longitude , calendar USE cable_common_module , ONLY : ktau_gl , kend_gl , knode_gl , cable_user , & cable_runtime , fileName , myhome , & redistrb , wiltParam , satuParam , CurYear , & IS_LEAPYEAR , calcsoilalbedo , & kwidth_gl , gw_params USE casa_ncdf_module , ONLY : is_casa_time ! physical constants USE cable_phys_constants_mod , ONLY : CTFRZ => TFRZ USE cable_phys_constants_mod , ONLY : CEMLEAF => EMLEAF USE cable_phys_constants_mod , ONLY : CEMSOIL => EMSOIL USE cable_phys_constants_mod , ONLY : CSBOLTZ => SBOLTZ USE cable_input_module , ONLY : open_met_file , load_parameters , & get_met_data , close_met_file USE cable_output_module , ONLY : create_restart , open_output_file , & write_output , close_output_file USE cable_write_module , ONLY : nullify_write USE cable_cbm_module USE cable_climate_mod ! modules related to CASA-CNP USE casadimension , ONLY : icycle , mplant , mlitter , msoil , mwood USE casavariable , ONLY : casafile , casa_biome , casa_pool , casa_flux , & casa_met , casa_balance , zero_sum_casa , update_sum_casa USE phenvariable , ONLY : phen_variable USE casa_cable USE casa_inout_module !CLN added ! modules related to POP USE POP_Types , ONLY : POP_TYPE USE POP_Constants , ONLY : HEIGHT_BINS , NCOHORT_MAX ! LUC_EXPT only USE CABLE_LUC_EXPT , ONLY : LUC_EXPT_TYPE , LUC_EXPT_INIT USE POPLUC_Types , ONLY : POPLUC_Type USE POPLUC_Module , ONLY : WRITE_LUC_OUTPUT_NC , WRITE_LUC_OUTPUT_GRID_NC , & POP_LUC_CASA_transfer , WRITE_LUC_RESTART_NC , POPLUC_set_patchfrac ! PLUME-MIP only USE CABLE_PLUME_MIP , ONLY : PLUME_MIP_TYPE , PLUME_MIP_GET_MET ,& PLUME_MIP_INIT USE CABLE_CRU , ONLY : CRU_TYPE , CRU_GET_SUBDIURNAL_MET , CRU_INIT USE cable_namelist_util , ONLY : get_namelist_file_name ,& CABLE_NAMELIST , arg_not_namelist USE landuse_constant , ONLY : mstate , mvmax , mharvw USE landuse_variable IMPLICIT NONE ! MPI: INTEGER :: comm ! MPI communicator for comms with the workers ! CABLE namelist: model configuration, runtime/user switches !CHARACTER(LEN=200), PARAMETER :: CABLE_NAMELIST='cable.nml' ! timing variables INTEGER , PARAMETER :: kstart = 1 ! start of simulation INTEGER :: & ktau , & ! increment equates to timestep, resets if spinning up ktau_tot , & ! NO reset when spinning up, total timesteps by model kend , & ! no. of time steps in run !CLN      kstart = 1, &  ! timestep to start at koffset = 0 , & ! timestep to start at ktauday , & ! day counter for CASA-CNP idoy , & ! day of year (1:365) counter for CASA-CNP nyear , & ! year counter for CASA-CNP casa_it , & ! number of calls to CASA-CNP ctime , & ! day count for casacnp YYYY , & ! LOY , & ! Length of Year count_sum_casa , & ! number of time steps over which casa pools and fluxes are aggregated (for output) maxdiff ( 2 ) ! location of maximum in convergence test REAL :: dels ! time step size in seconds CHARACTER :: dum * 9 , str1 * 9 , str2 * 9 , str3 * 9 ! dummy char for fileName generation ! CABLE variables TYPE ( met_type ) :: met ! met input variables: see below for imet in MPI variables TYPE ( air_type ) :: air ! air property variables TYPE ( canopy_type ) :: canopy ! vegetation variables TYPE ( radiation_type ) :: rad ! radiation variables TYPE ( roughness_type ) :: rough ! roughness varibles TYPE ( balances_type ) :: bal ! energy and water balance variables TYPE ( soil_snow_type ) :: ssnow ! soil and snow variables TYPE ( climate_type ) :: climate ! climate variables ! CABLE parameters TYPE ( soil_parameter_type ) :: soil ! soil parameters TYPE ( veg_parameter_type ) :: veg ! vegetation parameters: see below for iveg in MPI variables TYPE ( sum_flux_type ) :: sum_flux ! cumulative flux variables TYPE ( bgc_pool_type ) :: bgc ! carbon pool variables ! CASA-CNP variables TYPE ( casa_biome ) :: casabiome TYPE ( casa_pool ) :: casapool TYPE ( casa_flux ) :: casaflux TYPE ( casa_pool ) :: sum_casapool TYPE ( casa_flux ) :: sum_casaflux TYPE ( casa_met ) :: casamet TYPE ( casa_balance ) :: casabal TYPE ( phen_variable ) :: phen TYPE ( POP_TYPE ) :: POP TYPE ( POPLUC_TYPE ) :: POPLUC TYPE ( LUC_EXPT_TYPE ) :: LUC_EXPT TYPE ( PLUME_MIP_TYPE ) :: PLUME TYPE ( CRU_TYPE ) :: CRU TYPE ( landuse_mp ) :: lucmp CHARACTER :: cyear * 4 CHARACTER :: ncfile * 99 ! declare vars for switches (default .FALSE.) etc declared thru namelist LOGICAL , SAVE :: & vegparmnew = . FALSE ., & ! using new format input file (BP dec 2007) spinup = . FALSE ., & ! model spinup to soil state equilibrium? spinConv = . FALSE ., & ! has spinup converged? spincasa = . FALSE ., & ! TRUE: CASA-CNP Will spin mloop times, l_casacnp = . FALSE ., & ! using CASA-CNP with CABLE l_landuse = . FALSE ., & ! using LANDUSE l_laiFeedbk = . FALSE ., & ! using prognostic LAI l_vcmaxFeedbk = . FALSE ., & ! using prognostic Vcmax CASAONLY = . FALSE ., & ! ONLY Run CASA-CNP CALL1 = . TRUE . REAL :: & delsoilM , & ! allowed variation in soil moisture for spin up delsoilT ! allowed variation in soil temperature for spin up REAL :: delgwM = 1e-4 ! temporary storage for soil moisture/temp. in spin up mode REAL , ALLOCATABLE , DIMENSION (:,:) :: & soilMtemp , & soilTtemp REAL , ALLOCATABLE , DIMENSION (:) :: & GWtemp ! MPI: TYPE ( met_type ) :: imet ! read ahead met input variables TYPE ( veg_parameter_type ) :: iveg ! MPI read ahead vegetation parameters LOGICAL :: loop_exit ! MPI: exit flag for bcast to workers INTEGER :: iktau ! read ahead index of time step = 1 ..  kend INTEGER :: oktau ! ktau = 1 ..  kend for output INTEGER :: tmp_kgl ! temp for ktau_gl INTEGER :: icomm ! separate dupes of MPI communicator for send and recv INTEGER :: ocomm ! separate dupes of MPI communicator for send and recv INTEGER :: ierr INTEGER :: rank , count , off , cnt ! Vars for standard for quasi-bitwise reproducability b/n runs ! Check triggered by cable_user%consistency_check = .TRUE. in cable.nml CHARACTER ( len = 30 ), PARAMETER :: & Ftrunk_sumbal = \".trunk_sumbal\" , & Fnew_sumbal = \"new_sumbal\" DOUBLE PRECISION , SAVE :: & trunk_sumbal = 0.0 , & ! new_sumbal = 0.0 , & new_sumfpn = 0.0 , & new_sumfe = 0.0 INTEGER :: count_bal = 0 INTEGER :: nkend = 0 INTEGER :: ioerror = 0 ! switches etc defined thru namelist (by default cable.nml) NAMELIST / CABLE / & filename , & ! TYPE, containing input filenames vegparmnew , & ! use new soil param. method soilparmnew , & ! use new soil param. method calcsoilalbedo , & ! ! vars intro for Ticket #27 spinup , & ! spinup model (soil) to steady state delsoilM , delsoilT ,& ! output , & patchout , & check , & verbose , & leaps , & logn , & fixedCO2 , & spincasa , & l_casacnp , & l_landuse , & l_laiFeedbk , & l_vcmaxFeedbk , & icycle , & casafile , & ncciy , & gswpfile , & globalMetfile , & redistrb , & wiltParam , & satuParam , & cable_user , & ! additional USER switches gw_params INTEGER :: i , x , kk , m , np , ivt INTEGER :: LALLOC INTEGER , PARAMETER :: mloop = 30 ! CASA-CNP PreSpinup loops REAL :: etime ! for landuse integer mlon , mlat , mpx real ( r_2 ), dimension (:,:,:), allocatable , save :: luc_atransit real ( r_2 ), dimension (:,:), allocatable , save :: luc_fharvw real ( r_2 ), dimension (:,:,:), allocatable , save :: luc_xluh2cable real ( r_2 ), dimension (:), allocatable , save :: arealand integer , dimension (:,:), allocatable , save :: landmask integer , dimension (:), allocatable , save :: cstart , cend , nap real ( r_2 ), dimension (:,:,:), allocatable , save :: patchfrac_new ! END header ! Open, read and close the namelist file. OPEN ( 10 , FILE = CABLE_NAMELIST , STATUS = \"OLD\" , ACTION = \"READ\" ) READ ( 10 , NML = CABLE ) !where NML=CABLE defined above CLOSE ( 10 ) ! Open, read and close the consistency check file. ! Check triggered by cable_user%consistency_check = .TRUE. in cable.nml IF ( cable_user % consistency_check ) THEN OPEN ( 11 , FILE = Ftrunk_sumbal , STATUS = 'old' , ACTION = 'READ' , IOSTAT = ioerror ) IF ( ioerror == 0 ) THEN READ ( 11 , * ) trunk_sumbal ! written by previous trunk version ENDIF CLOSE ( 11 ) ENDIF ! Open log file: OPEN ( logn , FILE = filename % log ) IF ( IARGC () > 0 ) THEN CALL GETARG ( 1 , filename % met ) CALL GETARG ( 2 , casafile % cnpipool ) ENDIF ! INITIALISATION depending on nml settings IF ( TRIM ( cable_user % MetType ) . EQ . 'gswp' . OR . TRIM ( cable_user % MetType ) . EQ . 'gswp3' ) THEN IF ( CABLE_USER % YearStart . EQ . 0 . AND . ncciy . GT . 0 ) THEN CABLE_USER % YearStart = ncciy CABLE_USER % YearEnd = ncciy ELSEIF ( CABLE_USER % YearStart . EQ . 0 . AND . ncciy . EQ . 0 ) THEN PRINT * , 'undefined start year for gswp met: ' PRINT * , 'enter value for ncciy or' PRINT * , '(CABLE_USER%YearStart and  CABLE_USER%YearEnd) & in cable.nml' WRITE ( logn , * ) 'undefined start year for gswp met: ' WRITE ( logn , * ) 'enter value for ncciy or' WRITE ( logn , * ) '(CABLE_USER%YearStart and  CABLE_USER%YearEnd) & in cable.nml' STOP ENDIF ENDIF CurYear = CABLE_USER % YearStart IF ( icycle . GE . 11 ) THEN icycle = icycle - 10 CASAONLY = . TRUE . CABLE_USER % CASA_DUMP_READ = . TRUE . CABLE_USER % CASA_DUMP_WRITE = . FALSE . ELSEIF ( icycle . EQ . 0 ) THEN CABLE_USER % CASA_DUMP_READ = . FALSE . CABLE_USER % CALL_POP = . FALSE . ENDIF !! vh_js !! IF ( icycle . GT . 0 ) THEN l_casacnp = . TRUE . ELSE l_casacnp = . FALSE . ENDIF !! vh_js !! suggest LALLOC should ulitmately be a switch in the .nml file IF ( CABLE_USER % CALL_POP ) THEN LALLOC = 3 ! for use with POP: makes use of pipe model to partition between stem and leaf ELSE LALLOC = 0 ! default ENDIF IF ( TRIM ( cable_user % MetType ) . EQ . 'gpgs' ) THEN leaps = . TRUE . cable_user % MetType = 'gswp' ENDIF cable_runtime % offline = . TRUE . IF ( l_casacnp . AND . ( icycle == 0 . OR . icycle > 3 ) ) & STOP 'icycle must be 1 to 3 when using casaCNP' IF ( ( l_laiFeedbk . OR . l_vcmaxFeedbk ) . AND . ( . NOT . l_casacnp ) ) & STOP 'casaCNP required to get prognostic LAI or Vcmax' IF ( l_vcmaxFeedbk . AND . icycle < 2 ) & STOP 'icycle must be 2 to 3 to get prognostic Vcmax' IF ( icycle > 0 . AND . ( . NOT . soilparmnew ) ) & STOP 'casaCNP must use new soil parameters' ! casa time count ctime = 0 ! Iinitialise settings depending on met dataset ! Open met data and get site information from netcdf file. (NON-GSWP ONLY!) ! This retrieves time step size, number of timesteps, starting date, ! latitudes, longitudes, number of sites. IF ( TRIM ( cable_user % MetType ) . NE . \"gswp\" . AND . & TRIM ( cable_user % MetType ) . NE . \"gswp3\" . AND . & TRIM ( cable_user % MetType ) . NE . \"gpgs\" . AND . & TRIM ( cable_user % MetType ) . NE . \"plum\" . AND . & TRIM ( cable_user % MetType ) . NE . \"cru\" . AND . & TRIM ( cable_user % MetType ) . NE . \"gpcc\" ) THEN CALL open_met_file ( dels , koffset , kend , spinup , CTFRZ ) IF ( koffset . NE . 0 . AND . CABLE_USER % CALL_POP ) THEN WRITE ( * , * ) \"When using POP, episode must start at Jan 1st!\" STOP 991 ENDIF ENDIF ! Tell the workers if we're leaping CALL MPI_Bcast ( leaps , 1 , MPI_LOGICAL , 0 , comm , ierr ) ! outer loop - spinup loop no. ktau_tot : ktau_tot = 0 ktau = 0 SPINLOOP : DO YEARLOOP : DO YYYY = CABLE_USER % YearStart , CABLE_USER % YearEnd CurYear = YYYY IF ( leaps . AND . IS_LEAPYEAR ( YYYY ) ) THEN LOY = 366 ELSE LOY = 365 ENDIF IF ( TRIM ( cable_user % MetType ) . EQ . 'plum' ) THEN ! CLN HERE PLUME modfications IF ( CALL1 ) THEN CALL PLUME_MIP_INIT ( PLUME ) dels = PLUME % dt koffset = 0 leaps = PLUME % LeapYears WRITE ( str1 , '(i4)' ) CurYear str1 = ADJUSTL ( str1 ) WRITE ( str2 , '(i2)' ) 1 str2 = ADJUSTL ( str2 ) WRITE ( str3 , '(i2)' ) 1 str3 = ADJUSTL ( str3 ) timeunits = \"seconds since \" // TRIM ( str1 ) // \"-\" // TRIM ( str2 ) // \"-\" // TRIM ( str3 ) // \" & 00:00\" ENDIF kend = NINT ( 2 4.0 * 360 0.0 / dels ) * LOY ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'cru' ) THEN ! CLN HERE CRU modfications IF ( CALL1 ) THEN CALL CPU_TIME ( etime ) CALL CRU_INIT ( CRU ) dels = CRU % dtsecs koffset = 0 leaps = . FALSE . ! No leap years in CRU-NCEP exists % Snowf = . FALSE . ! No snow in CRU-NCEP, so ensure it will ! be determined from temperature in CABLE WRITE ( str1 , '(i4)' ) CurYear str1 = ADJUSTL ( str1 ) WRITE ( str2 , '(i2)' ) 1 str2 = ADJUSTL ( str2 ) WRITE ( str3 , '(i2)' ) 1 str3 = ADJUSTL ( str3 ) timeunits = \"seconds since \" // TRIM ( str1 ) // \"-\" // TRIM ( str2 ) // \"-\" // TRIM ( str3 ) // \" & 00:00\" ENDIF LOY = 365 kend = NINT ( 2 4.0 * 360 0.0 / dels ) * LOY ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'gswp' ) THEN ncciy = CurYear WRITE ( * , * ) 'Looking for global offline run info.' CALL prepareFiles ( ncciy ) CALL open_met_file ( dels , koffset , kend , spinup , CTFRZ ) ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'gswp3' ) THEN ncciy = CurYear WRITE ( * , * ) 'Looking for global offline run info.' CALL open_met_file ( dels , koffset , kend , spinup , CTFRZ ) IF ( leaps . AND . IS_LEAPYEAR ( YYYY ) ) THEN calendar = \"standard\" ELSE calendar = \"noleap\" ENDIF ELSE IF ( globalMetfile % l_gpcc ) THEN ncciy = CurYear WRITE ( * , * ) 'Looking for global offline run info.' CALL open_met_file ( dels , koffset , kend , spinup , CTFRZ ) ENDIF ! somethings (e.g. CASA-CNP) only need to be done once per day ktauday = INT ( 2 4.0 * 360 0.0 / dels ) ! Checks where parameters and initialisations should be loaded from. ! If they can be found in either the met file or restart file, they will ! load from there, with the met file taking precedence. Otherwise, they'll ! be chosen from a coarse global grid of veg and soil types, based on ! the lat/lon coordinates. Allocation of CABLE's main variables also here. IF ( CALL1 ) THEN IF ( cable_user % POPLUC ) THEN CALL LUC_EXPT_INIT ( LUC_EXPT ) ENDIF !! vh_js !! CALL load_parameters ( met , air , ssnow , veg , climate , bgc , & soil , canopy , rough , rad , sum_flux , & bal , logn , vegparmnew , casabiome , casapool , & casaflux , sum_casapool , sum_casaflux , & casamet , casabal , phen , POP , spinup , & CEMSOIL , CTFRZ , LUC_EXPT , POPLUC ) IF ( CABLE_USER % POPLUC . AND . TRIM ( CABLE_USER % POPLUC_RunType ) . EQ . 'static' ) & CABLE_USER % POPLUC = . FALSE . ssnow % otss_0 = ssnow % tgg (:, 1 ) ssnow % otss = ssnow % tgg (:, 1 ) ssnow % tss = ssnow % tgg (:, 1 ) canopy % fes_cor = 0. canopy % fhs_cor = 0. met % ofsd = 0.1 IF (. NOT . spinup ) spinConv = . TRUE . ! MPI: above was standard serial code ! now it's time to initialize the workers ! MPI: bcast to workers so that they don't need to open the met ! file themselves CALL MPI_Bcast ( dels , 1 , MPI_REAL , 0 , comm , ierr ) ENDIF CALL MPI_Bcast ( kend , 1 , MPI_INTEGER , 0 , comm , ierr ) IF ( CALL1 ) THEN ! MPI: need to know extents before creating datatypes CALL find_extents ! MPI: calculate and broadcast landpoint decomposition to the workers CALL master_decomp ( comm , mland , mp ) ! MPI: set up stuff for new irecv isend code that separates completion ! from posting of requests ! wnp is set in master_decomp above ALLOCATE ( inp_req ( wnp )) ALLOCATE ( inp_stats ( MPI_STATUS_SIZE , wnp )) ALLOCATE ( recv_req ( wnp )) ALLOCATE ( recv_stats ( MPI_STATUS_SIZE , wnp )) CALL MPI_Comm_dup ( comm , icomm , ierr ) CALL MPI_Comm_dup ( comm , ocomm , ierr ) ! MPI: data set in load_parameter is now scattered out to the ! workers CALL master_cable_params ( comm , met , air , ssnow , veg , bgc , soil , canopy ,& & rough , rad , sum_flux , bal ) IF ( cable_user % call_climate ) THEN CALL master_climate_types ( comm , climate , ktauday ) ENDIF ! MPI: mvtype and mstype send out here instead of inside master_casa_params !      so that old CABLE carbon module can use them. (BP May 2013) CALL MPI_Bcast ( mvtype , 1 , MPI_INTEGER , 0 , comm , ierr ) CALL MPI_Bcast ( mstype , 1 , MPI_INTEGER , 0 , comm , ierr ) ! MPI: casa parameters scattered only if cnp module is active IF ( icycle > 0 ) THEN ! MPI: CALL master_casa_params ( comm , casabiome , casapool , casaflux , casamet ,& & casabal , phen ) IF ( CABLE_USER % CALL_POP ) CALL master_pop_types ( comm , casamet , pop ) END IF ! MPI: allocate read ahead buffers for input met and veg data CALL alloc_cbm_var ( imet , mp ) CALL alloc_cbm_var ( iveg , mp ) ! MPI: create inp_t types to scatter input data to the workers ! at the start of every timestep !CALL master_intypes (comm,met,veg) ! for read ahead use the new variables CALL master_intypes ( comm , imet , iveg ) ! MPI: create recv_t types to receive results from the workers ! at the end of every timestep CALL master_outtypes ( comm , met , canopy , ssnow , rad , bal , air , soil , veg ) ! MPI: create type for receiving casa results ! only if cnp module is active IF ( icycle > 0 ) THEN CALL master_casa_types ( comm , casapool , casaflux , & casamet , casabal , phen ) IF ( CABLE_USER % CASA_DUMP_READ . OR . CABLE_USER % CASA_DUMP_WRITE ) & CALL master_casa_dump_types ( comm , casamet , casaflux , phen , climate ) WRITE ( * , * ) 'cable_mpimaster, POPLUC: ' , CABLE_USER % POPLUC IF ( CABLE_USER % POPLUC ) & CALL master_casa_LUC_types ( comm , casapool , casabal ) END IF ! MPI: create type to send restart data back to the master ! only if restart file is to be created IF ( output % restart ) THEN CALL master_restart_types ( comm , canopy , air ) END IF !  CALL zero_sum_casa(sum_casapool, sum_casaflux) !  count_sum_casa = 0 ! CALL master_sumcasa_types(comm, sum_casapool, sum_casaflux) IF ( icycle > 0 . AND . spincasa ) THEN PRINT * , 'EXT spincasacnp enabled with mloop= ' , mloop , dels , kstart , kend CALL master_spincasacnp ( dels , kstart , kend , mloop , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , icomm , ocomm ) SPINconv = . FALSE . CASAONLY = . TRUE . ktau_gl = 0 ktau = 0 ELSEIF ( casaonly . AND . (. NOT . spincasa ) . AND . cable_user % popluc ) THEN CALL master_CASAONLY_LUC ( dels , kstart , kend , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , LUC_EXPT , POPLUC , & icomm , ocomm ) SPINconv = . FALSE . ktau_gl = 0 ktau = 0 ENDIF ! MPI: mostly original serial code follows... ENDIF ! CALL1 ! Open output file: IF (. NOT . CASAONLY ) THEN IF ( TRIM ( filename % out ) . EQ . '' ) THEN IF ( CABLE_USER % YEARSTART . GT . 0 ) THEN WRITE ( dum , FMT = \"(I4,'_',I4)\" ) CABLE_USER % YEARSTART , & CABLE_USER % YEAREND filename % out = TRIM ( filename % path ) // '/' // & TRIM ( cable_user % RunIden ) // '_' // & TRIM ( dum ) // '_cable_out.nc' ELSE filename % out = TRIM ( filename % path ) // '/' // & TRIM ( cable_user % RunIden ) // '_cable_out.nc' ENDIF ENDIF IF ( YYYY . EQ . CABLE_USER % YEARSTART ) THEN CALL nullify_write () ! nullify pointers CALL open_output_file ( dels , soil , veg , bgc , rough ) ENDIF ENDIF ! globally (WRT code) accessible kend through USE cable_common_module ktau_gl = 0 kwidth_gl = INT ( dels ) kend_gl = kend knode_gl = 0 ! MPI: separate time step counters for reading and writing ! (ugly, I know) iktau = ktau_gl oktau = ktau_gl ! MPI: read ahead iktau = iktau + 1 ! MPI: flip ktau_gl !tmp_kgl = ktau_gl ktau_gl = iktau IF (. NOT . casaonly ) THEN IF ( TRIM ( cable_user % MetType ) . EQ . 'plum' ) THEN CALL PLUME_MIP_GET_MET ( PLUME , iMET , YYYY , 1 , kend , & ( YYYY . EQ . CABLE_USER % YearEnd . AND . 1. EQ . kend )) ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'cru' ) THEN CALL CRU_GET_SUBDIURNAL_MET ( CRU , imet , YYYY , 1 , kend , & ( YYYY . EQ . CABLE_USER % YearEnd )) ELSE CALL get_met_data ( spinup , spinConv , imet , soil , & rad , iveg , kend , dels , CTFRZ , iktau + koffset , & kstart + koffset ) ENDIF ENDIF !  IF ( CASAONLY .AND. IS_CASA_TIME(\"dread\", yyyy, iktau, kstart, koffset, & !       kend, ktauday, logn) ) THEN !     WRITE(CYEAR,FMT=\"(I4)\")CurYear + INT((ktau-kstart+koffset)/(LOY*ktauday)) !     ncfile  = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc' !     casa_it = NINT( REAL(iktau / ktauday) ) !     CALL read_casa_dump( ncfile, casamet, casaflux,phen, casa_it, kend, .FALSE. ) !  ENDIF canopy % oldcansto = canopy % cansto ! Zero out lai where there is no vegetation acc. to veg. index WHERE ( iveg % iveg (:) . GE . 14 ) iveg % vlai = 0. IF ( . NOT . CASAONLY ) THEN ! MPI: scatter input data to the workers CALL master_send_input ( icomm , inp_ts , iktau ) !  CALL MPI_Waitall (wnp, inp_req, inp_stats, ierr) ELSE CALL master_send_input ( icomm , casa_dump_ts , iktau ) CALL MPI_Waitall ( wnp , inp_req , inp_stats , ierr ) ENDIF IF ( spincasa . OR . casaonly ) THEN EXIT ENDIF !IF (.NOT.spincasa) THEN ! time step loop over ktau KTAULOOP : DO ktau = kstart , kend - 1 !         ! increment total timstep counter !         ktau_tot = ktau_tot + 1 iktau = iktau + 1 oktau = oktau + 1 WRITE ( logn , * ) 'Progress -' , REAL ( ktau ) / REAL ( kend ) * 10 0.0 met % year = imet % year met % doy = imet % doy ! globally (WRT code) accessible kend through USE cable_common_module ktau_tot = ktau_tot + 1 ktau_gl = iktau ! some things (e.g. CASA-CNP) only need to be done once per day idoy = INT ( MOD (( REAL ( ktau + koffset ) / REAL ( ktauday )), REAL ( LOY ))) IF ( idoy . EQ . 0 ) idoy = LOY ! needed for CASA-CNP nyear = INT (( kend - kstart + 1 ) / ( LOY * ktauday )) ! Get met data and LAI, set time variables. ! Rainfall input may be augmented for spinup purposes: !          met%ofsd = met%fsd(:,1) + met%fsd(:,2) IF ( TRIM ( cable_user % MetType ) . EQ . 'plum' ) THEN CALL PLUME_MIP_GET_MET ( PLUME , iMET , YYYY , iktau , kend , & ( YYYY . EQ . CABLE_USER % YearEnd . AND . iktau . EQ . kend )) ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'cru' ) THEN CALL CRU_GET_SUBDIURNAL_MET ( CRU , imet , YYYY , iktau , kend , & ( YYYY . EQ . CABLE_USER % YearEnd ) ) ELSE CALL get_met_data ( spinup , spinConv , imet , soil , & rad , iveg , kend , dels , CTFRZ , iktau + koffset , & kstart + koffset ) ENDIF IF ( ( TRIM ( cable_user % MetType ) . NE . 'gswp' ) . AND . & ( TRIM ( cable_user % MetType ) . NE . 'gswp3' ) ) CurYear = met % year ( 1 ) !!$             IF ( CASAONLY .AND. IS_CASA_TIME(\"dread\", yyyy, iktau, kstart, koffset, & !!$                  kend, ktauday, logn) )  THEN !!$                ! CLN READ FROM FILE INSTEAD ! !!$                WRITE(CYEAR,FMT=\"(I4)\")CurYear + INT((ktau-kstart+koffset)/(LOY*ktauday)) !!$                ncfile  = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc' !!$                casa_it = NINT( REAL(iktau / ktauday) ) !!$                CALL read_casa_dump( ncfile, casamet, casaflux, casa_it, kend, .FALSE. ) !!$             ENDIF !!$             ! At first time step of year, set tile area according to updated LU areas !!$             IF (ktau == 1 .and. CABLE_USER%POPLUC) THEN !!$               CALL POPLUC_set_patchfrac(POPLUC,LUC_EXPT) !!$            ENDIF IF ( . NOT . CASAONLY ) THEN IF ( icycle > 0 ) THEN ! receive casa update from worker CALL master_receive ( ocomm , oktau , casa_ts ) CALL MPI_Waitall ( wnp , recv_req , recv_stats , ierr ) ! receive casa dump requirements from worker IF ( ((. NOT . spinup ). OR .( spinup . AND . spinConv )) . AND . & ( IS_CASA_TIME ( \"dwrit\" , yyyy , oktau , kstart , & koffset , kend , ktauday , logn ) ) ) THEN CALL master_receive ( ocomm , oktau , casa_dump_ts ) ! CALL MPI_Waitall (wnp, recv_req, recv_stats, ierr) ENDIF ENDIF ! MPI: receive this time step's results from the workers CALL master_receive ( ocomm , oktau , recv_ts ) ! CALL MPI_Waitall (wnp, recv_req, recv_stats, ierr) ! MPI: scatter input data to the workers CALL master_send_input ( icomm , inp_ts , iktau ) !  CALL MPI_Waitall (wnp, inp_req, inp_stats, ierr) !!$                IF ( ((.NOT.spinup).OR.(spinup.AND.spinConv)) .AND.   & !!$                     ( IS_CASA_TIME(\"dwrit\", yyyy, oktau, kstart, & !!$                        koffset, kend, ktauday, logn) ) ) THEN !!$                   WRITE(CYEAR,FMT=\"(I4)\") CurYear + INT((ktau-kstart)/(LOY*ktauday)) !!$                   ncfile = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc' !!$                   CALL write_casa_dump( ncfile, casamet , casaflux, idoy, & !!$                        kend/ktauday ) !!$ !!$                ENDIF IF (((. NOT . spinup ). OR .( spinup . AND . spinConv )). AND . & MOD (( ktau - kstart + 1 ), ktauday ) == 0 ) THEN IF ( CABLE_USER % CASA_DUMP_WRITE ) THEN !CLN CHECK FOR LEAP YEAR WRITE ( CYEAR , FMT = \"(I4)\" ) CurYear + INT (( ktau - kstart ) / ( LOY * ktauday )) ncfile = TRIM ( casafile % c2cdumppath ) // 'c2c_' // CYEAR // '_dump.nc' CALL write_casa_dump ( ncfile , casamet , casaflux , phen , climate , idoy , & kend / ktauday ) ENDIF ENDIF ELSE IF ( MOD (( ktau - kstart + 1 + koffset ), ktauday ) == 0 ) THEN CALL master_send_input ( icomm , casa_dump_ts , iktau ) !    CALL MPI_Waitall (wnp, inp_req, inp_stats, ierr) ENDIF !             CALL MPI_Waitall (wnp, recv_req, recv_stats, ierr) !             CALL MPI_Waitall (wnp, inp_req, inp_stats, ierr) met % ofsd = met % fsd (:, 1 ) + met % fsd (:, 2 ) canopy % oldcansto = canopy % cansto ! Zero out lai where there is no vegetation acc. to veg. index WHERE ( iveg % iveg (:) . GE . 14 ) iveg % vlai = 0. ! Write time step's output to file if either: we're not spinning up ! or we're spinning up and the spinup has converged: ! MPI: TODO: pull mass and energy balance calculation from write_output ! and refactor into worker code ktau_gl = oktau IF ((. NOT . spinup ). OR .( spinup . AND . spinConv )) THEN IF ( icycle > 0 ) THEN IF ( IS_CASA_TIME ( \"write\" , yyyy , oktau , kstart , & koffset , kend , ktauday , logn ) ) THEN ctime = ctime + 1 CALL WRITE_CASA_OUTPUT_NC ( veg , casamet , casapool , casabal , casaflux , & CASAONLY , ctime , & ( ktau . EQ . kend . AND . YYYY . EQ . cable_user % YearEnd ) ) ENDIF ENDIF IF ( (. NOT . CASAONLY ). AND . spinConv ) THEN IF ( TRIM ( cable_user % MetType ) . EQ . 'plum' & . OR . TRIM ( cable_user % MetType ) . EQ . 'cru' & . OR . TRIM ( cable_user % MetType ) . EQ . 'gswp' & . OR . TRIM ( cable_user % MetType ) . EQ . 'gswp3' ) THEN CALL write_output ( dels , ktau_tot , met , canopy , casaflux , casapool , & casamet , ssnow , & rad , bal , air , soil , veg , CSBOLTZ , & CEMLEAF , CEMSOIL ) ELSE CALL write_output ( dels , ktau , met , canopy , casaflux , casapool , & casamet , ssnow , & rad , bal , air , soil , veg , CSBOLTZ , CEMLEAF , CEMSOIL ) ENDIF END IF ENDIF !---------------------------------------------------------------------! ! Check this run against standard for quasi-bitwise reproducability   ! ! Check triggered by cable_user%consistency_check=.TRUE. in cable.nml ! !---------------------------------------------------------------------! IF ( cable_user % consistency_check ) THEN count_bal = count_bal + 1 ; new_sumbal = new_sumbal + SUM ( bal % wbal ) / mp + SUM ( bal % ebal ) / mp new_sumfpn = new_sumfpn + SUM ( canopy % fpn ) / mp new_sumfe = new_sumfe + SUM ( canopy % fe ) / mp !!$                    if (ktau == kend-1) PRINT*, \"time-space-averaged energy & water balances\" !!$                    if (ktau == kend-1) PRINT*,\"Ebal_tot[Wm-2], Wbal_tot[mm]\", & !!$                         sum(bal%ebal_tot)/mp/count_bal, sum(bal%wbal_tot)/mp/count_bal !!$                    if (ktau == kend-1) PRINT*, \"time-space-averaged latent heat and net photosynthesis\" !!$                    if (ktau == kend-1) PRINT*, \"sum_fe[Wm-2], sum_fpn[umol/m2/s]\",  & !!$                         new_sumfe/count_bal, new_sumfpn/count_bal ! check for Nans in biophysical outputs and abort if there are any IF ( ANY ( canopy % fe . NE . canopy % fe )) THEN DO kk = 1 , mp IF ( canopy % fe ( kk ). NE . canopy % fe ( kk )) THEN WRITE ( * , * ) 'Nan in evap flux,' , kk , patch ( kk )% latitude , patch ( kk )% longitude WRITE ( * , * ) 'fe nan' , kk , ktau , met % qv ( kk ), met % precip ( kk ), met % precip_sn ( kk ), & met % fld ( kk ), met % fsd ( kk ,:), met % tk ( kk ), met % ua ( kk ), & ssnow % potev ( kk ), met % pmb ( kk ), & canopy % ga ( kk ), ssnow % tgg ( kk ,:), canopy % fwsoil ( kk ), & rad % fvlai ( kk ,:) , rad % fvlai ( kk , 1 ), & rad % fvlai ( kk , 2 ), canopy % vlaiw ( kk ) CALL MPI_Abort ( comm , 0 , ierr ) ENDIF ENDDO ENDIF IF ( ktau == ( kend - 1 )) THEN nkend = nkend + 1 IF ( ABS ( new_sumbal - trunk_sumbal ) < 1.e-7 ) THEN PRINT * , \"\" PRINT * , & \"NB. Offline-parallel runs spinup cycles:\" , nkend PRINT * , & \"Internal check shows this version reproduces the trunk sumbal\" ELSE PRINT * , \"\" PRINT * , & \"NB. Offline-parallel runs spinup cycles:\" , nkend PRINT * , & \"Internal check shows in this version new_sumbal != trunk sumbal\" PRINT * , \"The difference is: \" , new_sumbal - trunk_sumbal PRINT * , & \"Writing new_sumbal to the file:\" , TRIM ( Fnew_sumbal ) !CLN                      OPEN( 12, FILE = Fnew_sumbal ) !CLN                      WRITE( 12, '(F20.7)' ) new_sumbal  ! written by previous trunk version !CLN                      CLOSE(12) ENDIF ENDIF ENDIF CALL1 = . FALSE . !WRITE(*,*) \" ktauloop end \", ktau, CurYear END DO KTAULOOP ! END Do loop over timestep ktau CALL1 = . FALSE . ! MPI: read ahead tail to receive (last step and write) met % year = imet % year met % doy = imet % doy oktau = oktau + 1 ktau_tot = ktau_tot + 1 ktau_gl = oktau IF ( . NOT . CASAONLY ) THEN IF ( icycle > 0 ) THEN CALL master_receive ( ocomm , oktau , casa_ts ) IF ( ((. NOT . spinup ). OR .( spinup . AND . spinConv )) . AND . & ( IS_CASA_TIME ( \"dwrit\" , yyyy , oktau , kstart , & koffset , kend , ktauday , logn ) ) ) THEN CALL master_receive ( ocomm , oktau , casa_dump_ts ) ENDIF ENDIF CALL master_receive ( ocomm , oktau , recv_ts ) ENDIF met % ofsd = met % fsd (:, 1 ) + met % fsd (:, 2 ) canopy % oldcansto = canopy % cansto IF ( ( TRIM ( cable_user % MetType ) . EQ . \"gswp\" ) . OR . ( TRIM ( cable_user % MetType ) . EQ . \"gswp3\" ) ) & CALL close_met_file IF ( icycle > 0 . AND . cable_user % CALL_POP ) THEN WRITE ( * , * ), 'b4 annual calcs' IF ( CABLE_USER % POPLUC ) THEN ! master receives casa updates required for LUC calculations here CALL master_receive ( ocomm , 0 , casa_LUC_ts ) ! Dynamic LUC CALL LUCdriver ( casabiome , casapool , casaflux , POP , LUC_EXPT , POPLUC , veg ) ! transfer POP updates to workers off = 1 DO rank = 1 , wnp IF ( rank . GT . 1 ) off = off + wland ( rank - 1 )% npop_iwood cnt = wland ( rank )% npop_iwood CALL MPI_Send ( POP % pop_grid ( off ), cnt , pop_ts , rank , 0 , icomm , ierr ) END DO ENDIF ! one annual time-step of POP (worker calls POP here) !CALL POPdriver(casaflux,casabal,veg, POP) CALL master_receive_pop ( POP , ocomm ) IF ( CABLE_USER % POPLUC ) THEN ! Dynamic LUC: update casa pools according to LUC transitions CALL POP_LUC_CASA_transfer ( POPLUC , POP , LUC_EXPT , casapool , casabal , casaflux , ktauday ) ! Dynamic LUC: write output IF ( output % grid ( 1 : 3 ) == 'lan' ) THEN CALL WRITE_LUC_OUTPUT_NC ( POPLUC , YYYY , ( YYYY . EQ . cable_user % YearEnd )) ELSE CALL WRITE_LUC_OUTPUT_GRID_NC ( POPLUC , YYYY , ( YYYY . EQ . cable_user % YearEnd )) !CALL WRITE_LUC_OUTPUT_NC( POPLUC, YYYY, ( YYYY.EQ.cable_user%YearEnd )) ENDIF ENDIF IF ( CABLE_USER % POPLUC ) & ! send updates for CASA pools, resulting from LUC CALL master_send_input ( icomm , casa_LUC_ts , nyear ) ENDIF WRITE ( * , * ) 'after annual calcs' ! WRITE OUTPUT IF ((. NOT . spinup ). OR .( spinup . AND . spinConv )) THEN IF ( icycle > 0 ) THEN ctime = ctime + 1 CALL WRITE_CASA_OUTPUT_NC ( veg , casamet , casapool , casabal , casaflux , & CASAONLY , ctime , ( ktau . EQ . kend . AND . YYYY . EQ . & cable_user % YearEnd ) ) IF ( cable_user % CALL_POP ) THEN ! CALL master_receive_pop(POP, ocomm) ! CALL MPI_Waitall (wnp, recv_req, recv_stats, ierr) IF ( TRIM ( cable_user % POP_out ). EQ . 'epi' ) THEN CALL POP_IO ( pop , casamet , CurYear , 'WRITE_EPI' , & ( CurYear . EQ . CABLE_USER % YearEnd ) ) ENDIF ENDIF END IF !!$             IF ( CABLE_USER%CASA_DUMP_WRITE )  THEN !!$                !CLN CHECK FOR LEAP YEAR !!$                WRITE(CYEAR,FMT=\"(I4)\") CurYear + INT((ktau-kstart)/(LOY*ktauday)) !!$                ncfile = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc' !!$                CALL write_casa_dump( ncfile, casamet , casaflux, idoy, & !!$                     kend/ktauday ) !!$ !!$             ENDIF IF (((. NOT . spinup ). OR .( spinup . AND . spinConv )). AND . & MOD (( ktau - kstart + 1 ), ktauday ) == 0 ) THEN IF ( CABLE_USER % CASA_DUMP_WRITE ) THEN !CLN CHECK FOR LEAP YEAR WRITE ( CYEAR , FMT = \"(I4)\" ) CurYear + INT (( ktau - kstart ) / ( LOY * ktauday )) ncfile = TRIM ( casafile % c2cdumppath ) // 'c2c_' // CYEAR // '_dump.nc' CALL write_casa_dump ( ncfile , casamet , casaflux , phen , climate , LOY , & kend / ktauday ) ENDIF ENDIF IF ( (. NOT . CASAONLY ) . AND . spinConv ) THEN IF ( TRIM ( cable_user % MetType ) . EQ . 'plum' & . OR . TRIM ( cable_user % MetType ) . EQ . 'cru' & . OR . TRIM ( cable_user % MetType ) . EQ . 'gswp' & . OR . TRIM ( cable_user % MetType ) . EQ . 'gswp3' ) THEN CALL write_output ( dels , ktau_tot , met , canopy , casaflux , casapool , & casamet , ssnow , & rad , bal , air , soil , veg , CSBOLTZ , & CEMLEAF , CEMSOIL ) ELSE CALL write_output ( dels , ktau , met , canopy , casaflux , casapool , casamet , & ssnow , & rad , bal , air , soil , veg , CSBOLTZ , CEMLEAF , CEMSOIL ) ENDIF END IF IF ( cable_user % consistency_check ) THEN count_bal = count_bal + 1 ; new_sumbal = new_sumbal + SUM ( bal % wbal ) / mp + SUM ( bal % ebal ) / mp new_sumfpn = new_sumfpn + SUM ( canopy % fpn ) / mp new_sumfe = new_sumfe + SUM ( canopy % fe ) / mp IF ( ktau == kend ) PRINT * IF ( ktau == kend ) PRINT * , \"time-space-averaged energy & water balances\" IF ( ktau == kend ) PRINT * , \"Ebal_tot[Wm-2], Wbal_tot[mm per timestep]\" , & SUM ( bal % ebal_tot ) / mp / count_bal , SUM ( bal % wbal_tot ) / mp / count_bal IF ( ktau == kend ) PRINT * , \"time-space-averaged latent heat and & net photosynthesis\" IF ( ktau == kend ) PRINT * , \"sum_fe[Wm-2], sum_fpn[umol/m2/s]\" , & new_sumfe / count_bal , new_sumfpn / count_bal IF ( ktau == kend ) WRITE ( logn , * ) IF ( ktau == kend ) WRITE ( logn , * ), \"time-space-averaged energy & water balances\" IF ( ktau == kend ) WRITE ( logn , * ), \"Ebal_tot[Wm-2], Wbal_tot[mm per timestep]\" , & SUM ( bal % ebal_tot ) / mp / count_bal , SUM ( bal % wbal_tot ) / mp / count_bal IF ( ktau == kend ) WRITE ( logn , * ), \"time-space-averaged latent heat and & net photosynthesis\" IF ( ktau == kend ) WRITE ( logn , * ), \"sum_fe[Wm-2], sum_fpn[umol/m2/s]\" , & new_sumfe / count_bal , new_sumfpn / count_bal ENDIF END IF ! set tile area according to updated LU areas IF ( CABLE_USER % POPLUC ) THEN CALL POPLUC_set_patchfrac ( POPLUC , LUC_EXPT ) ENDIF END DO YEARLOOP IF ( spincasa . OR . casaonly ) THEN EXIT ENDIF ! jhan this is insufficient testing. condition for ! spinup=.false. & we want CASA_dump.nc (spinConv=.true.) ! see if spinup (if conducting one) has converged: IF ( spinup . AND .. NOT . spinConv . AND . . NOT . CASAONLY ) THEN ! Write to screen and log file: WRITE ( * , '(A18,I3,A24)' ) ' Spinning up: run ' , INT ( ktau_tot / kend ), & ' of data set complete...' WRITE ( logn , '(A18,I3,A24)' ) ' Spinning up: run ' , INT ( ktau_tot / kend ), & ' of data set complete...' ! IF not 1st run through whole dataset: IF ( INT ( ktau_tot / kend ) > 1 ) THEN ! evaluate spinup IF ( ANY ( ABS ( ssnow % wb - soilMtemp ) > delsoilM ). OR . & ANY ( ABS ( ssnow % tgg - soilTtemp ) > delsoilT ) . OR . & MAXVAL ( ABS ( ssnow % GWwb - GWtemp ), dim = 1 ) > delgwM ) THEN ! No complete convergence yet !               PRINT *, 'ssnow%wb : ', ssnow%wb !               PRINT *, 'soilMtemp: ', soilMtemp !               PRINT *, 'ssnow%tgg: ', ssnow%tgg !               PRINT *, 'soilTtemp: ', soilTtemp maxdiff = MAXLOC ( ABS ( ssnow % wb - soilMtemp )) PRINT * , 'Example location of moisture non-convergence: ' , maxdiff PRINT * , 'ssnow%wb : ' , ssnow % wb ( maxdiff ( 1 ), maxdiff ( 2 )) PRINT * , 'soilMtemp: ' , soilMtemp ( maxdiff ( 1 ), maxdiff ( 2 )) maxdiff = MAXLOC ( ABS ( ssnow % tgg - soilTtemp )) PRINT * , 'Example location of temperature non-convergence: ' , maxdiff PRINT * , 'ssnow%tgg: ' , ssnow % tgg ( maxdiff ( 1 ), maxdiff ( 2 )) PRINT * , 'soilTtemp: ' , soilTtemp ( maxdiff ( 1 ), maxdiff ( 2 )) IF ( cable_user % gw_model ) THEN maxdiff ( 1 ) = MAXLOC ( ABS ( ssnow % GWwb - GWtemp ), dim = 1 ) PRINT * , 'ssnow%GWwb: ' , ssnow % GWwb ( maxdiff ( 1 )) PRINT * , 'GWtemp: ' , GWtemp ( maxdiff ( 1 )) ENDIF ELSE ! spinup has converged spinConv = . TRUE . ! Write to screen and log file: WRITE ( * , '(A33)' ) ' Spinup has converged - final run' WRITE ( logn , '(A52)' ) & ' Spinup has converged - final run - writing all data' WRITE ( logn , '(A37,F8.5,A28)' ) & ' Criteria: Change in soil moisture < ' , & delsoilM , ' in any layer over whole run' WRITE ( logn , '(A40,F8.5,A28)' ) & '           Change in soil temperature < ' , & delsoilT , ' in any layer over whole run' END IF ELSE ! allocate variables for storage IF (. NOT . ALLOCATED ( soilMtemp )) ALLOCATE ( soilMtemp ( mp , ms ) ) IF (. NOT . ALLOCATED ( soilTtemp )) ALLOCATE ( soilTtemp ( mp , ms ) ) IF (. NOT . ALLOCATED ( GWtemp )) ALLOCATE ( GWtemp ( mp ) ) END IF IF ( cable_user % max_spins . GT . 0 ) THEN IF ( INT ( ktau_tot / kend ) . GT . cable_user % max_spins ) THEN spinConv = . TRUE . ! Write to screen and log file: WRITE ( * , * ) ' Spinup exceeded max ' , cable_user % max_spins , ' cycles ' WRITE ( * , * ) ' Forcing the final run without spin up convergence ' WRITE ( logn , * ) ' Spinup exceeded max ' , cable_user % max_spins , ' cycles ' WRITE ( logn , * ) ' Forcing the final run without spin up convergence ' END IF END IF IF ( YYYY . GT . CABLE_USER % YearEnd ) THEN ! store soil moisture and temperature soilTtemp = ssnow % tgg soilMtemp = REAL ( ssnow % wb ) END IF ! MPI: loop_exit = . FALSE . ELSE ! if not spinning up, or spin up has converged, exit: ! EXIT ! MPI: loop_exit = . TRUE . END IF ! MPI: let the workers know whether it's time to quit CALL MPI_Bcast ( loop_exit , 1 , MPI_LOGICAL , 0 , comm , ierr ) IF ( loop_exit ) THEN EXIT END IF END DO SPINLOOP IF ( icycle > 0 . AND . (. NOT . spincasa ). AND . (. NOT . casaonly )) THEN ! MPI: gather casa results from all the workers CALL master_receive ( ocomm , ktau_gl , casa_ts ) !CALL MPI_Waitall (wnp, recv_req, recv_stats, ierr) !!$       CALL casa_poolout( ktau, veg, soil, casabiome,                           & !!$            casapool, casaflux, casamet, casabal, phen ) CALL casa_fluxout ( nyear , veg , soil , casabal , casamet ) if (. not . l_landuse ) then CALL write_casa_restart_nc ( casamet , casapool , casaflux , phen , CASAONLY ) endif !CALL write_casa_restart_nc ( casamet, casapool, met, CASAONLY ) IF (. not . l_landuse . and . CABLE_USER % CALL_POP . AND . POP % np . GT . 0 ) THEN IF ( CASAONLY . OR . cable_user % POP_fromZero & . OR . TRIM ( cable_user % POP_out ). EQ . 'ini' ) THEN CALL POP_IO ( pop , casamet , CurYear + 1 , 'WRITE_INI' , . TRUE .) ELSE CALL POP_IO ( pop , casamet , CurYear + 1 , 'WRITE_RST' , . TRUE .) ENDIF END IF IF (. not . l_landuse . and . cable_user % POPLUC . AND . . NOT . CASAONLY ) THEN CALL WRITE_LUC_RESTART_NC ( POPLUC , YYYY ) ENDIF END IF ! Write restart file if requested: IF ( output % restart . AND . (. NOT . CASAONLY )) THEN ! MPI: TODO: receive variables that are required by create_restart ! but not write_output !CALL receive_restart (comm,ktau,dels,soil,veg,ssnow, & !       &              canopy,rough,rad,bgc,bal) ! gol124: how about call master_receive (comm, ktau, restart_ts) ! instead of a separate receive_restart sub? CALL master_receive ( comm , ktau_gl , restart_ts ) !       CALL MPI_Waitall (wnp, recv_req, recv_stats, ierr) if (. not . l_landuse ) then CALL create_restart ( logn , dels , ktau , soil , veg , ssnow , & canopy , rough , rad , bgc , bal , met ) endif IF ( cable_user % CALL_climate ) THEN CALL master_receive ( comm , ktau_gl , climate_ts ) !CALL MPI_Waitall (wnp, recv_req, recv_stats, ierr) CALL WRITE_CLIMATE_RESTART_NC ( climate , ktauday ) END IF END IF IF ( l_landuse . and . . not . CASAONLY ) then mlon = maxval ( landpt ( 1 : mland )% ilon ) mlat = maxval ( landpt ( 1 : mland )% ilat ) allocate ( luc_atransit ( mland , mvmax , mvmax )) allocate ( luc_fharvw ( mland , mharvw )) allocate ( luc_xluh2cable ( mland , mvmax , mstate )) allocate ( landmask ( mlon , mlat )) allocate ( arealand ( mland )) allocate ( patchfrac_new ( mlon , mlat , mvmax )) allocate ( cstart ( mland ), cend ( mland ), nap ( mland )) do m = 1 , mland cstart ( m ) = landpt ( m )% cstart cend ( m ) = landpt ( m )% cend nap ( m ) = landpt ( m )% nap enddo call landuse_data ( mlon , mlat , landmask , arealand , luc_atransit , luc_fharvw , luc_xluh2cable ) call landuse_driver ( mlon , mlat , landmask , arealand , ssnow , soil , veg , bal , canopy , & phen , casapool , casabal , casamet , casabiome , casaflux , bgc , rad , & cstart , cend , nap , lucmp ) print * , 'writing new gridinfo: landuse' print * , 'new patch information. mland= ' , mland do m = 1 , mland do np = cstart ( m ), cend ( m ) ivt = lucmp % iveg ( np ) if ( ivt < 1. or . ivt > mvmax ) then print * , 'landuse: error in vegtype' , m , np , ivt stop endif patchfrac_new ( landpt ( m )% ilon , landpt ( m )% ilat , ivt ) = lucmp % patchfrac ( np ) enddo enddo call create_new_gridinfo ( filename % type , filename % gridnew , mlon , mlat , landmask , patchfrac_new ) call WRITE_LANDUSE_CASA_RESTART_NC ( cend ( mland ), lucmp , CASAONLY ) call create_landuse_cable_restart ( logn , dels , ktau , soil , cend ( mland ), lucmp , cstart , cend , nap ) call landuse_deallocate_mp ( cend ( mland ), ms , msn , nrb , mplant , mlitter , msoil , mwood , lucmp ) ENDIF ! Close met data input file: IF ( TRIM ( cable_user % MetType ) . NE . \"gswp\" . AND . & TRIM ( cable_user % MetType ) . NE . \"gswp3\" . AND . & TRIM ( cable_user % MetType ) . NE . \"plum\" . AND . & TRIM ( cable_user % MetType ) . NE . \"cru\" ) CALL close_met_file IF (. NOT . CASAONLY ) THEN ! Close output file and deallocate main variables: CALL close_output_file ( bal , air , bgc , canopy , met , & rad , rough , soil , ssnow , & sum_flux , veg ) ! WRITE(logn,*) bal%wbal_tot, bal%ebal_tot, bal%ebal_tot_cncheck ENDIF ! Close log file CLOSE ( logn ) CALL CPU_TIME ( etime ) PRINT * , 'Master End. ' , etime , ' seconds' ! MPI: cleanup CALL master_end ( icycle , output % restart ) RETURN END SUBROUTINE mpidrv_master SUBROUTINE prepareFiles ( ncciy ) USE cable_IO_vars_module , ONLY : logn , gswpfile IMPLICIT NONE INTEGER , INTENT ( IN ) :: ncciy WRITE ( logn , * ) 'CABLE offline global run using gswp forcing for ' , ncciy PRINT * , 'CABLE offline global run using gswp forcing for ' , ncciy CALL renameFiles ( logn , gswpfile % rainf , ncciy , 'rainf' ) CALL renameFiles ( logn , gswpfile % snowf , ncciy , 'snowf' ) CALL renameFiles ( logn , gswpfile % LWdown , ncciy , 'LWdown' ) CALL renameFiles ( logn , gswpfile % SWdown , ncciy , 'SWdown' ) CALL renameFiles ( logn , gswpfile % PSurf , ncciy , 'PSurf' ) CALL renameFiles ( logn , gswpfile % Qair , ncciy , 'Qair' ) CALL renameFiles ( logn , gswpfile % Tair , ncciy , 'Tair' ) CALL renameFiles ( logn , gswpfile % wind , ncciy , 'wind' ) END SUBROUTINE prepareFiles SUBROUTINE renameFiles ( logn , inFile , ncciy , inName ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: logn , ncciy INTEGER :: nn CHARACTER ( LEN = 200 ), INTENT ( INOUT ) :: inFile CHARACTER ( LEN =* ), INTENT ( IN ) :: inName INTEGER :: idummy nn = INDEX ( inFile , '19' ) READ ( inFile ( nn : nn + 3 ), '(i4)' ) idummy WRITE ( inFile ( nn : nn + 3 ), '(i4.4)' ) ncciy WRITE ( logn , * ) TRIM ( inName ), ' global data from ' , TRIM ( inFile ) END SUBROUTINE renameFiles !CLNSUBROUTINE prepareFiles(ncciy) !CLN  USE cable_IO_vars_module, ONLY: logn,gswpfile !CLN  IMPLICIT NONE !CLN  INTEGER, INTENT(IN) :: ncciy !CLN !CLN  WRITE(logn,*) 'CABLE offline global run using gswp forcing for ', ncciy !CLN  PRINT *,      'CABLE offline global run using gswp forcing for ', ncciy !CLN !CLN  CALL renameFiles(logn,gswpfile%rainf,16,ncciy,'rainf') !CLN  CALL renameFiles(logn,gswpfile%snowf,16,ncciy,'snowf') !CLN  CALL renameFiles(logn,gswpfile%LWdown,16,ncciy,'LWdown') !CLN  CALL renameFiles(logn,gswpfile%SWdown,16,ncciy,'SWdown') !CLN  CALL renameFiles(logn,gswpfile%PSurf,16,ncciy,'PSurf') !CLN  CALL renameFiles(logn,gswpfile%Qair,14,ncciy,'Qair') !CLN  CALL renameFiles(logn,gswpfile%Tair,14,ncciy,'Tair') !CLN  CALL renameFiles(logn,gswpfile%wind,15,ncciy,'wind') !CLN !CLNEND SUBROUTINE prepareFiles !CLN !CLN !CLNSUBROUTINE renameFiles(logn,inFile,nn,ncciy,inName) !CLN  IMPLICIT NONE !CLN  INTEGER, INTENT(IN) :: logn !CLN  INTEGER, INTENT(IN) :: nn !CLN  INTEGER, INTENT(IN) :: ncciy !CLN  CHARACTER(LEN=99), INTENT(INOUT) :: inFile !CLN  CHARACTER(LEN=*),  INTENT(IN)    :: inName !CLN  INTEGER :: idummy !CLN !CLN  READ(inFile(nn:nn+3),'(i4)') idummy !CLN  IF (idummy < 1983 .OR. idummy > 1995) THEN !CLN    PRINT *, 'Check position of the year number in input gswp file', inFile !CLN    STOP !CLN  ELSE !CLN    WRITE(inFile(nn:nn+3),'(i4.4)') ncciy !CLN    WRITE(logn,*) TRIM(inName), ' global data from ', TRIM(inFile) !CLN  ENDIF !CLN !CLNEND SUBROUTINE renameFiles ! ============== PRIVATE SUBROUTINES USED ONLY BY THE MPI MASTER =============== ! MPI: calculates and sends grid decomposition info to the workers SUBROUTINE master_decomp ( comm , mland , mp ) USE mpi USE cable_IO_vars_module , ONLY : landpt , patch IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm ! MPI communicator to talk to the workers INTEGER , INTENT ( IN ) :: mland ! total number of landpoints in the global grid INTEGER , INTENT ( IN ) :: mp ! total number of land patches in the global grid INTEGER :: lpw ! average number of landpoints per worker INTEGER :: rank , rest , nxt , pcnt , ierr , i , tmp INTEGER :: patchcnt ! sum of patches for a range landpoints ! how many workers do we have? CALL MPI_Comm_size ( comm , wnp , ierr ) wnp = wnp - 1 ALLOCATE ( wland ( wnp ), STAT = ierr ) IF ( ierr /= 0 ) THEN ! TODO: print an error message PRINT * , 'master-decomp MPI_ABORT' CALL MPI_Abort ( comm , 0 , ierr ) END IF ! MPI: calculate landpoint distribution among the workers ! this version distributes landpoints rather than active patches, ! but perhaps this will be easy to change in the future? lpw = mland / wnp rest = MOD ( mland , wnp ) nxt = 1 DO rank = 1 , wnp wland ( rank )% landp0 = nxt pcnt = lpw ! MPI: poor man's load balancing: ! - difference between number of landpoints assigned to ! different workers is 1 at most ! - inherent load balance because calculations are done on \"patches\" ! whose number differ between landpoints ! TODO: - the above to be addressed in the next version IF ( rest > 0 ) THEN pcnt = pcnt + 1 rest = rest - 1 END IF wland ( rank )% nland = pcnt ! MPI: let each worker know their assignement ! in this version of cable workers care only about the number of points ! CALL MPI_Send (nxt, 1, MPI_INTEGER, rank, 0, comm, ierr) CALL MPI_Send ( pcnt , 1 , MPI_INTEGER , rank , 0 , comm , ierr ) ! MPI: should be the same as landpt(nxt)%cstart wland ( rank )% patch0 = landpt ( nxt )% cstart ! MPI: calculate no of patches for pcnt landpoint starting from nxt ! MPI: TODO: workers only need to know the number of their patches ! or maybe not (if they need patch displacement in the input) ! MPI: find number of patches in all landpoints assigned to this ! worker (difference between last patch of last landpoint and first of ! first) patchcnt = landpt ( nxt + pcnt - 1 )% cend - landpt ( nxt )% cstart + 1 wland ( rank )% npatch = patchcnt ! MPI: development check tmp = 0 DO i = 1 , pcnt tmp = tmp + landpt ( nxt + i - 1 )% nap END DO IF ( patchcnt /= tmp ) THEN WRITE ( * , * ) 'invalid patch number for worker ' , & & patchcnt , tmp , rank CALL MPI_Abort ( comm , 0 , ierr ) END IF ! MPI: at this point workers can't determine patches on their own ! so we need to send it explicitely ! in this version of cable workers care only about the number of patches ! CALL MPI_Send (wland(rank)%patch0, 1, MPI_INTEGER, rank, 0, comm, ierr) CALL MPI_Send ( wland ( rank )% npatch , 1 , MPI_INTEGER , rank , 0 , comm , ierr ) nxt = nxt + pcnt END DO RETURN END SUBROUTINE master_decomp ! MPI: creates param_t type for the master to scatter the default parameters ! to the workers ! then sends the parameters ! and finally frees the MPI type SUBROUTINE master_cable_params ( comm , met , air , ssnow , veg , bgc , soil , canopy ,& rough , rad , sum_flux , bal ) USE mpi USE cable_def_types_mod USE cable_IO_vars_module ! switch soil colour albedo calc - Ticket #27 USE cable_common_module , ONLY : calcsoilalbedo IMPLICIT NONE ! subroutine arguments INTEGER , INTENT ( IN ) :: comm ! MPI communicator TYPE ( met_type ), INTENT ( INOUT ) :: met TYPE ( air_type ), INTENT ( INOUT ) :: air TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg TYPE ( bgc_pool_type ), INTENT ( INOUT ) :: bgc TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy TYPE ( roughness_type ), INTENT ( INOUT ) :: rough TYPE ( radiation_type ), INTENT ( INOUT ) :: rad TYPE ( sum_flux_type ), INTENT ( INOUT ) :: sum_flux TYPE ( balances_type ), INTENT ( INOUT ) :: bal ! local vars ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blen INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize , localtotal , remotetotal INTEGER :: stat ( MPI_STATUS_SIZE ), ierr INTEGER , ALLOCATABLE , DIMENSION (:) :: param_ts INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride , istride INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank INTEGER :: landpt_t , patch_t INTEGER :: nxt , pcnt , off , cnt ! create MPI types for exchanging slices of landpt and patch arrays CALL decomp_types ( landpt_t , patch_t ) ! MPI: TODO: replace sends with isends DO rank = 1 , wnp ! MPI: send worker's landpts nxt = wland ( rank )% landp0 pcnt = wland ( rank )% nland CALL MPI_Send ( landpt ( nxt ), pcnt , landpt_t , rank , 0 , comm , ierr ) ! MPI: send worker's patch nxt = wland ( rank )% patch0 pcnt = wland ( rank )% npatch CALL MPI_Send ( patch ( nxt ), pcnt , patch_t , rank , 0 , comm , ierr ) END DO ! MPI: TODO: free landp_t and patch_t types? ntyp = nparam ! vars intro for Ticket #27 IF ( calcsoilalbedo ) THEN ntyp = nparam + 1 END IF ALLOCATE ( param_ts ( wnp )) ALLOCATE ( blen ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! MPI: array strides for multi-dimensional types r1stride = mp * extr1 r2stride = mp * extr2 istride = mp * extid ! default type is byte, to be overriden for multi-D types types = MPI_BYTE ! total size of input data sent to all workers localtotal = 0 ! create a separate MPI derived datatype for each worker DO rank = 1 , wnp ! starting patch and number for each worker rank off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r2len = cnt * extr2 I1LEN = cnt * extid llen = cnt * extl bidx = 0 ! the order of variables follows argument list ! the order of fields within follows alloc_*_type subroutines ! ----------- met -------------- bidx = bidx + 1 CALL MPI_Get_address ( met % ca ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % year ( off ), displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( met % moy ( off ), displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( met % doy ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % hod ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % fsd ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( swb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( met % fld ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % precip ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % precip_sn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % tk ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % tvair ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % tvrad ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % pmb ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % ua ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % qv ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % qvair ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % da ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % dva ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % coszen ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ----------- air -------------- bidx = bidx + 1 CALL MPI_Get_address ( air % rho ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % volm ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % rlam ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % qsat ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % epsi ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % visc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % psyc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % dsatdk ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % cmolar ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ----------- ssnow -------------- bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dtmlt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( 3 , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % pudsto ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % pudsmx ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % albsoilsn ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % cls ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfn_dtg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfh_dtg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfe_dtg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfe_ddq ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR new variable bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ddq_dtg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % evapsn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop1 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop2 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop3 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % gammzz ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % isflag ( off ), displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( ssnow % osnowd ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % potev ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % pwb_min ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % runoff ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rnof1 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rnof2 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rtsoil ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sconds ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sdepth ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % smass ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snage ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snowd ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % smelt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ssdn ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ssdnn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tgg ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tggsn ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tss ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wb ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbfice ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbice ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wblf ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 ! additional  for sli bidx = bidx + 1 CALL MPI_Get_address ( ssnow % S ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % Tsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !!$ bidx = bidx + 1 CALL MPI_Get_address ( ssnow % thetai ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snowliq ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( 3 , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % Tsurface ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % h0 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % nsnow ( off ), displs ( bidx ), ierr ) blen ( bidx ) = I1len ! end additional for sli !blen(bidx) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbtot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wb_lake ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sinfil ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % evapfbl ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qstss ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wetfac ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % owetfac ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % t_snwlr ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tggav ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % otss ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % otss_0 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ----------- veg -------------- bidx = bidx + 1 CALL MPI_Get_address ( veg % canst1 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % dleaf ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % ejmax ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % frac4 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % froot ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % hc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % iveg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( veg % meth ( off ), displs ( bidx ), ierr ) ! Maciej: veg%meth is REAL !     blen(bidx) = I1LEN blen ( bidx ) = R1LEN bidx = bidx + 1 CALL MPI_Get_address ( veg % rp20 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % rpcoef ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % shelrb ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % wai ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % vegcf ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % tminvj ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % tmaxvj ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % vbeta ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % xalbnir ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % vcmax ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! bidx = bidx + 1 ! CALL MPI_Get_address (veg%vlai(off), displs(bidx), ierr) ! blen(bidx) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % xfang ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % extkn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % deciduous ( off ), displs ( bidx ), ierr ) ! Maciej: deciduous is logical !     blen(bidx) = r1len blen ( bidx ) = llen bidx = bidx + 1 CALL MPI_Get_address ( veg % a1gs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % d0gs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % alpha ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % convex ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % cfrd ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % gswmin ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % conkc0 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % conko0 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % ekc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % eko ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % clitt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( veg % zr ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( veg % gamma ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( veg % refl ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( 2 , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( veg % taul ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( 2 , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( veg % disturbance_interval ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( 2 , i1len , istride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( veg % disturbance_intensity ( off , 1 ), displs ( bidx ), ierr ) ! Maciej: disturbance_intensity is REAL(r_2) !     CALL MPI_Type_create_hvector (2, r1len, r1stride, MPI_BYTE, & !          &                             types(bidx), ierr) CALL MPI_Type_create_hvector ( 2 , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 ! Ticket #56, adding veg parms for Medlyn model bidx = bidx + 1 CALL MPI_Get_address ( veg % g0 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % g1 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! Ticket #56, finish adding new veg parms ! ----------- bgc -------------- bidx = bidx + 1 CALL MPI_Get_address ( bgc % cplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ncp , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ncp * r1len bidx = bidx + 1 CALL MPI_Get_address ( bgc % csoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ncs , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ncs * r1len ! constant * ncp, each worker gets the same copy of whole array bidx = bidx + 1 CALL MPI_Get_address ( bgc % ratecp , displs ( bidx ), ierr ) blen ( bidx ) = ncp * extr1 ! constant * ncs, each worker gets the same copy of whole array bidx = bidx + 1 CALL MPI_Get_address ( bgc % ratecs , displs ( bidx ), ierr ) blen ( bidx ) = ncs * extr1 ! ----------- soil -------------- bidx = bidx + 1 CALL MPI_Get_address ( soil % albsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % bch ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % c3 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % clay ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % cnsd ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % css ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % hsbh ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % hyds ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % i2bp3 ( off ), displs ( bidx ), ierr ) ! Maciej: i2bp3 is REAL !     blen(bidx) = I1LEN blen ( bidx ) = R1LEN bidx = bidx + 1 CALL MPI_Get_address ( soil % ibp2 ( off ), displs ( bidx ), ierr ) ! Maciej: ibp2 is REAL !     blen(bidx) = I1LEN blen ( bidx ) = R1LEN bidx = bidx + 1 CALL MPI_Get_address ( soil % isoilm ( off ), displs ( bidx ), ierr ) ! Maciej isoilm is INTEGER !     blen(bidx) = r1len blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( soil % rhosoil ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % rs20 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % sand ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % sfc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % silt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % ssat ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % sucs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % swilt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! the next two are extra for sli bidx = bidx + 1 CALL MPI_Get_address ( soil % zeta ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % fsatmax ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len ! end extra sli ! constant * ms, each worker gets the same copy of whole array bidx = bidx + 1 CALL MPI_Get_address ( soil % zse , displs ( bidx ), ierr ) blen ( bidx ) = ms * extr1 ! constant * (ms+1), each worker gets the same copy of whole array bidx = bidx + 1 CALL MPI_Get_address ( soil % zshh , displs ( bidx ), ierr ) blen ( bidx ) = ( ms + 1 ) * extr1 ! vars intro for Ticket #27 IF ( calcsoilalbedo ) THEN bidx = bidx + 1 CALL MPI_Get_address ( soil % soilcol ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len END IF ! ----------- canopy -------------- bidx = bidx + 1 CALL MPI_Get_address ( canopy % fess ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fesp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % cansto ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % oldcansto ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % cduv ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % delwc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % dewmm ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % dgdtg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fe ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fh ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fpn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpw ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpr ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnee ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frday ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnv ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fev ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevw ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len !  bidx = bidx + 1 !  CALL MPI_Get_address (canopy%potev_c(off), displs(bidx), ierr) !  blen(bidx) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhv ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhvw ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fns ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR new variable - temporary? bidx = bidx + 1 CALL MPI_Get_address ( canopy % fns_cor ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fes ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len !INH - REV_CORR new variable - temporary? bidx = bidx + 1 CALL MPI_Get_address ( canopy % fes_cor ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len !INH - SSEB new variable - temporary? !bidx = bidx + 1 !CALL MPI_Get_address (canopy%fescor_upp(off), displs(bidx), ierr) !blen(bidx) = r2len !INH - SSEB new variable - temporary? !bidx = bidx + 1 !CALL MPI_Get_address (canopy%fescor_low(off), displs(bidx), ierr) !blen(bidx) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR - temporary? bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhs_cor ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fwet ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % ga ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR - temporary? bidx = bidx + 1 CALL MPI_Get_address ( canopy % ga_cor ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % ghflux ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % precis ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % qscrn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % rnet ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % segg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % sghflux ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % spill ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % through ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % tscrn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % tv ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % us ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % uscrn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % vlaiw ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % rghlai ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % wcint ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len !  bidx = bidx + 1 !  CALL MPI_Get_address (canopy%rwater(off,1), displs(bidx), ierr) !  CALL MPI_Type_create_hvector (ms, r1len, r1stride, MPI_BYTE, & !  &                             types(bidx), ierr) !  blen(bidx) = 1 !  !blen(bidx) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % evapfbl ( off , 1 ), displs ( bidx ), ierr ) ! MPI: gol124: changed to r1 when Bernard ported to CABLE_r491 CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % epot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnpp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevw_pot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % gswx_T ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % cdtq ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % wetfac_cs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fwsoil ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % gswx ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % zetar ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( niter , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 ! ------- rough ------- bidx = bidx + 1 CALL MPI_Get_address ( rough % coexp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % disp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % hruff ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % hruff_grmx ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % rt0us ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % rt1usa ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % rt1usb ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % rt1 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % term2 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % term3 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % term5 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % term6 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % usuh ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % za_uv ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % za_tq ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % z0m ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % zref_uv ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % zref_tq ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % zruffs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % z0soilsn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % z0soil ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! --------rad -------- bidx = bidx + 1 CALL MPI_Get_address ( rad % albedo ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkb ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkd2 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkd ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % flws ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % fvlai ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mf * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % gradis ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mf * r2len bidx = bidx + 1 CALL MPI_Get_address ( rad % latitude ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % lwabv ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % qcan ( off , 1 , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mf * nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 ! blen(bidx) = mf * nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % qssabs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % rhocdf ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % rniso ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mf * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % scalex ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mf * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % transd ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % trad ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % reffdf ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % reffbm ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkbm ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkdm ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % fbeam ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % cexpkbm ( off , 1 ), displs ( bidx ), ierr ) ! Maciej: cexpkbm is mp*swb !     CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !          &                             types(bidx), ierr) CALL MPI_Type_create_hvector ( swb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % cexpkdm ( off , 1 ), displs ( bidx ), ierr ) ! Maciej: cexpkdm is mp*swb !     CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !          &                             types(bidx), ierr) CALL MPI_Type_create_hvector ( swb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % rhocbm ( off , 1 ), displs ( bidx ), ierr ) ! Maciej: rhocbm is mp*nrb !     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !          &                             types(bidx), ierr) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( rad % transb ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ------- sum_flux ----- bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumpn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrpw ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrpr ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrd ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % dsumpn ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % dsumrp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % dsumrs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % dsumrd ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumxrp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumxrs ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ------- bal ---- bidx = bidx + 1 CALL MPI_Get_address ( bal % drybal ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal_cncheck ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal_tot_cncheck ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % evap_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % osnowd0 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % precip_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % rnoff_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wbal ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wbal_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wbtot0 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wetbal ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % owbtot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % evapc_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % evaps_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % rnof1_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % rnof2_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % snowdc_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wbal_tot1 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % delwc_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % qasrf_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % qfsrf_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % qssrf_tot ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len ! additional field missing from previous versions; ! added when trying to fix a bug in the new mpi code ! the order of these new fields follows the order of their ! declaration in cable_define_types.F90 bidx = bidx + 1 CALL MPI_Get_address ( bal % ebaltr ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal_tottr ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % cansto0 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % iantrct ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tss_p ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % deltss ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % owb1 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbtot1 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tprecip ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tevap ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % trnoff ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % totenbal ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % totenbal2 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fland ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ifland ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tilefrac ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( n_tiles , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qasrf ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qfsrf ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qssrf ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % vlaimax ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % albedo_T ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % longitude ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len !mrd need to add parameters here... !2D bidx = bidx + 1 CALL MPI_Get_address ( soil % ssat_vec ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( soil % sucs_vec ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( soil % hyds_vec ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( soil % bch_vec ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( soil % watr ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( soil % swilt_vec ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( soil % sfc_vec ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !1D bidx = bidx + 1 CALL MPI_Get_address ( soil % GWssat_vec ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWsucs_vec ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWhyds_vec ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWbch_vec ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWwatr ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWz ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWdz ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % slope ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % slope_std ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % GWwb ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'master: invalid number of param_t fields ' , bidx , ', fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blen , displs , types , param_ts ( rank ), ierr ) CALL MPI_Type_commit ( param_ts ( rank ), ierr ) CALL MPI_Type_size ( param_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( param_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'master to rank param_t blocks, size, extent and lb: ' , rank , bidx , tsize , text , tmplb localtotal = localtotal + tsize END DO ! rank WRITE ( * , * ) 'total cable params size sent to all workers: ' , localtotal DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blen ) ! MPI: check whether total size of send input data equals total ! data received by all the workers remotetotal = 0 CALL MPI_Reduce ( MPI_IN_PLACE , remotetotal , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) WRITE ( * , * ) 'total cable params size received by all workers: ' , remotetotal IF ( localtotal /= remotetotal ) THEN WRITE ( * , * ) 'error: total length of cable params sent and received differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF ! so, now send all the parameters CALL master_send_input ( comm , param_ts , 0 ) !  CALL MPI_Waitall (wnp, inp_req, inp_stats, ierr) ! finally free the MPI type DO rank = 1 , wnp CALL MPI_Type_Free ( param_ts ( rank ), ierr ) END DO DEALLOCATE ( param_ts ) ! all CABLE parameters have been transferred to the workers by now RETURN END SUBROUTINE master_cable_params ! MPI: creates casa_ts types to broadcast/scatter the default casa parameters ! to all the workers ! then sends them ! and finally frees the MPI type SUBROUTINE master_casa_params ( comm , casabiome , casapool , casaflux , casamet ,& casabal , phen ) USE mpi USE cable_def_types_mod USE casavariable USE phenvariable IMPLICIT NONE ! sub arguments INTEGER , INTENT ( IN ) :: comm ! MPI communicator ! TODO: have these variables been already allocated? TYPE ( casa_biome ) , INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ) , INTENT ( INOUT ) :: casapool TYPE ( casa_flux ) , INTENT ( INOUT ) :: casaflux TYPE ( casa_met ) , INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! local vars ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blen INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and tot1al length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize , localtotal , remotetotal INTEGER :: stat ( MPI_STATUS_SIZE ), ierr ! INTEGER :: landp_t, patch_t, param_t INTEGER , ALLOCATABLE , DIMENSION (:) :: casa_ts INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride , istride INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank , off , cnt !  moved to calling before this subroutine (BP May 2013) !  CALL MPI_Bcast (mvtype, 1, MPI_INTEGER, 0, comm, ierr) !  CALL MPI_Bcast (mstype, 1, MPI_INTEGER, 0, comm, ierr) ntyp = ncasaparam ALLOCATE ( casa_ts ( wnp )) ALLOCATE ( blen ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! MPI: array strides for multi-dimensional types r1stride = mp * extr1 r2stride = mp * extr2 istride = mp * extid ! default type is byte, to be overriden for multi-D types types = MPI_BYTE ! total size of input data sent to all workers localtotal = 0 ! create a separate MPI derived datatype for each worker DO rank = 1 , wnp ! starting patch and number for each worker rank off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r2len = cnt * extr2 I1LEN = cnt * extid llen = cnt * extl bidx = 0 ! ------- casabiome ----- bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ivt2 , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extid bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkleafcoldmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkleafcoldexp , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkleafdrymax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkleafdryexp , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % glaimax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % glaimin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % sla , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratiofrootleaf , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % kroot , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % krootlen , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % rootdepth , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % kuptake , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % kminN , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % KuplabP , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % kclabrate , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 !=============================================================== bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xnpmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % q10soil , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkoptlitter , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkoptsoil , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % maxfinelitter , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % maxcwd , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % prodptase , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % costnpup , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkplab , displs ( bidx ), ierr ) blen ( bidx ) = mso * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkpsorb , displs ( bidx ), ierr ) blen ( bidx ) = mso * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkpocc , displs ( bidx ), ierr ) blen ( bidx ) = mso * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % nintercept , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % nslope , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 !================================================================== bidx = bidx + 1 CALL MPI_Get_address ( casabiome % plantrate , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % rmplant , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % fracnpptoP , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % fraclignin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % fraclabile , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioNCplantmin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioNCplantmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioPCplantmin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioPCplantmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % fracLigninplant , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ftransNPtoL , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ftransPPtoL , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % litterrate , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mlitter * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % soilrate , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * msoil * extr2 ! added by ln bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioNPplantmin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioNPplantmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 ! ------ casapool ---- bidx = bidx + 1 CALL MPI_Get_address ( casapool % Clabile ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dClabiledt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Cplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Pplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dCplantdt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dNplantdt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPplantdt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPCplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nsoilmin ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Psoillab ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Psoilsorb ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Psoilocc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dNsoilmindt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPsoillabdt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPsoilsorbdt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPsoiloccdt ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Clitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nlitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Plitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dClitterdt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dNlitterdt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPlitterdt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNClitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPClitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Csoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Psoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dCsoildt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dNsoildt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPsoildt ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPCsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoilnew ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoilmin ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoilmax ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 ! added by LN bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNPplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNPlitter ( off , 1 ), displs ( bidx ), ierr ) !  CALL MPI_Type_create_hvector (mplant, r2len, r2stride, MPI_BYTE, & ! Maciej CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNPsoil ( off , 1 ), displs ( bidx ), ierr ) !  CALL MPI_Type_create_hvector (mplant, r2len, r2stride, MPI_BYTE, & ! Maciej CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 ! added by ypw bidx = bidx + 1 CALL MPI_Get_address ( casapool % cwoodprod ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mwood , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % nwoodprod ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mwood , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % pwoodprod ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mwood , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 ! ------- casaflux ---- bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cgpp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cnpp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crp ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crgplant ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminfix ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminuptake ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Plabuptake ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Clabloss ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracClabile ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracCalloc ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracNalloc ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracPalloc ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crmplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len ! gol124: temp ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromPtoL ( off , 1 , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant * mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cnep ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crsoil ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nmindep ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminloss ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminleach ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nupland ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nlittermin ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsmin ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsimm ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsnet ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fNminloss ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fNminleach ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Pdep ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Pwea ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Pleach ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Ploss ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Pupland ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Plittermin ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Psmin ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Psimm ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Psnet ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fPleach ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kplab ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kpsorb ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kpocc ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kmlabP ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Psorbmax ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % frac_sapwood ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % sapwood_area ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % klitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % ksoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len ! gol124: temp only ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromLtoS ( off , 1 , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil * mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * mlitter * r2len ! gol124: temp only ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromStoS ( off , 1 , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil * msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromLtoCO2 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromStoCO2 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtolitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxNtolitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxPtolitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtosoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxNtosoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxPtosoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtoCO2 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len ! ------- casamet ---- bidx = bidx + 1 CALL MPI_Get_address ( casamet % glai ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % Tairk ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % precip ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % tsoilavg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % moistavg ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % btran ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % lnonwood ( off ), displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( casamet % Tsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % moist ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % iveg2 ( off ), displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( casamet % ijgcm ( off ), displs ( bidx ), ierr ) ! Maciej: ijgcm is INTEGER blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( casamet % isorder ( off ), displs ( bidx ), ierr ) ! Maciej: isorder is INTEGER blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( casamet % lat ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % lon ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % areacell ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len ! ------- casabal ---- bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCgppyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCnppyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmleafyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmwoodyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmrootyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrgrowyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrpyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrsyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCneeyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNdepyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNfixyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNsnetyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNupyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNleachyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNlossyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPweayear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPdustyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPsnetyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPupyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPleachyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPlossyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % glaimon ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( 12 , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = 12 * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % glaimonx ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( 12 , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = 12 * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % cplantlast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nplantlast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % pplantlast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % clitterlast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nlitterlast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % plitterlast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % csoillast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nsoillast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % psoillast ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 !blen(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nsoilminlast ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % psoillablast ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % psoilsorblast ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % psoilocclast ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % cbalance ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nbalance ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % pbalance ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumcbal ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumnbal ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumpbal ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % clabilelast ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len ! ------- phen ------- bidx = bidx + 1 CALL MPI_Get_address ( phen % phase ( off ), displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % TKshed , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphase ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mphase , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % phen ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( phen % aphen ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( phen % phasespin ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_1 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_2 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_3 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_4 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blen ( bidx ) = 1 ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'master: invalid number of casa_t param fields ' , bidx , ', fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blen , displs , types , casa_ts ( rank ), ierr ) CALL MPI_Type_commit ( casa_ts ( rank ), ierr ) CALL MPI_Type_size ( casa_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( casa_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'master to rank casa_t param blocks, size, extent and lb: ' , rank , bidx , tsize , text , tmplb localtotal = localtotal + tsize END DO ! rank WRITE ( * , * ) 'total casa params size sent to all workers: ' , localtotal DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blen ) ! MPI: check whether total size of received data equals total ! data sent by all the workers remotetotal = 0 CALL MPI_Reduce ( MPI_IN_PLACE , remotetotal , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) WRITE ( * , * ) 'total casa params size received by all workers: ' , remotetotal IF ( localtotal /= remotetotal ) THEN WRITE ( * , * ) 'error: total length of casa params sent and received differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF CALL MPI_Barrier ( comm , ierr ) ! so, now send all the parameters CALL master_send_input ( comm , casa_ts , 0 ) !  CALL MPI_Waitall (wnp, inp_req, inp_stats, ierr) ! finally free the MPI type DO rank = 1 , wnp CALL MPI_Type_Free ( casa_ts ( rank ), ierr ) END DO DEALLOCATE ( casa_ts ) ! all casa parameters have been sent to the workers by now RETURN END SUBROUTINE master_casa_params ! MPI: creates inp_t types to send input data to the workers ! input data means arrays read by get_met_data; each worker receives ! only its own slice of the arrays SUBROUTINE master_intypes ( comm , met , veg ) USE mpi USE cable_def_types_mod IMPLICIT NONE ! Arguments INTEGER , INTENT ( IN ) :: comm TYPE ( met_type ), INTENT ( IN ) :: met ! meteorological data TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! LAI retrieved from file ! Local variables ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize , localtotal , remotetotal INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank ! worker rank INTEGER :: off ! first patch index for a worker INTEGER :: cnt ! mp for a worker INTEGER :: ierr ALLOCATE ( inp_ts ( wnp )) ! max total number of fields to receive: met + veg fields !ntyp = 10 + 1 ntyp = ninput ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! chunks of all 1D vectors are contiguous blocks of memory so just send them ! as blocks of bytes types = MPI_BYTE ! total size of input data sent to all workers localtotal = 0 ! create a separate MPI derived datatype for each worker DO rank = 1 , wnp ! starting patch and number for each worker rank off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r2len = cnt * extr2 I1LEN = cnt * extid llen = cnt * extl r1stride = mp * extr1 bidx = 0 ! met fields bidx = bidx + 1 CALL MPI_Get_address ( met % fsd ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( swb , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % tk ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % pmb ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % qv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % ua ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % precip ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % precip_sn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % fld ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % ca ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % coszen ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % Ndep ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! veg fields bidx = bidx + 1 CALL MPI_Get_address ( veg % vlai ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! additional field missing from previous versions; ! added when trying to fix a bug in the new mpi code ! the order of these new fields follows the order of their ! declaration in cable_define_types.F90 bidx = bidx + 1 CALL MPI_Get_address ( met % year ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( met % moy ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( met % doy ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % hod ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'master: invalid intype nmat, nvec or n3d constant, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF ! marshall all fields into a single MPI derived datatype for worker rank CALL MPI_Type_create_struct ( bidx , blocks , displs , types , inp_ts ( rank ), ierr ) CALL MPI_Type_commit ( inp_ts ( rank ), ierr ) CALL MPI_Type_size ( inp_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( inp_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'master to ' , rank , ': intype struct blocks, size, extent and lb: ' , & bidx , tsize , text , tmplb localtotal = localtotal + tsize END DO ! rank DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) WRITE ( * , * ) 'total input data size sent to all workers: ' , localtotal ! MPI: check whether total size of send input data equals total ! data received by all the workers remotetotal = 0 CALL MPI_Reduce ( MPI_IN_PLACE , remotetotal , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) WRITE ( * , * ) 'total input data size received by all workers: ' , remotetotal IF ( localtotal /= remotetotal ) THEN WRITE ( * , * ) 'error: total length of input data sent and received differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF RETURN END SUBROUTINE master_intypes ! MPI: creates out_t types to receive the results from the workers SUBROUTINE master_outtypes ( comm , met , canopy , ssnow , rad , bal , air , soil , veg ) USE mpi USE cable_def_types_mod IMPLICIT NONE INTEGER :: comm ! MPI communicator to talk to the workers TYPE ( met_type ), INTENT ( IN ) :: met TYPE ( canopy_type ), INTENT ( IN ) :: canopy TYPE ( soil_snow_type ), INTENT ( IN ) :: ssnow TYPE ( radiation_type ), INTENT ( IN ) :: rad TYPE ( balances_type ), INTENT ( INOUT ) :: bal TYPE ( air_type ), INTENT ( IN ) :: air TYPE ( soil_parameter_type ), INTENT ( IN ) :: soil ! soil parameters TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters ! MPI: displacement (address) vector for vectors (1D arrays) INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: vaddr ! MPI: displacement (address) vector for matrices (2D arrays) INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: maddr ! MPI: displacement (address) vector for 3D arrays INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: m3daddr ! MPI: temp arrays for marshalling all types into a struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types INTEGER :: ntyp ! number of worker's types ! MPI: block lenghts for hindexed representing all vectors INTEGER , ALLOCATABLE , DIMENSION (:) :: blen ! MPI: block lengths and strides for hvector representing matrices INTEGER :: r1len , r2len INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride INTEGER :: tsize , totalrecv , totalsend INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: rank , off , cnt INTEGER :: midx , vidx , ierr ! base index to make types indexing easier INTEGER :: istart INTEGER :: i ! MPI: calculate the sizes/extents of Fortran types used by ! CABLE ! gol124: commented out because called earlier in mpidrv_master ! before it calls master_intypes ! CALL find_extents ! MPI: allocate matrices to hold datatype handles ALLOCATE ( m3d_t ( n3d , wnp )) ALLOCATE ( mat_t ( nmat , wnp )) ALLOCATE ( vec_t ( wnp )) ! MPI: allocate temp vectors used for marshalling ntyp = n3d + nmat + nvec ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! MPI: allocate vector to hold handles for the combined type ALLOCATE ( recv_ts ( wnp )) ! MPI: type_struct that combines all data for a single worker ! MPI: allocate address vectors for 3D matrices ! currently only 1 is 3D but to make future expansion easier ! let's handle it the same way as 3D and 2D ALLOCATE ( m3daddr ( n3d )) ! MPI: allocate address vectors for matrices ALLOCATE ( maddr ( nmat )) ! MPI: allocate address vectors for vectors ALLOCATE ( vaddr ( nvec )) ! MPI: allocate vector block lengths ALLOCATE ( blen ( nvec )) ! MPI: TODO: global var that holds the total number of patches/landunits? r1stride = mp * extr1 r2stride = mp * extr2 totalrecv = 0 ! create a separate datatype for each worker ! TODO: replace all hvectors with mpi_type_create_subarray! DO rank = 1 , wnp off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r2len = cnt * extr2 ! ------------- 3D arrays ------------- ! rad 3D ! TODO: REAL(r_1) : rad%qcan(landunits,mf,nrb) CALL MPI_Get_address ( rad % qcan ( off , 1 , 1 ), m3daddr ( 1 ), ierr ) CALL MPI_Type_create_hvector ( mf * nrb , r1len , r1stride , MPI_BYTE , & & m3d_t ( 1 , rank ), ierr ) CALL MPI_Type_commit ( m3d_t ( 1 , rank ), ierr ) ! ------------- 2D arrays ------------- ! MPI: an hvector type for each vector, maddr contains displacements ! for bundling these hvectors into the struct later ! block length is number of patches/worker * type extent ! stride is global number of patches * type extent ! repeat/no of blocks is the 2nd rank ! met 2D midx = 0 midx = midx + 1 CALL MPI_Get_address ( met % fsd ( off , 1 ), maddr ( midx ), ierr ) CALL MPI_Type_create_hvector ( swb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) ! canopy 2D !     ! REAL(r_1) !     CALL MPI_Get_address (canopy%rwater(off,1), maddr(midx), ierr) ! 1 !     CALL MPI_Type_create_hvector (ms, r1len, r1stride, MPI_BYTE, & !          &                        mat_t(midx, rank), ierr) !     CALL MPI_Type_commit (mat_t(midx, rank), ierr) !     midx = midx + 1 ! REAL(r_2) ! MPI: gol124: backport to r1134 changes r_2 to r_1 ! MPI: gol124: in newest CABLE-cnp it's r_2 again midx = midx + 1 CALL MPI_Get_address ( canopy % evapfbl ( off , 1 ), maddr ( midx ), ierr ) ! 2 ! MPI: gol124: changed to r1 when Bernard ported to CABLE_r491 CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 CALL MPI_Get_address ( canopy % gswx ( off , 1 ), maddr ( midx ), ierr ) ! 2 CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 CALL MPI_Get_address ( canopy % zetar ( off , 1 ), maddr ( midx ), ierr ) ! 2 CALL MPI_Type_create_hvector ( niter , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) ! ssnow 2D midx = midx + 1 CALL MPI_Get_address ( ssnow % dtmlt ( off , 1 ), maddr ( midx ), ierr ) CALL MPI_Type_create_hvector ( 3 , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % albsoilsn ( off , 1 ), maddr ( midx ), ierr ) ! 3 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % gammzz ( off , 1 ), maddr ( midx ), ierr ) ! 4 CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % sconds ( off , 1 ), maddr ( midx ), ierr ) ! 5 CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % sdepth ( off , 1 ), maddr ( midx ), ierr ) ! 6 CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % smass ( off , 1 ), maddr ( midx ), ierr ) ! 7 CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) ! MPI: r1134 does not know about this field, comment out !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%dtmlt(off,1), maddr(midx), ierr) ! 8 !CALL MPI_Type_create_hvector (msn, r1len, r1stride, MPI_BYTE, & !     &                        mat_t(midx, rank), ierr) !CALL MPI_Type_commit (mat_t(midx, rank), ierr) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % ssdn ( off , 1 ), maddr ( midx ), ierr ) ! 9 CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % tgg ( off , 1 ), maddr ( midx ), ierr ) ! 10 CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % tggsn ( off , 1 ), maddr ( midx ), ierr ) ! 11 CALL MPI_Type_create_hvector ( msn , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % wb ( off , 1 ), maddr ( midx ), ierr ) ! 12 CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % evapfbl ( off , 1 ), maddr ( midx ), ierr ) ! 12 CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % wbfice ( off , 1 ), maddr ( midx ), ierr ) ! 13 CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % wbice ( off , 1 ), maddr ( midx ), ierr ) ! 14 CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % wblf ( off , 1 ), maddr ( midx ), ierr ) ! 15 CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) ! additional  for sli midx = midx + 1 CALL MPI_Get_address ( ssnow % S ( off , 1 ), maddr ( midx ), ierr ) ! 15 CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 CALL MPI_Get_address ( ssnow % Tsoil ( off , 1 ), maddr ( midx ), ierr ) ! 15 CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 CALL MPI_Get_address ( ssnow % thetai ( off , 1 ), maddr ( midx ), ierr ) ! 15 CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 CALL MPI_Get_address ( ssnow % snowliq ( off , 1 ), maddr ( midx ), ierr ) ! 15 CALL MPI_Type_create_hvector ( 3 , r2len , r2stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) ! end additional for sli ! rad 2D midx = midx + 1 CALL MPI_Get_address ( rad % fbeam ( off , 1 ), maddr ( midx ), ierr ) ! 102 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % albedo ( off , 1 ), maddr ( midx ), ierr ) ! 16 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % fvlai ( off , 1 ), maddr ( midx ), ierr ) ! 17 CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_2) CALL MPI_Get_address ( rad % gradis ( off , 1 ), maddr ( midx ), ierr ) ! 18 CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % rhocdf ( off , 1 ), maddr ( midx ), ierr ) ! 19 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % rniso ( off , 1 ), maddr ( midx ), ierr ) ! 20 CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % scalex ( off , 1 ), maddr ( midx ), ierr ) ! 21 CALL MPI_Type_create_hvector ( mf , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % reffdf ( off , 1 ), maddr ( midx ), ierr ) ! 22 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % reffbm ( off , 1 ), maddr ( midx ), ierr ) ! 23 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % extkbm ( off , 1 ), maddr ( midx ), ierr ) ! 24 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % extkdm ( off , 1 ), maddr ( midx ), ierr ) ! 25 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % cexpkbm ( off , 1 ), maddr ( midx ), ierr ) ! 26 ! Maciej: cexpkbm is mp*swb !     CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !          &                        mat_t(midx, rank), ierr) CALL MPI_Type_create_hvector ( swb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % cexpkdm ( off , 1 ), maddr ( midx ), ierr ) ! 27 ! Maciej: cexpkdm is mp*swb !     CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !          &                        mat_t(midx, rank), ierr) CALL MPI_Type_create_hvector ( swb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % rhocbm ( off , 1 ), maddr ( midx ), ierr ) ! 27 ! Maciej: rhocbm is mp*nrb !     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !          &                        mat_t(midx, rank), ierr) CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) ! air 2D - all fields 1D - skipped ! soil 2D midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % albsoil ( off , 1 ), maddr ( midx ), ierr ) ! 28 CALL MPI_Type_create_hvector ( nrb , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) ! veg 2D midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % refl ( off , 1 ), maddr ( midx ), ierr ) ! 29 CALL MPI_Type_create_hvector ( 2 , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % taul ( off , 1 ), maddr ( midx ), ierr ) ! 29 CALL MPI_Type_create_hvector ( 2 , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) midx = midx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % froot ( off , 1 ), maddr ( midx ), ierr ) ! 29 CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & mat_t ( midx , rank ), ierr ) CALL MPI_Type_commit ( mat_t ( midx , rank ), ierr ) ! MPI: sanity check IF ( midx /= nmat ) THEN WRITE ( * , * ) 'master: outtype invalid nmat ' , midx , ' constant, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF ! ------------- 1D arrays ------------- ! met vidx = 0 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % ca ( off ), vaddr ( vidx ), ierr ) ! 1 blen ( vidx ) = cnt * extr1 ! gol124: not output, removed !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (met%year(off), vaddr(vidx), ierr) ! 2 !blen(vidx) = cnt * extid ! gol124: not output, removed !vidx = vidx + 1 ! INTEGER(i_d) ! CALL MPI_Get_address (met%moy(off), vaddr(vidx), ierr) ! 3 ! blen(vidx) = cnt * extid ! gol124: not output, removed !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%doy(off), vaddr(vidx), ierr) ! 4 !blen(vidx) = cnt * extr1 ! gol124: not output, removed !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%hod(off), vaddr(vidx), ierr) ! 5 !blen(vidx) = cnt * extr1 !vidx = vidx + 1 ! REAL(r_1) ! MPI: gol124: changed to 2D and moved up when Bernard ! ported to CABLE_r491 !CALL MPI_Get_address (met%fsd(off,1), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % fld ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % precip ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % precip_sn ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % tk ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % tvair ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % tvrad ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % pmb ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % ua ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % qv ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % qvair ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % da ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % dva ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( met % coszen ( off ), vaddr ( vidx ), ierr ) ! 19 blen ( vidx ) = cnt * extr1 ! canopy vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fess ( off ), vaddr ( vidx ), ierr ) ! 20 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fesp ( off ), vaddr ( vidx ), ierr ) ! 20 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % cansto ( off ), vaddr ( vidx ), ierr ) ! 20 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % cduv ( off ), vaddr ( vidx ), ierr ) ! 21 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % delwc ( off ), vaddr ( vidx ), ierr ) ! 22 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % dewmm ( off ), vaddr ( vidx ), ierr ) ! 23 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( canopy % dgdtg ( off ), vaddr ( vidx ), ierr ) ! 24 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fe ( off ), vaddr ( vidx ), ierr ) ! 25 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fh ( off ), vaddr ( vidx ), ierr ) ! 26 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fpn ( off ), vaddr ( vidx ), ierr ) ! 27 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % frp ( off ), vaddr ( vidx ), ierr ) ! 28 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % frpw ( off ), vaddr ( vidx ), ierr ) ! 29 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % frpr ( off ), vaddr ( vidx ), ierr ) ! 30 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % frs ( off ), vaddr ( vidx ), ierr ) ! 31 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fnee ( off ), vaddr ( vidx ), ierr ) ! 32 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % frday ( off ), vaddr ( vidx ), ierr ) ! 33 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fnv ( off ), vaddr ( vidx ), ierr ) ! 34 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fev ( off ), vaddr ( vidx ), ierr ) ! 35 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( canopy % fevc ( off ), vaddr ( vidx ), ierr ) ! 36 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( canopy % fevw ( off ), vaddr ( vidx ), ierr ) ! 37 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 !     ! REAL(r_2) !     CALL MPI_Get_address (canopy%potev_c(off), vaddr(vidx), ierr) ! 38 !     blen(vidx) = cnt * extr2 !     vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fhv ( off ), vaddr ( vidx ), ierr ) ! 39 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( canopy % fhvw ( off ), vaddr ( vidx ), ierr ) ! 40 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fns ( off ), vaddr ( vidx ), ierr ) ! 41 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 !INH - REV_CORR - temporary? CALL MPI_Get_address ( canopy % fns_cor ( off ), vaddr ( vidx ), ierr ) ! 41 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fes ( off ), vaddr ( vidx ), ierr ) ! 42 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fes_cor ( off ), vaddr ( vidx ), ierr ) ! 42 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 !REAL(r_1) !INH - SSEB  - temporary? !CALL MPI_Get_address (canopy%fescor_upp(off), vaddr(vidx), ierr) ! 42 !blen(vidx) = cnt * extr2 !vidx = vidx + 1 !REAL(r_1) !INH - SSEB - temporary? !CALL MPI_Get_address (canopy%fescor_low(off), vaddr(vidx), ierr) ! 42 !blen(vidx) = cnt * extr2 !vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fhs ( off ), vaddr ( vidx ), ierr ) ! 43 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fhs_cor ( off ), vaddr ( vidx ), ierr ) ! 43 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fwet ( off ), vaddr ( vidx ), ierr ) ! 44 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % epot ( off ), vaddr ( vidx ), ierr ) ! 44 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fnpp ( off ), vaddr ( vidx ), ierr ) ! 44 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % fevw_pot ( off ), vaddr ( vidx ), ierr ) ! 44 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % gswx_T ( off ), vaddr ( vidx ), ierr ) ! 44 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % cdtq ( off ), vaddr ( vidx ), ierr ) ! 44 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % wetfac_cs ( off ), vaddr ( vidx ), ierr ) ! 44 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % ga ( off ), vaddr ( vidx ), ierr ) ! 45 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) !INH - REV_CORR - temporary? CALL MPI_Get_address ( canopy % ga_cor ( off ), vaddr ( vidx ), ierr ) ! 45 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % ghflux ( off ), vaddr ( vidx ), ierr ) ! 46 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % precis ( off ), vaddr ( vidx ), ierr ) ! 47 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % qscrn ( off ), vaddr ( vidx ), ierr ) ! 48 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % rnet ( off ), vaddr ( vidx ), ierr ) ! 49 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % segg ( off ), vaddr ( vidx ), ierr ) ! 50 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % sghflux ( off ), vaddr ( vidx ), ierr ) ! 51 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % spill ( off ), vaddr ( vidx ), ierr ) ! 52 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % through ( off ), vaddr ( vidx ), ierr ) ! 53 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % tscrn ( off ), vaddr ( vidx ), ierr ) ! 54 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % tv ( off ), vaddr ( vidx ), ierr ) ! 55 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % us ( off ), vaddr ( vidx ), ierr ) ! 56 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % uscrn ( off ), vaddr ( vidx ), ierr ) ! 57 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % vlaiw ( off ), vaddr ( vidx ), ierr ) ! 58 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % rghlai ( off ), vaddr ( vidx ), ierr ) ! 58 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( canopy % wcint ( off ), vaddr ( vidx ), ierr ) ! 59 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( canopy % fwsoil ( off ), vaddr ( vidx ), ierr ) ! 59 blen ( vidx ) = cnt * extr2 ! MPI: 2D vars moved above ! rwater ! evapfbl ! ssnow ! MPI: 2D vars moved above ! albsoilsn vidx = vidx + 1 CALL MPI_Get_address ( ssnow % pudsto ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = r1len vidx = vidx + 1 CALL MPI_Get_address ( ssnow % pudsmx ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = r1len vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % cls ( off ), vaddr ( vidx ), ierr ) ! 60 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % dfn_dtg ( off ), vaddr ( vidx ), ierr ) ! 61 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % dfh_dtg ( off ), vaddr ( vidx ), ierr ) ! 62 blen ( vidx ) = cnt * extr1 !INH - REV_CORR - no longer needed vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % dfe_ddq ( off ), vaddr ( vidx ), ierr ) ! +1 blen ( vidx ) = cnt * extr1 !INH - REV_CORR vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % dfe_dtg ( off ), vaddr ( vidx ), ierr ) ! +1 blen ( vidx ) = cnt * extr1 !INH - REV_CORR - no longer needed vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % ddq_dtg ( off ), vaddr ( vidx ), ierr ) ! 63 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % evapsn ( off ), vaddr ( vidx ), ierr ) ! 64 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % fwtop ( off ), vaddr ( vidx ), ierr ) ! 65 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 CALL MPI_Get_address ( ssnow % fwtop1 ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = r1len vidx = vidx + 1 CALL MPI_Get_address ( ssnow % fwtop2 ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = r1len vidx = vidx + 1 CALL MPI_Get_address ( ssnow % fwtop3 ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = r1len ! MPI: 2D vars moved above ! gammzz vidx = vidx + 1 ! INTEGER(i_d) CALL MPI_Get_address ( ssnow % isflag ( off ), vaddr ( vidx ), ierr ) ! 66 blen ( vidx ) = cnt * extid vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % osnowd ( off ), vaddr ( vidx ), ierr ) ! 67 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % potev ( off ), vaddr ( vidx ), ierr ) ! 68 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( soil % pwb_min ( off ), vaddr ( vidx ), ierr ) ! 69 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % runoff ( off ), vaddr ( vidx ), ierr ) ! 70 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % rnof1 ( off ), vaddr ( vidx ), ierr ) ! 71 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % rnof2 ( off ), vaddr ( vidx ), ierr ) ! 72 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % rtsoil ( off ), vaddr ( vidx ), ierr ) ! 73 blen ( vidx ) = cnt * extr1 ! MPI: 2D vars moved above ! sconds ! sdepth ! smass vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % snage ( off ), vaddr ( vidx ), ierr ) ! 74 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % snowd ( off ), vaddr ( vidx ), ierr ) ! 75 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % smelt ( off ), vaddr ( vidx ), ierr ) ! 76 blen ( vidx ) = cnt * extr1 ! MPI: 2D vars moved above ! dtmlt ! ssdn vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % ssdnn ( off ), vaddr ( vidx ), ierr ) ! 77 blen ( vidx ) = cnt * extr1 ! MPI: 2D vars moved above ! tgg ! tggsn vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % tss ( off ), vaddr ( vidx ), ierr ) ! 78 blen ( vidx ) = cnt * extr1 ! MPI: r1134 does not know about this field, comment out !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%otss(off), vaddr(vidx), ierr) ! 79 !blen(vidx) = cnt * extr1 ! MPI: 2D vars moved above ! wb ! wbfice ! wbice ! wblf vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % wbtot ( off ), vaddr ( vidx ), ierr ) ! 90 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % wb_lake ( off ), vaddr ( vidx ), ierr ) ! 91 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % sinfil ( off ), vaddr ( vidx ), ierr ) ! 91 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % qstss ( off ), vaddr ( vidx ), ierr ) ! 91 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % wetfac ( off ), vaddr ( vidx ), ierr ) ! 91 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) ! MPI: TODO: maybe not needed for transfer to master? CALL MPI_Get_address ( ssnow % owetfac ( off ), vaddr ( vidx ), ierr ) ! 92 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % t_snwlr ( off ), vaddr ( vidx ), ierr ) ! 91 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % tggav ( off ), vaddr ( vidx ), ierr ) ! 91 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % otss ( off ), vaddr ( vidx ), ierr ) ! 91 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( ssnow % otss_0 ( off ), vaddr ( vidx ), ierr ) ! 91 blen ( vidx ) = cnt * extr1 ! rad ! MPI: 2D vars moved above ! albedo vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % extkb ( off ), vaddr ( vidx ), ierr ) ! 93 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % extkd2 ( off ), vaddr ( vidx ), ierr ) ! 94 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % extkd ( off ), vaddr ( vidx ), ierr ) ! 95 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % flws ( off ), vaddr ( vidx ), ierr ) ! 96 blen ( vidx ) = cnt * extr1 ! MPI: 2D vars moved above ! fvlai ! gradis vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % latitude ( off ), vaddr ( vidx ), ierr ) ! 97 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % lwabv ( off ), vaddr ( vidx ), ierr ) !98 blen ( vidx ) = cnt * extr1 ! MPI: 3D vars moved above ! qcan vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % qssabs ( off ), vaddr ( vidx ), ierr ) !99 blen ( vidx ) = cnt * extr1 ! MPI: 2D vars moved above ! rhocdf ! rniso ! scalex vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % transd ( off ), vaddr ( vidx ), ierr ) ! 100 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % trad ( off ), vaddr ( vidx ), ierr ) ! 101 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( rad % transb ( off ), vaddr ( vidx ), ierr ) ! 101 blen ( vidx ) = cnt * extr1 ! MPI: 2D vars moved above ! reffdf ! reffbm ! extkbm ! extkdm ! MPI: gol124: changed to 2D and moved up when Bernard ! ported to CABLE_r491 !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%fbeam(off,1), vaddr(vidx), ierr) ! 102 !blen(vidx) = cnt * extr1 ! MPI: 2D vars moved above ! cexpkbm ! cexpkdm ! bal vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( bal % drybal ( off ), vaddr ( vidx ), ierr ) ! 103 blen ( vidx ) = cnt * extr1 ! MPI: remove ebal from exchanged data, calculate temp val on the master !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%ebal(off), vaddr(vidx), ierr) ! 104 !blen(vidx) = cnt * extr1 ! MPI: remove ebal_tot from exchanged data, calculate val on the master !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%ebal_tot(off), vaddr(vidx), ierr) ! 105 !blen(vidx) = cnt * extr1 ! MPI: remove seb from exchanged data, calculate temp val on the master !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%seb(off), vaddr(vidx), ierr) ! 106 !blen(vidx) = cnt * extr1 ! MPI: remove seb_tot from exchanged data, calculate val on the master !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%seb_tot(off), vaddr(vidx), ierr) ! 107 !blen(vidx) = cnt * extr1 !vidx = vidx + 1 ! REAL(r_1) ! MPI: remove evap_tot from exchanged data !CALL MPI_Get_address (bal%evap_tot(off), vaddr(vidx), ierr) ! 108 !blen(vidx) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( bal % osnowd0 ( off ), vaddr ( vidx ), ierr ) ! 109 blen ( vidx ) = cnt * extr1 !vidx = vidx + 1 ! REAL(r_1) ! MPI: remove precip_tot from exchanged data !CALL MPI_Get_address (bal%precip_tot(off), vaddr(vidx), ierr) ! 110 !blen(vidx) = cnt * extr1 !vidx = vidx + 1 ! REAL(r_1) ! MPI: remove rnoff_tot from exchanged data !CALL MPI_Get_address (bal%rnoff_tot(off), vaddr(vidx), ierr) ! 111 !blen(vidx) = cnt * extr1 ! vidx = vidx + 1 ! MPI: remove wbal from exchanged data ! REAL(r_1) ! CALL MPI_Get_address (bal%wbal(off), vaddr(vidx), ierr) ! 112 !blen(vidx) = cnt * extr1 !vidx = vidx + 1 ! MPI: remove wbal_tot from exchanged data ! REAL(r_1) !CALL MPI_Get_address (bal%wbal_tot(off), vaddr(vidx), ierr) ! 113 !blen(vidx) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( bal % wbtot0 ( off ), vaddr ( vidx ), ierr ) ! 114 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( bal % wetbal ( off ), vaddr ( vidx ), ierr ) ! 115 blen ( vidx ) = cnt * extr1 ! air vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % rho ( off ), vaddr ( vidx ), ierr ) ! 116 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % volm ( off ), vaddr ( vidx ), ierr ) ! 117 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % rlam ( off ), vaddr ( vidx ), ierr ) ! 118 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % qsat ( off ), vaddr ( vidx ), ierr ) ! 119 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % epsi ( off ), vaddr ( vidx ), ierr ) ! 120 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % visc ( off ), vaddr ( vidx ), ierr ) ! 121 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % psyc ( off ), vaddr ( vidx ), ierr ) ! 122 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % dsatdk ( off ), vaddr ( vidx ), ierr ) ! 123 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( air % cmolar ( off ), vaddr ( vidx ), ierr ) ! 124 blen ( vidx ) = cnt * extr1 ! soil ! MPI: 2D vars moved above ! albsoil vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % bch ( off ), vaddr ( vidx ), ierr ) ! 125 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % c3 ( off ), vaddr ( vidx ), ierr ) ! 126 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % clay ( off ), vaddr ( vidx ), ierr ) ! 127 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % cnsd ( off ), vaddr ( vidx ), ierr ) ! 128 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % css ( off ), vaddr ( vidx ), ierr ) ! 129 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % hsbh ( off ), vaddr ( vidx ), ierr ) ! 130 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % hyds ( off ), vaddr ( vidx ), ierr ) ! 131 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! INTEGER(i_d) CALL MPI_Get_address ( soil % i2bp3 ( off ), vaddr ( vidx ), ierr ) ! 132 ! Maciej: i2bp3 is REAL !     blen(vidx) = cnt * extid blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! INTEGER(i_d) CALL MPI_Get_address ( soil % ibp2 ( off ), vaddr ( vidx ), ierr ) ! 133 ! Maciej: ibp2 is REAL !     blen(vidx) = cnt * extid blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! INTEGER(i_d) CALL MPI_Get_address ( soil % isoilm ( off ), vaddr ( vidx ), ierr ) ! 134 blen ( vidx ) = cnt * extid vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % rhosoil ( off ), vaddr ( vidx ), ierr ) ! 135 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % rs20 ( off ), vaddr ( vidx ), ierr ) ! 136 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % sand ( off ), vaddr ( vidx ), ierr ) ! 137 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % sfc ( off ), vaddr ( vidx ), ierr ) ! 138 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % silt ( off ), vaddr ( vidx ), ierr ) ! 139 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % ssat ( off ), vaddr ( vidx ), ierr ) ! 140 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % sucs ( off ), vaddr ( vidx ), ierr ) ! 141 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( soil % swilt ( off ), vaddr ( vidx ), ierr ) ! 142 blen ( vidx ) = cnt * extr1 ! veg vidx = vidx + 1 ! INTEGER(i_d) CALL MPI_Get_address ( veg % iveg ( off ), vaddr ( vidx ), ierr ) ! 143 blen ( vidx ) = cnt * extid vidx = vidx + 1 ! INTEGER(i_d) CALL MPI_Get_address ( veg % meth ( off ), vaddr ( vidx ), ierr ) ! 144 ! Maciej: veg%meth is REAL !     blen(vidx) = cnt * extid blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % vlai ( off ), vaddr ( vidx ), ierr ) ! 145 blen ( vidx ) = cnt * extr1 ! MPI: 2D vars moved above ! froot vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % canst1 ( off ), vaddr ( vidx ), ierr ) ! 146 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % ejmax ( off ), vaddr ( vidx ), ierr ) ! 147 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % frac4 ( off ), vaddr ( vidx ), ierr ) ! 148 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % wai ( off ), vaddr ( vidx ), ierr ) ! 149 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % vegcf ( off ), vaddr ( vidx ), ierr ) ! 150 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % tminvj ( off ), vaddr ( vidx ), ierr ) ! 151 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % tmaxvj ( off ), vaddr ( vidx ), ierr ) ! 152 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % vbeta ( off ), vaddr ( vidx ), ierr ) ! 153 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % xalbnir ( off ), vaddr ( vidx ), ierr ) ! 154 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % hc ( off ), vaddr ( vidx ), ierr ) ! 155 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % shelrb ( off ), vaddr ( vidx ), ierr ) ! 156 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % vcmax ( off ), vaddr ( vidx ), ierr ) ! 157 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % xfang ( off ), vaddr ( vidx ), ierr ) ! 158 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % dleaf ( off ), vaddr ( vidx ), ierr ) ! 159 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % rp20 ( off ), vaddr ( vidx ), ierr ) ! 160 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % rpcoef ( off ), vaddr ( vidx ), ierr ) ! 161 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! REAL(r_1) CALL MPI_Get_address ( veg % extkn ( off ), vaddr ( vidx ), ierr ) ! 162 blen ( vidx ) = cnt * extr1 vidx = vidx + 1 ! LOGICAL CALL MPI_Get_address ( veg % deciduous ( off ), vaddr ( vidx ), ierr ) ! 163 blen ( vidx ) = cnt * extl vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % GWwb ( off ), vaddr ( vidx ), ierr ) ! 40 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % wtd ( off ), vaddr ( vidx ), ierr ) ! 40 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % satfrac ( off ), vaddr ( vidx ), ierr ) ! 40 blen ( vidx ) = cnt * extr2 vidx = vidx + 1 ! REAL(r_2) CALL MPI_Get_address ( ssnow % Qrecharge ( off ), vaddr ( vidx ), ierr ) ! 40 blen ( vidx ) = cnt * extr2 ! additional for SLI vidx = vidx + 1 CALL MPI_Get_address ( ssnow % Tsurface ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr2 vidx = vidx + 1 CALL MPI_Get_address ( ssnow % h0 ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr2 vidx = vidx + 1 CALL MPI_Get_address ( ssnow % delwcol ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr2 vidx = vidx + 1 CALL MPI_Get_address ( ssnow % evap ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr2 vidx = vidx + 1 CALL MPI_Get_address ( ssnow % nsnow ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extid vidx = vidx + 1 CALL MPI_Get_address ( ssnow % nsteps ( off ), vaddr ( vidx ), ierr ) blen ( vidx ) = cnt * extr2 ! end additional for SLI ! MPI: sanity check IF ( vidx /= nvec ) THEN WRITE ( * , * ) 'master: outtype invalid nvec ' , vidx , ' constant, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF ! MPI: all vectors into a single hindexed type for each worker CALL MPI_Type_create_hindexed ( vidx , blen , vaddr , MPI_BYTE , vec_t ( rank ), & & ierr ) CALL MPI_Type_commit ( vec_t ( rank ), ierr ) ! MPI: TODO: each worker's all types into a single struct ! 1 slice of 3D array (hvector), displacement offset ! TODO: displ(1) not set! istart = 0 blocks ( istart + 1 ) = 1 ! 1 copy of hvector displs ( istart + 1 ) = m3daddr ( istart + 1 ) types ( istart + 1 ) = m3d_t ( istart + 1 , rank ) ! 29 slices of matrices (hvector), displacements maddr array istart = istart + n3d DO i = 1 , midx !blocks(istart + i) = extent or size of mat_t? blocks ( istart + i ) = 1 ! single copy of mat_t displs ( istart + i ) = maddr ( i ) types ( istart + i ) = mat_t ( i , rank ) END DO ! 163 hindexed, displacements vaddr istart = istart + midx DO i = 1 , vidx blocks ( istart + i ) = blen ( i ) displs ( istart + i ) = vaddr ( i ) types ( istart + i ) = MPI_BYTE END DO ! total: 184 CALL MPI_Type_create_struct ( vidx + midx + 1 , blocks , displs , types , recv_ts ( rank ), ierr ) CALL MPI_Type_commit ( recv_ts ( rank ), ierr ) CALL MPI_Type_size ( recv_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( recv_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'master: data recv from ' , rank , ': size, extent, lb: ' , & & tsize , text , tmplb totalrecv = totalrecv + tsize END DO WRITE ( * , * ) 'total data size received from all workers: ' , totalrecv ! MPI: check whether total size of received data equals total ! data sent by all the workers totalsend = 0 CALL MPI_Reduce ( MPI_IN_PLACE , totalsend , 1 , MPI_INTEGER , MPI_SUM , & & 0 , comm , ierr ) WRITE ( * , * ) 'total data size sent by all workers: ' , totalsend IF ( totalrecv /= totalsend ) THEN WRITE ( * , * ) 'error master: totalsend and totalrecv differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF DEALLOCATE ( blen ) DEALLOCATE ( vaddr ) DEALLOCATE ( maddr ) DEALLOCATE ( m3daddr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE master_outtypes ! MPI: creates handles for receiving casa final results from the workers SUBROUTINE master_casa_types ( comm , casapool , casaflux , & casamet , casabal , phen ) USE mpi USE cable_def_types_mod USE casadimension USE casavariable USE phenvariable IMPLICIT NONE INTEGER :: comm ! MPI communicator to talk to the workers TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! MPI: temp arrays for marshalling all types into a struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types INTEGER :: ntyp ! number of worker's types INTEGER :: last2d , i ! MPI: block lenghts for hindexed representing all vectors INTEGER , ALLOCATABLE , DIMENSION (:) :: blen ! MPI: block lengths and strides for hvector representing matrices INTEGER :: r1len , r2len , I1LEN INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride , istride INTEGER :: tsize , totalrecv , totalsend INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: rank , off , cnt INTEGER :: bidx , midx , vidx , ierr ALLOCATE ( casa_ts ( wnp )) ! MPI: allocate temp vectors used for marshalling ntyp = ncasa_mat + ncasa_vec + ( nphen - 1 ) ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) r1stride = mp * extr1 r2stride = mp * extr2 istride = mp * extid ! counter to sum total number of bytes receives from all workers totalrecv = 0 DO rank = 1 , wnp off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r2len = cnt * extr2 I1LEN = cnt * extid bidx = 0 ! ------------- 2D arrays ------------- bidx = bidx + 1 CALL MPI_Get_address ( casapool % cplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % clitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % csoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % nplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % nlitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % nsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % pplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % plitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPCplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNClitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPClitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPCsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 ! added by YPW bidx = bidx + 1 CALL MPI_Get_address ( casapool % cwoodprod ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mwood , r2len , r2stride , MPI_BYTE , types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % nwoodprod ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mwood , r2len , r2stride , MPI_BYTE , types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % pwoodprod ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mwood , r2len , r2stride , MPI_BYTE , types ( bidx ), ierr ) blocks ( bidx ) = 1 !============ypw bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphase ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mphase , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % phasespin ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_1 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_2 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_3 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_4 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mdyear , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cplant_turnover ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracCalloc ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracNalloc ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracPalloc ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crmplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromPtoL ( off , 1 , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant * mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casaflux % klitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % ksoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = msoil * r2len ! gol124: temp only ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromLtoS ( off , 1 , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil * mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = msoil * mlitter * r2len ! gol124: temp only ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromStoS ( off , 1 , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil * msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = msoil * msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromLtoCO2 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromStoCO2 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtolitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxNtolitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxPtolitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtosoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxNtosoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxPtosoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 !blocks(bidx) = msoil * r2len ! ------------- 1D vectors ------------- last2d = bidx bidx = bidx + 1 CALL MPI_Get_address ( casamet % glai ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( phen % phase ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % phen ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( phen % aphen ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( casapool % clabile ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Ctot ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Ctot_0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % nsoilmin ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoillab ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoilsorb ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoilocc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % psorbmax ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumcbal ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumnbal ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumpbal ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCgppyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCnppyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmleafyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmwoodyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmrootyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrgrowyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrpyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrsyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCneeyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNdepyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNfixyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNsnetyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNupyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNleachyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNlossyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPweayear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPdustyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPsnetyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPupyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPleachyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPlossyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !***************************** bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cgpp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cnpp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crgplant ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminfix ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminuptake ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Plabuptake ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Clabloss ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracClabile ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cnep ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crsoil ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nmindep ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminloss ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminleach ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nupland ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nlittermin ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsmin ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsimm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsnet ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !**************************************************** bidx = bidx + 1 CALL MPI_Get_address ( casaflux % frac_sapwood ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % sapwood_area ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cplant_turnover_disturbance ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cplant_turnover_crowding ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cplant_turnover_resource_limitation ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len types ( last2d + 1 : bidx ) = MPI_BYTE ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'master: invalid number of casa fields, fix it!' WRITE ( * , * ) 'ntyp: ' , ntyp , 'bidx: ' , bidx CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blocks , displs , types , casa_ts ( rank ), ierr ) CALL MPI_Type_commit ( casa_ts ( rank ), ierr ) CALL MPI_Type_size ( casa_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( casa_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'casa results recv from worker, size, extent, lb: ' , & & rank , tsize , text , tmplb totalrecv = totalrecv + tsize ! free the partial types used for matrices ! TODO: also free partial types for intypes, outtypes etc. DO i = 1 , last2d CALL MPI_Type_free ( types ( i ), ierr ) END DO END DO WRITE ( * , * ) 'total size of casa results received from all workers: ' , totalrecv ! MPI: check whether total size of received data equals total ! data sent by all the workers totalsend = 0 CALL MPI_Reduce ( MPI_IN_PLACE , totalsend , 1 , MPI_INTEGER , MPI_SUM , & & 0 , comm , ierr ) WRITE ( * , * ) 'total size of casa results sent by all workers: ' , totalsend IF ( totalrecv /= totalsend ) THEN WRITE ( * , * ) 'error: casa results totalsend and totalrecv differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE master_casa_types SUBROUTINE master_climate_types ( comm , climate , ktauday ) USE mpi USE cable_def_types_mod , ONLY : climate_type , mp USE cable_climate_mod , ONLY : climate_init , READ_CLIMATE_RESTART_NC USE cable_common_module , ONLY : CABLE_USER TYPE ( climate_type ) :: climate INTEGER :: comm ! MPI: temp arrays for marshalling all types into a struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types INTEGER :: ntyp ! number of worker's types INTEGER :: last2d , i , ktauday ! MPI: block lenghts for hindexed representing all vectors INTEGER , ALLOCATABLE , DIMENSION (:) :: blen ! MPI: block lengths and strides for hvector representing matrices INTEGER :: r1len , r2len , I1LEN INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride INTEGER :: tsize , totalrecv , totalsend INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: rank , off , cnt INTEGER :: bidx , midx , vidx , ierr , ny , nd , ndq IF ( cable_user % call_climate ) CALL climate_init ( climate , mp , ktauday ) IF ( cable_user % call_climate . AND .(. NOT . cable_user % climate_fromzero )) & CALL READ_CLIMATE_RESTART_NC ( climate , ktauday ) ALLOCATE ( climate_ts ( wnp )) ! MPI: allocate temp vectors used for marshalling ntyp = nclimate ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) r1stride = mp * extr1 r2stride = mp * extr2 ! counter to sum total number of bytes receives from all workers totalrecv = 0 DO rank = 1 , wnp off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r2len = cnt * extr2 I1LEN = cnt * extid bidx = 0 ! ------------- 2D arrays ------------- ny = climate % nyear_average nd = climate % nday_average ndq = 91 !print*, 'master, nd ny mp', nd, ny,mp !print*, 'master, size(climate)', size(climate%mtemp_min_20) bidx = bidx + 1 !types(bidx)  = MPI_REAL CALL MPI_Get_address ( climate % mtemp_min_20 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ny , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 ! print*, 'master', blocks, bidx, ny, r1len, displs, ierr, climate%mtemp_min_20(off,:) bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_max_20 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ny , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( climate % alpha_PT_20 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ny , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( climate % dtemp_31 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nd , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( climate % dtemp_91 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ndq , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( climate % dmoist_31 ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( nd , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 ! ------------- 1D vectors ------------- bidx = bidx + 1 CALL MPI_Get_address ( climate % chilldays ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = i1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % iveg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = i1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % biome ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = i1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % dtemp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % dmoist ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % qtemp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mmoist ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_min ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_max ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % qtemp_max ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % qtemp_max_last_year ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_min20 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_max20 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % atemp_mean ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % agdd5 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % gdd5 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % agdd0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % gdd0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % alpha_PT ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % evap_PT ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % aevap ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE ! ------------- scalars  ------------- bidx = bidx + 1 CALL MPI_Get_address ( climate % nyears , displs ( bidx ), ierr ) blocks ( bidx ) = extid types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % doy , displs ( bidx ), ierr ) blocks ( bidx ) = extid types ( bidx ) = MPI_BYTE ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'master: invalid number of climate fields, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blocks , displs , types , climate_ts ( rank ), ierr ) CALL MPI_Type_commit ( climate_ts ( rank ), ierr ) CALL MPI_Type_size ( climate_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( climate_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'climate results recv from worker, size, extent, lb: ' , & & rank , tsize , text , tmplb totalrecv = totalrecv + tsize END DO WRITE ( * , * ) 'total size of climate results received from all workers: ' , totalrecv ! MPI: check whether total size of received data equals total ! data sent by all the workers totalsend = 0 CALL MPI_Reduce ( MPI_IN_PLACE , totalsend , 1 , MPI_INTEGER , MPI_SUM , & & 0 , comm , ierr ) WRITE ( * , * ) 'total size of climate results sent by all workers: ' , totalsend IF ( totalrecv /= totalsend ) THEN WRITE ( * , * ) 'error: climate results totalsend and totalrecv differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF DO rank = 1 , wnp CALL MPI_ISend ( MPI_BOTTOM , 1 , climate_ts ( rank ), rank , 0 , comm , & & inp_req ( rank ), ierr ) END DO CALL MPI_Waitall ( wnp , inp_req , inp_stats , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE master_climate_types !MPI !CLNSUBROUTINE master_casa_restart_types( comm, casamet, casapool ) !CLN !CLN    USE mpi !CLN !CLN  USE casavariable, ONLY: casa_met, casa_pool !CLN !CLN  IMPLICIT NONE !CLN !CLN  INTEGER,INTENT(IN) :: comm !CLN  TYPE (casa_met)    , INTENT(OUT) :: casamet !CLN  TYPE (casa_pool)   , INTENT(OUT) :: casapool !CLN !CLN  ! local vars !CLN !CLN  ! temp arrays for marshalling all fields into a single struct !CLN  INTEGER, ALLOCATABLE, DIMENSION(:) :: blocks !CLN  INTEGER(KIND=MPI_ADDRESS_KIND), ALLOCATABLE, DIMENSION(:) :: displs !CLN  INTEGER, ALLOCATABLE, DIMENSION(:) :: types !CLN !CLN  ! temp vars for verifying block number and total length of inp_t !CLN  INTEGER(KIND=MPI_ADDRESS_KIND) :: text, tmplb !CLN  INTEGER :: tsize, localtotal, remotetotal !CLN !CLN  INTEGER(KIND=MPI_ADDRESS_KIND) :: r1stride !CLN  INTEGER :: r1len, r2len, I1LEN, llen ! block lengths !CLN  INTEGER :: bidx ! block index !CLN  INTEGER :: ntyp ! total number of blocks !CLN  INTEGER :: rank ! worker rank !CLN  INTEGER :: off  ! first patch index for a worker !CLN  INTEGER :: cnt  ! mp for a worker !CLN  INTEGER :: ierr !CLN !CLN  ALLOCATE (casa_dump_ts(wnp)) !CLN !CLN  ntyp = ncdumprw !CLN !CLN  ALLOCATE (blocks(ntyp)) !CLN  ALLOCATE (displs(ntyp)) !CLN  ALLOCATE (types(ntyp)) !CLN !CLN  ! chunks of all 1D vectors are contiguous blocks of memory so just send them !CLN  ! as blocks of bytes !CLN  types = MPI_BYTE !CLN !CLN  ! total size of input data sent to all workers !CLN  localtotal = 0 !CLN !CLN  ! create a separate MPI derived datatype for each worker !CLN  DO rank = 1, wnp !CLN !CLN     ! starting patch and number for each worker rank !CLN     off = wland(rank)%patch0 !CLN     cnt = wland(rank)%npatch !CLN !CLN     r1len = cnt * extr1 !CLN !CLN     r1stride = mp * extr1 !CLN !CLN     ! casamet fields !CLN !CLN     bidx = 1 !CLN     CALL MPI_Get_address (casamet%glai(off), displs(bidx), ierr) !CLN     blocks(bidx) = r1len !CLN !CLN     ! casapool fields !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%clabile(off), displs(bidx), ierr) !CLN     blocks(bidx) = r1len !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%psoillab(off), displs(bidx), ierr) !CLN     blocks(bidx) = r1len !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%psoilsorb(off), displs(bidx), ierr) !CLN     blocks(bidx) = r1len !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%psoilocc(off), displs(bidx), ierr) !CLN     blocks(bidx) = r1len !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%cplant(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%nplant(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%pplant(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%cplant(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%clitter(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%nlitter(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%csoil(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%nsoil(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     bidx = bidx + 1 !CLN     CALL MPI_Get_address (casapool%psoil(off,1), displs(bidx), ierr) !CLN     CALL MPI_Type_create_hvector (swb, r1len, r1stride, MPI_BYTE, & !CLN          types(bidx), ierr) !CLN     blocks(bidx) = 1 !CLN !CLN     ! MPI: sanity check !CLN     IF (bidx /= ntyp) THEN !CLN        WRITE (*,*) 'master: invalid intype in master_casa_dump, fix it!' !CLN        CALL MPI_Abort (comm, 1, ierr) !CLN     END IF !CLN !CLN     ! marshall all fields into a single MPI derived datatype for worker rank !CLN !CLN     CALL MPI_Type_create_struct (bidx, blocks, displs, types, casa_restart_ts(rank), ierr) !CLN     CALL MPI_Type_commit (casa_restart_ts(rank), ierr) !CLN !CLN     CALL MPI_Type_size (casa_restart_ts(rank), tsize, ierr) !CLN     CALL MPI_Type_get_extent (casa_restart_ts(rank), tmplb, text, ierr) !CLN !CLN     WRITE (*,*) 'master to ',rank,': intype struct blocks, size, extent and lb: ', & !CLN                 bidx,tsize,text,tmplb !CLN !CLN     localtotal = localtotal + tsize !CLN !CLN  END DO ! rank !CLN !CLN  DEALLOCATE(types) !CLN  DEALLOCATE(displs) !CLN  DEALLOCATE(blocks) !CLN !CLN  WRITE (*,*) 'total casa_dump size sent to all workers: ', localtotal !CLN !CLN  ! MPI: check whether total size of send input data equals total !CLN  ! data received by all the workers !CLN  remotetotal = 0 !CLN  CALL MPI_Reduce (MPI_IN_PLACE, remotetotal, 1, MPI_INTEGER, MPI_SUM, 0, comm, ierr) !CLN !CLN  WRITE (*,*) 'total input data size received by all workers: ', remotetotal !CLN !CLN  IF (localtotal /= remotetotal) THEN !CLN          WRITE (*,*) 'error: total length of input data sent and received differ' !CLN          CALL MPI_Abort (comm, 0, ierr) !CLN  END IF !CLN !CLNEND SUBROUTINE master_casa_restart_types ! MPI: creates datatype handles to receive restart data from workers SUBROUTINE master_restart_types ( comm , canopy , air ) USE mpi USE cable_def_types_mod USE casadimension USE casavariable IMPLICIT NONE INTEGER :: comm ! MPI communicator to talk to the workers TYPE ( canopy_type ), INTENT ( IN ) :: canopy TYPE ( air_type ), INTENT ( IN ) :: air !  TYPE (casa_pool),           INTENT(INOUT) :: casapool !  TYPE (casa_flux),           INTENT(INOUT) :: casaflux !  TYPE (casa_met),            INTENT(INOUT) :: casamet !  TYPE (casa_balance),        INTENT(INOUT) :: casabal ! MPI: temp arrays for marshalling all types into a struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types INTEGER :: ntyp ! number of worker's types INTEGER :: last2d , i ! MPI: block lenghts for hindexed representing all vectors INTEGER , ALLOCATABLE , DIMENSION (:) :: blen ! MPI: block lengths and strides for hvector representing matrices INTEGER :: r1len , r2len INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride INTEGER :: tsize , totalrecv , totalsend INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: rank , off , cnt INTEGER :: bidx , midx , vidx , ierr ALLOCATE ( restart_ts ( wnp )) ! MPI: allocate temp vectors used for marshalling ntyp = nrestart ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) r1stride = mp * extr1 r2stride = mp * extr2 ! counter to sum total number of bytes receives from all workers totalrecv = 0 DO rank = 1 , wnp off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r2len = cnt * extr2 bidx = 0 ! ------------- 2D arrays ------------- !     bidx = bidx + 1 !     CALL MPI_Get_address (canopy%rwater(off,1), displs(bidx), ierr) ! 1 !     CALL MPI_Type_create_hvector (ms, r1len, r1stride, MPI_BYTE, & !     &                             types(bidx), ierr) !     blocks(bidx) = 1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % evapfbl ( off , 1 ), displs ( bidx ), ierr ) ! 2 ! MPI: gol124: changed to r1 when Bernard ported to CABLE_r491 CALL MPI_Type_create_hvector ( ms , r1len , r1stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 last2d = bidx ! ------------- 1D vectors ------------- bidx = bidx + 1 CALL MPI_Get_address ( canopy % cduv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % dewmm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % dgdtg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpw ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpr ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % rho ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % volm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % qsat ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % epsi ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % visc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % psyc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % dsatdk ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % cmolar ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( last2d + 1 : bidx ) = MPI_BYTE ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'master: invalid number of restart fields, fix it!' WRITE ( * , * ) 'bidx' , bidx WRITE ( * , * ) 'ntyp' , ntyp CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blocks , displs , types , restart_ts ( rank ), ierr ) CALL MPI_Type_commit ( restart_ts ( rank ), ierr ) CALL MPI_Type_size ( restart_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( restart_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'restart results recv from worker, size, extent, lb: ' , & & rank , tsize , text , tmplb totalrecv = totalrecv + tsize ! free the partial types used for matrices DO i = 1 , last2d CALL MPI_Type_free ( types ( i ), ierr ) END DO END DO WRITE ( * , * ) 'total size of restart fields received from all workers: ' , totalrecv ! MPI: check whether total size of received data equals total ! data sent by all the workers totalsend = 0 CALL MPI_Reduce ( MPI_IN_PLACE , totalsend , 1 , MPI_INTEGER , MPI_SUM , & & 0 , comm , ierr ) WRITE ( * , * ) 'total size of restart fields sent by all workers: ' , totalsend IF ( totalrecv /= totalsend ) THEN WRITE ( * , * ) 'error: restart fields totalsend and totalrecv differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE master_restart_types ! MPI: Casa - dump read and write SUBROUTINE master_casa_dump_types ( comm , casamet , casaflux , phen , climate ) USE mpi USE casavariable , ONLY : casa_met , casa_flux USE cable_def_types_mod , ONLY : climate_type USE phenvariable IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm TYPE ( casa_flux ) , INTENT ( INOUT ) :: casaflux TYPE ( casa_met ) , INTENT ( INOUT ) :: casamet TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( climate_type ) :: climate ! local vars ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize , localtotal , remotetotal INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride , Istride INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank ! worker rank INTEGER :: off ! first patch index for a worker INTEGER :: cnt ! mp for a worker INTEGER :: ierr ALLOCATE ( casa_dump_ts ( wnp )) ntyp = ncdumprw ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! chunks of all 1D vectors are contiguous blocks of memory so just send them ! as blocks of bytes types = MPI_BYTE ! total size of input data sent to all workers localtotal = 0 ! create a separate MPI derived datatype for each worker DO rank = 1 , wnp ! starting patch and number for each worker rank off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r1stride = mp * extr1 I1LEN = cnt * extid istride = mp * extid r2len = cnt * extr2 r2stride = mp * extr2 ! casamet fields bidx = 1 CALL MPI_Get_address ( casamet % tairk ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % tsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casamet % moist ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ms , r2len , r2stride , MPI_BYTE , & types ( bidx ), ierr ) blocks ( bidx ) = 1 ! casaflux fields bidx = bidx + 1 CALL MPI_Get_address ( casaflux % cgpp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % crmplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( ncp , r2len , r2stride , MPI_BYTE , & types ( bidx ), ierr ) blocks ( bidx ) = 1 !**************************************************************** ! phen fields bidx = bidx + 1 CALL MPI_Get_address ( phen % phase ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphase ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mphase , I1LEN , istride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 ! #294 - Avoid malformed var write for now ! bidx = bidx + 1 ! CALL MPI_Get_address (climate%mtemp_max(off), displs(bidx), ierr) ! blocks(bidx) = r1len !**************************************************************** ! Ndep bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nmindep ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !****************************************************************** ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'master: invalid intype in master_casa_dump, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF ! marshall all fields into a single MPI derived datatype for worker rank CALL MPI_Type_create_struct ( bidx , blocks , displs , types , casa_dump_ts ( rank ), ierr ) CALL MPI_Type_commit ( casa_dump_ts ( rank ), ierr ) CALL MPI_Type_size ( casa_dump_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( casa_dump_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'master to ' , rank , ': intype struct blocks, size, extent and lb: ' , & bidx , tsize , text , tmplb localtotal = localtotal + tsize END DO ! ranks DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) WRITE ( * , * ) 'total casa_dump size sent to all workers: ' , localtotal ! MPI: check whether total size of send input data equals total ! data received by all the workers remotetotal = 0 CALL MPI_Reduce ( MPI_IN_PLACE , remotetotal , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) WRITE ( * , * ) 'total input data size received by all workers: ' , remotetotal IF ( localtotal /= remotetotal ) THEN WRITE ( * , * ) 'error: total length of input data sent and received differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF !!$  DO rank = 1, wnp !!$ !!$     CALL MPI_ISend (MPI_BOTTOM, 1, casa_dump_ts(rank), rank, 0, comm, & !!$          &               inp_req(rank), ierr) !!$ !!$  END DO !!$ !!$  CALL MPI_Waitall (wnp, inp_req, inp_stats, ierr) END SUBROUTINE master_casa_dump_types ! ############################################################################################################# ! MPI: Casa-LUC: exchanging casapools between master and worker, as required for LUC updates SUBROUTINE master_casa_LUC_types ( comm , casapool , casabal ) USE mpi USE casavariable , ONLY : casa_pool , mplant , mlitter , msoil , casa_balance IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm TYPE ( casa_pool ), INTENT ( IN ) :: casapool TYPE ( casa_balance ), INTENT ( IN ) :: casabal ! local vars ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize , localtotal , remotetotal INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride , Istride INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank ! worker rank INTEGER :: off ! first patch index for a worker INTEGER :: cnt ! mp for a worker INTEGER :: ierr ALLOCATE ( casa_LUC_ts ( wnp )) ntyp = nLUCrw ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! chunks of all 1D vectors are contiguous blocks of memory so just send them ! as blocks of bytes types = MPI_BYTE ! total size of input data sent to all workers localtotal = 0 ! create a separate MPI derived datatype for each worker DO rank = 1 , wnp ! starting patch and number for each worker rank off = wland ( rank )% patch0 cnt = wland ( rank )% npatch r1len = cnt * extr1 r1stride = mp * extr1 I1LEN = cnt * extid istride = mp * extid r2len = cnt * extr2 r2stride = mp * extr2 bidx = 0 ! casapool fields bidx = bidx + 1 CALL MPI_Get_address ( casapool % cplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % clitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % csoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % nplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % nlitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % nsoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % pplant ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mplant , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % plitter ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( mlitter , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoil ( off , 1 ), displs ( bidx ), ierr ) CALL MPI_Type_create_hvector ( msoil , r2len , r2stride , MPI_BYTE , & & types ( bidx ), ierr ) blocks ( bidx ) = 1 bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nsoilmin ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % clabile ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len ! casabal fields bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCneeyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'master: invalid intype in master_casa_LUC, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF ! marshall all fields into a single MPI derived datatype for worker rank CALL MPI_Type_create_struct ( bidx , blocks , displs , types , casa_LUC_ts ( rank ), ierr ) CALL MPI_Type_commit ( casa_LUC_ts ( rank ), ierr ) CALL MPI_Type_size ( casa_LUC_ts ( rank ), tsize , ierr ) CALL MPI_Type_get_extent ( casa_LUC_ts ( rank ), tmplb , text , ierr ) WRITE ( * , * ) 'master to ' , rank , ': intype struct blocks, size, extent and lb: ' , & bidx , tsize , text , tmplb localtotal = localtotal + tsize END DO ! ranks DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) WRITE ( * , * ) 'total casa_LUC size sent to all workers: ' , localtotal ! MPI: check whether total size of send input data equals total ! data received by all the workers remotetotal = 0 CALL MPI_Reduce ( MPI_IN_PLACE , remotetotal , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) WRITE ( * , * ) 'total input data size received by all workers: ' , remotetotal IF ( localtotal /= remotetotal ) THEN WRITE ( * , * ) 'error: total length of input data sent and received differ' CALL MPI_Abort ( comm , 0 , ierr ) END IF END SUBROUTINE master_casa_LUC_types ! ******************************************************************************************* ! MPI ! Creates pop_ts types to broadcast/cscatter the default POP parameters ! to all workers SUBROUTINE master_pop_types ( comm , casamet , pop ) USE mpi USE POP_mpi USE POP_types , ONLY : pop_type USE cable_common_module , ONLY : cable_user USE casavariable , ONLY : casa_met IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm TYPE ( casa_met ) , INTENT ( IN ) :: casamet TYPE ( pop_type ) , INTENT ( INOUT ) :: pop ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize , localtotal , remotetotal INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r2stride , ilstride , idstride INTEGER :: r2len , illen , idlen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank ! worker rank INTEGER :: off ! first patch index for a worker INTEGER :: cnt ! mp for a worker INTEGER :: ierr INTEGER :: x , l , prev_mp INTEGER , ALLOCATABLE :: w_iwood (:), nwoodcells (:) ! Also send Pop relevant info to workers. prev_mp = 0 DO rank = 1 , wnp off = wland ( rank )% patch0 ! number of forest or shrub patches per worker wland ( rank )% npop_iwood = & COUNT ( POP % Iwood . GE . off . AND . POP % Iwood . LT . ( off + wland ( rank )% npatch )) CALL MPI_Send ( wland ( rank )% npop_iwood , 1 , MPI_INTEGER , rank , 0 , comm , ierr ) ! Index mapping for pop-pixels for each worker ALLOCATE ( wland ( rank )% iwood ( wland ( rank )% npop_iwood ) ) ALLOCATE ( w_iwood ( wland ( rank )% npop_iwood ) ) ! Array of indeces in master domain wland ( rank )% iwood (:) = PACK ( POP % Iwood , ( POP % Iwood . GE . off . AND . POP % Iwood . LT . ( off + wland ( rank )% npatch ))) ! Index of patch in worker domain w_iwood (:) = wland ( rank )% iwood (:) - prev_mp CALL MPI_Send ( w_iwood , wland ( rank )% npop_iwood , MPI_INTEGER , rank , 0 , comm , ierr ) DEALLOCATE ( w_iwood ) ! accounted patches so far prev_mp = prev_mp + wland ( rank )% npatch END DO ! once generate a structure fitting the pop derived types CALL create_pop_gridcell_type ( pop_ts , comm ) ! Send restart stuff once IF ( . NOT . CABLE_USER % POP_fromZero ) THEN off = 1 DO rank = 1 , wnp IF ( rank . GT . 1 ) off = off + wland ( rank - 1 )% npop_iwood cnt = wland ( rank )% npop_iwood ! Maciej: worker_pop_types always call MPI_Recv, even if cnt is zero !        IF ( cnt .EQ. 0 ) CYCLE CALL MPI_Send ( POP % pop_grid ( off ), cnt , pop_ts , rank , 0 , comm , ierr ) END DO !     CALL MPI_Waitall (wnp, inp_req, inp_stats, ierr) ENDIF END SUBROUTINE master_pop_types SUBROUTINE master_receive_pop ( POP , comm ) USE MPI USE POP_mpi USE POP_Types , ONLY : pop_type USE cable_common_module , ONLY : cable_user IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm TYPE ( pop_type ) , INTENT ( INOUT ) :: pop INTEGER :: ierr , rank , off , cnt , stat ( MPI_STATUS_SIZE ) off = 1 DO rank = 1 , wnp IF ( rank . GT . 1 ) off = off + wland ( rank - 1 )% npop_iwood cnt = wland ( rank )% npop_iwood IF ( cnt . EQ . 0 ) CYCLE CALL MPI_Recv ( POP % pop_grid ( off ), cnt , pop_ts , rank , 0 , comm , stat , ierr ) END DO ! NO Waitall here as some workers might not be involved!!! END SUBROUTINE master_receive_pop ! MPI: scatters input data for timestep ktau to all workers SUBROUTINE master_send_input ( comm , dtypes , ktau ) USE mpi IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm INTEGER , DIMENSION (:), INTENT ( IN ) :: dtypes INTEGER , INTENT ( IN ) :: ktau ! timestep INTEGER :: rank , ierr !  IF (.NOT. ALLOCATED(inp_req)) THEN !     ALLOCATE (inp_req(wnp)) !  END IF DO rank = 1 , wnp CALL MPI_ISend ( MPI_BOTTOM , 1 , dtypes ( rank ), rank , ktau , comm , & & inp_req ( rank ), ierr ) END DO !IF (.NOT. ALLOCATED(inp_stats)) THEN !   ALLOCATE (inp_stats(MPI_STATUS_SIZE, wnp)) !END IF CALL MPI_Waitall ( wnp , inp_req , inp_stats , ierr ) RETURN END SUBROUTINE master_send_input ! receives model output variables from the workers for a single timestep ! uses the timestep value as the message tag SUBROUTINE master_receive ( comm , ktau , types ) USE mpi IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm INTEGER , INTENT ( IN ) :: ktau ! timestep ! array with MPI datatype handles for receiving INTEGER , DIMENSION (:), INTENT ( IN ) :: types ! local vars INTEGER :: rank , ierr !IF (.NOT. ALLOCATED(recv_req)) THEN !   ALLOCATE (recv_req(wnp)) !END IF !IF (.NOT. ALLOCATED(recv_stats)) THEN !   ALLOCATE (recv_stats(MPI_STATUS_SIZE, wnp)) !END IF DO rank = 1 , wnp CALL MPI_Irecv ( MPI_BOTTOM , 1 , types ( rank ), rank , ktau , comm , & & recv_req ( rank ), ierr ) END DO ! MPI: we need all timesteps data before processing/saving CALL MPI_Waitall ( wnp , recv_req , recv_stats , ierr ) RETURN END SUBROUTINE master_receive ! TODO: receives variables that are required by create_restart ! but not write_output ! gol124: how about call master_receive (comm, ktau, restart_ts) ! instead of a separate receive_restart sub? !SUBROUTINE receive_restart (comm,ktau,dels,soil,veg,ssnow, & !            &              canopy,rough,rad,bgc,bal) ! ! !  RETURN ! !END SUBROUTINE receive_restart ! frees memory used for data structures specific to the master SUBROUTINE master_end ( icycle , restart ) USE mpi IMPLICIT NONE INTEGER :: icycle ! casa flag LOGICAL :: restart ! restart flag INTEGER :: rank , i , ierr ! MPI: free MPI types DO rank = 1 , wnp CALL MPI_Type_free ( inp_ts ( rank ), ierr ) CALL MPI_Type_free ( recv_ts ( rank ), ierr ) IF ( restart ) THEN CALL MPI_Type_free ( restart_ts ( rank ), ierr ) END IF IF ( icycle > 0 ) THEN CALL MPI_Type_free ( casa_ts ( rank ), ierr ) END IF ! gol124: TODO: m3d_t, mat_t and vec_t can ! be freed at the end of master_outtypes DO i = 1 , n3d CALL MPI_Type_free ( m3d_t ( i , rank ), ierr ) END DO DO i = 1 , nmat CALL MPI_Type_free ( mat_t ( i , rank ), ierr ) END DO CALL MPI_Type_free ( vec_t ( rank ), ierr ) END DO ! MPI: free arrays for receive requests and statuses IF ( ALLOCATED ( recv_stats )) THEN DEALLOCATE ( recv_stats ) END IF IF ( ALLOCATED ( recv_req )) THEN DEALLOCATE ( recv_req ) END IF ! MPI: free arrays for send requests and statuses IF ( ALLOCATED ( inp_stats )) THEN DEALLOCATE ( inp_stats ) END IF IF ( ALLOCATED ( inp_req )) THEN DEALLOCATE ( inp_req ) END IF ! MPI: free derived datatype handle array DEALLOCATE ( inp_ts ) DEALLOCATE ( recv_ts ) IF ( restart ) THEN DEALLOCATE ( restart_ts ) END IF IF ( icycle > 0 ) THEN DEALLOCATE ( casa_ts ) END IF ! MPI: free partial derived datatype handle arrays DEALLOCATE ( vec_t ) DEALLOCATE ( mat_t ) DEALLOCATE ( m3d_t ) ! MPI: free landpoint decomposition info DEALLOCATE ( wland ) RETURN END SUBROUTINE master_end SUBROUTINE master_spincasacnp ( dels , kstart , kend , mloop , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , icomm , ocomm ) !USE cable_mpimaster USE cable_def_types_mod USE cable_carbon_module USE cable_common_module , ONLY : CABLE_USER USE casadimension USE casaparm USE casavariable USE phenvariable USE POP_Types , ONLY : POP_TYPE USE POPMODULE , ONLY : POPStep USE TypeDef , ONLY : i4b , dp IMPLICIT NONE !!CLN  CHARACTER(LEN=99), INTENT(IN)  :: fcnpspin REAL , INTENT ( IN ) :: dels INTEGER , INTENT ( IN ) :: kstart INTEGER , INTENT ( IN ) :: kend INTEGER , INTENT ( IN ) :: mloop INTEGER , INTENT ( IN ) :: LALLOC TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( climate_TYPE ), INTENT ( INOUT ) :: climate ! communicator for error-messages INTEGER , INTENT ( IN ) :: icomm , ocomm TYPE ( casa_met ) :: casaspin ! local variables REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_cleaf2met , avg_cleaf2str , avg_croot2met , avg_croot2str , avg_cwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_nleaf2met , avg_nleaf2str , avg_nroot2met , avg_nroot2str , avg_nwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_pleaf2met , avg_pleaf2str , avg_proot2met , avg_proot2str , avg_pwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_cgpp , avg_cnpp , avg_nuptake , avg_puptake REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_nsoilmin , avg_psoillab , avg_psoilsorb , avg_psoilocc !chris 12/oct/2012 for spin up casa REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_ratioNCsoilmic , avg_ratioNCsoilslow , avg_ratioNCsoilpass REAL ( r_2 ), DIMENSION (:), ALLOCATABLE , SAVE :: avg_xnplimit , avg_xkNlimiting , avg_xklitter , avg_xksoil ! local variables INTEGER :: myearspin , nyear , nloop1 CHARACTER ( LEN = 99 ) :: ncfile CHARACTER ( LEN = 4 ) :: cyear INTEGER :: ktau , ktauday , nday , idoy , ktaux , ktauy , nloop INTEGER , SAVE :: ndays REAL , DIMENSION ( mp ) :: cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd REAL , DIMENSION ( mp ) :: nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd REAL , DIMENSION ( mp ) :: pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd REAL , DIMENSION ( mp ) :: xcgpp , xcnpp , xnuptake , xpuptake REAL , DIMENSION ( mp ) :: xnsoilmin , xpsoillab , xpsoilsorb , xpsoilocc REAL ( r_2 ), DIMENSION ( mp ) :: xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , xkleafcold , xkleafdry ! more variables to store the spinup pool size over the last 10 loops. Added by Yp Wang 30 Nov 2012 REAL , DIMENSION ( 5 , mvtype , mplant ) :: bmcplant , bmnplant , bmpplant REAL , DIMENSION ( 5 , mvtype , mlitter ) :: bmclitter , bmnlitter , bmplitter REAL , DIMENSION ( 5 , mvtype , msoil ) :: bmcsoil , bmnsoil , bmpsoil REAL , DIMENSION ( 5 , mvtype ) :: bmnsoilmin , bmpsoillab , bmpsoilsorb , bmpsoilocc REAL , DIMENSION ( mvtype ) :: bmarea INTEGER nptx , nvt , kloop ktauday = INT ( 2 4.0 * 360 0.0 / dels ) nday = ( kend - kstart + 1 ) / ktauday ktau = 0 myearspin = CABLE_USER % CASA_SPIN_ENDYEAR - CABLE_USER % CASA_SPIN_STARTYEAR + 1 ! compute the mean fluxes and residence time of each carbon pool DO nyear = 1 , myearspin WRITE ( CYEAR , FMT = \"(I4)\" ) CABLE_USER % CASA_SPIN_STARTYEAR + nyear - 1 ncfile = TRIM ( casafile % c2cdumppath ) // 'c2c_' // CYEAR // '_dump.nc' CALL read_casa_dump ( ncfile , casamet , casaflux , phen , climate , ktau , kend ,. TRUE . ) DO idoy = 1 , mdyear ktau = ( idoy - 1 ) * ktauday + 1 casamet % tairk (:) = casamet % Tairkspin (:, idoy ) casamet % tsoil (:, 1 ) = casamet % Tsoilspin_1 (:, idoy ) casamet % tsoil (:, 2 ) = casamet % Tsoilspin_2 (:, idoy ) casamet % tsoil (:, 3 ) = casamet % Tsoilspin_3 (:, idoy ) casamet % tsoil (:, 4 ) = casamet % Tsoilspin_4 (:, idoy ) casamet % tsoil (:, 5 ) = casamet % Tsoilspin_5 (:, idoy ) casamet % tsoil (:, 6 ) = casamet % Tsoilspin_6 (:, idoy ) casamet % moist (:, 1 ) = casamet % moistspin_1 (:, idoy ) casamet % moist (:, 2 ) = casamet % moistspin_2 (:, idoy ) casamet % moist (:, 3 ) = casamet % moistspin_3 (:, idoy ) casamet % moist (:, 4 ) = casamet % moistspin_4 (:, idoy ) casamet % moist (:, 5 ) = casamet % moistspin_5 (:, idoy ) casamet % moist (:, 6 ) = casamet % moistspin_6 (:, idoy ) casaflux % cgpp (:) = casamet % cgppspin (:, idoy ) casaflux % crmplant (:, 1 ) = casamet % crmplantspin_1 (:, idoy ) casaflux % crmplant (:, 2 ) = casamet % crmplantspin_2 (:, idoy ) casaflux % crmplant (:, 3 ) = casamet % crmplantspin_3 (:, idoy ) phen % phase (:) = phen % phasespin (:, idoy ) phen % doyphase (:, 1 ) = phen % doyphasespin_1 (:, idoy ) phen % doyphase (:, 2 ) = phen % doyphasespin_2 (:, idoy ) phen % doyphase (:, 3 ) = phen % doyphasespin_3 (:, idoy ) phen % doyphase (:, 4 ) = phen % doyphasespin_4 (:, idoy ) climate % mtemp_max (:) = casamet % mtempspin (:, idoy ) CALL master_send_input ( icomm , casa_dump_ts , idoy ) ENDDO ENDDO nloop1 = MAX ( 1 , mloop - 3 ) DO nloop = 1 , mloop WRITE ( * , * ) 'nloop =' , nloop !!CLN  OPEN(91,file=fcnpspin) !!CLN  read(91,*) DO nyear = 1 , myearspin WRITE ( CYEAR , FMT = \"(I4)\" ) CABLE_USER % CASA_SPIN_STARTYEAR + nyear - 1 ncfile = TRIM ( casafile % c2cdumppath ) // 'c2c_' // CYEAR // '_dump.nc' CALL read_casa_dump ( ncfile , casamet , casaflux , phen , climate , ktau , kend , . TRUE . ) DO idoy = 1 , mdyear ktauy = idoy * ktauday casamet % tairk (:) = casamet % Tairkspin (:, idoy ) casamet % tsoil (:, 1 ) = casamet % Tsoilspin_1 (:, idoy ) casamet % tsoil (:, 2 ) = casamet % Tsoilspin_2 (:, idoy ) casamet % tsoil (:, 3 ) = casamet % Tsoilspin_3 (:, idoy ) casamet % tsoil (:, 4 ) = casamet % Tsoilspin_4 (:, idoy ) casamet % tsoil (:, 5 ) = casamet % Tsoilspin_5 (:, idoy ) casamet % tsoil (:, 6 ) = casamet % Tsoilspin_6 (:, idoy ) casamet % moist (:, 1 ) = casamet % moistspin_1 (:, idoy ) casamet % moist (:, 2 ) = casamet % moistspin_2 (:, idoy ) casamet % moist (:, 3 ) = casamet % moistspin_3 (:, idoy ) casamet % moist (:, 4 ) = casamet % moistspin_4 (:, idoy ) casamet % moist (:, 5 ) = casamet % moistspin_5 (:, idoy ) casamet % moist (:, 6 ) = casamet % moistspin_6 (:, idoy ) casaflux % cgpp (:) = casamet % cgppspin (:, idoy ) casaflux % crmplant (:, 1 ) = casamet % crmplantspin_1 (:, idoy ) casaflux % crmplant (:, 2 ) = casamet % crmplantspin_2 (:, idoy ) casaflux % crmplant (:, 3 ) = casamet % crmplantspin_3 (:, idoy ) phen % phase (:) = phen % phasespin (:, idoy ) phen % doyphase (:, 1 ) = phen % doyphasespin_1 (:, idoy ) phen % doyphase (:, 2 ) = phen % doyphasespin_2 (:, idoy ) phen % doyphase (:, 3 ) = phen % doyphasespin_3 (:, idoy ) phen % doyphase (:, 4 ) = phen % doyphasespin_4 (:, idoy ) climate % mtemp_max (:) = casamet % mtempspin (:, idoy ) CALL master_send_input ( icomm , casa_dump_ts , idoy ) ENDDO ! end doy ENDDO ! end of nyear ENDDO ! end of nloop WRITE ( * , * ) 'b4 master receive' CALL master_receive ( ocomm , 0 , casa_ts ) WRITE ( * , * ) 'after master receive' CALL casa_poolout ( ktau , veg , soil , casabiome , & casapool , casaflux , casamet , casabal , phen ) CALL write_casa_restart_nc ( casamet , casapool , casaflux , phen ,. TRUE . ) IF ( CABLE_USER % CALL_POP . AND . POP % np . GT . 0 ) THEN CALL master_receive_pop ( POP , ocomm ) CALL POP_IO ( pop , casamet , myearspin , 'WRITE_INI' , . TRUE .) ENDIF END SUBROUTINE master_spincasacnp !********************************************************************************************* SUBROUTINE master_CASAONLY_LUC ( dels , kstart , kend , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , LUC_EXPT , POPLUC , & icomm , ocomm ) USE cable_def_types_mod USE cable_carbon_module USE cable_common_module , ONLY : CABLE_USER USE casa_ncdf_module , ONLY : is_casa_time USE cable_IO_vars_module , ONLY : logn , landpt , patch , output USE casadimension USE casaparm USE casavariable USE phenvariable USE POP_Types , ONLY : POP_TYPE USE POPMODULE , ONLY : POPStep , POP_init_single USE TypeDef , ONLY : i4b , dp USE CABLE_LUC_EXPT , ONLY : LUC_EXPT_TYPE , read_LUH2 ,& ptos , ptog , stog , gtos , grassfrac , pharv , smharv , syharv USE POPLUC_Types USE POPLUC_Module , ONLY : POPLUCStep , POPLUC_weights_Transfer , WRITE_LUC_OUTPUT_NC , & POP_LUC_CASA_transfer , WRITE_LUC_RESTART_NC , READ_LUC_RESTART_NC , & POPLUC_set_patchfrac , WRITE_LUC_OUTPUT_GRID_NC IMPLICIT NONE REAL , INTENT ( IN ) :: dels INTEGER , INTENT ( IN ) :: kstart INTEGER , INTENT ( IN ) :: kend INTEGER , INTENT ( IN ) :: LALLOC TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( climate_TYPE ), INTENT ( INOUT ) :: climate TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC !TYPE (casa_pool)   , INTENT(INOUT) :: sum_casapool !TYPE (casa_flux)   , INTENT(INOUT) :: sum_casaflux ! communicator for error-messages INTEGER , INTENT ( IN ) :: icomm , ocomm TYPE ( casa_met ) :: casaspin ! local variables REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_cleaf2met , avg_cleaf2str , avg_croot2met , avg_croot2str , avg_cwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_nleaf2met , avg_nleaf2str , avg_nroot2met , avg_nroot2str , avg_nwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_pleaf2met , avg_pleaf2str , avg_proot2met , avg_proot2str , avg_pwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_cgpp , avg_cnpp , avg_nuptake , avg_puptake REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_nsoilmin , avg_psoillab , avg_psoilsorb , avg_psoilocc !chris 12/oct/2012 for spin up casa REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_ratioNCsoilmic , avg_ratioNCsoilslow , avg_ratioNCsoilpass REAL ( r_2 ), DIMENSION (:), ALLOCATABLE , SAVE :: avg_xnplimit , avg_xkNlimiting , avg_xklitter , avg_xksoil ! local variables INTEGER :: myearspin , nyear , yyyy , nyear_dump CHARACTER ( LEN = 99 ) :: ncfile CHARACTER ( LEN = 4 ) :: cyear INTEGER :: ktau , ktauday , nday , idoy , ktaux , ktauy , nloop INTEGER , SAVE :: ndays REAL , DIMENSION ( mp ) :: cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd REAL , DIMENSION ( mp ) :: nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd REAL , DIMENSION ( mp ) :: pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd REAL , DIMENSION ( mp ) :: xcgpp , xcnpp , xnuptake , xpuptake REAL , DIMENSION ( mp ) :: xnsoilmin , xpsoillab , xpsoilsorb , xpsoilocc REAL ( r_2 ), DIMENSION ( mp ) :: xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , xkleafcold , xkleafdry ! more variables to store the spinup pool size over the last 10 loops. Added by Yp Wang 30 Nov 2012 REAL , DIMENSION ( 5 , mvtype , mplant ) :: bmcplant , bmnplant , bmpplant REAL , DIMENSION ( 5 , mvtype , mlitter ) :: bmclitter , bmnlitter , bmplitter REAL , DIMENSION ( 5 , mvtype , msoil ) :: bmcsoil , bmnsoil , bmpsoil REAL , DIMENSION ( 5 , mvtype ) :: bmnsoilmin , bmpsoillab , bmpsoilsorb , bmpsoilocc REAL , DIMENSION ( mvtype ) :: bmarea INTEGER :: nptx , nvt , kloop , ctime , k , j , l REAL ( dp ) :: StemNPP ( mp , 2 ) REAL ( dp ), ALLOCATABLE , SAVE :: LAImax (:) , Cleafmean (:), Crootmean (:) REAL ( dp ), ALLOCATABLE :: NPPtoGPP (:) INTEGER , ALLOCATABLE :: Iw (:) ! array of indices corresponding to woody (shrub or forest) tiles INTEGER :: count_sum_casa ! number of time steps over which casa pools & !and fluxes are aggregated (for output) INTEGER :: rank , count , off , cnt , ierr !!$  if (.NOT.Allocated(LAIMax)) allocate(LAIMax(mp)) !!$  if (.NOT.Allocated(Cleafmean))  allocate(Cleafmean(mp)) !!$  if (.NOT.Allocated(Crootmean)) allocate(Crootmean(mp)) !!$  if (.NOT.Allocated(NPPtoGPP)) allocate(NPPtoGPP(mp)) !!$  if (.NOT.Allocated(Iw)) allocate(Iw(POP%np)) !!$ !!$  IF (cable_user%CALL_POP) THEN !!$     Iw = POP%Iwood !!$  ENDIF ktauday = INT ( 2 4.0 * 360 0.0 / dels ) nday = ( kend - kstart + 1 ) / ktauday !!$  ctime = 0 !!$  CALL zero_sum_casa(sum_casapool, sum_casaflux) !!$       count_sum_casa = 0 myearspin = CABLE_USER % YEAREND - CABLE_USER % YEARSTART + 1 yyyy = CABLE_USER % YEARSTART - 1 DO nyear = 1 , myearspin yyyy = yyyy + 1 WRITE ( * , * ) 'casaonly_LUC' , YYYY nyear_dump = MOD ( nyear , & CABLE_USER % CASA_SPIN_ENDYEAR - CABLE_USER % CASA_SPIN_STARTYEAR + 1 ) IF ( nyear_dump == 0 ) & nyear_dump = CABLE_USER % CASA_SPIN_ENDYEAR - CABLE_USER % CASA_SPIN_STARTYEAR + 1 WRITE ( CYEAR , FMT = \"(I4)\" ) CABLE_USER % CASA_SPIN_STARTYEAR + nyear_dump - 1 ncfile = TRIM ( casafile % c2cdumppath ) // 'c2c_' // CYEAR // '_dump.nc' CALL read_casa_dump ( ncfile , casamet , casaflux , phen , climate , 1 , 1 ,. TRUE . ) !!CLN901  format(A99) DO idoy = 1 , mdyear ktau = ( idoy - 1 ) * ktauday + ktauday casamet % tairk (:) = casamet % Tairkspin (:, idoy ) casamet % tsoil (:, 1 ) = casamet % Tsoilspin_1 (:, idoy ) casamet % tsoil (:, 2 ) = casamet % Tsoilspin_2 (:, idoy ) casamet % tsoil (:, 3 ) = casamet % Tsoilspin_3 (:, idoy ) casamet % tsoil (:, 4 ) = casamet % Tsoilspin_4 (:, idoy ) casamet % tsoil (:, 5 ) = casamet % Tsoilspin_5 (:, idoy ) casamet % tsoil (:, 6 ) = casamet % Tsoilspin_6 (:, idoy ) casamet % moist (:, 1 ) = casamet % moistspin_1 (:, idoy ) casamet % moist (:, 2 ) = casamet % moistspin_2 (:, idoy ) casamet % moist (:, 3 ) = casamet % moistspin_3 (:, idoy ) casamet % moist (:, 4 ) = casamet % moistspin_4 (:, idoy ) casamet % moist (:, 5 ) = casamet % moistspin_5 (:, idoy ) casamet % moist (:, 6 ) = casamet % moistspin_6 (:, idoy ) casaflux % cgpp (:) = casamet % cgppspin (:, idoy ) casaflux % crmplant (:, 1 ) = casamet % crmplantspin_1 (:, idoy ) casaflux % crmplant (:, 2 ) = casamet % crmplantspin_2 (:, idoy ) casaflux % crmplant (:, 3 ) = casamet % crmplantspin_3 (:, idoy ) phen % phase (:) = phen % phasespin (:, idoy ) phen % doyphase (:, 1 ) = phen % doyphasespin_1 (:, idoy ) phen % doyphase (:, 2 ) = phen % doyphasespin_2 (:, idoy ) phen % doyphase (:, 3 ) = phen % doyphasespin_3 (:, idoy ) phen % doyphase (:, 4 ) = phen % doyphasespin_4 (:, idoy ) climate % mtemp_max (:) = casamet % mtempspin (:, idoy ) CALL master_send_input ( icomm , casa_dump_ts , idoy ) !!$        ! zero annual sums !!$        if (idoy==1) CALL casa_cnpflux(casaflux,casapool,casabal,.TRUE.) !!$        CALL biogeochem(ktau,dels,idoy,LALLOC,veg,soil,casabiome,casapool,casaflux, & !!$             casamet,casabal,phen,POP,climate,xnplimit,xkNlimiting,xklitter, & !!$             xksoil,xkleaf,xkleafcold,xkleafdry,& !!$             cleaf2met,cleaf2str,croot2met,croot2str,cwood2cwd,         & !!$             nleaf2met,nleaf2str,nroot2met,nroot2str,nwood2cwd,         & !!$             pleaf2met,pleaf2str,proot2met,proot2str,pwood2cwd) !!$ !!$        ! update time-aggregates of casa pools and fluxes !!$        CALL update_sum_casa(sum_casapool, sum_casaflux, casapool, casaflux, & !!$                            & .TRUE. , .FALSE., 1) !!$        count_sum_casa = count_sum_casa + 1 !!$           ! accumulate annual variables for use in POP !!$           IF(idoy==1 ) THEN !!$              casaflux%stemnpp =  casaflux%cnpp * casaflux%fracCalloc(:,2) * 0.7 ! (assumes 70% of wood NPP is allocated above ground) !!$              LAImax = casamet%glai !!$              Cleafmean = casapool%cplant(:,1)/real(mdyear)/1000. !!$              Crootmean = casapool%cplant(:,3)/real(mdyear)/1000. !!$           ELSE !!$              casaflux%stemnpp = casaflux%stemnpp + casaflux%cnpp * casaflux%fracCalloc(:,2) * 0.7 !!$              LAImax = max(casamet%glai, LAImax) !!$              Cleafmean = Cleafmean + casapool%cplant(:,1)/real(mdyear)/1000. !!$              Crootmean = Crootmean +casapool%cplant(:,3)/real(mdyear)/1000. !!$           ENDIF IF ( idoy == mdyear ) THEN ! end of year ! get casa update from workers CALL master_receive ( ocomm , 0 , casa_LUC_ts ) LUC_EXPT % CTSTEP = yyyy - LUC_EXPT % FirstYear + 1 CALL READ_LUH2 ( LUC_EXPT ) DO k = 1 , mland POPLUC % ptos ( k ) = LUC_EXPT % INPUT ( ptos )% VAL ( k ) POPLUC % ptog ( k ) = LUC_EXPT % INPUT ( ptog )% VAL ( k ) POPLUC % stop ( k ) = 0.0 POPLUC % stog ( k ) = LUC_EXPT % INPUT ( stog )% VAL ( k ) POPLUC % gtop ( k ) = 0.0 POPLUC % gtos ( k ) = LUC_EXPT % INPUT ( gtos )% VAL ( k ) POPLUC % pharv ( k ) = LUC_EXPT % INPUT ( pharv )% VAL ( k ) POPLUC % smharv ( k ) = LUC_EXPT % INPUT ( smharv )% VAL ( k ) POPLUC % syharv ( k ) = LUC_EXPT % INPUT ( syharv )% VAL ( k ) POPLUC % thisyear = yyyy ENDDO ! set landuse index for secondary forest POP landscapes DO k = 1 , POP % np IF ( yyyy . EQ . LUC_EXPT % YearStart ) THEN IF ( veg % iLU ( POP % Iwood ( k )). EQ . 2 ) THEN !POP%LU(k) = 2 POP % pop_grid ( k )% LU = 2 ENDIF ENDIF ENDDO ! zero secondary forest tiles in POP where secondary forest area is zero DO k = 1 , mland IF (( POPLUC % primf ( k ) - POPLUC % frac_forest ( k )) == 0.0 & . AND . (. NOT . LUC_EXPT % prim_only ( k ))) THEN j = landpt ( k )% cstart + 1 DO l = 1 , SIZE ( POP % Iwood ) IF ( POP % Iwood ( l ) == j ) THEN CALL POP_init_single ( POP , veg % disturbance_interval , l ) EXIT ENDIF ENDDO casapool % cplant ( j , leaf ) = 0.01 casapool % nplant ( j , leaf ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), leaf ) * casapool % cplant ( j , leaf ) casapool % pplant ( j , leaf ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), leaf ) * casapool % cplant ( j , leaf ) casapool % cplant ( j , froot ) = 0.01 casapool % nplant ( j , froot ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), froot ) * casapool % cplant ( j , froot ) casapool % pplant ( j , froot ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), froot ) * casapool % cplant ( j , froot ) casapool % cplant ( j , wood ) = 0.01 casapool % nplant ( j , wood ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), wood ) * casapool % cplant ( j , wood ) casapool % pplant ( j , wood ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), wood ) * casapool % cplant ( j , wood ) casaflux % frac_sapwood ( j ) = 1.0 ENDIF ENDDO CALL POPLUCStep ( POPLUC , yyyy ) CALL POPLUC_weights_transfer ( POPLUC , POP , LUC_EXPT ) ! transfer POP updates to workers off = 1 DO rank = 1 , wnp IF ( rank . GT . 1 ) off = off + wland ( rank - 1 )% npop_iwood cnt = wland ( rank )% npop_iwood CALL MPI_Send ( POP % pop_grid ( off ), cnt , pop_ts , rank , 0 , icomm , ierr ) END DO ! workers call POP here !!$           CALL POPdriver(casaflux,casabal,veg, POP) CALL master_receive_pop ( POP , ocomm ) CALL POP_LUC_CASA_transfer ( POPLUC , POP , LUC_EXPT , casapool , casabal , casaflux , ktauday ) IF ( output % grid ( 1 : 3 ) == 'lan' ) THEN CALL WRITE_LUC_OUTPUT_NC ( POPLUC , YYYY , ( YYYY . EQ . cable_user % YearEnd )) ELSE CALL WRITE_LUC_OUTPUT_GRID_NC ( POPLUC , YYYY , ( YYYY . EQ . cable_user % YearEnd )) !CALL WRITE_LUC_OUTPUT_NC( POPLUC, YYYY, ( YYYY.EQ.cable_user%YearEnd )) ENDIF CALL POPLUC_set_patchfrac ( POPLUC , LUC_EXPT ) ENDIF ! end of year ENDDO ! send updates for CASA pools, resulting from LUC CALL master_send_input ( icomm , casa_LUC_ts , nyear ) ENDDO CALL WRITE_LUC_RESTART_NC ( POPLUC , YYYY ) CALL write_casa_restart_nc ( casamet , casapool , casaflux , phen ,. TRUE . ) CALL POP_IO ( pop , casamet , myearspin , 'WRITE_INI' , . TRUE .) END SUBROUTINE master_CASAONLY_LUC !******************************************************************************************************** ! subroutine for reading LU input data, zeroing biomass in empty secondary forest tiles ! and tranferring LUC-based age weights for secondary forest to POP structure SUBROUTINE LUCdriver ( casabiome , casapool , & casaflux , POP , LUC_EXPT , POPLUC , veg ) USE cable_def_types_mod , ONLY : veg_parameter_type , mland USE cable_carbon_module USE cable_common_module , ONLY : CABLE_USER , CurYear USE casa_ncdf_module , ONLY : is_casa_time USE cable_IO_vars_module , ONLY : logn , landpt , patch USE casadimension USE casaparm USE casavariable USE POP_Types , ONLY : POP_TYPE USE POPMODULE , ONLY : POPStep , POP_init_single USE TypeDef , ONLY : i4b , dp USE CABLE_LUC_EXPT , ONLY : LUC_EXPT_TYPE , read_LUH2 ,& ptos , ptog , stog , gtos , grassfrac , pharv , smharv , syharv USE POPLUC_Types USE POPLUC_Module , ONLY : POPLUCStep , POPLUC_weights_Transfer , WRITE_LUC_OUTPUT_NC , & POP_LUC_CASA_transfer , WRITE_LUC_RESTART_NC , READ_LUC_RESTART_NC USE casa_cable IMPLICIT NONE TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters INTEGER :: k , j , l , yyyy WRITE ( * , * ) 'cablecasa_LUC' , CurYear yyyy = CurYear LUC_EXPT % CTSTEP = yyyy - LUC_EXPT % FirstYear + 1 CALL READ_LUH2 ( LUC_EXPT ) DO k = 1 , mland POPLUC % ptos ( k ) = LUC_EXPT % INPUT ( ptos )% VAL ( k ) POPLUC % ptog ( k ) = LUC_EXPT % INPUT ( ptog )% VAL ( k ) POPLUC % stop ( k ) = 0.0 POPLUC % stog ( k ) = LUC_EXPT % INPUT ( stog )% VAL ( k ) POPLUC % gtop ( k ) = 0.0 POPLUC % gtos ( k ) = LUC_EXPT % INPUT ( gtos )% VAL ( k ) POPLUC % pharv ( k ) = LUC_EXPT % INPUT ( pharv )% VAL ( k ) POPLUC % smharv ( k ) = LUC_EXPT % INPUT ( smharv )% VAL ( k ) POPLUC % syharv ( k ) = LUC_EXPT % INPUT ( syharv )% VAL ( k ) POPLUC % thisyear = yyyy ENDDO ! zero secondary forest tiles in POP where secondary forest area is zero DO k = 1 , mland IF (( POPLUC % frac_primf ( k ) - POPLUC % frac_forest ( k )) == 0.0 & . AND . (. NOT . LUC_EXPT % prim_only ( k ))) THEN j = landpt ( k )% cstart + 1 DO l = 1 , SIZE ( POP % Iwood ) IF ( POP % Iwood ( l ) == j ) THEN CALL POP_init_single ( POP , veg % disturbance_interval , l ) EXIT ENDIF ENDDO casapool % cplant ( j , leaf ) = 0.01 casapool % nplant ( j , leaf ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), leaf ) * casapool % cplant ( j , leaf ) casapool % pplant ( j , leaf ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), leaf ) * casapool % cplant ( j , leaf ) casapool % cplant ( j , froot ) = 0.01 casapool % nplant ( j , froot ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), froot ) * casapool % cplant ( j , froot ) casapool % pplant ( j , froot ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), froot ) * casapool % cplant ( j , froot ) casapool % cplant ( j , wood ) = 0.01 casapool % nplant ( j , wood ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), wood ) * casapool % cplant ( j , wood ) casapool % pplant ( j , wood ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), wood ) * casapool % cplant ( j , wood ) casaflux % frac_sapwood ( j ) = 1.0 ENDIF ENDDO CALL POPLUCStep ( POPLUC , yyyy ) CALL POPLUC_weights_transfer ( POPLUC , POP , LUC_EXPT ) END SUBROUTINE LUCdriver !********************************************************************************************************* END MODULE cable_mpimaster","tags":"","loc":"sourcefile/cable_mpimaster.f90.html"},{"title":"cable_iovars.F90 – CABLE","text":"Contents Modules cable_IO_vars_module Source Code cable_iovars.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory cTYPE(casa_flux_type), INTENT(IN) :: casaflux ! casa fluxesontaining CABLE code. ! ! ============================================================================== ! Purpose: Defines input/output related variables for CABLE offline ! ! Contact: Bernard.Pak@csiro.au ! ! History: Development by Gab Abramowitz !          Additional code to use multiple vegetation types per grid-cell (patches) ! ! ============================================================================== MODULE cable_IO_vars_module USE cable_def_types_mod , ONLY : r_2 , mvtype , mstype IMPLICIT NONE PUBLIC PRIVATE r_2 , mvtype , mstype !mrd561 debug INTEGER :: wlogn ! ============ Timing variables ===================== REAL :: shod ! start time hour-of-day INTEGER :: sdoy , smoy , syear ! start time day-of-year month and year CHARACTER ( LEN = 200 ) :: timeunits ! timing info read from nc file CHARACTER ( LEN = 10 ) :: calendar ! 'noleap' for no leap years, 'standard' for leap years CHARACTER ( LEN = 3 ) :: time_coord ! GMT or LOCal time variables REAL ( r_2 ), POINTER , DIMENSION (:) :: timevar ! time variable from file INTEGER , DIMENSION ( 12 ) :: & daysm = ( / 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 / ), & daysml = ( / 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 / ), & lastday = ( / 31 , 59 , 90 , 120 , 151 , 181 , 212 , 243 , 273 , 304 , 334 , 365 / ), & lastdayl = ( / 31 , 60 , 91 , 121 , 152 , 182 , 213 , 244 , 274 , 305 , 335 , 366 / ) LOGICAL :: leaps ! use leap year timing? ! ============ Structure variables =================== REAL , POINTER , DIMENSION (:) :: latitude , longitude REAL , POINTER , DIMENSION (:,:) :: lat_all , lon_all ! lat and lon CHARACTER ( LEN = 4 ) :: metGrid ! Either 'land' or 'mask' INTEGER , POINTER , DIMENSION (:,:) :: mask ! land/sea mask from met file INTEGER , POINTER , DIMENSION (:) :: land_x , land_y ! indicies of land in mask INTEGER :: & xdimsize , ydimsize , & ! sizes of x and y dimensions ngridcells ! number of gridcells in simulation ! For vegetated surface type TYPE patch_type REAL :: & frac , & ! fractional cover of each veg patch latitude ,& longitude END TYPE patch_type TYPE land_type INTEGER :: & nap , & ! number of active (>0%) patches (<=max_vegpatches) cstart , & ! pos of 1st gridcell veg patch in main arrays cend , & ! pos of last gridcell veg patch in main arrays ilat , & ! replacing land_y  ! ?? ilon ! replacing land_x  ! ?? END TYPE land_type TYPE ( land_type ), DIMENSION (:), POINTER :: landpt TYPE ( patch_type ), DIMENSION (:), POINTER :: patch INTEGER :: & max_vegpatches , & ! The maximum # of patches in any grid cell nmetpatches ! size of patch dimension in met file, if exists ! =============== File details ========================== TYPE globalMet_type LOGICAL :: & l_gpcc ,& ! = .FALSE., &         ! ypwang following Chris Lu (30/oct/2012) l_gswp ,& != .FALSE. , &         ! BP May 2013 l_ncar ,& ! = .FALSE., &         ! BP Dec 2013 l_access ! = .FALSE.          ! BP May 2013 CHARACTER ( LEN = 99 ) :: & rainf , & snowf , & LWdown , & SWdown , & PSurf , & Qair , & Tair , & wind END TYPE globalMet_type TYPE ( globalMet_type ) :: globalMetfile TYPE gswp_type CHARACTER ( LEN = 200 ) :: & rainf , & snowf , & LWdown , & SWdown , & PSurf , & Qair , & Tair , & wind , & mask END TYPE gswp_type TYPE ( gswp_type ) :: gswpfile INTEGER :: & ncciy , & ! year number (& switch) for gswp run ncid_rin , & ! input netcdf restart file ID logn ! log file unit number LOGICAL :: & verbose , & ! print init and param details of all grid cells? soilparmnew ! read IGBP new soil map. Q.Zhang @ 12/20/2010 ! ================ Veg and soil type variables ============================ INTEGER , POINTER :: & soiltype_metfile (:,:), & ! user defined soil type (from met file) vegtype_metfile (:,:) ! user-def veg type (from met file) REAL , POINTER :: vegpatch_metfile (:,:) ! Anna: patchfrac for user-def vegtype TYPE parID_type ! model parameter IDs in netcdf file INTEGER :: bch , latitude , clay , css , rhosoil , hyds , rs20 , sand , sfc , silt , & ssat , sucs , swilt , froot , zse , canst1 , dleaf , meth , za_tq , za_uv , & ejmax , frac4 , hc , lai , rp20 , rpcoef , shelrb , vbeta , xalbnir , & vcmax , xfang , ratecp , ratecs , refsbare , isoil , iveg , albsoil , & taul , refl , tauw , refw , wai , vegcf , extkn , tminvj , tmaxvj , & veg_class , soil_class , mvtype , mstype , patchfrac , & WatSat , GWWatSat , SoilMatPotSat , GWSoilMatPotSat , & HkSat , GWHkSat , FrcSand , FrcClay , Clappb , Watr , GWWatr , sfc_vec , forg , swilt_vec , & slope , slope_std , GWdz , SatFracmax , Qhmax , QhmaxEfold , HKefold , HKdepth INTEGER :: ishorizon , nhorizons , clitt , & zeta , fsatmax , & gamma , ZR , F10 INTEGER :: g0 , g1 ! Ticket #56 END TYPE parID_type ! =============== Logical  variables ============================ TYPE input_details_type LOGICAL :: & Wind , & ! T => 'Wind' is present; F => use vector component wind LWdown , & ! T=> downward longwave is present in met file CO2air , & ! T=> air CO2 concentration is present in met file PSurf , & ! T=> surface air pressure is present in met file Snowf , & ! T=> snowfall variable is present in met file avPrecip ,& ! T=> ave rainfall present in met file (use for spinup) LAI , & ! T=> LAI is present in the met file LAI_T , & ! T=> LAI is time dependent, for each time step LAI_M , & ! T=> LAI is time dependent, for each month LAI_P , & ! T=> LAI is patch dependent parameters ,& ! TRUE if non-default parameters are found initial , & ! switched to TRUE when initialisation data are loaded patch , & ! T=> met file have a subgrid veg/soil patch dimension laiPatch ! T=> LAI file have a subgrid veg patch dimension END TYPE input_details_type TYPE ( input_details_type ) :: exists TYPE output_inclusion_type ! Which variables to include in output file, values initialised here ! and can be reset by namelist file read in driver: ! Groups of output variables: LOGICAL :: & met = . FALSE ., & ! input met data flux = . FALSE ., & ! convective, runoff, NEE radiation = . FALSE ., & ! net rad, albedo carbon = . FALSE ., & ! NEE, GPP, NPP, stores soil = . FALSE ., & ! soil states snow = . FALSE ., & ! snow states veg = . FALSE ., & ! vegetation states params = . FALSE ., & ! input parameters used to produce run balances = . FALSE ., & ! energy and water balances restart = . FALSE ., & ! create restart file? ensemble = . FALSE ., & ! are we creating an ensemble run? patch = . FALSE . , & ! should patch-specific info be written ! to output file? !! vh_js !! casa = . FALSE . ! additional casa outputs (C stores and plant turnover) ! Should output grid follow met file 'default'; force with 'land' or 'mask': CHARACTER ( LEN = 7 ) :: & grid = 'default' , & averaging = 'all' ! 'all', 'daily', 'monthly', 'user6'(6hrly) INTEGER :: & interval ! in case of 'user6' above, interval will be 6 ! variables specified individually: LOGICAL :: & SWdown = . FALSE ., & ! 6 downward short-wave radiation [W/m2] LWdown = . FALSE ., & ! 7 downward long-wave radiation [W/m2] Rainf = . FALSE ., & ! 8 rainfall [kg/m2/s] Snowf = . FALSE ., & ! 9 snowfall [kg/m2/s] PSurf = . FALSE ., & ! 10 surface pressure [Pa] Tair = . FALSE ., & ! 11 surface air temperature [K] Qair = . FALSE ., & ! 12 specific humidity [kg/kg] Tscrn = . FALSE ., & !    screen level air temperature [oC] Tex = . FALSE ., & !    extremes in screen level temperature [oC] Qscrn = . FALSE ., & !    screen level specific humidity [kg/kg] CO2air = . FALSE ., & ! 13 CO2 concentration [ppmv] Wind = . FALSE ., & ! 14 windspeed [m/s] Wind_N = . FALSE ., & ! 15 surface wind speed, N component [m/s] Wind_E = . FALSE ., & ! 16 surface wind speed, E component [m/s] LAI = . FALSE ., & ! Qmom = . FALSE ., & !    momentum flux [kg/m/s2] Qh = . FALSE ., & ! 17 sensible heat flux [W/m2] Qle = . FALSE ., & ! 18 latent heat flux [W/m2] Qg = . FALSE ., & ! 19 ground heat flux [W/m2] SWnet = . FALSE ., & ! 20 net shortwave [W/m2] LWnet = . FALSE ., & ! 21 net longwave [W/m2] Evap = . FALSE ., & ! 22 total evapotranspiration [kg/m2/s] Ewater = . FALSE ., & ! 23 evap. from surface water storage [kg/m2/s] ESoil = . FALSE ., & ! 24 bare soil evaporation [kg/m2/s] TVeg = . FALSE ., & ! 25 vegetation transpiration [kg/m2/s] ECanop = . FALSE ., & ! 26 interception evaporation [kg/m2/s] PotEvap = . FALSE ., & ! 27 potential evapotranspiration [kg/m2/s] ACond = . FALSE ., & ! 28 aerodynamic conductance [m/s] SoilWet = . FALSE ., & ! 29 total soil wetness [-] Albedo = . FALSE ., & ! 30 albedo [-] visAlbedo = . FALSE ., & ! vars intro for Ticket #27 nirAlbedo = . FALSE ., & ! vars intro for Ticket #27 VegT = . FALSE ., & ! 31 vegetation temperature [K] SoilTemp = . FALSE ., & ! 32 av.layer soil temperature [K] SoilMoist = . FALSE ., & ! 33 av.layer soil moisture [kg/m2] SoilMoistIce = . FALSE ., & ! 33 av.layer soil frozen moisture [kg/m2] Qs = . FALSE ., & ! 34 surface runoff [kg/m2/s] Qsb = . FALSE ., & ! 35 subsurface runoff [kg/m2/s] DelSoilMoist = . FALSE ., & ! 36 change in soilmoisture ! (sum layers) [kg/m2] DelSWE = . FALSE ., & ! 37 change in snow water equivalent [kg/m2] DelIntercept = . FALSE .,& ! 38 change in interception storage [kg/m2] SnowT = . FALSE ., & ! 39 snow surface temp [K] BaresoilT = . FALSE ., & ! 40 surface bare soil temp [K] AvgSurfT = . FALSE ., & ! 41 Average surface temperature [K] RadT = . FALSE ., & ! 42 Radiative surface temperature [K] SWE = . FALSE ., & ! 43 snow water equivalent [kg/m2] SnowMelt = . FALSE ., & ! 43 snow melt [kg/m2/s] !vh! RootMoist = . FALSE ., & ! 44 root zone soil moisture [kg/m2] CanopInt = . FALSE ., & ! 45 total canopy water storage [kg/m2] NEE = . FALSE ., & ! 46 net ecosystem exchange [umol/m2/s] NPP = . FALSE ., & ! 47 net primary production of C ! by veg [umol/m2/s] GPP = . FALSE ., & ! 48 gross primary production C ! by veg [umol/m2/s] AutoResp = . FALSE ., & ! 49 autotrophic respiration [umol/m2/s] LeafResp = . FALSE ., & ! 51 autotrophic respiration [umol/m2/s] HeteroResp = . FALSE .,& ! 50 heterotrophic respiration [umol/m2/s] SnowDepth = . FALSE ., & ! actual depth of snow in [m] !variables Rnet = . FALSE ., & ! net absorbed radiation [W/m2] HVeg = . FALSE ., & ! sensible heat from vegetation [W/m2] HSoil = . FALSE ., & ! sensible heat from soil [W/m2] RnetSoil = . FALSE ., & ! sensible heat from soil [W/m2] !vh! Ebal = . FALSE ., & ! cumulative energy balance [W/m2] Wbal = . FALSE ., & ! cumulative water balance [W/m2] !! vh_js ! added CanT and fwsoil to the list CanT = . FALSE ., & ! within-canopy temperature [K] Fwsoil = . FALSE ., & ! soil moisture modifier to stomatal conductance Area = . FALSE ., & ! patch area in km2 !mrd561 !MD GW GWMoist = . FALSE ., & ! water balance of aquifer [mm3/mm3] WatTable = . FALSE ., & ! water table depth [m] Qrecharge = . FALSE ., & !recharge to /from auqifer SatFrac = . FALSE ., & ! Saturated Fraction of Gridcell (tile) !! vh_js !! additional casa variables NBP = . FALSE ., & dCdt = . FALSE ., & TotSoilCarb = . FALSE ., & TotLivBiomass = . FALSE ., & TotLittCarb = . FALSE ., & SoilCarbFast = . FALSE ., & SoilCarbSlow = . FALSE ., & SoilCarbPassive = . FALSE ., & LittCarbMetabolic = . FALSE ., & LittCarbStructural = . FALSE ., & LittCarbCWD = . FALSE ., & PlantCarbLeaf = . FALSE ., & PlantCarbFineRoot = . FALSE ., & PlantCarbWood = . FALSE ., & PlantTurnover = . FALSE ., & PlantTurnoverLeaf = . FALSE ., & PlantTurnoverFineRoot = . FALSE ., & PlantTurnoverWood = . FALSE ., & PlantTurnoverWoodDist = . FALSE ., & PlantTurnoverWoodCrowding = . FALSE ., & PlantTurnoverWoodResourceLim = . FALSE ., & LandUseFlux = . FALSE ., & !parameters bch = . FALSE ., & ! parameter b in Campbell equation 1985 latitude = . FALSE ., & ! site latitude clay = . FALSE ., & ! fraction of clay in soil css = . FALSE ., & ! heat capacity of soil minerals [J/kg/C] rhosoil = . FALSE ., & ! soil density [kg/m3] hyds = . FALSE ., & ! hydraulic conductivity @ saturation [m/s], Ksat rs20 = . FALSE ., & ! soil respiration at 20 C [dimensionless], ! (0.1 - 10), prop to om sand = . FALSE ., & ! fraction of sand in soil sfc = . FALSE ., & ! vol H2O @ field capacity silt = . FALSE ., & ! fraction of silt in soil ssat = . FALSE ., & ! vol H2O @ saturation sucs = . FALSE ., & ! suction at saturation [m] swilt = . FALSE ., & ! vol H2O @ wilting froot = . FALSE ., & ! fraction of roots in each soil layer zse = . FALSE ., & ! thickness of each soil layer (1=top) (m) canst1 = . FALSE ., & ! max intercepted water by canopy [mm/LAI] ! (0.08 - 0.12) {avoid} dleaf = . FALSE ., & ! chararacteristic length of leaf [m], ! (0.005 - 0.2) pine -> tropical ejmax = . FALSE ., & ! max pot. electron transport rate ! top leaf[mol/m2/s](1e-5 - 3e-4) {use} frac4 = . FALSE ., & ! fraction of c4 plants [-] hc = . FALSE ., & ! height of canopy [m] rp20 = . FALSE ., & ! plant respiration coefficient at ! 20 C [-] 0.1 - 10 (frp 0 - 15e-6 mol/m2/s) g0 = . FALSE ., & ! Ticket #56 g1 = . FALSE ., & ! Ticket #56 rpcoef = . FALSE ., & ! temperature coef nonleaf plant ! respiration [1/C] (0.8 - 1.5) shelrb = . FALSE ., & ! sheltering factor [-] {avoid - insensitive?} vcmax = . FALSE ., & ! maximum RuBP carboxylation rate ! top leaf [mol/m2/s](5e-6 - 1.5e-4){use} xfang = . FALSE ., & ! leaf angle PARAMETER (dimensionless) ! (v leaf -1.0 horiz 1.0 sphere 0 (-1 - 1)) wai = . FALSE ., & ! wood area index vegcf = . FALSE ., & ! extkn = . FALSE ., & ! ratecp = . FALSE ., & ! plant carbon pool rate constant (1/year) ratecs = . FALSE ., & ! soil carbon pool rate constant (1/year) albsoil = . FALSE ., & ! soil reflectance [-] taul = . FALSE ., & ! leaf transmissivity [-](V:0.07 - 0.15 ! NIR: 0.3 - 0.6 IR: 0.0 - 0.05) refl = . FALSE ., & ! leaf reflectance [-](V:0.07 - 0.15 \\ ! NIR: 0.3 - 0.6 IR: 0.0 - 0.05) tminvj = . FALSE ., & ! min temperature of the start of ! photosynthesis(leaf phenology)[-] (-10 - 10) tmaxvj = . FALSE ., & ! max temperature of the start of ! photosynthesis(leaf phenology)[-] (-5 - 15) vbeta = . FALSE ., & ! stomatal sensitivity to soil water xalbnir = . FALSE ., & ! modifier for albedo in near ir band iveg = . FALSE ., & ! vegetation type from global index patchfrac = . FALSE .,& ! fractional cover of each veg/soil patch isoil = . FALSE ., & ! soil type from global index meth = . FALSE ., & ! method for solving turbulence in canopy scheme za = . FALSE ., & ! something to do with roughness ???? slope = . FALSE .,& !mean subgrid slope slope_std = . FALSE .,& !stddev of subgrid slope GWdz = . FALSE .,& !aquifer thickness SatFracmax = . FALSE .,& Qhmax = . FALSE .,& QhmaxEfold = . FALSE .,& HKefold = . FALSE .,& HKdepth END TYPE output_inclusion_type TYPE ( output_inclusion_type ), SAVE :: output TYPE ( output_inclusion_type ), SAVE :: patchout ! do we want patch-specific info TYPE checks_type LOGICAL :: ranges , energy_bal , mass_bal END TYPE checks_type TYPE ( checks_type ) :: check ! what types of checks to perform ! ============== Proxy input variables ================================ REAL , POINTER , DIMENSION (:) :: PrecipScale ! precip scaling per site for spinup REAL , POINTER , DIMENSION (:,:) :: defaultLAI ! in case met file/host model ! has no LAI REAL :: fixedCO2 ! CO2 level if CO2air not in met file ! For threading: !$OMP THREADPRIVATE(landpt,patch) END MODULE cable_IO_vars_module","tags":"","loc":"sourcefile/cable_iovars.f90.html"},{"title":"cable_pft_params.F90 – CABLE","text":"Contents Modules cable_pft_params_mod Source Code cable_pft_params.F90 Source Code MODULE cable_pft_params_mod USE grid_constants_mod_cbl , ONLY : ntype_max IMPLICIT NONE TYPE vegin_type CHARACTER ( LEN = 70 ) :: desc ( ntype_max ) ! decriptions of veg type REAL :: & canst1 ( ntype_max ), & length ( ntype_max ), & width ( ntype_max ), & vcmax ( ntype_max ), & ejmax ( ntype_max ), & hc ( ntype_max ), & xfang ( ntype_max ), & rp20 ( ntype_max ), & rpcoef ( ntype_max ), & rs20 ( ntype_max ), & wai ( ntype_max ), & rootbeta ( ntype_max ), & shelrb ( ntype_max ), & vegcf ( ntype_max ), & frac4 ( ntype_max ), & xalbnir ( ntype_max ), & extkn ( ntype_max ), & tminvj ( ntype_max ), & tmaxvj ( ntype_max ), & vbeta ( ntype_max ), & a1gs ( ntype_max ), & d0gs ( ntype_max ), & alpha ( ntype_max ), & convex ( ntype_max ), & cfrd ( ntype_max ), & gswmin ( ntype_max ), & conkc0 ( ntype_max ), & conko0 ( ntype_max ), & ekc ( ntype_max ), & eko ( ntype_max ), & g0 ( ntype_max ), & g1 ( ntype_max ), & zr ( ntype_max ), & clitt ( ntype_max ), & froot1 ( ntype_max ), & froot2 ( ntype_max ), & froot3 ( ntype_max ), & froot4 ( ntype_max ), & froot5 ( ntype_max ), & froot6 ( ntype_max ), & csoil1 ( ntype_max ), & csoil2 ( ntype_max ), & ratecs1 ( ntype_max ), & ratecs2 ( ntype_max ), & cplant1 ( ntype_max ), & cplant2 ( ntype_max ), & cplant3 ( ntype_max ), & ratecp1 ( ntype_max ), & ratecp2 ( ntype_max ), & ratecp3 ( ntype_max ), & refl1 ( ntype_max ), & refl2 ( ntype_max ), & refl3 ( ntype_max ), & taul1 ( ntype_max ), & taul2 ( ntype_max ), & taul3 ( ntype_max ), & dleaf ( ntype_max ), & lai ( ntype_max ) END TYPE vegin_type TYPE ( vegin_type ) :: vegin CHARACTER ( LEN = 70 ) :: veg_desc ( ntype_max ) ! decriptions of veg type CONTAINS subroutine cable_pft_params () ! Gets parameter values for each vegetation type USE cable_def_types_mod , ONLY : mvtype integer :: ERROR integer , parameter :: namelist_unit = 711179 integer :: j CHARACTER ( LEN =* ), parameter :: nml_dir = './' CHARACTER ( LEN =* ), parameter :: iomessage = 'something wrong with your PFT params file' CHARACTER ( LEN =* ), PARAMETER :: routinename = 'cable_pft_params' NAMELIST / cable_pftparm / vegin !HACK:offline(cable_parameters) checks mvtype mvtype = ntype_max !----------------------------------------------------------------------------- ! Read namelist !----------------------------------------------------------------------------- write ( 6 , * ) \"Reading CABLE_PFTPARM namelist...\" OPEN ( namelist_unit , FILE = ( TRIM ( nml_dir ) // '/' // 'pft_params.nml' ), & STATUS = 'old' , POSITION = 'rewind' , ACTION = 'read' , IOSTAT = ERROR ) IF ( ERROR /= 0 ) write ( 6 , * ) \"Error opening  CABLE_PFTPARM namelist...\" READ ( namelist_unit , NML = cable_pftparm , IOSTAT = ERROR ) IF ( ERROR /= 0 ) write ( 6 , * ) \"Error reading  CABLE_PFTPARM namelist...\" CLOSE ( namelist_unit , IOSTAT = ERROR ) ! new calculation dleaf since April 2012 (cable v1.8 did not use width) vegin % dleaf = SQRT ( vegin % width * vegin % length ) veg_desc = vegin % desc End subroutine cable_pft_params END MODULE cable_pft_params_mod","tags":"","loc":"sourcefile/cable_pft_params.f90.html"},{"title":"cable_metutils.F90 – CABLE","text":"Contents Modules CABLE_METUTILS_MODULE Source Code cable_metutils.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: lookup tables for possible names for the met. forcing variables in !          netcdf files ! ! Contact: jhan.srbinovsky@csiro.au ! ! History: First version by Claire Carouge (09/2021) ! ! ============================================================================== ! module CABLE_METUTILS_MODULE USE netcdf implicit none PUBLIC :: & possible_varnames , & ! Subroutines find_metvarid TYPE input_netcdf_names ! Latitude variable CHARACTER ( LEN = 8 ), DIMENSION ( 3 ) :: LatNames = ( / & 'latitude' , 'nav_lat ' , 'lat     ' & / ) ! Longitude variable CHARACTER ( LEN = 9 ), DIMENSION ( 3 ) :: LonNames = ( / & 'longitude' , 'nav_lon  ' , 'lon      ' & / ) ! Mask variable CHARACTER ( LEN = 7 ), DIMENSION ( 2 ) :: MaskNames = ( / & 'mask   ' , 'landsea' & / ) ! Time variable CHARACTER ( LEN = 4 ), DIMENSION ( 1 ) :: TimeNames = ( / & 'time' & / ) ! Downward Shortwave radiation variable CHARACTER ( LEN = 6 ), DIMENSION ( 4 ) :: SWdownNames = ( / & 'dswrf ' , 'rsds  ' , 'FSDS  ' , 'SWdown' & / ) ! Air temperature variable CHARACTER ( LEN = 4 ), DIMENSION ( 3 ) :: TairNames = ( / & 'tas ' , 'TBOT' , 'Tair' & / ) ! Air humidity variable CHARACTER ( LEN = 4 ), DIMENSION ( 4 ) :: QairNames = ( / & 'shum' , 'huss' , 'QBOT' , 'Qair' & / ) ! Wind variable CHARACTER ( LEN = 4 ), DIMENSION ( 3 ) :: WindNames = ( / & 'wind' , 'Wind' , 'WIND' & / ) ! Rain variable CHARACTER ( LEN = 8 ), DIMENSION ( 5 ) :: RainNames = ( / & 'prcp    ' , 'pr      ' , 'RAIN    ' , 'Rainf   ' , & 'Precip  ' & / ) ! Downward longwave radiation variable CHARACTER ( LEN = 6 ), DIMENSION ( 4 ) :: LWdownNames = ( / & 'dlwrf ' , 'rlds  ' , 'FLDS  ' , 'LWdown' & / ) ! Surface pressure variable CHARACTER ( LEN = 5 ), DIMENSION ( 5 ) :: PSurfNames = ( / & 'pres ' , 'ps   ' , 'PBOT ' , 'PSurf' , 'Psurf' & / ) ! Elevation variable CHARACTER ( LEN = 9 ), DIMENSION ( 1 ) :: ElevNames = ( / & 'Elevation' & / ) ! CO2 concentration variable CHARACTER ( LEN = 6 ), DIMENSION ( 1 ) :: CO2Names = ( / & 'CO2air' & / ) ! Snow variable CHARACTER ( LEN = 5 ), DIMENSION ( 1 ) :: SnowNames = ( / & 'Snowf' & / ) ! LAI variable CHARACTER ( LEN = 3 ), DIMENSION ( 1 ) :: LAINames = ( / & 'LAI' & / ) ! avPrecip variable CHARACTER ( LEN = 8 ), DIMENSION ( 1 ) :: APrecipNames = ( / & 'avPrecip' & / ) ! Vegetation types variable CHARACTER ( LEN = 4 ), DIMENSION ( 1 ) :: IVegNames = ( / & 'iveg' & / ) ! Patch fraction variable CHARACTER ( LEN = 9 ), DIMENSION ( 1 ) :: PFracNames = ( / & 'patchfrac' & / ) ! Soil type variable CHARACTER ( LEN = 5 ), DIMENSION ( 1 ) :: ISoilNames = ( / & 'isoil' & / ) END TYPE input_netcdf_names type ( input_netcdf_names ) :: possible_varnames CONTAINS !============================================================================== ! ! Name: find_metvarid ! ! Purpose: Find the var ID in the met. file. It will use a lookup table of !   possible variable names to find the variable in the netcdf file. ! ! CALLed from: open_met_file ! !============================================================================== SUBROUTINE find_metvarid ( file_id , possible_names , varid , status ) IMPLICIT NONE ! Arguments ! ID of the netcdf with the met. forcing INTEGER , INTENT ( IN ) :: file_id ! Lookup table for names of the variable in netcdf files CHARACTER ( LEN =* ), DIMENSION (:), INTENT ( IN ) :: possible_names ! Output: variable id in netcdf file INTEGER , INTENT ( OUT ) :: varid ! Output: error status if variable not found. INTEGER , INTENT ( OUT ) :: status ! Local variables INTEGER :: i ! Loop index ! Initialise varid varid = - 10 DO i = 1 , size ( possible_names ) status = NF90_INQ_VARID ( file_id , trim ( possible_names ( i )), varid ) ! Stop the loop if variable found IF ( status == NF90_NOERR ) exit END DO END SUBROUTINE find_metvarid end module CABLE_METUTILS_MODULE","tags":"","loc":"sourcefile/cable_metutils.f90.html"},{"title":"cable_output.F90 – CABLE","text":"Contents Modules cable_output_module Source Code cable_output.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Output module for CABLE offline ! ! Contact: Bernard.Pak@csiro.au ! ! History: Developed by Gab Abramowitz !          Output of additional variables and parameters relative to v1.4b ! ! ! ============================================================================== ! CALLed from:    cable_driver.F90 ! ! MODULEs used:   cable_abort_module !                 cable_common_module !                 cable_checks_module !                 cable_def_types_mod !                 cable_IO_vars_module !                 cable_write_module !                 netcdf ! ! CALLs:          open_output_file !                 write_output !                 close_output_file !                 create_restart ! MODULE cable_output_module USE cable_abort_module , ONLY : abort , nc_abort USE cable_def_types_mod USE casavariable , ONLY : casa_pool , casa_flux , casa_met USE cable_IO_vars_module USE cable_checks_module , ONLY : mass_balance , energy_balance , ranges USE cable_write_module USE netcdf USE cable_common_module , ONLY : filename , calcsoilalbedo , CurYear , IS_LEAPYEAR , cable_user ,& gw_params IMPLICIT NONE PRIVATE PUBLIC open_output_file , write_output , close_output_file , create_restart INTEGER :: ncid_out ! output data netcdf file ID REAL :: missing_value = - 99999 9.0 ! for netcdf output TYPE out_varID_type ! output variable IDs in netcdf file INTEGER :: SWdown , LWdown , Wind , Wind_E , PSurf , & Tair , Qair , Tscrn , Qscrn , Rainf , Snowf , CO2air , & Tmx , Tmn , Txx , Tnn , & Qmom , Qle , Qh , Qg , NEE , SWnet , & LWnet , SoilMoist , SoilTemp , Albedo , & visAlbedo , nirAlbedo , SoilMoistIce , & Qs , Qsb , Evap , BaresoilT , SWE , SnowT , & RadT , VegT , Ebal , Wbal , AutoResp , RootResp , & StemResp , LeafResp , HeteroResp , GPP , NPP , LAI , & ECanop , TVeg , ESoil , CanopInt , SnowDepth , & HVeg , HSoil , Rnet , tvar , CanT , Fwsoil , RnetSoil , SnowMelt , & NBP , TotSoilCarb , TotLivBiomass , & TotLittCarb , SoilCarbFast , SoilCarbSlow , SoilCarbPassive , & LittCarbMetabolic , LittCarbStructural , LittCarbCWD , & PlantCarbLeaf , PlantCarbFineRoot , PlantCarbWood , & PlantTurnover , PlantTurnoverLeaf , PlantTurnoverFineRoot , & PlantTurnoverWood , PlantTurnoverWoodDist , PlantTurnoverWoodCrowding , & PlantTurnoverWoodResourceLim , dCdt , Area , LandUseFlux , patchfrac , & vcmax , hc , WatTable , GWMoist , SatFrac , Qrecharge END TYPE out_varID_type TYPE ( out_varID_type ) :: ovid ! netcdf variable IDs for output variables TYPE ( parID_type ) :: opid ! netcdf variable IDs for output variables TYPE output_temporary_type REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SWdown ! 6 downward short-wave ! radiation [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: LWdown ! 7 downward long-wave ! radiation [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Rainf ! 8 rainfall [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Snowf ! 9 snowfall [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PSurf ! 10 surface pressure [Pa] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Tair ! 11 surface air temperature ! [K] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qair ! 12 specific humidity [kg/kg] !INH new output variables REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Tscrn ! -- screen-level air ! temperature [oC] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qscrn ! -- screen level specific ! humidity [kg/kg] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Tmx ! -- averaged daily maximum ! screen level temp [oC] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Txx ! -- max screen level temp ! in averaging period [oC] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Tmn ! -- averaged daily minimum ! screen level temp [oC] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Tnn ! -- min screen level temp ! in averaging period [oC] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Tdaymx ! -- daily maximum ! screen level temp [oC] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Tdaymn ! -- daily maximum ! screen level temp [oC] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: CO2air ! 13 CO2 concentration [ppmv] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Wind ! 14 windspeed [m/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Wind_N ! 15 surface wind speed, N ! component [m/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Wind_E ! 16 surface wind speed, E ! component [m/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: LAI REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qmom ! -- momentum flux [kg/m/s2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qh ! 17 sensible heat flux [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qle ! 18 latent heat flux [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qg ! 19 ground heat flux [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SWnet ! 20 net shortwave [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: LWnet ! 21 net longwave [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Evap ! 22 total evapotranspiration ! [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Ewater ! 23 evap. from surface water ! storage [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: ESoil ! 24 bare soil evaporation ! [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: TVeg ! 25 vegetation transpiration ! [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: ECanop ! 26 interception evaporation ! [kg/m2/s] ! 27 potential evapotranspiration [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PotEvap REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: ACond ! 28 aerodynamic conductance ! [m/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SoilWet ! 29 total soil wetness [-] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Albedo ! 30 albedo [-] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: visAlbedo ! vars intro for Ticket #27 REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: nirAlbedo ! vars intro for Ticket #27 REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: VegT ! 31 vegetation temperature ! [K] REAL ( KIND = 4 ), POINTER , DIMENSION (:,:) :: SoilTemp ! 32 av.layer soil ! temperature [K] REAL ( KIND = 4 ), POINTER , DIMENSION (:,:) :: SoilMoist ! 33 av.layer soil ! moisture [kg/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:,:) :: SoilMoistIce ! 33 av.layer soil ! frozen moisture [kg/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qs ! 34 surface runoff [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qsb ! 35 subsurface runoff [kg/m2/s] ! 36 change in soilmoisture (sum layers) [kg/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: DelSoilMoist ! 37 change in snow water equivalent [kg/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: DelSWE ! 38 change in interception storage [kg/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: DelIntercept REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SnowT ! 39 snow surface temp [K] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: BaresoilT ! 40 surface bare soil ! temp [K] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: AvgSurfT ! 41 Average surface ! temperature [K] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: RadT ! 42 Radiative surface ! temperature [K] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SWE ! 43 snow water equivalent ! [kg/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: RootMoist ! 44 root zone soil ! moisture [kg/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: CanopInt ! 45 total canopy water ! storage [kg/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: NEE ! 46 net ecosystem exchange ! [umol/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: NPP ! 47 net primary production ! of C by veg [umol/m2/s] ! 48 gross primary production C by veg [umol/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: GPP REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: AutoResp ! 49 autotrophic ! respiration [umol/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: LeafResp ! 51 autotrophic ! respiration [umol/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: HeteroResp ! 50 heterotrophic ! respiration [umol/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SnowDepth ! actual depth of snow in ! [m] ! Non-Alma variables REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Rnet ! net absorbed radiation [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: HVeg ! sensible heat from vegetation ! [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: HSoil ! sensible heat from soil ! [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: RnetSoil ! latent heat from soil ! [kg/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SnowMelt ! snow melt ! [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Ebal ! cumulative energy balance ! [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Wbal ! cumulative water balance ! [W/m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: CanT ! within-canopy temperature ! [K] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Fwsoil ! soil-moisture modfier to stomatal conductance ! [-] ![umol/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: NBP REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: dCdt ! [kg C /m2] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: TotSoilCarb REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: TotLivBiomass REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: TotLittCarb REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SoilCarbFast REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SoilCarbSlow REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SoilCarbPassive REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: LittCarbMetabolic REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: LittCarbStructural REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: LittCarbCWD REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantCarbLeaf REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantCarbFineRoot REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantCarbWood REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantTurnover REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantTurnoverLeaf REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantTurnoverFineRoot REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantTurnoverWood REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantTurnoverWoodDist REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantTurnoverWoodCrowding REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: PlantTurnoverWoodResourceLim REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Area REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: LandUseFlux REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: vcmax REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: patchfrac REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: hc REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: SatFrac !Saturated Fraction of Grid Cell REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: Qrecharge !recharge rate Grid Cell REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: GWMoist ! water balance of aquifer [mm3/mm3] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: WatTable ! water table depth [m] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: RootResp !  autotrophic root respiration [umol/m2/s] REAL ( KIND = 4 ), POINTER , DIMENSION (:) :: StemResp !  autotrophic stem respiration [umol/m2/s] END TYPE output_temporary_type TYPE ( output_temporary_type ), SAVE :: out INTEGER :: ok ! netcdf error status CONTAINS SUBROUTINE open_output_file ( dels , soil , veg , bgc , rough ) ! Creates netcdf output file, defines all variables ! and writes parameters to it if requested by user. REAL , INTENT ( IN ) :: dels ! time step size TYPE ( soil_parameter_type ), INTENT ( IN ) :: soil ! soil parameters TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters TYPE ( bgc_pool_type ), INTENT ( IN ) :: bgc TYPE ( roughness_type ), INTENT ( IN ) :: rough ! REAL, POINTER,DIMENSION(:,:) :: surffrac ! fraction of each surf type INTEGER :: xID , yID , zID , radID , soilID , soilcarbID , & plantcarbID , tID , landID , patchID ! dimension IDs INTEGER :: latID , lonID , llatvID , llonvID ! time,lat,lon variable ID INTEGER :: xvID , yvID ! coordinate variable IDs for GrADS readability !    INTEGER :: surffracID         ! surface fraction varaible ID CHARACTER ( LEN = 10 ) :: todaydate , nowtime ! used to timestamp netcdf file ! Create output file: ok = NF90_CREATE ( filename % out , NF90_CLOBBER , ncid_out ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error creating output file ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! Put the file in define mode: ok = NF90_REDEF ( ncid_out ) ! Define dimensions: ok = NF90_DEF_DIM ( ncid_out , 'x' , xdimsize , xID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining x dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_DIM ( ncid_out , 'y' , ydimsize , yID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining y dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) ! Define patch dimension, whether it's used or not: ok = NF90_DEF_DIM ( ncid_out , 'patch' , max_vegpatches , patchID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining patch dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) !   ! Define surftype dimension (currently only used for surffrac variable): !    ok = NF90_DEF_DIM(ncid_out,'surftype',4,surftypeID) !    IF (ok /= NF90_NOERR) CALL nc_abort & !         (ok,'Error defining syrftype dimension in output file. '// & !         '(SUBROUTINE open_output_file)') ok = NF90_DEF_DIM ( ncid_out , 'soil' , ms , soilID ) ! number of soil layers IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining vertical soil dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_DIM ( ncid_out , 'rad' , nrb , radID ) ! number of radiation bands IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining radiation dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_DIM ( ncid_out , 'soil_carbon_pools' , ncs , soilcarbID ) ! # pools IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining soil carbon pool dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_DIM ( ncid_out , 'plant_carbon_pools' , ncp , plantcarbID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining plant carbon pool dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_DIM ( ncid_out , 'time' , NF90_UNLIMITED , tID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) IF ( output % grid == 'mask' . OR . output % grid == 'ALMA' . OR . & ( metGrid == 'mask' . AND . output % grid == 'default' )) THEN ! for land/sea mask type grid: ! Atmospheric 'z' dim of size 1 to comply with ALMA grid type: ok = NF90_DEF_DIM ( ncid_out , 'z' , 1 , zID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining z dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) ELSE IF ( output % grid == 'land' . OR . & ( metGrid == 'land' . AND . output % grid == 'default' )) THEN ! For land only compression grid: ok = NF90_DEF_DIM ( ncid_out , 'land' , mland , landID ) ! number of land ! points IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining land dimension in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_VAR ( ncid_out , 'local_lat' , NF90_FLOAT , ( / landID / ), llatvID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining land lat variable in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , llatvID , 'units' , \"degrees_north\" ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining local lat variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_VAR ( ncid_out , 'local_lon' , NF90_FLOAT , ( / landID / ), llonvID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining land lon variable in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , llonvID , 'units' , \"degrees_east\" ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining local lon variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) END IF ! Define \"time\" variable and its attributes: ok = NF90_DEF_VAR ( ncid_out , 'time' , NF90_DOUBLE , ( / tID / ), ovid % tvar ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , ovid % tvar , 'units' , timeunits ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , ovid % tvar , 'coordinate' , time_coord ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , ovid % tvar , 'calendar' , calendar ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) ! Define latitude and longitude variable (ALMA): ok = NF90_DEF_VAR ( ncid_out , 'latitude' , NF90_FLOAT , ( / xID , yID / ), latID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining latitude variable in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , latID , 'units' , 'degrees_north' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining latitude variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_VAR ( ncid_out , 'longitude' , NF90_FLOAT , ( / xID , yID / ), lonID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining longitude variable in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , lonID , 'units' , 'degrees_east' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining longitude variable attributes in output file. ' // & '(SUBROUTINE open_output_file)' ) ! Write \"cordinate variables\" to enable reading by GrADS: ok = NF90_DEF_VAR ( ncid_out , 'x' , NF90_FLOAT , ( / xID / ), xvID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining \"x\" variable (for GrADS) in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , xvID , 'units' , 'degrees_east' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing x coordinate variable (GrADS) units in output ' // & 'file. (SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , xvID , 'comment' , & 'x coordinate variable for GrADS compatibility' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing x variables comment in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_DEF_VAR ( ncid_out , 'y' , NF90_FLOAT , ( / yID / ), yvID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining \"y\" variable (for GrADS) in output file. ' // & '(SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , yvID , 'units' , 'degrees_north' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing y coordinate variable (GrADS) units in output ' // & 'file. (SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , yvID , 'comment' , & 'y coordinate variable for GrADS compatibility' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing y variables comment in output file. ' // & '(SUBROUTINE open_output_file)' ) !   ! Define fraction of each surface type: !   CALL define_ovar(ncid_out,surffracID,'surffrac','-', & !       'Fraction of each surface type: vegetated; urban; lake; land ice', & !       .FALSE.,surftypeID,'surftype',xID,yID,zID,landID,patchID) !=============DEFINE OUTPUT VARIABLES======================================= ! Define met forcing variables in output file and allocate temp output vars: IF ( output % met . OR . output % SWdown ) THEN CALL define_ovar ( ncid_out , & ovid % SWdown , 'SWdown' , 'W/m&#94;2' , 'Downward shortwave radiation' , & patchout % SWdown , 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SWdown ( mp )) out % SWdown = 0.0 ! initialise END IF IF ( output % met . OR . output % LWdown ) THEN CALL define_ovar ( ncid_out , ovid % LWdown , 'LWdown' , 'W/m&#94;2' , & 'Downward longwave radiation' , patchout % LWdown , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % LWdown ( mp )) out % LWdown = 0.0 ! initialise END IF IF ( output % met . OR . output % Tair ) THEN CALL define_ovar ( ncid_out , ovid % Tair , & 'Tair' , 'K' , 'Surface air temperature' , patchout % Tair , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Tair ( mp )) out % Tair = 0.0 ! initialise END IF IF ( output % met . OR . output % Rainf ) THEN CALL define_ovar ( ncid_out , ovid % Rainf , 'Rainf' , & 'kg/m&#94;2/s' , 'Rainfall+snowfall' , patchout % Rainf , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Rainf ( mp )) out % Rainf = 0.0 ! initialise END IF IF ( output % met . OR . output % Snowf ) THEN CALL define_ovar ( ncid_out , ovid % Snowf , 'Snowf' , & 'kg/m&#94;2/s' , 'Snowfall' , patchout % Snowf , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Snowf ( mp )) out % Snowf = 0.0 ! initialise END IF IF ( output % met . OR . output % Qair ) THEN CALL define_ovar ( ncid_out , ovid % Qair , 'Qair' , & 'kg/kg' , 'Surface specific humidity' , patchout % Qair , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qair ( mp )) out % Qair = 0.0 ! initialise END IF IF ( output % met . OR . output % Wind ) THEN CALL define_ovar ( ncid_out , ovid % Wind , 'Wind' , & 'm/s' , 'Scalar surface wind speed' , patchout % Wind , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Wind ( mp )) out % Wind = 0.0 ! initialise END IF IF ( output % met . OR . output % PSurf ) THEN CALL define_ovar ( ncid_out , ovid % PSurf , 'PSurf' , & 'hPa' , 'Surface air pressure' , patchout % PSurf , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PSurf ( mp )) out % PSurf = 0.0 ! initialise END IF IF ( output % met . OR . output % CO2air ) THEN CALL define_ovar ( ncid_out , ovid % CO2air , 'CO2air' , 'ppmv' , & 'Surface air CO2 concentration' , patchout % CO2air , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % CO2air ( mp )) out % CO2air = 0.0 ! initialise END IF ! Define surface flux variables in output file and allocate temp output ! vars: IF ( output % flux . OR . output % Qmom ) THEN CALL define_ovar ( ncid_out , ovid % Qmom , 'Qmom' , 'kg/m/s2' , & 'Surface momentum flux' , patchout % Qmom , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qmom ( mp )) out % Qmom = 0.0 ! initialise END IF IF ( output % flux . OR . output % Qle ) THEN CALL define_ovar ( ncid_out , ovid % Qle , 'Qle' , 'W/m&#94;2' , & 'Surface latent heat flux' , patchout % Qle , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qle ( mp )) out % Qle = 0.0 ! initialise END IF IF ( output % flux . OR . output % Qh ) THEN CALL define_ovar ( ncid_out , ovid % Qh , 'Qh' , 'W/m&#94;2' , & 'Surface sensible heat flux' , patchout % Qh , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qh ( mp )) out % Qh = 0.0 ! initialise END IF IF ( output % flux . OR . output % Qg ) THEN CALL define_ovar ( ncid_out , ovid % Qg , 'Qg' , 'W/m&#94;2' , & 'Surface ground heat flux' , patchout % Qg , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qg ( mp )) out % Qg = 0.0 ! initialise END IF IF ( output % flux . OR . output % Qs ) THEN CALL define_ovar ( ncid_out , ovid % Qs , 'Qs' , & 'kg/m&#94;2/s' , 'Surface runoff' , patchout % Qs , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qs ( mp )) out % Qs = 0.0 ! initialise END IF IF ( output % flux . OR . output % Qsb ) THEN CALL define_ovar ( ncid_out , ovid % Qsb , 'Qsb' , 'kg/m&#94;2/s' , & 'Subsurface runoff' , patchout % Qsb , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qsb ( mp )) out % Qsb = 0.0 ! initialise END IF IF ( output % flux . OR . output % Evap ) THEN CALL define_ovar ( ncid_out , ovid % Evap , 'Evap' , 'kg/m&#94;2/s' , & 'Total evapotranspiration' , patchout % Evap , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Evap ( mp )) out % Evap = 0.0 ! initialise END IF IF ( output % flux . OR . output % ECanop ) THEN CALL define_ovar ( ncid_out , ovid % Ecanop , 'ECanop' , 'kg/m&#94;2/s' , & 'Wet canopy evaporation' , patchout % ECanop , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % ECanop ( mp )) out % ECanop = 0.0 ! initialise END IF IF ( output % flux . OR . output % TVeg ) THEN CALL define_ovar ( ncid_out , ovid % TVeg , 'TVeg' , 'kg/m&#94;2/s' , & 'Vegetation transpiration' , patchout % TVeg , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % TVeg ( mp )) out % TVeg = 0.0 ! initialise END IF IF ( output % flux . OR . output % ESoil ) THEN CALL define_ovar ( ncid_out , ovid % ESoil , 'ESoil' , 'kg/m&#94;2/s' , & 'Evaporation from soil' , patchout % ESoil , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % ESoil ( mp )) out % ESoil = 0.0 ! initialise END IF IF ( output % flux . OR . output % HVeg ) THEN CALL define_ovar ( ncid_out , ovid % HVeg , 'HVeg' , 'W/m&#94;2' , & 'Sensible heat from vegetation' , patchout % HVeg , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % HVeg ( mp )) out % HVeg = 0.0 ! initialise END IF IF ( output % flux . OR . output % HSoil ) THEN CALL define_ovar ( ncid_out , ovid % HSoil , 'HSoil' , 'W/m&#94;2' , & 'Sensible heat from soil' , patchout % HSoil , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % HSoil ( mp )) out % HSoil = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % RnetSoil , 'RnetSoil' , 'W/m&#94;2' , & 'Net radiation absorbed by ground' , patchout % RnetSoil , 'dummy' , & xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % RnetSoil ( mp )) out % RnetSoil = 0.0 ! initialise END IF IF ( output % flux . OR . output % carbon . OR . output % NEE ) THEN CALL define_ovar ( ncid_out , ovid % NEE , 'NEE' , 'umol/m&#94;2/s' , & 'Net ecosystem exchange of CO2' , patchout % NEE , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % NEE ( mp )) out % NEE = 0.0 ! initialise END IF ! Define soil state variables in output file and allocate temp output vars: IF ( output % soil . OR . output % SoilMoist ) THEN CALL define_ovar ( ncid_out , ovid % SoilMoist , 'SoilMoist' , 'm&#94;3/m&#94;3' , & 'Average layer soil moisture' , patchout % SoilMoist , & 'soil' , xID , yID , zID , landID , patchID , soilID , tID ) CALL define_ovar ( ncid_out , ovid % SoilMoistIce , 'SoilMoistIce' , 'm&#94;3/m&#94;3' , & 'Average layer frozen soil moisture' , patchout % SoilMoistIce , & 'soil' , xID , yID , zID , landID , patchID , soilID , tID ) ALLOCATE ( out % SoilMoist ( mp , ms )) ALLOCATE ( out % SoilMoistIce ( mp , ms )) out % SoilMoist = 0.0 ! initialise out % SoilMoistIce = 0.0 ! initialise END IF IF ( output % soil . OR . output % SoilTemp ) THEN CALL define_ovar ( ncid_out , ovid % SoilTemp , 'SoilTemp' , 'K' , & 'Average layer soil temperature' , patchout % SoilTemp , & 'soil' , xID , yID , zID , landID , patchID , soilID , tID ) ALLOCATE ( out % SoilTemp ( mp , ms )) out % SoilTemp = 0.0 ! initialise END IF IF ( output % soil . OR . output % BaresoilT ) THEN CALL define_ovar ( ncid_out , ovid % BaresoilT , 'BaresoilT' , & 'K' , 'Bare soil temperature' , patchout % BaresoilT , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % BaresoilT ( mp )) out % BaresoilT = 0.0 ! initialise END IF ! Define snow state variables in output file and allocate temp output vars: IF ( output % snow . OR . output % SWE ) THEN CALL define_ovar ( ncid_out , ovid % SWE , 'SWE' , 'kg/m&#94;2' , & 'Snow water equivalent' , patchout % SWE , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SWE ( mp )) out % SWE = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % SnowMelt , 'SnowMelt' , 'kg/m&#94;2/s' , & 'Snow Melt Rate' , patchout % SnowMelt , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SnowMelt ( mp )) out % SnowMelt = 0.0 ! initialise END IF IF ( output % snow . OR . output % SnowT ) THEN CALL define_ovar ( ncid_out , ovid % SnowT , 'SnowT' , 'K' , & 'Snow surface temperature' , patchout % SnowT , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SnowT ( mp )) out % SnowT = 0.0 ! initialise END IF IF ( output % snow . OR . output % SnowDepth ) THEN CALL define_ovar ( ncid_out , ovid % SnowDepth , 'SnowDepth' , & 'm' , 'Snow depth' , patchout % SnowDepth , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SnowDepth ( mp )) out % SnowDepth = 0.0 ! initialise END IF ! Define radiative variables in output file and allocate temp output vars: IF ( output % radiation . OR . output % SWnet ) THEN CALL define_ovar ( ncid_out , ovid % SWnet , 'SWnet' , 'W/m&#94;2' , & 'Net shortwave radiation absorbed by surface' , & patchout % SWnet , 'dummy' , xID , yID , zID , landID , & patchID , tID ) ALLOCATE ( out % SWnet ( mp )) out % SWnet = 0.0 ! initialise END IF IF ( output % radiation . OR . output % LWnet ) THEN CALL define_ovar ( ncid_out , ovid % LWnet , 'LWnet' , 'W/m&#94;2' , & 'Net longwave radiation absorbed by surface' , & patchout % LWnet , 'dummy' , xID , yID , zID , landID , & patchID , tID ) ALLOCATE ( out % LWnet ( mp )) out % LWnet = 0.0 ! initialise END IF IF ( output % radiation . OR . output % Rnet ) THEN CALL define_ovar ( ncid_out , ovid % Rnet , 'Rnet' , 'W/m&#94;2' , & 'Net radiation absorbed by surface' , patchout % Rnet , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Rnet ( mp )) out % Rnet = 0.0 ! initialise END IF IF ( output % radiation . OR . output % Albedo ) THEN CALL define_ovar ( ncid_out , ovid % Albedo , 'Albedo' , '-' , & 'Surface albedo' , patchout % Albedo , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Albedo ( mp )) out % Albedo = 0.0 ! initialise END IF ! output calc of soil albedo based on colour? - Ticket #27 IF ( calcsoilalbedo ) THEN IF ( output % radiation . OR . output % visAlbedo ) THEN CALL define_ovar ( ncid_out , ovid % visAlbedo , 'visAlbedo' , '-' , & 'Surface vis albedo' , patchout % visAlbedo , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % visAlbedo ( mp )) out % visAlbedo = 0.0 ! initialise END IF IF ( output % radiation . OR . output % nirAlbedo ) THEN CALL define_ovar ( ncid_out , ovid % nirAlbedo , 'nirAlbedo' , '-' , & 'Surface nir albedo' , patchout % nirAlbedo , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % nirAlbedo ( mp )) out % nirAlbedo = 0.0 ! initialise END IF END IF IF ( output % radiation . OR . output % RadT ) THEN CALL define_ovar ( ncid_out , ovid % RadT , 'RadT' , 'K' , & 'Radiative surface temperature' , patchout % RadT , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % RadT ( mp )) out % RadT = 0.0 ! initialise END IF ! Define vegetation variables in output file and allocate temp output vars: ! REV_CORR - new output variables. IF ( output % Tscrn . OR . output % veg ) THEN CALL define_ovar ( ncid_out , ovid % Tscrn , & 'Tscrn' , 'oC' , 'screen level air temperature' , & patchout % Tscrn , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Tscrn ( mp )) out % Tscrn = 0.0 ! initialise END IF IF ( output % Tex . OR . output % veg ) THEN IF (( output % averaging ( 1 : 2 ) == 'da' ). OR .( output % averaging ( 1 : 2 ) == 'mo' )) THEN CALL define_ovar ( ncid_out , ovid % Txx , & 'Txx' , 'oC' , 'max screen-level T in reporting period' ,& patchout % Tex , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Txx ( mp )) out % Txx = - 1.0E6 !initialise extremes at unreasonable value CALL define_ovar ( ncid_out , ovid % Tnn , & 'Tnn' , 'oC' , 'min screen-level T in reporting period' ,& patchout % Tex , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Tnn ( mp )) out % Tnn = 1.0E6 !initialise extremes at unreasonable value ENDIF IF ( output % averaging ( 1 : 2 ) == 'mo' ) THEN !%Tdaymx is the current day max T - this is a working variable) !%Tmx is average of those values to be output CALL define_ovar ( ncid_out , ovid % Tmx , & 'Tmx' , 'oC' , 'averaged daily maximum screen-level T' , & patchout % Tex , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Tmx ( mp ), out % Tdaymx ( mp )) out % Tmx = 0.0 !initialise average out % Tdaymx = - 1.0E6 !initialise extremes at unreasonable value CALL define_ovar ( ncid_out , ovid % Tmn , & 'Tmn' , 'oC' , 'averaged daily minimum screen-level T' , & patchout % Tex , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Tmn ( mp ), out % Tdaymn ( mp )) out % Tmn = 0.0 out % Tdaymn = 1.0E6 ENDIF ENDIF IF ( output % Qscrn . OR . output % veg ) THEN CALL define_ovar ( ncid_out , ovid % Qscrn , & 'Qscrn' , 'kg/kg' , 'screen level specific humdity' , & patchout % Qscrn , & 'ALMA' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qscrn ( mp )) out % Qscrn = 0.0 ! initialise END IF IF ( output % veg . OR . output % VegT ) THEN CALL define_ovar ( ncid_out , ovid % VegT , 'VegT' , 'K' , & 'Average vegetation temperature' , patchout % VegT , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % VegT ( mp )) out % VegT = 0.0 ! initialise END IF IF ( output % veg . OR . output % CanT ) THEN CALL define_ovar ( ncid_out , ovid % CanT , 'CanT' , 'K' , & 'Within-canopy temperature' , patchout % CanT , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % CanT ( mp )) out % CanT = 0.0 ! initialise END IF IF ( output % veg . OR . output % Fwsoil ) THEN CALL define_ovar ( ncid_out , ovid % Fwsoil , 'Fwsoil' , '[-]' , & 'soil moisture modifier to stomatal conductance' , patchout % Fwsoil , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Fwsoil ( mp )) out % Fwsoil = 0.0 ! initialise END IF IF ( output % veg . OR . output % CanopInt ) THEN CALL define_ovar ( ncid_out , ovid % CanopInt , 'CanopInt' , 'kg/m&#94;2' , & 'Canopy intercepted water storage' , patchout % CanopInt , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % CanopInt ( mp )) out % CanopInt = 0.0 ! initialise END IF IF ( output % veg . OR . output % LAI ) THEN CALL define_ovar ( ncid_out , ovid % LAI , 'LAI' , '-' , & 'Leaf area index' , patchout % LAI , 'dummy' , xID , & yID , zID , landID , patchID , tID ) ALLOCATE ( out % LAI ( mp )) out % LAI = 0.0 ! initialise END IF ! Define balance variables in output file and allocate temp output vars: IF ( output % balances . OR . output % Ebal ) THEN CALL define_ovar ( ncid_out , ovid % Ebal , 'Ebal' , 'W/m&#94;2' , & 'Cumulative energy imbalance' , patchout % Ebal , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Ebal ( mp )) out % Ebal = 0.0 ! initialise END IF IF ( output % balances . OR . output % Wbal ) THEN CALL define_ovar ( ncid_out , ovid % Wbal , 'Wbal' , 'kg/m&#94;2' , & 'Cumulative water imbalance' , patchout % Wbal , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Wbal ( mp )) out % Wbal = 0.0 ! initialise END IF ! Define carbon variables in output file and allocate temp output vars: IF ( output % carbon . OR . output % AutoResp ) THEN CALL define_ovar ( ncid_out , ovid % AutoResp , 'AutoResp' , 'umol/m&#94;2/s' , & 'Autotrophic respiration' , patchout % AutoResp , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % AutoResp ( mp )) out % AutoResp = 0.0 ! initialise END IF IF ( output % casa . OR . output % AutoResp ) THEN CALL define_ovar ( ncid_out , ovid % RootResp , 'RootResp' , 'umol/m&#94;2/s' , & 'Fine Root Autotrophic respiration' , patchout % AutoResp , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % RootResp ( mp )) out % RootResp = 0.0 ! initialise END IF IF ( output % casa . OR . output % AutoResp ) THEN CALL define_ovar ( ncid_out , ovid % StemResp , 'StemResp' , 'umol/m&#94;2/s' , & 'StemWood Autotrophic respiration' , patchout % AutoResp , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % StemResp ( mp )) out % StemResp = 0.0 ! initialise END IF IF ( output % carbon . OR . output % LeafResp ) THEN CALL define_ovar ( ncid_out , ovid % LeafResp , 'LeafResp' , 'umol/m&#94;2/s' , & 'Leaf respiration' , patchout % LeafResp , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % LeafResp ( mp )) out % LeafResp = 0.0 ! initialise END IF IF ( output % carbon . OR . output % HeteroResp ) THEN CALL define_ovar ( ncid_out , ovid % HeteroResp , 'HeteroResp' , 'umol/m&#94;2/s' , & 'Heterotrophic respiration' , patchout % HeteroResp , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % HeteroResp ( mp )) out % HeteroResp = 0.0 ! initialise END IF IF ( output % carbon . OR . output % GPP ) THEN CALL define_ovar ( ncid_out , ovid % GPP , 'GPP' , 'umol/m&#94;2/s' , & 'Gross primary production' , patchout % GPP , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % GPP ( mp )) out % GPP = 0.0 ! initialise END IF IF ( output % carbon . OR . output % NPP ) THEN CALL define_ovar ( ncid_out , ovid % NPP , 'NPP' , 'umol/m&#94;2/s' , & 'Net primary production' , patchout % NPP , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % NPP ( mp )) out % NPP = 0.0 ! initialise END IF !MD groundwater related variables IF ( output % soil . OR . output % WatTable ) THEN CALL define_ovar ( ncid_out , ovid % WatTable , 'WatTable' , 'm' , & 'Water Table Depth' , patchout % WatTable , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % WatTable ( mp )) out % WatTable = 0.0 ! initialise END IF IF ( output % soil . OR . output % GWMoist ) THEN CALL define_ovar ( ncid_out , ovid % GWMoist , 'GWMoist' , 'mm3/mm3' , & 'Aquifer mositure content' , patchout % GWMoist , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % GWMoist ( mp )) out % GWMoist = 0.0 ! initialise END IF IF ( output % soil . OR . output % SatFrac ) THEN CALL define_ovar ( ncid_out , ovid % SatFrac , 'SatFrac' , 'unitless' , & 'Saturated Fraction of Gridcell' , patchout % SatFrac , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SatFrac ( mp )) out % SatFrac = 0.0 ! initialise END IF IF ( output % soil . OR . output % Qrecharge ) THEN CALL define_ovar ( ncid_out , ovid % Qrecharge , 'Qrecharge' , 'mm/s' , & 'Recharge to or from Aquifer' , patchout % Qrecharge , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Qrecharge ( mp )) out % Qrecharge = 0.0 ! initialise END IF IF ( output % casa ) THEN CALL define_ovar ( ncid_out , ovid % NBP , 'NBP' , 'umol/m&#94;2/s' , & 'Net Biosphere Production & (uptake +ve)' , patchout % NBP , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % NBP ( mp )) out % NBP = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % dCdt , 'dCdt' , 'umol/m&#94;2/s' , & 'Carbon accumulation rate (uptake +ve)' , patchout % dCdt , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % dCdt ( mp )) out % dCdt = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % TotSoilCarb , 'TotSoilCarb' , 'kg C/m&#94;2' , & 'Total Soil and Litter Carbon' , patchout % TotSoilCarb , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % TotSoilCarb ( mp )) out % TotSoilCarb = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % TotLittCarb , 'TotLittCarb' , 'kg C/m&#94;2' , & 'Total Litter Carbon' , patchout % TotLittCarb , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % TotLittCarb ( mp )) out % TotLittCarb = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % SoilCarbFast , 'SoilCarbFast' , 'kg C/m&#94;2' , & 'Soil Carbon: Fast Turnover' , patchout % SoilCarbFast , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SoilCarbFast ( mp )) out % SoilCarbFast = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % SoilCarbSlow , 'SoilCarbSlow' , 'kg C/m&#94;2' , & 'Soil Carbon: Slow Turnover' , patchout % SoilCarbSlow , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SoilCarbSlow ( mp )) out % SoilCarbSlow = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % SoilCarbPassive , 'SoilCarbPassive' , 'kg C/m&#94;2' , & 'Soil Carbon: Passive' , patchout % SoilCarbPassive , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % SoilCarbPassive ( mp )) out % SoilCarbPassive = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % LittCarbMetabolic , 'LittCarbMetabolic' , 'kg C/m&#94;2' , & 'Litter Carbon: metabolic' , patchout % LittCarbMetabolic , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % LittCarbMetabolic ( mp )) out % LittCarbMetabolic = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % LittCarbStructural , 'LittCarbStructural' , 'kg C/m&#94;2' , & 'Litter Carbon: structural' , patchout % LittCarbStructural , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % LittCarbStructural ( mp )) out % LittCarbStructural = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % LittCarbCWD , 'LittCarbCWD' , 'kg C/m&#94;2' , & 'Litter Carbon: CWD' , patchout % LittCarbCWD , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % LittCarbCWD ( mp )) out % LittCarbCWD = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % PlantCarbLeaf , 'PlantCarbLeaf' , 'kg C/m&#94;2' , & 'Plant Carbon: leaf' , patchout % PlantCarbLeaf , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantCarbLeaf ( mp )) out % PlantCarbLeaf = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % PlantCarbFineRoot , 'PlantCarbFineRoot' , 'kg C/m&#94;2' , & 'Plant Carbon: Fine roots' , patchout % PlantCarbFineRoot , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantCarbFineRoot ( mp )) out % PlantCarbFineRoot = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % PlantCarbWood , 'PlantCarbWood' , 'kg C/m&#94;2' , & 'Plant Carbon: wood (above- and below-ground' , patchout % PlantCarbWood , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantCarbWood ( mp )) out % PlantCarbWood = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % TotLivBiomass , 'TotLivBiomass' , 'kg C/m&#94;2' , & 'Total Biomass' , patchout % TotLivBiomass , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % TotLivBiomass ( mp )) out % TotLivBiomass = 0.0 ! initialise CALL define_ovar ( ncid_out , ovid % PlantTurnover , 'PlantTurnover' , 'umol/m&#94;2/s' , & 'Total Biomass Turnover' , patchout % PlantTurnover , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantTurnover ( mp )) out % PlantTurnover = 0.0 CALL define_ovar ( ncid_out , ovid % PlantTurnoverLeaf , 'PlantTurnoverLeaf ' , & 'umol/m&#94;2/s' , & 'Leaf Biomass Turnover' , patchout % PlantTurnoverLeaf , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantTurnoverLeaf ( mp )) out % PlantTurnoverLeaf = 0.0 CALL define_ovar ( ncid_out , ovid % PlantTurnoverFineRoot , 'PlantTurnoverFineRoot ' , & 'umol/m&#94;2/s' , & 'FineRoot Biomass Turnover' , patchout % PlantTurnoverFineRoot , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantTurnoverFineRoot ( mp )) out % PlantTurnoverFineRoot = 0.0 CALL define_ovar ( ncid_out , ovid % PlantTurnoverWood , 'PlantTurnoverWood ' , & 'umol/m&#94;2/s' , & 'Woody Biomass Turnover' , patchout % PlantTurnoverWood , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantTurnoverWood ( mp )) out % PlantTurnoverWood = 0.0 CALL define_ovar ( ncid_out , ovid % PlantTurnoverWoodDist , 'PlantTurnoverWoodDist ' , & 'umol/m&#94;2/s' , & 'Woody Biomass Turnover (disturbance)' , patchout % PlantTurnoverWoodDist , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantTurnoverWoodDist ( mp )) out % PlantTurnoverWoodDist = 0.0 CALL define_ovar ( ncid_out , ovid % PlantTurnoverWoodCrowding , 'PlantTurnoverWoodCrowding ' , & 'umol/m&#94;2/s' , & 'Woody Biomass Turnover (crowding)' , patchout % PlantTurnoverWoodCrowding , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantTurnoverWoodCrowding ( mp )) out % PlantTurnoverWoodCrowding = 0.0 CALL define_ovar ( ncid_out , ovid % PlantTurnoverWoodResourceLim , 'PlantTurnoverWoodResourceLim ' , & 'umol/m&#94;2/s' , & 'Woody Biomass Turnover (Resource Limitation)' , patchout % PlantTurnoverWoodResourceLim , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % PlantTurnoverWoodResourceLim ( mp )) out % PlantTurnoverWoodResourceLim = 0.0 IF ( cable_user % POPLUC ) THEN CALL define_ovar ( ncid_out , ovid % LandUseFlux , 'LandUseFlux ' , & 'umol/m&#94;2/s' , & 'Sum of wood harvest and clearing fluxes' , patchout % LandUseFlux , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % LandUseFlux ( mp )) out % LandUseFlux = 0.0 ENDIF END IF !! vh_js !! CALL define_ovar ( ncid_out , ovid % Area , 'Area' , 'km2' , & 'Patch Area' , patchout % Area , & 'dummy' , xID , yID , zID , landID , patchID , tID ) ALLOCATE ( out % Area ( mp )) out % Area = 0.0 ! initialise ! Define CABLE parameters in output file: IF ( output % params . OR . output % iveg ) CALL define_ovar ( ncid_out , opid % iveg , & 'iveg' , '-' , 'Vegetation type' , patchout % iveg , 'integer' , & xID , yID , zID , landID , patchID ) IF ( cable_user % POPLUC ) THEN CALL define_ovar ( ncid_out , opid % patchfrac , 'patchfrac' , '-' , & 'Fractional cover of vegetation patches' , patchout % patchfrac , 'real' , & xID , yID , zID , landID , patchID , tID ) ELSE IF (( output % params . OR . output % patchfrac ) & . AND . ( patchout % patchfrac . OR . output % patch )) & CALL define_ovar ( ncid_out , opid % patchfrac , 'patchfrac' , '-' , & 'Fractional cover of vegetation patches' , patchout % patchfrac , 'real' , & xID , yID , zID , landID , patchID ) ENDIF IF ( output % params . OR . output % isoil ) CALL define_ovar ( ncid_out , opid % isoil , & 'isoil' , '-' , 'Soil type' , patchout % isoil , 'integer' , & xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % bch ) CALL define_ovar ( ncid_out , opid % bch , & 'bch' , '-' , 'Parameter b, Campbell eqn 1985' , patchout % bch , 'real' , & xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % clay ) CALL define_ovar ( ncid_out , opid % clay , & 'clay' , '-' , 'Fraction of soil which is clay' , patchout % clay , 'real' , & xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % sand ) CALL define_ovar ( ncid_out , opid % sand , & 'sand' , '-' , 'Fraction of soil which is sand' , patchout % sand , 'real' , & xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % silt ) CALL define_ovar ( ncid_out , opid % silt , & 'silt' , '-' , 'Fraction of soil which is silt' , patchout % silt , 'real' , & xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % ssat ) CALL define_ovar ( ncid_out , opid % ssat , & 'ssat' , '-' , 'Fraction of soil volume which is water @ saturation' , & patchout % ssat , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % sfc ) CALL define_ovar ( ncid_out , opid % sfc , & 'sfc' , '-' , 'Fraction of soil volume which is water @ field capacity' , & patchout % sfc , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % swilt ) CALL define_ovar ( ncid_out , opid % swilt , & 'swilt' , '-' , 'Fraction of soil volume which is water @ wilting point' , & patchout % swilt , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % hyds ) CALL define_ovar ( ncid_out , opid % hyds , & 'hyds' , 'm/s' , 'Hydraulic conductivity @ saturation' , & patchout % hyds , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % sucs ) CALL define_ovar ( ncid_out , opid % sucs , & 'sucs' , 'm' , 'Suction @ saturation' , & patchout % sucs , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % css ) CALL define_ovar ( ncid_out , opid % css , & 'css' , 'J/kg/C' , 'Heat capacity of soil minerals' , & patchout % css , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % rhosoil ) CALL define_ovar ( ncid_out , & opid % rhosoil , 'rhosoil' , 'kg/m&#94;3' , 'Density of soil minerals' , & patchout % rhosoil , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % rs20 ) CALL define_ovar ( ncid_out , opid % rs20 , & 'rs20' , '-' , 'Soil respiration coefficient at 20C' , & patchout % rs20 , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % albsoil ) CALL define_ovar ( ncid_out , & opid % albsoil , 'albsoil' , '-' , & 'Snow free shortwave soil reflectance fraction' , & patchout % albsoil , radID , 'radiation' , xID , yID , zID , landID , patchID ) !! vh_js !! IF ( cable_user % CALL_POP ) THEN IF ( output % params . OR . output % hc ) CALL define_ovar ( ncid_out , opid % hc , & 'hc' , 'm' , 'Height of canopy' , patchout % hc , & 'real' , xID , yID , zID , landID , patchID , tID ) ELSE IF ( output % params . OR . output % hc ) CALL define_ovar ( ncid_out , opid % hc , & 'hc' , 'm' , 'Height of canopy' , patchout % hc , & 'real' , xID , yID , zID , landID , patchID ) ENDIF IF ( output % params . OR . output % canst1 ) CALL define_ovar ( ncid_out , & opid % canst1 , 'canst1' , 'mm/LAI' , 'Max water intercepted by canopy' , & patchout % canst1 , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % dleaf ) CALL define_ovar ( ncid_out , opid % dleaf , & 'dleaf' , 'm' , 'Chararacteristic length of leaf' , & patchout % dleaf , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % frac4 ) CALL define_ovar ( ncid_out , opid % frac4 , & 'frac4' , '-' , 'Fraction of plants which are C4' , & patchout % frac4 , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % ejmax ) CALL define_ovar ( ncid_out , opid % ejmax , & 'ejmax' , 'mol/m&#94;2/s' , 'Max potential electron transport rate top leaf' , & patchout % ejmax , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % vcmax ) CALL define_ovar ( ncid_out , opid % vcmax , & 'vcmax' , 'mol/m&#94;2/s' , 'Maximum RuBP carboxylation rate top leaf' , & patchout % vcmax , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % rp20 ) CALL define_ovar ( ncid_out , opid % rp20 , & 'rp20' , '-' , 'Plant respiration coefficient at 20C' , & patchout % rp20 , 'real' , xID , yID , zID , landID , patchID ) ! Ticket #56 IF ( output % params . OR . output % g0 ) CALL define_ovar ( ncid_out , opid % g0 , & 'g0' , '-' , 'g0 term in Medlyn Stom Cond. Param' , & patchout % g0 , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % g1 ) CALL define_ovar ( ncid_out , opid % g1 , & 'g1' , '-' , 'g1 term in Medlyn Stom Cond. Param' , & patchout % g1 , 'real' , xID , yID , zID , landID , patchID ) ! end Ticket #56 IF ( output % params . OR . output % rpcoef ) CALL define_ovar ( ncid_out , & opid % rpcoef , 'rpcoef' , '1/C' , & 'Temperature coef nonleaf plant respiration' , & patchout % rpcoef , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % shelrb ) CALL define_ovar ( ncid_out , & opid % shelrb , 'shelrb' , '-' , 'Sheltering factor' , patchout % shelrb , & 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % xfang ) CALL define_ovar ( ncid_out , opid % xfang , & 'xfang' , '-' , 'Leaf angle parameter' , patchout % xfang , 'real' , & xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % wai ) CALL define_ovar ( ncid_out , opid % wai , & 'wai' , '-' , 'Wood area index' , patchout % wai , 'real' , & xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % vegcf ) CALL define_ovar ( ncid_out , opid % vegcf , & 'vegcf' , '-' , 'vegcf' , patchout % vegcf , 'real' , & xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % extkn ) CALL define_ovar ( ncid_out , opid % extkn , & 'extkn' , '-' , 'Nitrogen extinction coef for vert. canopy profile' , & patchout % extkn , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % tminvj ) CALL define_ovar ( ncid_out , & opid % tminvj , 'tminvj' , 'C' , & 'Min temperature for the start of photosynthesis' , & patchout % tminvj , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % tmaxvj ) CALL define_ovar ( ncid_out , & opid % tmaxvj , 'tmaxvj' , 'C' , 'Max temperature for photosynthesis' , & patchout % tmaxvj , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % vbeta ) CALL define_ovar ( ncid_out , opid % vbeta , & 'vbeta' , '-' , 'Stomatal sensitivity to soil water' , & patchout % vbeta , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % xalbnir ) CALL define_ovar ( ncid_out , & opid % xalbnir , 'xalbnir' , '-' , 'Modifier for albedo in near ir band' , & patchout % xalbnir , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % meth ) CALL define_ovar ( ncid_out , opid % meth , & 'meth' , '-' , 'Canopy turbulence parameterisation choice' , & patchout % meth , 'real' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % za ) THEN CALL define_ovar ( ncid_out , opid % za_uv , 'za_uv' , 'm' , & 'Reference height (lowest atm. model layer) for momentum' , & patchout % za , 'real' , xID , yID , zID , landID , patchID ) CALL define_ovar ( ncid_out , opid % za_tq , 'za_tq' , 'm' , & 'Reference height (lowest atm. model layer) for scalars' , & patchout % za , 'real' , xID , yID , zID , landID , patchID ) ENDIF IF ( output % params . OR . output % ratecp ) CALL define_ovar ( ncid_out , & opid % ratecp , 'ratecp' , '1/year' , 'Plant carbon rate constant' , & patchout % ratecp , plantcarbID , 'plantcarbon' , xID , yID , zID , & landID , patchID ) IF ( output % params . OR . output % ratecs ) CALL define_ovar ( ncid_out , & opid % ratecs , 'ratecs' , '1/year' , 'Soil carbon rate constant' , & patchout % ratecs , soilcarbID , 'soilcarbon' , xID , yID , zID , & landID , patchID ) IF ( output % params . OR . output % zse ) CALL define_ovar ( ncid_out , opid % zse , & 'zse' , 'm' , 'Depth of each soil layer' , & patchout % zse , soilID , 'soil' , xID , yID , zID , landID , patchID ) IF ( output % params . OR . output % froot ) CALL define_ovar ( ncid_out , opid % froot , & 'froot' , '-' , 'Fraction of roots in each soil layer' , & patchout % froot , soilID , 'soil' , xID , yID , zID , landID , patchID ) !    IF(output%params .OR. output%slope) CALL define_ovar(ncid_out, opid%slope,   & !           'slope', '-', 'Mean subgrid topographic slope', & !                          patchout%slope, 'real', xID, yID, zID, landID, patchID) ! !    IF(output%params .OR. output%slope_std) CALL define_ovar(ncid_out, opid%slope_std,   & !           'slope_std', '-', 'Mean subgrid topographic slope_std', & !                          patchout%slope_std, 'real', xID, yID, zID, landID, patchID) ! !    IF(output%params .OR. output%GWdz) CALL define_ovar(ncid_out, opid%GWdz,   & !           'GWdz', '-', 'Mean aquifer layer thickness ', & !                          patchout%GWdz, 'real', xID, yID, zID, landID, patchID) ! IF ( output % params . AND . cable_user % gw_model ) THEN CALL define_ovar ( ncid_out , opid % Qhmax , & 'Qhmax' , 'mm/s' , 'Maximum subsurface drainage ' , & patchout % Qhmax , 'real' , xID , yID , zID , landID , patchID ) CALL define_ovar ( ncid_out , opid % QhmaxEfold , & 'QhmaxEfold' , 'm' , 'Maximum subsurface drainage decay rate' , & patchout % QhmaxEfold , 'real' , xID , yID , zID , landID , patchID ) CALL define_ovar ( ncid_out , opid % SatFracmax , & 'SatFracmax' , '-' , 'Controls max saturated fraction ' , & patchout % SatFracmax , 'real' , xID , yID , zID , landID , patchID ) CALL define_ovar ( ncid_out , opid % HKefold , & 'HKefold' , '1/m' , 'Rate HK decays with depth ' , & patchout % HKefold , 'real' , xID , yID , zID , landID , patchID ) CALL define_ovar ( ncid_out , opid % HKdepth , & 'HKdepth' , 'm' , 'Depth at which HKsat(z) is HKsat(0) ' , & patchout % HKdepth , 'real' , xID , yID , zID , landID , patchID ) END IF ! Write global attributes for file: CALL DATE_AND_TIME ( todaydate , nowtime ) todaydate = todaydate ( 1 : 4 ) // '/' // todaydate ( 5 : 6 ) // '/' // todaydate ( 7 : 8 ) nowtime = nowtime ( 1 : 2 ) // ':' // nowtime ( 3 : 4 ) // ':' // nowtime ( 5 : 6 ) ok = NF90_PUT_ATT ( ncid_out , NF90_GLOBAL , \"Production\" , & TRIM ( todaydate ) // ' at ' // TRIM ( nowtime )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , NF90_GLOBAL , \"Source\" , & 'CABLE LSM output file' ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ok = NF90_PUT_ATT ( ncid_out , NF90_GLOBAL , \"CABLE_input_file\" , & TRIM ( filename % met )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! Determine output aggregation details: IF ( output % averaging ( 1 : 4 ) == 'user' ) THEN ! User-specified aggregation interval for output: READ ( output % averaging ( 5 : 7 ), * ) output % interval ok = NF90_PUT_ATT ( ncid_out , NF90_GLOBAL , \"Output_averaging\" , & TRIM ( output % averaging ( 5 : 7 )) // '-hourly output' ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing global detail to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! Convert interval value from hours to time steps (for use in output ! write): output % interval = output % interval * 3600 / INT ( dels ) ELSE IF ( output % averaging ( 1 : 3 ) == 'all' ) THEN ! output all timesteps ok = NF90_PUT_ATT ( ncid_out , NF90_GLOBAL , \"Output_averaging\" , & TRIM ( output % averaging ) // ' timesteps recorded' ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing global detail to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! Set output interval to be one time step output % interval = 1 ELSE IF ( output % averaging ( 1 : 2 ) == 'mo' ) THEN ! monthly output ok = NF90_PUT_ATT ( ncid_out , NF90_GLOBAL , \"Output_averaging\" , & TRIM ( output % averaging )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing global detail to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! Output interval will be determined dynamically for monthly output ELSE IF ( output % averaging ( 1 : 2 ) == 'da' ) THEN ! daily output ok = NF90_PUT_ATT ( ncid_out , NF90_GLOBAL , \"Output_averaging\" , & TRIM ( output % averaging )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing global detail to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! Set output interval to be # time steps in 24 hours: output % interval = 3600 * 24 / INT ( dels ) ELSE CALL abort ( 'Unknown output averaging interval specified ' // & 'in namelist file. (SUBROUTINE open_output_file)' ) END IF ! End netcdf define mode: ok = NF90_ENDDEF ( ncid_out ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error creating output file ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! Write latitude and longitude variables: ok = NF90_PUT_VAR ( ncid_out , latID , REAL ( lat_all , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing latitude variable to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ok = NF90_PUT_VAR ( ncid_out , lonID , REAL ( lon_all , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing longitude variable to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) IF ( output % grid == 'land' . OR . & ( metGrid == 'land' . AND . output % grid == 'default' )) THEN ok = NF90_PUT_VAR ( ncid_out , llatvID , REAL ( latitude ) ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing loc lat variable to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ok = NF90_PUT_VAR ( ncid_out , llonvID , REAL ( longitude ) ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing loc lon variable to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ENDIF ! Write GrADS coordinate variables ok = NF90_PUT_VAR ( ncid_out , xvID , REAL ( lon_all (:, 1 ), 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing GrADS x coordinate variable to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ok = NF90_PUT_VAR ( ncid_out , yvID , REAL ( lat_all ( 1 , :), 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error writing GrADS y coordinate variable to ' & // TRIM ( filename % out ) // ' (SUBROUTINE open_output_file)' ) ! Write model parameters if requested: IF ( output % params . OR . output % iveg ) CALL write_ovar ( ncid_out , opid % iveg , & 'iveg' , REAL ( veg % iveg , 4 ), ranges % iveg , patchout % iveg , 'integer' ) IF (. NOT . cable_user % POPLUC ) THEN IF (( output % params . OR . output % patchfrac ) & . AND . ( patchout % patchfrac . OR . output % patch )) & CALL write_ovar ( ncid_out , opid % patchfrac , 'patchfrac' , & REAL ( patch (:)% frac , 4 ), ( / 0.0 , 1.0 / ), patchout % patchfrac , 'real' ) ENDIF IF ( output % params . OR . output % isoil ) CALL write_ovar ( ncid_out , opid % isoil , & 'isoil' , REAL ( soil % isoilm , 4 ), ranges % isoil , patchout % isoil , 'integer' ) IF ( output % params . OR . output % bch ) CALL write_ovar ( ncid_out , opid % bch , & 'bch' , REAL ( soil % bch , 4 ), ranges % bch , patchout % bch , 'real' ) IF ( output % params . OR . output % clay ) CALL write_ovar ( ncid_out , opid % clay , & 'clay' , REAL ( soil % clay , 4 ), ranges % clay , patchout % clay , 'real' ) IF ( output % params . OR . output % sand ) CALL write_ovar ( ncid_out , opid % sand , & 'sand' , REAL ( soil % sand , 4 ), ranges % sand , patchout % sand , 'real' ) IF ( output % params . OR . output % silt ) CALL write_ovar ( ncid_out , opid % silt , & 'silt' , REAL ( soil % silt , 4 ), ranges % silt , patchout % silt , 'real' ) IF ( output % params . OR . output % css ) CALL write_ovar ( ncid_out , opid % css , & 'css' , REAL ( soil % css , 4 ), ranges % css , patchout % css , 'real' ) IF ( output % params . OR . output % rhosoil ) CALL write_ovar ( ncid_out , & opid % rhosoil , 'rhosoil' , REAL ( soil % rhosoil , 4 ), & ranges % rhosoil , patchout % rhosoil , 'real' ) IF ( output % params . OR . output % hyds ) CALL write_ovar ( ncid_out , opid % hyds , & 'hyds' , REAL ( soil % hyds , 4 ), ranges % hyds , patchout % hyds , 'real' ) IF ( output % params . OR . output % sucs ) CALL write_ovar ( ncid_out , opid % sucs , & 'sucs' , REAL ( soil % sucs , 4 ), ranges % sucs , patchout % sucs , 'real' ) IF ( output % params . OR . output % rs20 ) CALL write_ovar ( ncid_out , opid % rs20 , & 'rs20' , REAL ( veg % rs20 , 4 ), ranges % rs20 , patchout % rs20 , 'real' ) !         'rs20',REAL(soil%rs20,4),ranges%rs20,patchout%rs20,'real') IF ( output % params . OR . output % ssat ) CALL write_ovar ( ncid_out , opid % ssat , & 'ssat' , REAL ( soil % ssat , 4 ), ranges % ssat , patchout % ssat , 'real' ) IF ( output % params . OR . output % sfc ) CALL write_ovar ( ncid_out , opid % sfc , & 'sfc' , REAL ( soil % sfc , 4 ), ranges % sfc , patchout % sfc , 'real' ) IF ( output % params . OR . output % swilt ) CALL write_ovar ( ncid_out , opid % swilt , & 'swilt' , REAL ( soil % swilt , 4 ), ranges % swilt , patchout % swilt , 'real' ) IF ( output % params . OR . output % albsoil ) CALL write_ovar ( ncid_out , & opid % albsoil , 'albsoil' , REAL ( soil % albsoil , 4 ), & ranges % albsoil , patchout % albsoil , 'radiation' ) IF ( output % params . OR . output % canst1 ) CALL write_ovar ( ncid_out , & opid % canst1 , 'canst1' , REAL ( veg % canst1 , 4 ), & ranges % canst1 , patchout % canst1 , 'real' ) IF ( output % params . OR . output % dleaf ) CALL write_ovar ( ncid_out , opid % dleaf , & 'dleaf' , REAL ( veg % dleaf , 4 ), ranges % dleaf , patchout % dleaf , 'real' ) IF ( output % params . OR . output % ejmax ) CALL write_ovar ( ncid_out , opid % ejmax , & 'ejmax' , REAL ( veg % ejmax , 4 ), ranges % ejmax , patchout % ejmax , 'real' ) IF ( output % params . OR . output % vcmax ) CALL write_ovar ( ncid_out , opid % vcmax , & 'vcmax' , REAL ( veg % vcmax , 4 ), ranges % vcmax , patchout % vcmax , 'real' ) IF ( output % params . OR . output % frac4 ) CALL write_ovar ( ncid_out , opid % frac4 , & 'frac4' , REAL ( veg % frac4 , 4 ), ranges % frac4 , patchout % frac4 , 'real' ) IF (. NOT . cable_user % CALL_POP ) THEN IF ( output % params . OR . output % hc ) CALL write_ovar ( ncid_out , opid % hc , & 'hc' , REAL ( veg % hc , 4 ), ranges % hc , patchout % hc , 'real' ) ENDIF IF ( output % params . OR . output % rp20 ) CALL write_ovar ( ncid_out , opid % rp20 , & 'rp20' , REAL ( veg % rp20 , 4 ), ranges % rp20 , patchout % rp20 , 'real' ) ! Ticket #56 IF ( output % params . OR . output % g0 ) CALL write_ovar ( ncid_out , opid % g0 , & 'g0' , REAL ( veg % g0 , 4 ), ranges % g0 , patchout % g0 , 'real' ) IF ( output % params . OR . output % g1 ) CALL write_ovar ( ncid_out , opid % g1 , & 'g1' , REAL ( veg % g1 , 4 ), ranges % g1 , patchout % g1 , 'real' ) ! End Ticket #56 IF ( output % params . OR . output % rpcoef ) CALL write_ovar ( ncid_out , & opid % rpcoef , 'rpcoef' , REAL ( veg % rpcoef , 4 ), & ranges % rpcoef , patchout % rpcoef , 'real' ) IF ( output % params . OR . output % shelrb ) CALL write_ovar ( ncid_out , & opid % shelrb , 'shelrb' , REAL ( veg % shelrb , 4 ), & ranges % shelrb , patchout % shelrb , 'real' ) IF ( output % params . OR . output % xfang ) CALL write_ovar ( ncid_out , opid % xfang , & 'xfang' , REAL ( veg % xfang , 4 ), ranges % xfang , patchout % xfang , 'real' ) IF ( output % params . OR . output % wai ) CALL write_ovar ( ncid_out , opid % wai , & 'wai' , REAL ( veg % wai , 4 ), ranges % wai , patchout % wai , 'real' ) IF ( output % params . OR . output % vegcf ) CALL write_ovar ( ncid_out , opid % vegcf , & 'vegcf' , REAL ( veg % vegcf , 4 ), ranges % vegcf , patchout % vegcf , 'real' ) IF ( output % params . OR . output % extkn ) CALL write_ovar ( ncid_out , opid % extkn , & 'extkn' , REAL ( veg % extkn , 4 ), ranges % extkn , patchout % extkn , 'real' ) IF ( output % params . OR . output % tminvj ) CALL write_ovar ( ncid_out , & opid % tminvj , 'tminvj' , REAL ( veg % tminvj , 4 ), & ranges % tminvj , patchout % tminvj , 'real' ) IF ( output % params . OR . output % tmaxvj ) CALL write_ovar ( ncid_out , & opid % tmaxvj , 'tmaxvj' , REAL ( veg % tmaxvj , 4 ), & ranges % tmaxvj , patchout % tmaxvj , 'real' ) IF ( output % params . OR . output % vbeta ) CALL write_ovar ( ncid_out , opid % vbeta , & 'vbeta' , REAL ( veg % vbeta , 4 ), ranges % vbeta , patchout % vbeta , 'real' ) IF ( output % params . OR . output % xalbnir ) CALL write_ovar ( ncid_out , & opid % xalbnir , 'xalbnir' , REAL ( veg % xalbnir , 4 ), & ranges % xalbnir , patchout % xalbnir , 'real' ) IF ( output % params . OR . output % meth ) CALL write_ovar ( ncid_out , opid % meth , & 'meth' , REAL ( veg % meth , 4 ), ranges % meth , patchout % meth , 'integer' ) IF ( output % params . OR . output % za ) THEN CALL write_ovar ( ncid_out , opid % za_uv , & 'za_uv' , REAL ( rough % za_uv , 4 ), ranges % za , patchout % za , 'real' ) CALL write_ovar ( ncid_out , opid % za_tq , & 'za_tq' , REAL ( rough % za_tq , 4 ), ranges % za , patchout % za , 'real' ) ENDIF IF ( output % params . OR . output % ratecp ) CALL write_ovar ( ncid_out , & opid % ratecp , 'ratecp' , SPREAD ( REAL ( bgc % ratecp , 4 ), 1 , mp ), ranges % ratecp , & patchout % ratecp , 'plantcarbon' ) ! no spatial dim at present IF ( output % params . OR . output % ratecs ) CALL write_ovar ( ncid_out , & opid % ratecs , 'ratecs' , SPREAD ( REAL ( bgc % ratecs , 4 ), 1 , mp ), ranges % ratecs , & patchout % ratecs , 'soilcarbon' ) ! no spatial dim at present IF ( output % params . OR . output % froot ) CALL write_ovar ( ncid_out , opid % froot , & 'froot' , REAL ( veg % froot , 4 ), ranges % froot , patchout % froot , 'soil' ) IF ( output % params . OR . output % zse ) CALL write_ovar ( ncid_out , opid % zse , & 'zse' , SPREAD ( REAL ( soil % zse , 4 ), 1 , mp ), ranges % zse , & patchout % zse , 'soil' ) ! no spatial dim at present !    IF(output%params .OR. output%slope) CALL write_ovar(ncid_out, opid%slope,    & !                 'slope', REAL(soil%slope, 4), (/0.0,1.0/), patchout%slope, 'real') !    IF(output%params .OR. output%slope_std) CALL write_ovar(ncid_out, opid%slope_std,    & !                 'slope_std', REAL(soil%slope_std, 4), (/0.0,1.0/), patchout%slope_std, 'real') !    IF(output%params .OR. output%GWdz) CALL write_ovar(ncid_out, opid%GWdz,    & !                 'GWdz', REAL(soil%GWdz, 4), (/0.0,10000.0/), patchout%GWdz, 'real') ! IF ( output % params . AND . cable_user % gw_model ) THEN CALL write_ovar ( ncid_out , opid % SatFracmax , & 'SatFracmax' , SPREAD ( REAL ( gw_params % MaxSatFraction , 4 ), 1 , mp ), & ( / 0.0 , 10000000 0.0 / ), patchout % SatFracmax , 'real' ) CALL write_ovar ( ncid_out , opid % Qhmax , & 'Qhmax' , SPREAD ( REAL ( gw_params % MaxHorzDrainRate , 4 ), 1 , mp ), & ( / 0.0 , 10000000 0.0 / ), patchout % Qhmax , 'real' ) CALL write_ovar ( ncid_out , opid % QhmaxEfold , & 'QhmaxEfold' , SPREAD ( REAL ( gw_params % EfoldHorzDrainRate , 4 ), 1 , mp ), & ( / 0.0 , 10000000 0.0 / ), patchout % QhmaxEfold , 'real' ) CALL write_ovar ( ncid_out , opid % HKefold , & 'HKefold' , SPREAD ( REAL ( gw_params % hkrz , 4 ), 1 , mp ), & ( / 0.0 , 10000000 0.0 / ), patchout % HKefold , 'real' ) CALL write_ovar ( ncid_out , opid % HKdepth , & 'HKdepth' , SPREAD ( REAL ( gw_params % zdepth , 4 ), 1 , mp ), & ( / 0.0 , 10000000 0.0 / ), patchout % HKdepth , 'real' ) END IF END SUBROUTINE open_output_file !============================================================================= SUBROUTINE write_output ( dels , ktau , met , canopy , casaflux , casapool , casamet , ssnow , & rad , bal , air , soil , veg , SBOLTZ , EMLEAF , EMSOIL ) ! Writes model output variables and, if requested, calls ! energy and mass balance routines. This subroutine is called ! each timestep, but may only write to the output file periodically, ! depending on whether the user has specified that output should be ! aggregated, e.g. to monthly or 6-hourly averages. REAL , INTENT ( IN ) :: dels ! time step size INTEGER , INTENT ( IN ) :: ktau ! timestep number in loop which include spinup REAL , INTENT ( IN ) :: SBOLTZ , EMLEAF , EMSOIL TYPE ( met_type ), INTENT ( IN ) :: met ! met data TYPE ( canopy_type ), INTENT ( IN ) :: canopy ! canopy variable data TYPE ( soil_snow_type ), INTENT ( IN ) :: ssnow ! soil data TYPE ( soil_parameter_type ), INTENT ( IN ) :: soil ! soil parameters TYPE ( radiation_type ), INTENT ( IN ) :: rad ! radiation data TYPE ( air_type ), INTENT ( IN ) :: air TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters TYPE ( casa_flux ), INTENT ( IN ) :: casaflux ! casa fluxes TYPE ( casa_pool ), INTENT ( IN ) :: casapool ! casa fluxes TYPE ( balances_type ), INTENT ( INOUT ) :: bal TYPE ( casa_met ), INTENT ( IN ) :: casamet REAL ( r_2 ), DIMENSION ( 1 ) :: timetemp ! temporary variable for storing time ! value LOGICAL :: writenow ! write to output file during this time step? INTEGER , SAVE :: out_timestep ! counter for output time steps INTEGER , SAVE :: out_month ! counter for output month INTEGER , DIMENSION ( mp ) :: realyear ! fix problem for yr b4 leap yr INTEGER :: backtrack ! modify timetemp for averaged output INTEGER :: dday ! number of past-years days for monthly output LN INTEGER :: iy ! Counter !MC - use met%year(1) instead of CABLE_USER%YearStart for non-GSWP forcing and leap years INTEGER , SAVE :: YearStart INTEGER :: ok ! IF asked to check mass/water balance: IF ( check % mass_bal ) CALL mass_balance ( dels , ktau , ssnow , soil , canopy , & met , air , bal ) ! IF asked to check energy balance: IF ( check % energy_bal ) CALL energy_balance ( dels , ktau , met , rad , & canopy , bal , ssnow , & SBOLTZ , EMLEAF , EMSOIL ) ! Initialise output time step counter and month counter: IF ( ktau == 1 ) THEN out_timestep = 0 out_month = 0 !MC - use met%year(1) instead of CABLE_USER%YearStart for non-GSWP forcing and leap years IF ( TRIM ( cable_user % MetType ) . EQ . '' ) THEN YearStart = met % year ( 1 ) ELSE YearStart = CABLE_USER % YearStart ENDIF END IF ! Decide on output averaging regime: IF ( output % averaging ( 1 : 3 ) == 'all' ) THEN ! write every time step to file ! Set flag to write data for current time step: writenow = . TRUE . ! Set output time step to be current model time step: out_timestep = ktau backtrack = 0 ELSE IF ( output % averaging ( 1 : 4 ) == 'user' . OR . output % averaging ( 1 : 2 ) == 'da' ) & THEN ! user defined output interval or daily output IF ( MOD ( ktau , output % interval ) == 0 ) THEN ! i.e.ktau divisible by ! interval ! write to output file this time step writenow = . TRUE . ! increment output time step counter: out_timestep = out_timestep + 1 backtrack = output % interval / 2 ELSE writenow = . FALSE . END IF ELSE IF ( output % averaging ( 1 : 2 ) == 'mo' ) THEN ! write monthly averages to file !realyear = met%year realyear = REAL ( CurYear ) IF ( ktau >= 365 * 24 * 3600 / INT ( dels )) THEN WHERE ( met % doy == 1 ) realyear = realyear - 1 ! last timestep of year END IF ! LN Inserted for multiyear output dday = 0 !MC - use met%year(1) instead of CABLE_USER%YearStart for non-GSWP forcing and leap years DO iy = YearStart , CurYear - 1 IF ( IS_LEAPYEAR ( iy ) . AND . leaps ) THEN dday = dday + 366 ELSE dday = dday + 365 ENDIF END DO ! LN Inserted for multiyear output ! Are we using leap year calendar? IF ( leaps ) THEN ! If currently a leap year: IF ( is_leapyear ( CurYear )) THEN !! vh_js !! IF ( ANY ( INT ( REAL ( lastdayl + dday ) * 2 4. * 360 0. / dels ) == ktau )) THEN out_month = MOD ( out_month , 12 ) + 1 ! can only be 1 - 12 ! write to output file this time step writenow = . TRUE . ! increment output time step counter: out_timestep = out_timestep + 1 ! set numbr of time steps in output period output % interval = daysml ( out_month ) * 24 * 3600 / INT ( dels ) ELSE writenow = . FALSE . END IF ELSE ! not currently a leap year ! last time step of month !! vh_js !! IF ( ANY ( INT ( REAL ( lastday + dday ) * 2 4. * 360 0. / dels ) == ktau )) THEN ! increment output month counter out_month = MOD ( out_month , 12 ) + 1 ! can only be 1 - 12 ! write to output file this time step writenow = . TRUE . ! increment output time step counter: out_timestep = out_timestep + 1 ! set numbr of time steps in output period output % interval = daysm ( out_month ) * 24 * 3600 / INT ( dels ) ELSE writenow = . FALSE . END IF END IF ELSE ! not using leap year timing in this run !! vh_js !! IF ( ANY ( INT (( REAL (( lastday + dday )) * 2 4. * 360 0. / REAL ( INT ( dels )))) == ktau )) THEN ! last time step of month ! IF(ANY(((lastday+dday)*24*3600/INT(dels))==ktau)) THEN ! last time step of month ! increment output month counter out_month = MOD ( out_month , 12 ) + 1 ! can only be 1 - 12 ! write to output file this time step writenow = . TRUE . ! increment output time step counter: out_timestep = out_timestep + 1 ! set numbr of time steps in output period output % interval = daysm ( out_month ) * 24 * 3600 / INT ( dels ) ELSE writenow = . FALSE . END IF END IF ! using leap year timing or not backtrack = output % interval / 2 ELSE ! type of output aggregation CALL abort ( 'Unknown output averaging request in namelist file.' // & '(SUBROUTINE write_output)' ) END IF ! Note that size of averaging interval, output%interval, is set when opening ! output file unless output is monthly (in which case it's set above) ! If this time step is an output time step: IF ( writenow ) THEN ! Write to temporary time variable: timetemp ( 1 ) = DBLE ( REAL ( ktau - backtrack ) * dels ) ! Write time variable for this output time step: ok = NF90_PUT_VAR ( ncid_out , ovid % tvar , timetemp , & start = ( / out_timestep / ), count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing time variable to ' & // TRIM ( filename % out ) // '(SUBROUTINE write_output)' ) END IF ! Arguments to write_ovar: current time step; output file netcdf file ID; ! netcdf variable ID; variable name; variable data; variable ranges; ! non-land fill value; include patch info for this var; any specific ! formatting info; met variables for reporting in case of abort. ! SWdown:  downward short-wave radiation [W/m&#94;2] IF ( output % met . OR . output % SWdown ) THEN ! Add current timestep's value to total of temporary output variable: out % SWdown = out % SWdown + REAL ( met % fsd (:, 1 ) + met % fsd (:, 2 ), 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SWdown = out % SWdown / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SWdown , 'SWdown' , & out % SWdown , ranges % SWdown , patchout % SWdown , 'default' , met ) ! Reset temporary output variable: out % SWdown = 0.0 END IF END IF ! LWdown: downward long-wave radiation [W/m&#94;2] IF ( output % met . OR . output % LWdown ) THEN ! Add current timestep's value to total of temporary output variable: out % LWdown = out % LWdown + REAL ( met % fld , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % LWdown = out % LWdown / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % LWdown , 'LWdown' , & out % LWdown , ranges % LWdown , patchout % LWdown , 'default' , met ) ! Reset temporary output variable: out % LWdown = 0.0 END IF END IF ! Tair: surface air temperature [K] IF ( output % met . OR . output % Tair ) THEN ! Add current timestep's value to total of temporary output variable: out % Tair = out % Tair + REAL ( met % tk , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Tair = out % Tair / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Tair , 'Tair' , out % Tair , & ranges % Tair , patchout % Tair , 'ALMA' , met ) ! Reset temporary output variable: out % Tair = 0.0 END IF END IF ! Rainf: rainfall [kg/m&#94;2/s] IF ( output % met . OR . output % Rainf ) THEN ! Add current timestep's value to total of temporary output variable: out % Rainf = out % Rainf + REAL ( met % precip / dels , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Rainf = out % Rainf / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Rainf , 'Rainf' , & out % Rainf , ranges % Rainf , patchout % Rainf , 'default' , met ) ! Reset temporary output variable: out % Rainf = 0.0 END IF END IF ! Snowf: snowfall [kg/m&#94;2/s] IF ( output % met . OR . output % Snowf ) THEN ! Add current timestep's value to total of temporary output variable: out % Snowf = out % Snowf + REAL ( met % precip_sn / dels , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Snowf = out % Snowf / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Snowf , 'Snowf' , & out % Snowf , ranges % Snowf , patchout % Snowf , 'default' , met ) ! Reset temporary output variable: out % Snowf = 0.0 END IF END IF ! PSurf: surface pressure [Pa] IF ( output % met . OR . output % PSurf ) THEN ! Add current timestep's value to total of temporary output variable: out % PSurf = out % PSurf + REAL ( met % pmb , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PSurf = out % PSurf / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PSurf , 'PSurf' , & out % PSurf , ranges % PSurf , patchout % PSurf , 'default' , met ) ! Reset temporary output variable: out % PSurf = 0.0 END IF END IF ! Qair: specific humidity [kg/kg] IF ( output % met . OR . output % Qair ) THEN ! Add current timestep's value to total of temporary output variable: out % Qair = out % Qair + REAL ( met % qv , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Qair = out % Qair / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qair , 'Qair' , out % Qair , & ranges % Qair , patchout % Qair , 'ALMA' , met ) ! Reset temporary output variable: out % Qair = 0.0 END IF END IF ! Wind: windspeed [m/s] IF ( output % met . OR . output % Wind ) THEN ! Add current timestep's value to total of temporary output variable: out % Wind = out % Wind + REAL ( met % ua , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Wind = out % Wind / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Wind , 'Wind' , out % Wind , & ranges % Wind , patchout % Wind , 'ALMA' , met ) ! Reset temporary output variable: out % Wind = 0.0 END IF END IF ! CO2air: CO2 concentration [ppmv] IF ( output % met . OR . output % CO2air ) THEN ! Add current timestep's value to total of temporary output variable: out % CO2air = out % CO2air + REAL ( met % ca * 100000 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % CO2air = out % CO2air / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % CO2air , 'CO2air' , & OUT % CO2air , ranges % CO2air , patchout % CO2air , 'ALMA' , met ) ! Reset temporary output variable: out % CO2air = 0.0 END IF END IF !-----------------------WRITE FLUX DATA------------------------------------- ! Qmom: momentum flux [kg/m/s2] INH IF ( output % flux . OR . output % Qmom ) THEN ! Add current timestep's value to total of temporary output variable: out % Qmom = out % Qmom + REAL ( air % rho , 4 ) * ( REAL ( canopy % us , 4 ) ** 2. ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Qmom = out % Qmom / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qmom , 'Qmom' , out % Qmom , & ranges % Qmom , patchout % Qmom , 'default' , met ) ! Reset temporary output variable: out % Qmom = 0.0 END IF END IF ! Qle: latent heat flux [W/m&#94;2] IF ( output % flux . OR . output % Qle ) THEN ! Add current timestep's value to total of temporary output variable: out % Qle = out % Qle + REAL ( canopy % fe , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Qle = out % Qle / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qle , 'Qle' , out % Qle , & ranges % Qle , patchout % Qle , 'default' , met ) ! Reset temporary output variable: out % Qle = 0.0 END IF END IF ! Qh: sensible heat flux [W/m&#94;2] IF ( output % flux . OR . output % Qh ) THEN ! Add current timestep's value to total of temporary output variable: out % Qh = out % Qh + REAL ( canopy % fh , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Qh = out % Qh / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qh , 'Qh' , out % Qh , & ranges % Qh , patchout % Qh , 'default' , met ) ! Reset temporary output variable: out % Qh = 0.0 END IF END IF ! Qg: ground heat flux [W/m&#94;2] IF ( output % flux . OR . output % Qg ) THEN ! Add current timestep's value to total of temporary output variable: out % Qg = out % Qg + REAL ( canopy % ga , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Qg = out % Qg / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qg , 'Qg' , out % Qg , & ranges % Qg , patchout % Qg , 'default' , met ) ! Reset temporary output variable: out % Qg = 0.0 END IF END IF ! Qs: surface runoff [kg/m&#94;2/s] IF ( output % flux . OR . output % Qs ) THEN ! Add current timestep's value to total of temporary output variable: out % Qs = out % Qs + ssnow % rnof1 / dels IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Qs = out % Qs / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qs , 'Qs' , out % Qs , & ranges % Qs , patchout % Qs , 'default' , met ) ! Reset temporary output variable: out % Qs = 0.0 END IF END IF ! Qsb: subsurface runoff [kg/m&#94;2/s] IF ( output % flux . OR . output % Qsb ) THEN ! Add current timestep's value to total of temporary output variable: out % Qsb = out % Qsb + REAL ( ssnow % rnof2 / dels , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Qsb = out % Qsb / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qsb , 'Qsb' , out % Qsb , & ranges % Qsb , patchout % Qsb , 'default' , met ) ! Reset temporary output variable: out % Qsb = 0.0 END IF END IF ! Evap: total evapotranspiration [kg/m&#94;2/s] IF ( output % flux . OR . output % Evap ) THEN ! Add current timestep's value to total of temporary output variable: out % Evap = out % Evap + REAL ( canopy % fe / air % rlam , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Evap = out % Evap / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Evap , 'Evap' , out % Evap , & ranges % Evap , patchout % Evap , 'default' , met ) ! Reset temporary output variable: out % Evap = 0.0 END IF END IF ! ECanop: interception evaporation [kg/m&#94;2/s] IF ( output % flux . OR . output % ECanop ) THEN ! Add current timestep's value to total of temporary output variable: out % ECanop = out % ECanop + REAL ( canopy % fevw / air % rlam , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % ECanop = out % ECanop / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % ECanop , 'ECanop' , & out % ECanop , ranges % ECanop , patchout % ECanop , 'default' , met ) ! Reset temporary output variable: out % ECanop = 0.0 END IF END IF ! TVeg: vegetation transpiration [kg/m&#94;2/s] IF ( output % flux . OR . output % TVeg ) THEN ! Add current timestep's value to total of temporary output variable: out % TVeg = out % TVeg + REAL ( canopy % fevc / air % rlam , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % TVeg = out % TVeg / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % TVeg , 'TVeg' , out % TVeg , & ranges % TVeg , patchout % TVeg , 'default' , met ) ! Reset temporary output variable: out % TVeg = 0.0 END IF END IF ! ESoil: bare soil evaporation [kg/m&#94;2/s] IF ( output % flux . OR . output % ESoil ) THEN ! Add current timestep's value to total of temporary output variable: IF ( cable_user % SOIL_STRUC == 'sli' ) THEN out % ESoil = out % ESoil + REAL ( ssnow % evap / dels , 4 ) !vh! ELSE out % ESoil = out % ESoil + REAL ( canopy % fes / air % rlam , 4 ) ENDIF IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % ESoil = out % ESoil / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % ESoil , 'ESoil' , & out % ESoil , ranges % ESoil , patchout % ESoil , 'default' , met ) ! Reset temporary output variable: out % ESoil = 0.0 END IF END IF ! HVeg: sensible heat from vegetation [W/m&#94;2] IF ( output % flux . OR . output % HVeg ) THEN ! Add current timestep's value to total of temporary output variable: out % HVeg = out % HVeg + REAL ( canopy % fhv , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % HVeg = out % HVeg / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % HVeg , 'HVeg' , out % HVeg , & ranges % HVeg , patchout % HVeg , 'default' , met ) ! Reset temporary output variable: out % HVeg = 0.0 END IF END IF ! HSoil: sensible heat from soil [W/m&#94;2] IF ( output % flux . OR . output % HSoil ) THEN ! Add current timestep's value to total of temporary output variable: out % HSoil = out % HSoil + REAL ( canopy % fhs , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % HSoil = out % HSoil / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % HSoil , 'HSoil' , & out % HSoil , ranges % HSoil , patchout % HSoil , 'default' , met ) ! Reset temporary output variable: out % HSoil = 0.0 END IF out % RnetSoil = out % RnetSoil + REAL ( canopy % fns , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % RnetSoil = out % RnetSoil / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % RnetSoil , 'RnetSoil' , & out % RnetSoil , ranges % HSoil , patchout % HSoil , 'default' , met ) ! Reset temporary output variable: out % RnetSoil = 0.0 END IF END IF ! NEE: net ecosystem exchange [umol/m&#94;2/s] IF ( output % flux . OR . output % carbon . OR . output % NEE ) THEN ! Add current timestep's value to total of temporary output variable: out % NEE = out % NEE + REAL ( canopy % fnee / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % NEE = out % NEE / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % NEE , 'NEE' , out % NEE , & ranges % NEE , patchout % NEE , 'default' , met ) ! Reset temporary output variable: out % NEE = 0.0 END IF END IF !-----------------------WRITE SOIL STATE DATA------------------------------- ! SoilMoist: av.layer soil moisture [kg/m&#94;2] IF ( output % soil . OR . output % SoilMoist ) THEN ! Add current timestep's value to total of temporary output variable: out % SoilMoist = out % SoilMoist + REAL ( ssnow % wb , 4 ) out % SoilMoistIce = out % SoilMoistIce + REAL ( ssnow % wbice , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SoilMoist = out % SoilMoist / REAL ( output % interval , 4 ) out % SoilMoistIce = out % SoilMoistIce / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SoilMoist , 'SoilMoist' , & out % SoilMoist , ranges % SoilMoist , patchout % SoilMoist , 'soil' , met ) CALL write_ovar ( out_timestep , ncid_out , ovid % SoilMoistIce , 'SoilMoistIce' , & out % SoilMoistIce , ranges % SoilMoist , patchout % SoilMoistIce , 'soil' , met ) ! Reset temporary output variable: out % SoilMoist = 0.0 out % SoilMoistIce = 0.0 END IF END IF ! SoilTemp: av.layer soil temperature [K] IF ( output % soil . OR . output % SoilTemp ) THEN ! Add current timestep's value to total of temporary output variable: out % SoilTemp = out % SoilTemp + REAL ( ssnow % tgg , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SoilTemp = out % SoilTemp / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SoilTemp , 'SoilTemp' , & out % SoilTemp , ranges % SoilTemp , patchout % SoilTemp , 'soil' , met ) ! Reset temporary output variable: out % SoilTemp = 0.0 END IF END IF ! BaresoilT: surface bare soil temp [K] IF ( output % soil . OR . output % BaresoilT ) THEN ! Add current timestep's value to total of temporary output variable: out % BaresoilT = out % BaresoilT + REAL ( ssnow % tgg (:, 1 ), 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % BaresoilT = out % BaresoilT / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % BaresoilT , 'BaresoilT' , & out % BaresoilT , ranges % BaresoilT , patchout % BaresoilT , 'default' , met ) ! Reset temporary output variable: out % BaresoilT = 0.0 END IF END IF !MD Write the hydrology output data from the groundwater module calculations !water table depth IF (( output % soil . OR . output % WatTable ) . AND . cable_user % GW_MODEL ) THEN !write(*,*) 'wtd'    !MDeck ! Add current timestep's value to total of temporary output variable: out % WatTable = out % WatTable + REAL ( ssnow % wtd / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % WatTable = out % WatTable / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % WatTable , 'WatTable' , & out % WatTable , ranges % WatTable , patchout % WatTable , 'default' , met ) ! Reset temporary output variable: out % WatTable = 0.0 END IF END IF !aquifer water content IF (( output % soil . OR . output % GWMoist ) . AND . cable_user % GW_MODEL ) THEN out % GWMoist = out % GWMoist + REAL ( ssnow % GWwb , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % GWMoist = out % GWMoist / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % GWMoist , 'GWMoist' , & out % GWMoist , ranges % GWwb , patchout % GWMoist , 'default' , met ) ! Reset temporary output variable: out % GWMoist = 0.0 END IF END IF IF (( output % soil . OR . output % SatFrac ) . AND . cable_user % GW_MODEL ) THEN !write(*,*) 'Qinfl'    !MDeck ! Add current timestep's value to total of temporary output variable: out % SatFrac = out % SatFrac + REAL ( ssnow % satfrac , 4 ) IF ( writenow ) THEN out % SatFrac = out % SatFrac / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SatFrac , 'SatFrac' , & out % SatFrac , ranges % SatFrac , patchout % SatFrac , 'default' , met ) ! Reset temporary output variable: out % SatFrac = 0.0 END IF END IF ! recharge rate IF ( output % soil . OR . output % Qrecharge ) THEN ! Add current timestep's value to total of temporary output variable: out % Qrecharge = out % Qrecharge + REAL ( ssnow % Qrecharge , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Qrecharge = out % Qrecharge / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qrecharge , 'Qrecharge' , & out % Qrecharge , ranges % Qrecharge , patchout % Qrecharge , 'default' , met ) ! Reset temporary output variable: out % Qrecharge = 0.0 END IF END IF !----------------------WRITE SNOW STATE DATA-------------------------------- ! SWE: snow water equivalent [kg/m&#94;2] IF ( output % snow . OR . output % SWE ) THEN ! Add current timestep's value to total of temporary output variable: out % SWE = out % SWE + REAL ( ssnow % snowd , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SWE = out % SWE / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SWE , 'SWE' , out % SWE , & ranges % SWE , patchout % SWE , 'default' , met ) ! Reset temporary output variable: out % SWE = 0.0 END IF ! Add current timestep's value to total of temporary output variable: out % SnowMelt = out % SnowMelt + REAL ( ssnow % smelt , 4 ) / dels ! temp test vh ! !out%SnowMelt = out%SnowMelt + REAL(ssnow%nsteps, 4)/dels IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SnowMelt = out % SnowMelt / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SnowMelt , 'SnowMelt' , out % SnowMelt , & ( /- 9999 9.0 , 999999 9.0 / ), patchout % SnowMelt , 'default' , met ) ! Reset temporary output variable: out % SnowMelt = 0.0 END IF END IF ! SnowT: snow surface temp [K] IF ( output % snow . OR . output % SnowT ) THEN ! Add current timestep's value to total of temporary output variable: out % SnowT = out % SnowT + REAL ( ssnow % tggsn (:, 1 ), 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SnowT = out % SnowT / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SnowT , 'SnowT' , & out % SnowT , ranges % SnowT , patchout % SnowT , 'default' , met ) ! Reset temporary output variable: out % SnowT = 0.0 END IF END IF ! SnowDepth: actual depth of snow in [m] IF ( output % snow . OR . output % SnowDepth ) THEN ! Add current timestep's value to total of temporary output variable: out % SnowDepth = out % SnowDepth + REAL ( SUM ( ssnow % sdepth , 2 ), 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SnowDepth = out % SnowDepth / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SnowDepth , 'SnowDepth' , & out % SnowDepth , ranges % SnowDepth , patchout % SnowDepth , 'default' , met ) ! Reset temporary output variable: out % SnowDepth = 0.0 END IF END IF !-------------------------WRITE RADIATION DATA------------------------------ ! SWnet: net shortwave [W/m&#94;2] IF ( output % radiation . OR . output % SWnet ) THEN ! Add current timestep's value to total of temporary output variable: out % SWnet = out % SWnet + REAL ( SUM ( rad % qcan (:, :, 1 ), 2 ) + & SUM ( rad % qcan (:, :, 2 ), 2 ) + rad % qssabs , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SWnet = out % SWnet / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SWnet , 'SWnet' , & out % SWnet , ranges % SWnet , patchout % SWnet , 'default' , met ) ! Reset temporary output variable: out % SWnet = 0.0 END IF END IF ! LWnet: net longwave [W/m&#94;2] IF ( output % radiation . OR . output % LWnet ) THEN ! Add current timestep's value to total of temporary output variable: out % LWnet = out % LWnet + & REAL ( met % fld - sboltz * emleaf * canopy % tv ** 4 * ( 1 - rad % transd ) - & rad % flws * rad % transd , 4 ) ! REV_CORR (needed for testing and offline-as-online cases): ! correction term added in entirety onto %LWnet not (1-rad%transd)* ! for standard offline cases %fns_cor = 0. IF ( cable_user % L_REV_CORR ) THEN out % LWnet = out % LWnet + canopy % fns_cor ENDIF IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % LWnet = out % LWnet / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % LWnet , 'LWnet' , & out % LWnet , ranges % LWnet , patchout % LWnet , 'default' , met ) ! Reset temporary output variable: out % LWnet = 0.0 END IF END IF ! Rnet: net absorbed radiation [W/m&#94;2] IF ( output % radiation . OR . output % Rnet ) THEN ! Add current timestep's value to total of temporary output variable: out % Rnet = out % Rnet + REAL ( met % fld - sboltz * emleaf * canopy % tv ** 4 * & ( 1 - rad % transd ) - rad % flws * rad % transd + & SUM ( rad % qcan (:, :, 1 ), 2 ) + & SUM ( rad % qcan (:, :, 2 ), 2 ) + rad % qssabs , 4 ) ! REV_CORR (needed for testing and offline-as-online cases): ! correction term added in entirety onto %Rnet not (1-rad%transd)* ! for standard offline cases %fns_cor = 0. IF ( cable_user % L_REV_CORR ) THEN out % Rnet = out % Rnet + canopy % fns_cor ENDIF IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Rnet = out % Rnet / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Rnet , 'Rnet' , out % Rnet , & ranges % Rnet , patchout % Rnet , 'default' , met ) ! Reset temporary output variable: out % Rnet = 0.0 END IF END IF ! Albedo: IF ( output % radiation . OR . output % Albedo ) THEN ! Add current timestep's value to total of temporary output variable: out % Albedo = out % Albedo + REAL (( rad % albedo (:, 1 ) + rad % albedo (:, 2 )) & * 0.5 , 4 ) ! output calc of soil albedo based on colour? - Ticket #27 IF ( calcsoilalbedo ) THEN out % visAlbedo = out % visAlbedo + REAL ( rad % albedo (:, 1 ) , 4 ) out % nirAlbedo = out % nirAlbedo + REAL ( rad % albedo (:, 2 ) , 4 ) END IF IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Albedo = out % Albedo / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Albedo , 'Albedo' , & out % Albedo , ranges % Albedo , patchout % Albedo , 'default' , met ) ! Reset temporary output variable: out % Albedo = 0.0 ! output calc of soil albedo based on colour? - Ticket #27 IF ( calcsoilalbedo ) THEN out % visAlbedo = out % visAlbedo / REAL ( output % interval , 4 ) CALL write_ovar ( out_timestep , ncid_out , ovid % visAlbedo , 'visAlbedo' ,& out % visAlbedo , ranges % visAlbedo , patchout % visAlbedo , 'default' , met ) out % visAlbedo = 0.0 out % nirAlbedo = out % nirAlbedo / REAL ( output % interval , 4 ) CALL write_ovar ( out_timestep , ncid_out , ovid % nirAlbedo , 'nirAlbedo' ,& out % nirAlbedo , ranges % nirAlbedo , patchout % nirAlbedo , 'default' , met ) out % nirAlbedo = 0.0 END IF END IF END IF ! RadT: Radiative surface temperature [K] IF ( output % radiation . OR . output % RadT ) THEN ! Add current timestep's value to total of temporary output variable: out % RadT = out % RadT + REAL (((( 1.0 - rad % transd ) * emleaf * sboltz * & canopy % tv ** 4 + rad % transd * emsoil * sboltz * ( ssnow % tss ) ** 4 ) / sboltz ) & ** 0.25 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % RadT = out % RadT / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % RadT , 'RadT' , out % RadT , & ranges % RadT , patchout % RadT , 'default' , met ) ! Reset temporary output variable: out % RadT = 0.0 END IF END IF !------------------------WRITE VEGETATION DATA------------------------------ ! Tscrn: screen level air temperature [oC] IF ( output % Tscrn . OR . output % veg ) THEN ! Add current timestep's value to total of temporary output variable: out % Tscrn = out % Tscrn + REAL ( canopy % tscrn , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Tscrn = out % Tscrn / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Tscrn , 'Tscrn' , & out % Tscrn , ranges % Tscrn , patchout % Tscrn , 'ALMA' , met ) ! Reset temporary output variable: out % Tscrn = 0.0 END IF END IF !INH - extremes in screen level air temperature [oC] IF ( output % Tex . OR . output % veg ) THEN !if 'daily' then only daily values - using variables Txx and Tnn IF ( output % averaging ( 1 : 2 ) == 'da' ) THEN DO iy = 1 , mp out % Txx ( iy ) = MAX ( out % Txx ( iy ), REAL ( canopy % tscrn ( iy ), 4 )) out % Tnn ( iy ) = MIN ( out % Tnn ( iy ), REAL ( canopy % tscrn ( iy ), 4 )) ENDDO IF ( writenow ) THEN CALL write_ovar ( out_timestep , ncid_out , ovid % Txx , 'Txx' , & out % Txx , ranges % Tscrn , patchout % Tex , 'ALMA' , met ) CALL write_ovar ( out_timestep , ncid_out , ovid % Tnn , 'Tnn' , & out % Tnn , ranges % Tscrn , patchout % Tex , 'ALMA' , met ) !Reset temporary output variables: out % Txx = - 1.0E6 out % Tnn = 1.0E6 ENDIF ENDIF IF ( output % averaging ( 1 : 2 ) == 'mo' ) THEN !if monthly then both full extremes and averaged extremes DO iy = 1 , mp out % Txx ( iy ) = MAX ( out % Txx ( iy ), REAL ( canopy % tscrn ( iy ), 4 )) out % Tnn ( iy ) = MIN ( out % Tnn ( iy ), REAL ( canopy % tscrn ( iy ), 4 )) out % Tdaymx ( iy ) = MAX ( out % Tdaymx ( iy ), REAL ( canopy % tscrn ( iy ), 4 )) out % Tdaymn ( iy ) = MIN ( out % Tdaymn ( iy ), REAL ( canopy % tscrn ( iy ), 4 )) ENDDO !take copy of day's max/min for averaged output - reset Tdaymx/mn IF ( MOD ( ktau , 24 * 3600 / INT ( dels )) == 0 ) THEN out % Tmx = out % Tmx + out % Tdaymx out % Tmn = out % Tmn + out % Tdaymn out % Tdaymx = - 1.0E6 out % Tdaymn = 1.0E6 ENDIF IF ( writenow ) THEN !divide by number of records in average (dels*%interval/24/3600) out % Tmx = REAL ( 86400 , 4 ) * out % Tmx / REAL ( output % interval * INT ( dels ), 4 ) out % Tmn = REAL ( 86400 , 4 ) * out % Tmn / REAL ( output % interval * INT ( dels ), 4 ) !write to file CALL write_ovar ( out_timestep , ncid_out , ovid % Txx , 'Txx' , & out % Txx , ranges % Tscrn , patchout % Tex , 'ALMA' , met ) CALL write_ovar ( out_timestep , ncid_out , ovid % Tnn , 'Tnn' , & out % Tnn , ranges % Tscrn , patchout % Tex , 'ALMA' , met ) CALL write_ovar ( out_timestep , ncid_out , ovid % Tmx , 'Tmx' , & out % Tmx , ranges % Tscrn , patchout % Tex , 'ALMA' , met ) CALL write_ovar ( out_timestep , ncid_out , ovid % Tmn , 'Tmn' , & out % Tmn , ranges % Tscrn , patchout % Tex , 'ALMA' , met ) !Reset temporary output variables: out % Txx = - 1.0E6 out % Tnn = 1.0E6 out % Tmx = 0.0 out % Tmn = 0.0 ENDIF ENDIF ENDIF ! Qscrn: screen level specific humdity [kg/kg] IF ( output % Qscrn . OR . output % veg ) THEN ! Add current timestep's value to total of temporary output variable: out % Qscrn = out % Qscrn + REAL ( canopy % qscrn , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % qscrn = out % qscrn / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Qscrn , 'Qscrn' , & out % Qscrn , ranges % Qscrn , patchout % Qscrn , 'ALMA' , met ) ! Reset temporary output variable: out % Qscrn = 0.0 END IF END IF ! VegT: vegetation temperature [K] IF ( output % veg . OR . output % VegT ) THEN ! Add current timestep's value to total of temporary output variable: out % VegT = out % VegT + REAL ( canopy % tv , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % VegT = out % VegT / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % VegT , 'VegT' , out % VegT , & ranges % VegT , patchout % VegT , 'default' , met ) ! Reset temporary output variable: out % VegT = 0.0 END IF END IF ! CanT: within-canopy temperature [K] IF ( output % veg . OR . output % CanT ) THEN ! Add current timestep's value to total of temporary output variable: out % CanT = out % CanT + REAL ( met % tvair , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % CanT = out % CanT / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % CanT , 'CanT' , out % CanT , & ranges % CanT , patchout % CanT , 'default' , met ) ! Reset temporary output variable: out % CanT = 0.0 END IF END IF IF ( output % veg . OR . output % Fwsoil ) THEN ! Add current timestep's value to total of temporary output variable: out % Fwsoil = out % Fwsoil + REAL ( canopy % fwsoil , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Fwsoil = out % Fwsoil / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Fwsoil , 'Fwsoil' , out % Fwsoil , & ranges % Fwsoil , patchout % Fwsoil , 'default' , met ) ! Reset temporary output variable: out % Fwsoil = 0.0 END IF END IF ! CanopInt: total canopy water storage [kg/m&#94;2] IF ( output % veg . OR . output % CanopInt ) THEN ! Add current timestep's value to total of temporary output variable: out % CanopInt = out % CanopInt + REAL ( canopy % cansto , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % CanopInt = out % CanopInt / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % CanopInt , 'CanopInt' , & out % CanopInt , ranges % CanopInt , patchout % CanopInt , 'default' , met ) ! Reset temporary output variable: out % CanopInt = 0.0 END IF END IF ! LAI: IF ( output % veg . OR . output % LAI ) THEN ! Add current timestep's value to total of temporary output variable: out % LAI = out % LAI + REAL ( veg % vlai , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % LAI = out % LAI / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % LAI , 'LAI' , out % LAI , & ranges % LAI , patchout % LAI , 'default' , met ) ! Reset temporary output variable: out % LAI = 0.0 END IF END IF !------------------------WRITE BALANCES DATA-------------------------------- ! Ebal: cumulative energy balance [W/m&#94;2] IF ( output % balances . OR . output % Ebal ) THEN ! Add current timestep's value to total of temporary output variable: out % Ebal = out % Ebal + REAL ( bal % ebal_tot , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Ebal = out % Ebal / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Ebal , 'Ebal' , out % Ebal , & ranges % Ebal , patchout % Ebal , 'default' , met ) ! Reset temporary output variable: out % Ebal = 0.0 END IF END IF ! Wbal: cumulative water balance  [kg/m&#94;2/s] IF ( output % balances . OR . output % Wbal ) THEN ! Add current timestep's value to total of temporary output variable: out % Wbal = out % Wbal + REAL ( bal % wbal_tot , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % Wbal = out % Wbal / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Wbal , 'Wbal' , & out % Wbal , ranges % Wbal , patchout % Wbal , 'default' , met ) ! Reset temporary output variable: out % Wbal = 0.0 END IF END IF !------------------------WRITE CARBON DATA---------------------------------- ! GPP: gross primary production C by veg [umol/m&#94;2/s] !      added frday in the calculation of GPP (BP may08) IF ( output % carbon . OR . output % GPP ) THEN ! Add current timestep's value to total of temporary output variable: out % GPP = out % GPP + REAL (( - 1.0 * canopy % fpn + canopy % frday ) & / 1.201E-5 , 4 ) ! out%GPP = out%GPP + REAL((-1.0 * canopy%fpn)             & !                         / 1.201E-5, 4) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % GPP = out % GPP / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % GPP , 'GPP' , out % GPP , & ranges % GPP , patchout % GPP , 'default' , met ) ! Reset temporary output variable: out % GPP = 0.0 END IF END IF ! NPP: net primary production of C by veg [umol/m&#94;2/s] IF ( output % carbon . OR . output % NPP ) THEN ! Add current timestep's value to total of temporary output variable: !out%NPP = out%NPP + REAL((-1.0 * canopy%fpn - canopy%frp & !     - casaflux%clabloss/86400.0) / 1.201E-5, 4) ! vh ! expression below can be slightly different form that above in cases where ! leaf maintenance respiration is reduced in CASA ! (relative to its original value calculated in cable_canopy) ! in order to avoid negative carbon stores. IF ( output % casa ) THEN out % NPP = out % NPP + REAL ( casaflux % cnpp / 8640 0.0 / 1.201E-5 , 4 ) ELSE out % NPP = out % NPP + REAL (( - 1.0 * canopy % fpn - canopy % frp ) / 1.201E-5 ) ! & ENDIF IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % NPP = out % NPP / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % NPP , 'NPP' , out % NPP , & ranges % NPP , patchout % NPP , 'default' , met ) ! Reset temporary output variable: out % NPP = 0.0 END IF END IF ! AutoResp: autotrophic respiration [umol/m&#94;2/s] IF ( output % carbon . OR . output % AutoResp ) THEN ! Add current timestep's value to total of temporary output variable: !out%AutoResp = out%AutoResp + REAL((canopy%frp + canopy%frday + casaflux%clabloss/86400.0)          & !                                    / 1.201E-5, 4) ! vh ! expression below can be slightly different form that above in cases where ! leaf maintenance respiration is reduced in CASA ! (relative to its original value calculated in cable_canopy) ! in order to avoid negative carbon stores. IF ( output % casa ) THEN out % AutoResp = out % AutoResp + REAL ( canopy % frday / 1.201E-5 , 4 ) + & REAL (( casaflux % crmplant (:, 2 ) / 8640 0.0 + casaflux % crmplant (:, 3 ) / 8640 0.0 + & casaflux % crgplant / 8640 0.0 + casaflux % clabloss / 8640 0. ) / 1.201E-5 , 4 ) ELSE out % AutoResp = out % AutoResp + REAL (( canopy % frp + canopy % frday ) & / 1.201E-5 , 4 ) ENDIF IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % AutoResp = out % AutoResp / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % AutoResp , 'AutoResp' , & out % AutoResp , ranges % AutoResp , patchout % AutoResp , 'default' , met ) ! Reset temporary output variable: out % AutoResp = 0.0 END IF IF ( output % casa ) THEN out % RootResp = out % RootResp + REAL ( casaflux % crmplant (:, 3 ) / 8640 0.0 / 1.201E-5 , 4 ) !+ & ! REAL(0.3*casaflux%crmplant(:,2)/86400.0/ 1.201E-5, 4) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % RootResp = out % RootResp / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % RootResp , 'RootResp' , & out % RootResp , ranges % AutoResp , patchout % AutoResp , 'default' , met ) ! Reset temporary output variable: out % RootResp = 0.0 END IF END IF IF ( output % casa ) THEN out % StemResp = out % StemResp + REAL ( casaflux % crmplant (:, 2 ) / 8640 0.0 / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % StemResp = out % StemResp / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % StemResp , 'StemResp' , & out % StemResp , ranges % AutoResp , patchout % AutoResp , 'default' , met ) ! Reset temporary output variable: out % StemResp = 0.0 END IF END IF END IF ! LeafResp: Leaf respiration [umol/m&#94;2/s] IF ( output % carbon . OR . output % LeafResp ) THEN ! Add current timestep's value to total of temporary output variable: out % LeafResp = out % LeafResp + REAL ( canopy % frday / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % LeafResp = out % LeafResp / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % LeafResp , 'LeafResp' , & out % LeafResp , ranges % LeafResp , patchout % LeafResp , 'default' , met ) ! Reset temporary output variable: out % LeafResp = 0.0 END IF END IF ! HeteroResp: heterotrophic respiration [umol/m&#94;2/s] IF ( output % carbon . OR . output % HeteroResp ) THEN ! Add current timestep's value to total of temporary output variable: out % HeteroResp = out % HeteroResp + REAL ( canopy % frs / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % HeteroResp = out % HeteroResp / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % HeteroResp , & 'HeteroResp' , out % HeteroResp , ranges % HeteroResp , & patchout % HeteroResp , 'default' , met ) ! Reset temporary output variable: out % HeteroResp = 0.0 END IF END IF ! output patch area IF ( output % casa ) THEN out % Area = casamet % areacell / 1e6 ! km2 IF ( writenow ) THEN ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % Area , 'Area' , out % Area , & ranges % Area , patchout % Area , 'default' , met ) END IF IF ( cable_user % POPLUC ) THEN ! output patch fraction IF ( writenow ) THEN CALL write_ovar ( out_timestep , ncid_out , opid % patchfrac , 'patchfrac' , & REAL ( patch (:)% frac , 4 ), ( / 0.0 , 1.0 / ), patchout % patchfrac , 'default' , met ) END IF ENDIF ENDIF IF ( cable_user % CALL_POP ) THEN IF ( writenow ) THEN IF ( output % params . OR . output % hc ) CALL write_ovar ( out_timestep , ncid_out , opid % hc , & 'hc' , REAL ( veg % hc , 4 ), ranges % hc , patchout % hc , 'default' , met ) ENDIF ENDIF ! NBP and turnover fluxes [umol/m&#94;2/s] IF (( output % carbon . OR . output % NBP ) . AND . output % casa ) THEN ! Add current timestep's value to total of temporary output variable: IF ( cable_user % POPLUC ) THEN out % NBP = out % NBP + - REAL (( casaflux % Crsoil - casaflux % cnpp & - casapool % dClabiledt ) / 8640 0.0 & / 1.201E-5 , 4 ) !-  & !REAL((casaflux%FluxCtohwp + casaflux%FluxCtoclear  )/86400.0 & !/ 1.201E-5, 4) ELSE out % NBP = out % NBP + - REAL (( casaflux % Crsoil - casaflux % cnpp & - casapool % dClabiledt ) / 8640 0.0 & / 1.201E-5 , 4 ) ENDIF IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % NBP = out % NBP / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % NBP , 'NBP' , out % NBP , & ranges % NEE , patchout % NBP , 'default' , met ) ! Reset temporary output variable: out % NBP = 0.0 END IF ENDIF IF ( output % casa ) THEN ! Add current timestep's value to total of temporary output variable: out % dCdt = out % dCdt + REAL (( casapool % ctot - casapool % ctot_0 ) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % dCdt = out % dCdt / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % dCdt , 'dCdt' , out % dCdt , & ranges % NEE , patchout % dCdt , 'default' , met ) ! Reset temporary output variable: out % dCdt = 0.0 END IF ! Add current timestep's value to total of temporary output variable: out % PlantTurnover = out % PlantTurnover + REAL (( SUM ( casaflux % Cplant_turnover , 2 )) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantTurnover = out % PlantTurnover / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantTurnover , 'PlantTurnover' , out % PlantTurnover , & ranges % NEE , patchout % PlantTurnover , 'default' , met ) ! Reset temporary output variable: out % PlantTurnover = 0.0 END IF ! Add current timestep's value to total of temporary output variable: out % PlantTurnoverLeaf = out % PlantTurnoverLeaf + REAL (( casaflux % Cplant_turnover (:, 1 )) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantTurnoverLeaf = out % PlantTurnoverLeaf / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantTurnoverLeaf , 'PlantTurnoverLeaf' , out % PlantTurnoverLeaf , & ranges % NEE , patchout % PlantTurnoverLeaf , 'default' , met ) ! Reset temporary output variable: out % PlantTurnoverLeaf = 0.0 END IF ! Add current timestep's value to total of temporary output variable: out % PlantTurnoverFineRoot = out % PlantTurnoverFineRoot + REAL (( casaflux % Cplant_turnover (:, 3 )) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantTurnoverFineRoot = out % PlantTurnoverFineRoot / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantTurnoverFineRoot , 'PlantTurnoverFineRoot' , & out % PlantTurnoverFineRoot , & ranges % NEE , patchout % PlantTurnoverFineRoot , 'default' , met ) ! Reset temporary output variable: out % PlantTurnoverFineRoot = 0.0 END IF ! Add current timestep's value to total of temporary output variable: out % PlantTurnoverWood = out % PlantTurnoverWood + REAL (( casaflux % Cplant_turnover (:, 2 )) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantTurnoverWood = out % PlantTurnoverWood / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantTurnoverWood , 'PlantTurnoverWood' , out % PlantTurnoverWood , & ranges % NEE , patchout % PlantTurnoverWood , 'default' , met ) ! Reset temporary output variable: out % PlantTurnoverWood = 0.0 END IF ! Add current timestep's value to total of temporary output variable: out % PlantTurnoverWoodDist = out % PlantTurnoverWoodDist + & REAL (( casaflux % Cplant_turnover_disturbance ) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantTurnoverWoodDist = out % PlantTurnoverWoodDist / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantTurnoverWoodDist , 'PlantTurnoverWoodDist' , & out % PlantTurnoverWoodDist , & ranges % NEE , patchout % PlantTurnoverWoodDist , 'default' , met ) ! Reset temporary output variable: out % PlantTurnoverWoodDist = 0.0 END IF ! Add current timestep's value to total of temporary output variable: out % PlantTurnoverWoodCrowding = out % PlantTurnoverWoodCrowding + & REAL (( casaflux % Cplant_turnover_crowding ) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantTurnoverWoodCrowding = out % PlantTurnoverWoodCrowding / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantTurnoverWoodCrowding , 'PlantTurnoverWoodCrowding' , & out % PlantTurnoverWoodCrowding , & ranges % NEE , patchout % PlantTurnoverWoodCrowding , 'default' , met ) ! Reset temporary output variable: out % PlantTurnoverWoodCrowding = 0.0 END IF ! Add current timestep's value to total of temporary output variable: out % PlantTurnoverWoodResourceLim = out % PlantTurnoverWoodResourceLim + & REAL (( casaflux % Cplant_turnover_resource_limitation ) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantTurnoverWoodResourceLim = out % PlantTurnoverWoodResourceLim / & REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantTurnoverWoodResourceLim , & 'PlantTurnoverWoodResourceLim' , & out % PlantTurnoverWoodResourceLim , & ranges % NEE , patchout % PlantTurnoverWoodResourceLim , 'default' , met ) ! Reset temporary output variable: out % PlantTurnoverWoodResourceLim = 0.0 END IF IF ( cable_user % POPLUC ) THEN ! Add current timestep's value to total of temporary output variable: out % LandUseFlux = out % LandUseFlux + & REAL (( casaflux % FluxCtohwp + casaflux % FluxCtoclear ) / 8640 0.0 & / 1.201E-5 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % LandUseFlux = out % LandUseFlux / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % LandUseFlux , 'LandUseFlux' , & out % LandUseFlux , & ranges % NEE , patchout % LandUseFlux , 'default' , met ) ! Reset temporary output variable: out % LandUseFlux = 0.0 END IF ENDIF END IF ! plant carbon [kg C m-2] IF ( output % casa ) THEN out % TotSoilCarb = out % TotSoilCarb + REAL (( SUM ( casapool % csoil , 2 ) + SUM ( casapool % clitter , 2 )) & / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % TotSoilCarb = out % TotSoilCarb / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % TotSoilCarb , 'TotSoilCarb' , out % TotSoilCarb , & ranges % TotSoilCarb , patchout % TotSoilCarb , 'default' , met ) ! Reset temporary output variable: out % TotSoilCarb = 0.0 END IF out % TotLittCarb = out % TotLittCarb + REAL ( SUM ( casapool % clitter , 2 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % TotLittCarb = out % TotLittCarb / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % TotLittCarb , 'TotLittCarb' , out % TotLittCarb , & ranges % TotLittCarb , patchout % TotLittCarb , 'default' , met ) ! Reset temporary output variable: out % TotLittCarb = 0.0 END IF out % SoilCarbFast = out % SoilCarbFast + REAL ( casapool % csoil (:, 1 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SoilCarbFast = out % SoilCarbFast / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SoilCarbFast , 'SoilCarbFast' & , out % SoilCarbFast , & ranges % TotSoilCarb , patchout % SoilCarbFast , 'default' , met ) ! Reset temporary output variable: out % SoilCarbFast = 0.0 END IF out % SoilCarbSlow = out % SoilCarbSlow + REAL ( casapool % csoil (:, 2 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SoilCarbSlow = out % SoilCarbSlow / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SoilCarbSlow , 'SoilCarbSlow' & , out % SoilCarbSlow , & ranges % TotSoilCarb , patchout % SoilCarbSlow , 'default' , met ) ! Reset temporary output variable: out % SoilCarbSlow = 0.0 END IF out % SoilCarbPassive = out % SoilCarbPassive + REAL ( casapool % csoil (:, 3 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % SoilCarbPassive = out % SoilCarbPassive / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % SoilCarbPassive , 'SoilCarbPassive' & , out % SoilCarbPassive , & ranges % TotSoilCarb , patchout % SoilCarbPassive , 'default' , met ) ! Reset temporary output variable: out % SoilCarbPassive = 0.0 END IF out % LittCarbMetabolic = out % LittCarbMetabolic + REAL ( casapool % clitter (:, 1 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % LittCarbMetabolic = out % LittCarbMetabolic / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % LittCarbMetabolic , 'LittCarbMetabolic' , out % LittCarbMetabolic , & ranges % TotLittCarb , patchout % LittCarbMetabolic , 'default' , met ) ! Reset temporary output variable: out % LittCarbMetabolic = 0.0 END IF out % LittCarbStructural = out % LittCarbStructural + REAL ( casapool % clitter (:, 2 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % LittCarbStructural = out % LittCarbStructural / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % LittCarbStructural , 'LittCarbStructural' , out % LittCarbStructural , & ranges % TotLittCarb , patchout % LittCarbStructural , 'default' , met ) ! Reset temporary output variable: out % LittCarbStructural = 0.0 END IF out % LittCarbCWD = out % LittCarbCWD + REAL ( casapool % clitter (:, 3 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % LittCarbCWD = out % LittCarbCWD / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % LittCarbCWD , 'LittCarbCWD' , out % LittCarbCWD , & ranges % TotLittCarb , patchout % LittCarbCWD , 'default' , met ) ! Reset temporary output variable: out % LittCarbCWD = 0.0 END IF out % PlantCarbLeaf = out % PlantCarbLeaf + REAL ( casapool % cplant (:, 1 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantCarbLeaf = out % PlantCarbLeaf / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantCarbLeaf , 'PlantCarbLeaf' , out % PlantCarbLeaf , & ranges % TotLittCarb , patchout % PlantCarbLeaf , 'default' , met ) ! Reset temporary output variable: out % PlantCarbLeaf = 0.0 END IF out % PlantCarbFineRoot = out % PlantCarbFineRoot + REAL ( casapool % cplant (:, 3 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantCarbFineRoot = out % PlantCarbFineRoot / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantCarbFineRoot , 'PlantCarbFineRoot' , & out % PlantCarbFineRoot , & ranges % TotLittCarb , patchout % PlantCarbFineRoot , 'default' , met ) ! Reset temporary output variable: out % PlantCarbFineRoot = 0.0 END IF out % PlantCarbWood = out % PlantCarbWood + REAL ( casapool % cplant (:, 2 ) / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % PlantCarbWood = out % PlantCarbWood / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % PlantCarbWood , 'PlantCarbWood' , out % PlantCarbWood , & ranges % TotLittCarb , patchout % PlantCarbWood , 'default' , met ) ! Reset temporary output variable: out % PlantCarbWood = 0.0 END IF out % TotLivBiomass = out % TotLivBiomass + REAL (( SUM ( casapool % cplant , 2 )) & / 100 0.0 , 4 ) IF ( writenow ) THEN ! Divide accumulated variable by number of accumulated time steps: out % TotLivBiomass = out % TotLivBiomass / REAL ( output % interval , 4 ) ! Write value to file: CALL write_ovar ( out_timestep , ncid_out , ovid % TotLivBiomass , 'TotLivBiomass' , out % TotLivBiomass , & ranges % TotLivBiomass , patchout % TotLivBiomass , 'default' , met ) ! Reset temporary output variable: out % TotLivBiomass = 0.0 END IF END IF IF ( cable_user % sync_nc_file ) & ok = NF90_SYNC ( ncid_out ) END SUBROUTINE write_output !============================================================================= SUBROUTINE close_output_file ( bal , air , bgc , canopy , met , & rad , rough , soil , ssnow , sum_flux , veg ) ! Closes output file, reports cumulative mass and energy ! balances, and deallocates variables. TYPE ( met_type ), INTENT ( INOUT ) :: met TYPE ( air_type ), INTENT ( INOUT ) :: air TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg TYPE ( bgc_pool_type ), INTENT ( INOUT ) :: bgc TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy TYPE ( roughness_type ), INTENT ( INOUT ) :: rough TYPE ( radiation_type ), INTENT ( INOUT ) :: rad TYPE ( sum_flux_type ), INTENT ( INOUT ) :: sum_flux TYPE ( balances_type ), INTENT ( INOUT ) :: bal INTEGER :: i ! do loop counter ! Close file ok = NF90_CLOSE ( ncid_out ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error closing output file ' & // TRIM ( filename % out ) // '(SUBROUTINE close_output_file)' ) ! Report balance info to log file if verbose writing is requested: IF ( output % balances . AND . verbose ) THEN WRITE ( logn , * ) DO i = 1 , mland WRITE ( logn , '(A51,I7,1X,A11,E12.4,A6)' ) & ' Cumulative energy balance for each patch in site #' , & i , 'is (W/m&#94;2):' WRITE ( logn , * ) & bal % ebal_tot ( landpt ( i )% cstart : landpt ( i )% cstart + & landpt ( i )% nap - 1 ) WRITE ( logn , '(A50,I7,1X,A8,E12.4,A3)' ) & ' Cumulative water balance for each patch in site #' , & i , 'is (mm):' WRITE ( logn , * ) & bal % wbal_tot ( landpt ( i )% cstart : landpt ( i )% cstart + & landpt ( i )% nap - 1 ) WRITE ( logn , * ) END DO END IF ! Successful run! WRITE ( logn , * ) WRITE ( logn , * ) 'Run finished and output file closed.' END SUBROUTINE close_output_file !============================================================================= SUBROUTINE create_restart ( logn , dels , ktau , soil , veg , ssnow , & canopy , rough , rad , bgc , bal , met ) ! Creates a restart file for CABLE using a land only grid with mland ! land points and max_vegpatches veg/soil patches (some of which may ! not be active). It uses CABLE's internal variable names. INTEGER , INTENT ( IN ) :: logn ! log file number REAL , INTENT ( IN ) :: dels ! time step size INTEGER , INTENT ( IN ) :: ktau ! timestep number in loop which include spinup TYPE ( met_type ), INTENT ( IN ) :: met ! meteorological data TYPE ( soil_parameter_type ), INTENT ( IN ) :: soil ! soil parameters TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters TYPE ( soil_snow_type ), INTENT ( IN ) :: ssnow ! soil and snow variables TYPE ( bgc_pool_type ), INTENT ( IN ) :: bgc ! carbon pool variables TYPE ( canopy_type ), INTENT ( IN ) :: canopy ! vegetation variables TYPE ( roughness_type ), INTENT ( IN ) :: rough ! roughness varibles TYPE ( radiation_type ), INTENT ( IN ) :: rad ! radiation variables TYPE ( balances_type ), INTENT ( IN ) :: bal ! energy and water balance variables !    INTEGER, INTENT(IN) :: mvtype !    INTEGER, INTENT(IN) :: mstype TYPE ( parID_type ) :: rpid ! parameter IDs for restart nc file INTEGER :: ncid_restart ! netcdf restart file ID ! REAL, POINTER,DIMENSION(:,:) :: surffrac ! fraction of each surf type INTEGER :: dummy ! dummy argument in subroutine call INTEGER :: mlandID , mpID , radID , soilID , napID , & soilcarbID , plantcarbID , tID , snowID ! dimension IDs !    INTEGER :: mlandID, surftypeID, patchID, radID, soilID, & !         soilcarbID, plantcarbID, tID, snowID ! dimension IDs INTEGER :: tvarID , latID , lonID !,surffracID ! time,lat,lon variable ID INTEGER :: tggID , wbID , wbiceID , tssID , ssdnnID , ssdnID , osnowdID , & smassID , sdepthID , snageID , snowdID , rtsoilID , isflagID , & canstoID , albsoilsnID , gammzzID , tggsnID , sghfluxID , & ghfluxID , runoffID , rnof1ID , rnof2ID , gaID , dgdtgID , & fevID , fesID , fhsID , wbtot0ID , osnowd0ID , cplantID , & csoilID , tradID , albedoID , gwID INTEGER :: h0ID , snowliqID , SID , TsurfaceID , scondsID , nsnowID , TsoilID CHARACTER ( LEN = 10 ) :: todaydate , nowtime ! used to timestamp netcdf file ! CHARACTER         :: FRST_OUT*100, CYEAR*4 CHARACTER :: FRST_OUT * 200 , CYEAR * 4 dummy = 0 ! initialise WRITE ( logn , '(A24)' ) ' Writing restart file...' frst_out = TRIM ( filename % restart_out ) ! Look for explicit restart file (netCDF). If not, asssume input is path IF ( INDEX ( TRIM ( frst_out ), '.nc' , BACK = . TRUE .) . NE . LEN_TRIM ( frst_out ) - 2 ) THEN WRITE ( CYEAR , FMT = \"(I4)\" ) CurYear + 1 frst_out = TRIM ( cable_user % RunIden ) // '_' // CYEAR // '_cable_rst.nc' ENDIF ! Create output file: ok = NF90_CREATE ( frst_out , NF90_CLOBBER , ncid_restart ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error creating restart file ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Put the file in define mode: ok = NF90_REDEF ( ncid_restart ) ! Define dimensions: ok = NF90_DEF_DIM ( ncid_restart , 'mland' , mland , mlandID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining mland dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'mp' , mp , mpID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining mp dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'soil' , ms , soilID ) ! number of soil layers IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining vertical soil dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'snow' , 3 , snowID ) ! number of snow layers IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining vertical snow dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'rad' , nrb , radID ) ! number of rad. bands IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining radiation dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'soil_carbon_pools' , ncs , soilcarbID ) ! number of soil carbon pools IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining soil carbon pool dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'plant_carbon_pools' , ncp , plantcarbID ) ! number of plant carbon pools IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining plant carbon pool dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'time' , 1 , tID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ! Define \"time\" variable and its attributes: ok = NF90_DEF_VAR ( ncid_restart , 'time' , NF90_DOUBLE ,( / tID / ), tvarID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , tvarID , 'units' , timeunits ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , tvarID , 'coordinate' , time_coord ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , tvarID , 'calendar' , calendar ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attribute calendar in restart file. ' // & '(SUBROUTINE create_restart)' ) ! Define latitude and longitude variable: ok = NF90_DEF_VAR ( ncid_restart , 'latitude' , NF90_FLOAT , ( / mlandID / ), latID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining latitude variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , latID , 'units' , 'degrees_north' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining latitude variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_VAR ( ncid_restart , 'longitude' , NF90_FLOAT , ( / mlandID / ), lonID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining longitude variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , lonID , 'units' , 'degrees_east' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining longitude variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ! Define number of active patches variable: ok = NF90_DEF_VAR ( ncid_restart , 'nap' , NF90_FLOAT , ( / mlandID / ), napID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining nap variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , napID , 'long_name' , & 'Number of active patches' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining nap variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ! Define patch fraction variable: ok = NF90_DEF_VAR ( ncid_restart , 'patchfrac' , NF90_FLOAT , ( / mpID / ), & rpid % patchfrac ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining patchfrac variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , rpid % patchfrac , 'long_name' , & 'Fraction of vegetated grid cell area occupied by a ' // & 'vegetation/soil patch' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining patchfrac variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ! mvtype (Number of vegetation types): ok = NF90_DEF_VAR ( ncid_restart , 'mvtype' , NF90_INT , rpid % mvtype ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining mvtype variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , rpid % mvtype , \"long_name\" , & \"Number of vegetation types\" ) ! mstype (Number of soil types): ok = NF90_DEF_VAR ( ncid_restart , 'mstype' , NF90_INT , rpid % mstype ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining mstype variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , rpid % mstype , \"long_name\" , & \"Number of soil types\" ) !======begin defining state variables======================================= ! Interface arguments: netcdf file ID, variableID, variable name, variable ! units, variable long name, YES to write patch info (as this is a restart ! file), OPTIONAL extra dimension ID (e.g. for soil dimensioned variables), ! dimension switch to indicate what extra dimension is real or integer for ! single dim variables, xdimID,ydimID, zdimID (all three not used here), ! land dim ID, patch dim ID, YES we're writing a restart file. !------------------define soil states--------------------------------------- CALL define_ovar ( ncid_restart , tggID , 'tgg' , 'K' , & 'Average layer soil temperature' , & . TRUE ., soilID , 'soil' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , wbID , 'wb' , 'vol/vol' , & 'Average layer volumetric soil moisture' , & . TRUE ., soilID , 'r2soil' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , wbiceID , 'wbice' , 'vol/vol' , & 'Average layer volumetric soil ice' , & . TRUE ., soilID , 'r2soil' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , tssID , 'tss' , 'K' , & 'Combined soil/snow temperature' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , albsoilsnID , 'albsoilsn' , '-' , & 'Combined soil/snow albedo' , & . TRUE ., radID , 'radiation' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , rtsoilID , 'rtsoil' , '??' , & 'Turbulent resistance for soil' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , gammzzID , 'gammzz' , 'J/kg/C' , & 'Heat capacity for each soil layer' , & . TRUE ., soilID , 'r2soil' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , runoffID , 'runoff' , 'mm/timestep' , & 'Total runoff' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , rnof1ID , 'rnof1' , 'mm/timestep' , & 'Surface runoff' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , rnof2ID , 'rnof2' , 'mm/timestep' , & 'Subsurface runoff' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !---------------define snow states------------------------------------------ CALL define_ovar ( ncid_restart , tggsnID , 'tggsn' , 'K' , & 'Average layer snow temperature' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , ssdnnID , 'ssdnn' , 'kg/m&#94;3' , & 'Average snow density' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , ssdnID , 'ssdn' , 'kg/m&#94;3' , & 'Average layer snow density' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , snowdID , 'snowd' , 'mm' , & 'Liquid water eqivalent snow depth' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , snageID , 'snage' , '??' , & 'Snow age' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , smassID , 'smass' , 'kg/m&#94;2' , & 'Average layer snow mass' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , sdepthID , 'sdepth' , 'm' , & 'Snow layer depth' , . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , osnowdID , 'osnowd' , 'mm' , & 'Previous time step snow depth in water equivalent' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , isflagID , 'isflag' , '-' , & 'Snow layer scheme flag' , . TRUE ., 'integer' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !----------------define canopy states---------------------------------- CALL define_ovar ( ncid_restart , canstoID , 'cansto' , 'mm' , & 'Canopy surface water storage' , . TRUE ., 'real' , 0 , 0 , 0 , & mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , ghfluxID , 'ghflux' , 'W/m&#94;2?' , & '????' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , sghfluxID , 'sghflux' , 'W/m&#94;2?' , & '????' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , gaID , 'ga' , 'W/m&#94;2' , & 'Ground heat flux' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , dgdtgID , 'dgdtg' , 'W/m&#94;2/K' , & 'Derivative of ground heat flux wrt soil temperature' , . TRUE ., & 'r2' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , fevID , 'fev' , 'W/m&#94;2' , & 'Latent heat flux from vegetation' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , fesID , 'fes' , 'W/m&#94;2' , & 'Latent heat flux from soil' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , fhsID , 'fhs' , 'W/m&#94;2' , & 'Sensible heat flux from soil' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !--------------biogeochemical variables------------------------ CALL define_ovar ( ncid_restart , cplantID , 'cplant' , 'gC/m&#94;2' , & 'Plant carbon stores' , & . TRUE ., plantcarbID , 'plantcarbon' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , csoilID , 'csoil' , 'gC/m&#94;2' , & 'Soil carbon stores' , & . TRUE ., soilcarbID , 'soilcarbon' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !-------------------others--------------------------------- CALL define_ovar ( ncid_restart , wbtot0ID , 'wbtot0' , 'mm' , & 'Initial time step soil water total' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , osnowd0ID , 'osnowd0' , 'mm' , & 'Initial time step snow water total' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , albedoID , 'albedo' , '-' , & 'Albedo for shortwave and NIR radiation' , & . TRUE ., radID , 'radiation' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , tradID , 'trad' , 'K' , & 'Surface radiative temperature (soil/snow/veg inclusive)' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !---------------------MODEL PARAMETERS--------------------------------- WRITE ( logn , '(A43)' ) '   Writing model parameters to restart file' CALL define_ovar ( ncid_restart , rpid % iveg , 'iveg' , '-' , & 'Vegetation type' , . TRUE ., 'integer' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , rpid % isoil , 'isoil' , '-' , & 'Soil type' , . TRUE ., 'integer' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !!$    CALL define_ovar(ncid_restart, rpid%clay, 'clay', '-',                     & !!$                     'Fraction of soil which is clay',                         & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%sand, 'sand', '-',                     & !!$                     'Fraction of soil which is sand',                         & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%silt, 'silt', '-',                     & !!$                     'Fraction of soil which is silt',                         & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%ssat, 'ssat', '-',                     & !!$                     'Fraction of soil volume which is water @ saturation',    & !!$                    .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%sfc, 'sfc', '-',                       & !!$                    'Fraction of soil volume which is water @ field capacity', & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%swilt, 'swilt', '-',                   & !!$                     'Fraction of soil volume which is water @ wilting point', & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) ! zse (depth of each soil layer): ok = NF90_DEF_VAR ( ncid_restart , 'zse' , NF90_FLOAT , ( / soilID / ), rpid % zse ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining zse variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , rpid % zse , \"long_name\" , & \"Depth of each soil layer\" ) ok = NF90_PUT_ATT ( ncid_restart , rpid % zse , \"units\" , \"m\" ) !!$    CALL define_ovar(ncid_restart, rpid%froot, 'froot', '-',                   & !!$                     'Fraction of roots in each soil layer',                   & !!$                      .TRUE., soilID, 'soil', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%bch, 'bch', '-',                       & !!$                     'Parameter b, Campbell eqn 1985',                         & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%hyds, 'hyds', 'm/s',                   & !!$                     'Hydraulic conductivity @ saturation',                    & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%sucs, 'sucs', 'm',                     & !!$                     'Suction @ saturation', .TRUE.,                           & !!$                     'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%css, 'css', 'J/kg/C',                  & !!$                     'Heat capacity of soil minerals',                         & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%rhosoil, 'rhosoil', 'kg/m&#94;3',          & !!$                     'Density of soil minerals',                               & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%rs20, 'rs20', '-',                     & !!$                     'Soil respiration coefficient at 20C',                    & !!$                      .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) CALL define_ovar ( ncid_restart , rpid % albsoil , 'albsoil' , '-' , & 'Soil reflectance' , . TRUE ., & radID , 'radiation' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !!$    CALL define_ovar(ncid_restart, rpid%hc, 'hc', 'm',                         & !!$                     'Height of canopy', .TRUE.,                               & !!$                     'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%canst1, 'canst1', 'mm/LAI',            & !!$                     'Max water intercepted by canopy',                        & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%dleaf, 'dleaf', 'm',                   & !!$                     'Chararacteristic length of leaf',                        & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%frac4, 'frac4', '-',                   & !!$                     'Fraction of plants which are C4',                        & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%ejmax, 'ejmax', 'mol/m&#94;2/s',           & !!$                     'Max potential electron transport rate top leaf', .TRUE., & !!$                     'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%vcmax, 'vcmax', 'mol/m&#94;2/s',           & !!$                     'Maximum RuBP carboxylation rate top leaf', .TRUE.,       & !!$                     'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%rp20, 'rp20', '-',                     & !!$                     'Plant respiration coefficient at 20C', .TRUE., 'real',   & !!$                     0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%g0, 'g0', '-',                     & !!$                     'g0 term in Medlyn Stomatal Cond. Param', .TRUE.,'real',& !!$                     0, 0, 0, mpID, dummy, .TRUE.) ! Ticket #56 !!$    CALL define_ovar(ncid_restart, rpid%g1, 'g1', '-',                     & !!$                     'g1 term in Medlyn Stomatal Cond. Param', .TRUE.,'real',& !!$                     0, 0, 0, mpID, dummy, .TRUE.)  ! Ticket #56 !!$    CALL define_ovar(ncid_restart, rpid%rpcoef, 'rpcoef', '1/C',               & !!$                     'Temperature coef nonleaf plant respiration', .TRUE.,     & !!$                     'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%shelrb, 'shelrb', '-',                 & !!$              'Sheltering factor', .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%xfang, 'xfang', '-',                   & !!$           'Leaf angle parameter', .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%wai, 'wai', '-',                       & !!$                'Wood area index', .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%vegcf, 'vegcf', '-',                   & !!$                     'vegcf', .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%extkn, 'extkn', '-',                   & !!$                     'Extinction coef for vertical nitrogen profile',          & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%tminvj, 'tminvj', 'C',                 & !!$                     'Min temperature for the start of photosynthesis',        & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%tmaxvj, 'tmaxvj', 'C',                 & !!$                     'Max temperature for the start of photosynthesis',        & !!$                      .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%vbeta, 'vbeta', '-',                   & !!$                     'Stomatal sensitivity to soil water',                     & !!$                      .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%xalbnir, 'xalbnir', '-',               & !!$                     'modifier for albedo in near ir band',                    & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    ! ratecp (Plant carbon rate constant): !!$    ok = NF90_DEF_VAR(ncid_restart, 'ratecp', NF90_FLOAT, (/plantcarbID/),     & !!$                      rpid%ratecp) !!$    IF (ok /= NF90_NOERR) CALL nc_abort                                        & !!$                     (ok, 'Error defining ratecp variable in restart file. '// & !!$                      '(SUBROUTINE create_restart)') !!$    ok = NF90_PUT_ATT(ncid_restart, rpid%ratecp, \"long_name\",                  & !!$                      \"Plant carbon rate constant\") !!$    ok = NF90_PUT_ATT(ncid_restart, rpid%ratecp, \"units\", \"1/year\") !!$    ! ratecs (Soil carbon rate constant): !!$    ok = NF90_DEF_VAR(ncid_restart, 'ratecs', NF90_FLOAT, (/soilcarbID/),      & !!$                      rpid%ratecs) !!$    IF (ok /= NF90_NOERR) CALL nc_abort                                        & !!$                     (ok, 'Error defining ratecs variable in restart file. '// & !!$                      '(SUBROUTINE create_restart)') !!$    ok = NF90_PUT_ATT(ncid_restart, rpid%ratecs, \"long_name\",                  & !!$                      \"Soil carbon rate constant\") !!$    ok = NF90_PUT_ATT(ncid_restart, rpid%ratecs, \"units\", \"1/year\") !!$    CALL define_ovar(ncid_restart, rpid%meth, 'meth', '-',                     & !!$                     'Canopy turbulence parameterisation switch',              & !!$                     .TRUE., 'integer', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%za_uv, 'za_uv', 'm',                   & !!$                    'Reference height (lowest atm. model layer) for momentum', & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) !!$    CALL define_ovar(ncid_restart, rpid%za_tq, 'za_tq', 'm',                   & !!$                     'Reference height (lowest atm. model layer) for scalars', & !!$                     .TRUE., 'real', 0, 0, 0, mpID, dummy, .TRUE.) CALL define_ovar ( ncid_restart , gwID , 'GWwb' , 'mm3/mm3' , 'GW water content' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !!$    IF(cable_user%SOIL_STRUC=='sli'.OR.cable_user%FWSOIL_SWITCH=='Haverd2013') THEN !!$      CALL define_ovar(ncid_restart,rpid%gamma,'gamma','-', & !!$            'Parameter in root efficiency function (Lai and Katul 2000)', & !!$            .TRUE.,'real',0,0,0,mpID,dummy,.TRUE.) !!$    ENDIF ! Soil-Litter-Iso soil model IF ( cable_user % SOIL_STRUC == 'sli' ) THEN ! Parameters for SLI: !!$       CALL define_ovar(ncid_restart,rpid%nhorizons,'nhorizons','-', & !!$            'Number of soil horizons',.TRUE.,'integer',0,0,0,mpID,dummy,.TRUE.) !!$       CALL define_ovar(ncid_restart,rpid%zeta,'zeta','[ ]', & !!$            'exponent factor in Topmodel eq',.TRUE.,'real',0,0,0,mpID,dummy,.TRUE.) !!$       CALL define_ovar(ncid_restart,rpid%fsatmax,'fsatmax','[ ]', & !!$            'param in Topmodel eq',.TRUE.,'real',0,0,0,mpID,dummy,.TRUE.) !!$       CALL define_ovar(ncid_restart,rpid%ishorizon,'ishorizon','-', & !!$            'Horizon number',.TRUE., soilID, 'soil', 0, 0, 0, mpID, dummy, .TRUE.) !!$       CALL define_ovar(ncid_restart,rpid%clitt,'clitt','tC/ha', & !!$            'Litter layer carbon content',.TRUE.,'real',0,0,0,mpID,dummy,.TRUE.) !!$       CALL define_ovar(ncid_restart,rpid%ZR,'ZR','cm', & !!$            'Maximum rooting depth',.TRUE.,'real',0,0,0,mpID,dummy,.TRUE.) !!$       CALL define_ovar(ncid_restart,rpid%F10,'F10','-', & !!$            'Fraction of roots in top 10 cm', & !!$            .TRUE.,'real',0,0,0,mpID,dummy,.TRUE.) ! Variables for SLI: CALL define_ovar ( ncid_restart , SID , 'S' , '-' ,& 'Fractional soil moisture content relative to saturated value' , & . TRUE ., soilID , 'soil' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , TsoilID , 'Tsoil' , 'degC' ,& 'Tsoil' , & . TRUE ., soilID , 'soil' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , snowliqID , 'snowliq' , 'mm' ,& 'liquid water content of snowpack' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , scondsID , 'sconds' , 'Wm-1K-1' ,& 'thermal cond of snowpack' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , h0ID , 'h0' , 'm' ,& 'Pond height above soil' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , nsnowID , 'nsnow' , '-' ,& 'number of snow layers' , & . TRUE ., 'integer' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , TsurfaceID , 'Tsurface' , 'degC' ,& 'soil or snow surface T' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) END IF ! SLI soil model ! Write global attributes for file: CALL DATE_AND_TIME ( todaydate , nowtime ) todaydate = todaydate ( 1 : 4 ) // '/' // todaydate ( 5 : 6 ) // '/' // todaydate ( 7 : 8 ) nowtime = nowtime ( 1 : 2 ) // ':' // nowtime ( 3 : 4 ) // ':' // nowtime ( 5 : 6 ) ok = NF90_PUT_ATT ( ncid_restart , NF90_GLOBAL , \"Production\" , & TRIM ( todaydate ) // ' at ' // TRIM ( nowtime )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( frst_out ) // ' (SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , NF90_GLOBAL , \"Source\" , & 'CABLE LSM restart file' ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( frst_out ) // ' (SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , NF90_GLOBAL , \"CABLE_input_file\" , & TRIM ( filename % met )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( frst_out ) // ' (SUBROUTINE create_restart)' ) ! End netcdf define mode: ok = NF90_ENDDEF ( ncid_restart ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error creating restart file ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write time variable: ok = NF90_PUT_VAR ( ncid_restart , tvarID , REAL ( REAL ( ktau ) * dels , r_2 )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error time variable to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write latitude and longitude variables: ok = NF90_PUT_VAR ( ncid_restart , latID , latitude ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing latitude variable to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ok = NF90_PUT_VAR ( ncid_restart , lonID , longitude ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing longitude variable to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write number of active patches for each land grid cell: ok = NF90_PUT_VAR ( ncid_restart , napID , landpt (:)% nap ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing nap variable to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write vegetated patch fractions ok = NF90_PUT_VAR ( ncid_restart , rpid % patchfrac , & patch (:)% frac , start = ( / 1 / ), count = ( / mp / )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing patchfrac to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write number of veg and soil types ok = NF90_PUT_VAR ( ncid_restart , rpid % mvtype , mvtype ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing mvtype parameter to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ok = NF90_PUT_VAR ( ncid_restart , rpid % mstype , mstype ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing mstype parameter to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write parameters: CALL write_ovar ( ncid_restart , rpid % iveg , 'iveg' , REAL ( veg % iveg , 4 ), & ranges % iveg , . TRUE ., 'integer' , . TRUE .) CALL write_ovar ( ncid_restart , rpid % isoil , 'isoil' , REAL ( soil % isoilm , 4 ), & ranges % isoil , . TRUE ., 'integer' , . TRUE .) !!$    CALL write_ovar (ncid_restart, rpid%bch, 'bch', REAL(soil%bch, 4),         & !!$                     ranges%bch, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%bch, 'bch', REAL(soil%bch, 4),         & !!$                     ranges%bch, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%clay, 'clay', REAL(soil%clay, 4),      & !!$                     ranges%clay, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%sand, 'sand', REAL(soil%sand, 4),      & !!$                     ranges%sand, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%silt, 'silt', REAL(soil%silt, 4),      & !!$                     ranges%silt, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%css, 'css', REAL(soil%css, 4),         & !!$                     ranges%css, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%rhosoil, 'rhosoil',                    & !!$                     REAL(soil%rhosoil,4), ranges%rhosoil, .TRUE., 'real',     & !!$                     .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%hyds, 'hyds', REAL(soil%hyds, 4),      & !!$                     ranges%hyds, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%sucs, 'sucs', REAL(soil%sucs, 4),      & !!$                     ranges%sucs, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%rs20, 'rs20', REAL(veg%rs20, 4),       & !!$                     ranges%rs20, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%ssat, 'ssat', REAL(soil%ssat, 4),      & !!$                     ranges%ssat, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%sfc, 'sfc', REAL(soil%sfc, 4),         & !!$                     ranges%sfc, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%swilt, 'swilt', REAL(soil%swilt, 4),   & !!$                     ranges%swilt, .TRUE., 'real', .TRUE.) ! Soil dimensioned variables/parameters: !!$    CALL write_ovar (ncid_restart, rpid%froot, 'froot', REAL(veg%froot, 4),    & !!$                     ranges%froot, .TRUE., 'soil', .TRUE.) CALL write_ovar ( ncid_restart , tggID , 'tgg' , REAL ( ssnow % tgg , 4 ), & ranges % SoilTemp , . TRUE ., 'soil' , . TRUE .) CALL write_ovar ( ncid_restart , wbID , 'wb' , ssnow % wb , ranges % SoilMoist , & . TRUE ., 'soil' , . TRUE .) CALL write_ovar ( ncid_restart , wbiceID , 'wbice' , ssnow % wbice , & ranges % SoilMoist , . TRUE ., 'soil' , . TRUE .) CALL write_ovar ( ncid_restart , gammzzID , 'gammzz' , ssnow % gammzz , & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'soil' , . TRUE .) ! Snow dimensioned variables/parameters: CALL write_ovar ( ncid_restart , ssdnID , 'ssdn' , REAL ( ssnow % ssdn , 4 ), & ( / 0.0 , 999 9.0 / ), . TRUE ., 'snow' , . TRUE .) CALL write_ovar ( ncid_restart , smassID , 'smass' , REAL ( ssnow % smass , 4 ), & ( / 0.0 , 999 9.0 / ), . TRUE ., 'snow' , . TRUE .) CALL write_ovar ( ncid_restart , sdepthID , 'sdepth' , REAL ( ssnow % sdepth , 4 ), & ( / 0.0 , 999 9.0 / ), . TRUE ., 'snow' , . TRUE .) CALL write_ovar ( ncid_restart , tggsnID , 'tggsn' , REAL ( ssnow % tggsn , 4 ), & ( / 10 0.0 , 30 0.0 / ), . TRUE ., 'snow' , . TRUE .) ! Other dims CALL write_ovar ( ncid_restart , albsoilsnID , 'albsoilsn' , & REAL ( ssnow % albsoilsn , 4 ), ( / 0.0 , 1.0 / ), . TRUE ., 'radiation' , . TRUE .) CALL write_ovar ( ncid_restart , cplantID , 'cplant' , REAL ( bgc % cplant , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'plantcarbon' , . TRUE .) CALL write_ovar ( ncid_restart , csoilID , 'csoil' , REAL ( bgc % csoil , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'soilcarbon' , . TRUE .) ok = NF90_PUT_VAR ( ncid_restart , rpid % zse , REAL ( soil % zse , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing zse parameter to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Single dim: CALL write_ovar ( ncid_restart , rpid % albsoil , 'albsoil' , & REAL ( soil % albsoil , 4 ), ranges % albsoil , . TRUE ., & 'radiation' , . TRUE .) !!$    CALL write_ovar (ncid_restart, rpid%canst1, 'canst1', REAL(veg%canst1, 4), & !!$                     ranges%canst1, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%dleaf, 'dleaf', REAL(veg%dleaf, 4),    & !!$                     ranges%dleaf, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%ejmax, 'ejmax', REAL(veg%ejmax, 4),    & !!$                     ranges%ejmax, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%vcmax, 'vcmax', REAL(veg%vcmax, 4),    & !!$                     ranges%vcmax, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%frac4, 'frac4', REAL(veg%frac4, 4),    & !!$                     ranges%frac4, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%hc, 'hc', REAL(veg%hc, 4),             & !!$                     ranges%hc, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%rp20, 'rp20', REAL(veg%rp20, 4),       & !!$                     ranges%rp20, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%g0, 'g0', REAL(veg%g0, 4),       & !!$                     ranges%g0, .TRUE., 'real', .TRUE.) ! Ticket #56 !!$    CALL write_ovar (ncid_restart, rpid%g1, 'g1', REAL(veg%g1, 4),       & !!$                     ranges%g1, .TRUE., 'real', .TRUE.) ! Ticket #56 !!$    CALL write_ovar (ncid_restart, rpid%rpcoef, 'rpcoef', REAL(veg%rpcoef, 4), & !!$                     ranges%rpcoef, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%shelrb, 'shelrb', REAL(veg%shelrb, 4), & !!$                     ranges%shelrb, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%xfang, 'xfang', REAL(veg%xfang, 4),    & !!$                     ranges%xfang, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%wai, 'wai', REAL(veg%wai, 4),          & !!$                     ranges%wai, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%vegcf, 'vegcf', REAL(veg%vegcf, 4),    & !!$                     ranges%vegcf, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%extkn, 'extkn', REAL(veg%extkn, 4),    & !!$                     ranges%extkn, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%tminvj, 'tminvj', REAL(veg%tminvj, 4), & !!$                     ranges%tminvj, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%tmaxvj, 'tmaxvj', REAL(veg%tmaxvj, 4), & !!$                     ranges%tmaxvj, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%vbeta, 'vbeta', REAL(veg%vbeta, 4),    & !!$                     ranges%vbeta, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%xalbnir, 'xalbnir',                    & !!$                     REAL(veg%xalbnir, 4), ranges%xalbnir, .TRUE.,             & !!$                     'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%tmaxvj, 'tmaxvj', REAL(veg%tmaxvj, 4), & !!$                     ranges%tmaxvj, .TRUE., 'real', .TRUE.) !!$    ok = NF90_PUT_VAR(ncid_restart, rpid%ratecp, REAL(bgc%ratecp, 4)) !!$    IF(ok /= NF90_NOERR) CALL nc_abort(ok,                                     & !!$                                       'Error writing ratecp parameter to '    & !!$         //TRIM(frst_out)// '(SUBROUTINE create_restart)') !!$    ok = NF90_PUT_VAR(ncid_restart, rpid%ratecs, REAL(bgc%ratecs, 4)) !!$    IF(ok /= NF90_NOERR) CALL nc_abort(ok,                                     & !!$                                       'Error writing ratecs parameter to '    & !!$         //TRIM(frst_out)// '(SUBROUTINE create_restart)') !!$    CALL write_ovar (ncid_restart, rpid%meth, 'meth', REAL(veg%meth, 4),       & !!$                     ranges%meth, .TRUE., 'integer', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%za_uv, 'za_uv', REAL(rough%za_uv, 4),  & !!$                     ranges%za, .TRUE., 'real', .TRUE.) !!$    CALL write_ovar (ncid_restart, rpid%za_tq, 'za_tq', REAL(rough%za_tq, 4),  & !!$                     ranges%za, .TRUE., 'real', .TRUE.) CALL write_ovar ( ncid_restart , tssID , 'tss' , REAL ( ssnow % tss , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , ssdnnID , 'ssdnn' , REAL ( ssnow % ssdnn , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , osnowdID , 'osnowd' , REAL ( ssnow % osnowd , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , snageID , 'snage' , REAL ( ssnow % snage , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , snowdID , 'snowd' , REAL ( ssnow % snowd , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , rtsoilID , 'rtsoil' , REAL ( ssnow % rtsoil , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , isflagID , 'isflag' , REAL ( ssnow % isflag , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'integer' , . TRUE .) CALL write_ovar ( ncid_restart , canstoID , 'cansto' , REAL ( canopy % cansto , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , sghfluxID , 'sghflux' , & REAL ( canopy % sghflux , 4 ), ( /- 9999 9.0 , 999999 9.0 / ), & . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , ghfluxID , 'ghflux' , REAL ( canopy % ghflux , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , runoffID , 'runoff' , REAL ( ssnow % runoff , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , rnof1ID , 'rnof1' , REAL ( ssnow % rnof1 , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , rnof2ID , 'rnof2' , REAL ( ssnow % rnof2 , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , gaID , 'ga' , REAL ( canopy % ga , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , dgdtgID , 'dgdtg' , canopy % dgdtg , & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'r2' , . TRUE .) CALL write_ovar ( ncid_restart , fevID , 'fev' , REAL ( canopy % fev , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , fesID , 'fes' , REAL ( canopy % fes , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , fhsID , 'fhs' , REAL ( canopy % fhs , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , wbtot0ID , 'wbtot0' , REAL ( bal % wbtot0 , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , osnowd0ID , 'osnowd0' , REAL ( bal % osnowd0 , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , albedoID , 'albedo' , REAL ( rad % albedo , 4 ), & ranges % Albedo , . TRUE ., 'radiation' , . TRUE .) CALL write_ovar ( ncid_restart , tradID , 'trad' , & REAL ( rad % trad , 4 ), ranges % RadT , . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , gwID , 'GWwb' , REAL ( ssnow % GWwb , 4 ), & ranges % GWwb , . TRUE ., 'real' , . TRUE .) !!$    IF(cable_user%SOIL_STRUC=='sli'.OR.cable_user%FWSOIL_SWITCH=='Haverd2013') THEN !!$       CALL write_ovar (ncid_restart,rpid%gamma,'gamma', & !!$            REAL(veg%gamma,4),(/-99999.0,99999.0/),.TRUE.,'real',.TRUE.) !!$    ENDIF !!$ IF ( cable_user % SOIL_STRUC == 'sli' ) THEN ! Write SLI parameters: !!$       CALL write_ovar (ncid_restart,rpid%nhorizons,'nhorizons', & !!$            REAL(soil%nhorizons,4),(/-99999.0,99999.0/),.TRUE.,'integer',.TRUE.) !!$       CALL write_ovar (ncid_restart,rpid%ishorizon,'ishorizon', & !!$            REAL(soil%ishorizon,4),(/-99999.0,99999.0/),.TRUE.,'soil',.TRUE.) !!$       CALL write_ovar (ncid_restart,rpid%clitt,'clitt', & !!$            REAL(veg%clitt,4),(/-99999.0,99999.0/),.TRUE.,'real',.TRUE.) !!$       CALL write_ovar (ncid_restart,rpid%ZR,'ZR', & !!$            REAL(veg%ZR,4),(/-99999.0,99999.0/),.TRUE.,'real',.TRUE.) !!$       CALL write_ovar (ncid_restart,rpid%F10,'F10', & !!$            REAL(veg%F10,4),(/-99999.0,99999.0/),.TRUE.,'real',.TRUE.) ! Write SLI variables: CALL write_ovar ( ncid_restart , SID , 'S' , REAL ( ssnow % S , 4 ), & ( / 0.0 , 1.5 / ),. TRUE ., 'soil' ,. TRUE .) CALL write_ovar ( ncid_restart , TsoilID , 'Tsoil' , REAL ( ssnow % Tsoil , 4 ), & ( /- 10 0.0 , 10 0.0 / ),. TRUE ., 'soil' ,. TRUE .) CALL write_ovar ( ncid_restart , snowliqID , 'snowliq' , REAL ( ssnow % snowliq , 4 ), & ( /- 9999 9.0 , 9999 9.0 / ),. TRUE ., 'snow' ,. TRUE .) CALL write_ovar ( ncid_restart , scondsID , 'sconds' , REAL ( ssnow % sconds , 4 ), & ( /- 9999 9.0 , 9999 9.0 / ),. TRUE ., 'snow' ,. TRUE .) CALL write_ovar ( ncid_restart , h0ID , 'h0' , REAL ( ssnow % h0 , 4 ), & ( /- 9999 9.0 , 9999 9.0 / ),. TRUE ., 'real' ,. TRUE .) CALL write_ovar ( ncid_restart , nsnowID , 'nsnow' , REAL ( ssnow % nsnow , 4 ), & ( /- 9999 9.0 , 9999 9.0 / ),. TRUE ., 'integer' ,. TRUE .) CALL write_ovar ( ncid_restart , TsurfaceID , 'Tsurface' , REAL ( ssnow % Tsurface , 4 ), & ( /- 9999 9.0 , 9999 9.0 / ),. TRUE ., 'real' ,. TRUE .) END IF ! Close restart file ok = NF90_CLOSE ( ncid_restart ) WRITE ( logn , '(A36)' ) '   Restart file complete and closed.' END SUBROUTINE create_restart END MODULE cable_output_module","tags":"","loc":"sourcefile/cable_output.f90.html"},{"title":"casa_ncdf.F90 – CABLE","text":"Contents Modules casa_ncdf_module Source Code casa_ncdf.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: handles additional, dynamically decided diagnostic output from model. !          permanently used for bitwise identical testing. more applications !          will follow. ! ! Contact: Jhan.Srbinovsky@csiro.au ! ! History: Currently stripped down version of cable_diag here. will be !          re-implemented in time. ! ! ============================================================================== !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++! !+++ USE this module in any subr. you wish to write vars from.             +++! !+++ x is typically the number of landpoints(tiles). binary file is        +++! !+++ then appended every timestep with the new foo(x_i)                    +++! !+++                                                                       +++! !+++ CALL syntax:                                                          +++! !+++                                                                       +++! !+++ cable_diag( Nvars, filename, dimx, dimy, timestep, vname1, var1 )     +++! !+++                                                                       +++! !+++ output binaries can be interpreted from the command line              +++! !+++ using a suite of tools. Currently, only zero_diff.ksh is supported.   +++! !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++! !CABLE_LSM:This has to be commented for offline !#define UM_BUILD YES MODULE casa_ncdf_module IMPLICIT NONE #ifndef UM_BUILD interface put_var_nc module procedure put_var_ncr1 , put_var_ncr2 , put_var_ncr3 end interface put_var_nc interface get_var_nc module procedure get_var_ncr2 , get_var_ncr3 end interface get_var_nc #endif CONTAINS #ifndef UM_BUILD subroutine def_dims ( nd , ncid , dimID , dim_len , dim_name ) use netcdf implicit none integer , intent ( in ) :: nd , ncid character ( len =* ), dimension (:), intent ( in ) :: dim_name integer , dimension (:), intent ( out ) :: dimID integer , dimension (:), intent ( in ) :: dim_len integer :: j , ncok do j = 1 , nd ncok = NF90_DEF_DIM ( ncid , trim ( dim_name ( j )), dim_len ( j ), dimID ( j ) ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def dim ' , dim_name ( j )) enddo return end subroutine def_dims subroutine def_vars ( nv , ncid , xtype , dimID , var_name , varID ) use netcdf implicit none integer , intent ( in ) :: nv , ncid , xtype integer , dimension (:), intent ( in ) :: dimID integer , dimension (:), intent ( inout ) :: varID character ( len =* ), dimension (:), intent ( in ) :: var_name integer :: j , ncok ! lat ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 1 )), xtype , & ( / dimID ( 1 ) / ), varID ( 1 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 1 )) ! lon ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 2 )), xtype , & ( / dimID ( 1 ) / ), varID ( 2 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 2 )) ! tairk ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 3 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 3 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 3 )) !tsoil ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 4 )), xtype , & ( / dimID ( 1 ), dimID ( 2 ), dimID ( 3 ) / ), varID ( 4 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 4 )) ! moist ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 5 )), xtype , & ( / dimID ( 1 ), dimID ( 2 ), dimID ( 3 ) / ), varID ( 5 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 5 )) !cgpp ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 6 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 6 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 6 )) !crmplant ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 7 )), xtype , & ( / dimID ( 1 ), dimID ( 2 ), dimID ( 3 ) / ), varID ( 7 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 7 )) !phenphase ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 8 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 8 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 8 )) !doyphase1 ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 9 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 9 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 9 )) !doyphase2 ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 10 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 10 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 10 )) !doyphase3 ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 11 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 11 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 11 )) !doyphase4 ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 12 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 12 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 12 )) !mtemp ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 13 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 13 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 13 )) !Ndep ncok = NF90_DEF_VAR ( ncid , trim ( var_name ( 14 )), xtype , & ( / dimID ( 1 ), dimID ( 3 ) / ), varID ( 14 )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def var ' , var_name ( 14 )) return end subroutine def_vars subroutine def_var_atts ( ncfile_in , ncid , varID ) use netcdf implicit none character ( len =* ), intent ( in ) :: ncfile_in integer , intent ( in ) :: ncid ! netcdf file ID integer , dimension (:), intent ( in ) :: varID ! (1) ~ tvair, (2) ~ pmb integer :: j , ncok character ( len = 10 ) dummy write ( dummy , 11 ) varID ( 1 ) 11 format ( i2 ) ncok = NF90_PUT_ATT ( ncid , nf90_global , \"Title\" , \"Forcing for define_air subroutine\" ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def att ' , ncfile_in ) ncok = NF90_PUT_ATT ( ncid , varID ( 3 ), \"longname\" , \"air temperature within canopy\" ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def att ' , dummy ) ncok = NF90_PUT_ATT ( ncid , varID ( 3 ), \"units\" , \"K\" ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'def att ' , dummy ) write ( dummy , 11 ) varID ( 2 ) return end subroutine def_var_atts subroutine put_var_ncr1 ( ncid , var_name , var ) use netcdf use cable_def_types_mod , only : mp implicit none character ( len =* ), intent ( in ) :: var_name real , dimension (:), intent ( in ) :: var integer , intent ( in ) :: ncid integer :: ncok , varID , j ncok = NF90_INQ_VARID ( ncid , var_name , varId ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'inquire var ' , var_name ) ncok = NF90_PUT_VAR ( ncid , varId , var , start = ( / 1 / ), & count = ( / mp / ) ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'putting var ' , var_name ) end subroutine put_var_ncr1 subroutine put_var_ncr2 ( ncid , var_name , var , n_call ) use netcdf use cable_def_types_mod , only : r_2 , mp implicit none character ( len =* ), intent ( in ) :: var_name real ( r_2 ), dimension (:), intent ( in ) :: var integer , intent ( in ) :: ncid , n_call integer :: ncok , varID ncok = NF90_INQ_VARID ( ncid , var_name , varId ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'inquire var ' , var_name ) ncok = NF90_PUT_VAR ( ncid , varId , var , start = ( / 1 , n_call / ), & count = ( / mp , 1 / ) ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'putting var ' , var_name ) end subroutine put_var_ncr2 !soil vars subroutine put_var_ncr3 ( ncid , var_name , var , n_call , nl ) use netcdf use cable_def_types_mod , only : r_2 , mp , ms implicit none character ( len =* ), intent ( in ) :: var_name real ( r_2 ), dimension (:,:), intent ( in ) :: var integer , intent ( in ) :: ncid , n_call , nl integer :: ncok , varID ncok = NF90_INQ_VARID ( ncid , var_name , varId ) IF ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'inquire var ' , var_name ) ncok = NF90_PUT_VAR ( ncid , varId , var , start = ( / 1 , 1 , n_call / ), & count = ( / mp , nl , 1 / )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'putting var ' , var_name ) return end subroutine put_var_ncr3 subroutine get_var_ncr2 ( ncid , var_name , var , n_call ) use netcdf use cable_def_types_mod , only : r_2 , mp implicit none character ( len =* ), intent ( in ) :: var_name real ( r_2 ), dimension (:), intent ( out ) :: var integer , intent ( in ) :: ncid integer :: ncok , varID , n_call real , dimension ( mp ) :: temp temp = 0. ncok = NF90_INQ_VARID ( ncid , var_name , varId ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'inquire var ' , var_name ) ncok = NF90_GET_VAR ( ncid , varId , temp , start = ( / 1 , n_call / ), & count = ( / mp , 1 / ) ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'getting var ' , var_name ) var = real ( temp , r_2 ) end subroutine get_var_ncr2 subroutine get_var_ncr3 ( ncid , var_name , var , n_call , nl ) use netcdf use cable_def_types_mod , only : r_2 , mp , ms implicit none character ( len =* ), intent ( in ) :: var_name real ( r_2 ), dimension (:,:), intent ( out ) :: var integer , intent ( in ) :: ncid , n_call , nl integer :: ncok , varID real , dimension ( mp , 1 : nl ) :: temp ncok = NF90_INQ_VARID ( ncid , var_name , varId ) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'inquire var ' , var_name ) ncok = NF90_GET_VAR ( ncid , varId , temp , start = ( / 1 , 1 , n_call / ), & count = ( / mp , nl , 1 / )) if ( ncok /= nf90_noerr ) call stderr_nc ( ncok , 'putting var ' , var_name ) var = real ( temp , r_2 ) end subroutine get_var_ncr3 SUBROUTINE HANDLE_ERR ( status , msg ) ! LN 06/2013 USE netcdf INTEGER :: status CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: msg IF ( status /= NF90_noerr ) THEN WRITE ( * , * ) \"netCDF error:\" IF ( PRESENT ( msg ) ) WRITE ( * , * ) msg !#define Vanessas_common !#ifdef Vanessas_common WRITE ( * , * ) TRIM ( NF90_strerror ( INT ( status , 4 ))) !#else !       WRITE(*,*) \"UM builds with -i8. Therefore call to nf90_strerror is \", & !       \" invalid. Quick fix to eliminate for now. Build NF90 with -i8, force -i4?\" !#endif STOP - 1 END IF END SUBROUTINE HANDLE_ERR SUBROUTINE GET_UNIT ( IUNIT ) ! Find an unused unit for intermediate use ! PLEASE, use it ONLY when you OPEN AND CLOSE WITHIN THE SAME CALL ! or there could be interferences with other files!!! ! LN 05/2014 IMPLICIT NONE INTEGER , INTENT ( OUT ) :: IUNIT INTEGER :: i LOGICAL :: is_open = . FALSE . DO i = 200 , 10000 INQUIRE ( UNIT = i , OPENED = is_open ) IF ( . NOT . is_open ) EXIT END DO IUNIT = i END SUBROUTINE GET_UNIT subroutine stderr_nc ( status , message , var ) use netcdf character ( len =* ), intent ( in ) :: message , var INTEGER , INTENT ( IN ) :: status character ( len = 7 ) :: err_mess err_mess = 'ERROR:' print * , ( err_mess // message ), var PRINT * , NF90_STRERROR ( status ) stop end subroutine stderr_nc #endif SUBROUTINE YMDHMS2DOYSOD ( YYYY , MM , DD , HOUR , MINUTE , SECOND , DOY , SOD ) USE cable_common_module , ONLY : IS_LEAPYEAR ! Compute Day-of-year and second-of-day from given date and time or IMPLICIT NONE INTEGER , INTENT ( IN ) :: YYYY , MM , DD , HOUR , MINUTE , SECOND INTEGER , INTENT ( OUT ) :: DOY , SOD !  LOGICAL :: IS_LEAPYEAR INTEGER , DIMENSION ( 12 ) :: MONTH = ( / 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 / ) IF ( IS_LEAPYEAR ( YYYY ) ) MONTH ( 2 ) = 29 IF ( DD . GT . MONTH ( MM ) . OR . DD . LT . 1 . OR . & MM . GT . 12 . OR . MM . LT . 1 ) THEN WRITE ( * , * ) \"Wrong date entered in YMDHMS2DOYSOD \" WRITE ( * , * ) \"DATE : \" , YYYY , MM , DD STOP ENDIF DOY = DD IF ( MM . GT . 1 ) DOY = DOY + SUM ( MONTH ( 1 : MM - 1 ) ) SOD = HOUR * 3600 + MINUTE * 60 + SECOND END SUBROUTINE YMDHMS2DOYSOD SUBROUTINE DOYSOD2YMDHMS ( YYYY , DOY , SOD , MM , DD , HOUR , MINUTE , SECOND ) USE cable_common_module , ONLY : IS_LEAPYEAR ! Compute Day-of-year and second-of-day from given date and time or IMPLICIT NONE INTEGER , INTENT ( IN ) :: YYYY , DOY , SOD INTEGER , INTENT ( OUT ) :: MM , DD INTEGER , INTENT ( OUT ), OPTIONAL :: HOUR , MINUTE , SECOND !  LOGICAL :: IS_LEAPYEAR INTEGER :: MON , i INTEGER , DIMENSION ( 12 ) :: MONTH = ( / 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 / ) IF ( IS_LEAPYEAR ( YYYY ) ) MONTH ( 2 ) = 29 IF ( SOD . GE . 86400 . OR . SOD . LT . 0 . OR . & DOY . GT . SUM ( MONTH ) . OR . DOY . LT . 1 ) THEN WRITE ( * , * ) \"Wrong date entered in DOYSOD2YMDHMS \" WRITE ( * , * ) \"YYYY DOY SOD : \" , YYYY , DOY , SOD STOP ENDIF MON = 0 DO i = 1 , 12 IF ( MON + MONTH ( i ) . LT . DOY ) THEN MON = MON + MONTH ( i ) ELSE MM = i DD = DOY - MON EXIT ENDIF END DO IF ( PRESENT ( HOUR ) ) HOUR = INT ( REAL ( SOD ) / 360 0. ) IF ( PRESENT ( MINUTE ) ) MINUTE = INT ( ( REAL ( SOD ) - REAL ( HOUR ) * 360 0. ) / 6 0. ) IF ( PRESENT ( SECOND ) ) SECOND = SOD - HOUR * 3600 - MINUTE * 60 END SUBROUTINE DOYSOD2YMDHMS FUNCTION IS_CASA_TIME ( iotype , yyyy , ktau , kstart , koffset , kend , ktauday , logn ) USE cable_common_module , ONLY : CABLE_USER ! Correctly determine if it is time to dump-read or standard-write ! casa output from cable_driver. ! Writing casa-dump data is handled in casa_cable and therefore not \\ ! captured here !cable_common module was intended to be unequivocally common to all !applications. iovars is an offline module and so not appropriate to include !here. Suggested FIX is to move decs of vars needed (e.g. leaps) to here, and !then use common in iovars #ifdef Vanessas_common USE cable_IO_vars_module , ONLY : leaps #endif IMPLICIT NONE LOGICAL :: IS_CASA_TIME INTEGER , INTENT ( IN ) :: yyyy , ktau , kstart , koffset , kend , ktauday , logn CHARACTER , INTENT ( IN ) :: iotype * 5 LOGICAL :: is_eod , is_eom , is_eoy INTEGER :: doy , m INTEGER , DIMENSION ( 12 ) :: MONTH is_eom = . FALSE . is_eoy = . FALSE . IS_CASA_TIME = . FALSE . MONTH = ( / 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 / ) is_eod = ( MOD (( ktau - kstart + 1 + koffset ), ktauday ). EQ . 0 ) IF ( . NOT . is_eod ) RETURN ! NO if it is not end of day #ifdef Vanessas_common IF ( IS_LEAPYEAR ( YYYY ) . AND . leaps ) THEN MONTH ( 2 ) = 29 ELSE MONTH ( 2 ) = 28 ENDIF #endif ! Check for reading from dump-file (hard-wired to daily casa-timestep) IF ( iotype . EQ . \"dread\" ) THEN IF ( CABLE_USER % CASA_DUMP_READ ) IS_CASA_TIME = . TRUE . ! Check for writing of casa dump output ELSE IF ( iotype . EQ . \"dwrit\" ) THEN IF ( CABLE_USER % CASA_DUMP_WRITE ) IS_CASA_TIME = . TRUE . ! Check for writing of casa standard output ELSE IF ( iotype . EQ . \"write\" ) THEN doy = NINT ( REAL ( ktau - kstart + 1 + koffset ) / REAL ( ktauday )) DO m = 1 , 12 IF ( doy . EQ . SUM ( MONTH ( 1 : m )) ) THEN is_eom = . TRUE . IF ( m . EQ . 12 ) is_eoy = . TRUE . EXIT ENDIF END DO SELECT CASE ( TRIM ( CABLE_USER % CASA_OUT_FREQ ) ) CASE ( \"daily\" ) ; IS_CASA_TIME = . TRUE . CASE ( \"monthly\" ) ; IF ( is_eom ) IS_CASA_TIME = . TRUE . CASE ( \"annually\" ) ; IF ( is_eoy ) IS_CASA_TIME = . TRUE . END SELECT ELSE WRITE ( logn , * ) \"Wrong statement 'iotype'\" , iotype , \"in call to IS_CASA_TIME\" WRITE ( * , * ) \"Wrong statement 'iotype'\" , iotype , \"in call to IS_CASA_TIME\" STOP - 1 ENDIF END FUNCTION IS_CASA_TIME END MODULE casa_ncdf_module","tags":"","loc":"sourcefile/casa_ncdf.f90.html"},{"title":"cable_site.F90 – CABLE","text":"Contents Modules CABLE_site Source Code cable_site.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: site information to drive biophysical+biogeochemical site run ! Contact: vanessa.haverd@csiro.au ! ! History: July 2017 ! ! ! ========================================untitled====================================== ! Uses:\t\t  CABLE_COMMON_MODULE !\t\t  cable_IO_vars_module ! ! CALLs:       site_init !              site_GET_CO2_Ndep ! ============================================================================== MODULE CABLE_site USE casa_ncdf_module , ONLY : HANDLE_ERR , GET_UNIT USE CABLE_COMMON_MODULE , ONLY : CurYear !  current year of multiannual run USE cable_IO_vars_module , ONLY : & ! Selected cable_iovars.F90 variables: logn ! in CRU-NCEP. Setting this ensures snow will be determined in CABLE from temperature. IMPLICIT NONE TYPE site_TYPE CHARACTER ( len = 15 ) :: RunType ! 'spinup', 'transient', 'AMB', 'ELE' REAL , DIMENSION (:) , ALLOCATABLE :: CO2VALS ! Global annual CO2 values (dim is the number of years of data, or 1 if time-invariant) REAL , DIMENSION (:) , ALLOCATABLE :: NdepVALS ! Global annual Ndep values (dim is the number of years of data, or 1 if time-invariant) REAL , DIMENSION (:) , ALLOCATABLE :: PdepVALS ! Global annual Pdep values (dim is the number of years of data, or 1 if time-invariant) INTEGER :: mland ! Number of land cells CHARACTER ( len = 200 ) :: CO2NdepFile ! CO2Ndepfile with path INTEGER :: spinstartyear INTEGER :: spinendyear REAL :: spinCO2 ! ppm in 1850 REAL :: spinNdep ! kgNha-1y-1 in 1850 REAL :: spinPdep ! kgPha-1y-1 in 1850 REAL :: CO2 ! CO2 for current time step REAL :: Ndep ! Ndep for current time step REAL :: Pdep ! Pdep for current time step END TYPE site_TYPE TYPE ( site_TYPE ) :: site ! Define the variable CRU, of type CRU_TYPE CONTAINS !************************************************************************************************** SUBROUTINE site_INIT ( site ) ! Initialise the contents of the site defined type collection, from the site namelist file !************************************************************************************************** IMPLICIT NONE TYPE ( site_TYPE ) :: site INTEGER :: nmlunit ! Unit number for reading namelist file ! Temporary local names for site% variables as they are read from the namelist file. CHARACTER ( len = 15 ) :: RunType CHARACTER ( len = 200 ) :: CO2NdepFile INTEGER :: spinstartyear INTEGER :: spinendyear REAL :: spinCO2 ! ppm in 1850 REAL :: spinNdep ! kgNha-1y-1 in 1850 REAL :: spinPdep ! kgPha-1y-1 in 1850 ! Flag for errors LOGICAL :: ERR = . FALSE . NAMELIST / siteNML / RunType , CO2NdepFile , spinstartyear , spinendyear , spinCO2 , & spinNdep , spinPdep ! Read site namelist settings CALL GET_UNIT ( nmlunit ) ! CABLE routine finds spare unit number OPEN ( nmlunit , FILE = \"site.nml\" , STATUS = 'OLD' , ACTION = 'READ' ) READ ( nmlunit , NML = siteNML ) CLOSE ( nmlunit ) ! Assign namelist settings to corresponding CRU defined-type elements site % RunType = RunType site % CO2NDepFile = CO2NdepFile site % spinstartyear = spinstartyear site % spinendyear = spinendyear site % spinCO2 = spinCO2 site % spinNdep = spinNdep site % spinPdep = spinPdep ! Print settings WRITE ( * , * ) \"========================================= SITE INFO  ============\" WRITE ( * , * ) \"site settings chosen:\" WRITE ( * , * ) \" RunType: \" , TRIM ( site % RunType ) WRITE ( * , * ) \" CO2NDepFile: \" , TRIM ( site % CO2NdepFile ) WRITE ( * , * ) \" spin start year               : \" , site % spinstartyear WRITE ( * , * ) \" spin end year : \" , site % spinendyear WRITE ( * , * ) \" CO2 value for spinup [ppm]  : \" , site % spinCO2 WRITE ( * , * ) \" Ndep value for spinup [kg n ha-1 y-1] \" , site % spinNdep WRITE ( * , * ) \" Pdep value for spinup [kg P ha-1 y-1] \" , site % spinPdep WRITE ( logn , * ) \"========================================= SITE INFO ============\" WRITE ( logn , * ) \"site settings chosen:\" WRITE ( logn , * ) \" RunType: \" , TRIM ( site % RunType ) WRITE ( logn , * ) \" CO2NDepFile: \" , TRIM ( site % CO2NdepFile ) WRITE ( logn , * ) \" spin start year      : \" , site % spinstartyear WRITE ( logn , * ) \" spin end year : \" , site % spinendyear WRITE ( logn , * ) \" CO2 value for spinup [ppm]  : \" , site % spinCO2 WRITE ( logn , * ) \" Ndep value for spinup [kg n ha-1 y-1] \" , site % spinNdep WRITE ( logn , * ) \" Pdep value for spinup [kg n ha-1 y-1] \" , site % spinPdep WRITE ( * , * ) \"========================================= site ============\" WRITE ( logn , * ) \"========================================= site ============\" site % mland = 1 END SUBROUTINE site_INIT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE site_GET_CO2_Ndep ( site ) ! Get CO2 and N-dep values for use with a site run. Assign a static value if specified otherwise ! on the first call read all the annual values from a file into the site%CO2VALS and site%Ndep arrays IMPLICIT NONE TYPE ( site_TYPE ) :: site ! site structure INTEGER :: i , iunit , iyear , IOS = 0 LOGICAL , SAVE :: CALL1 = . TRUE . ! A *local* variable recording the first call of this routine ! For S0_TRENDY, use only static 1860 CO2 value and return immediately IF ( TRIM ( site % RunType ) . EQ . \"spinup\" ) THEN site % CO2 = site % spinCO2 ! CO2 in ppm for spinup site % Ndep = site % spinNdep site % Pdep = site % spinPdep RETURN ! If not spinup, varying CO2 and Ndep values will be used... ELSE ! On the first call, allocate the CRU%CO2VALS array to store the entire history of annual CO2 ! values, open the (ascii) CO2 file and read the values into the array. IF ( CALL1 ) THEN ALLOCATE ( site % CO2VALS ( 1850 : 2100 ) ) ALLOCATE ( site % NdepVALS ( 1850 : 2100 )) ALLOCATE ( site % PdepVALS ( 1850 : 2100 )) CALL GET_UNIT ( iunit ) OPEN ( iunit , FILE = TRIM ( site % CO2NdepFILE ), STATUS = \"OLD\" , ACTION = \"READ\" ) ! get past header READ ( iunit , * ) DO WHILE ( IOS . EQ . 0 ) READ ( iunit , FMT =* , IOSTAT = IOS ) iyear , site % CO2VALS ( iyear ), site % NdepVALS ( iyear ), & site % PdepVALS ( iyear ) END DO CLOSE ( iunit ) CALL1 = . FALSE . END IF 91 FORMAT ( i4 , ',' , f5 . 1 , ',' , f4 . 2 , ',' , f5 . 3 ) ! In all varying CO2 cases, return the element of the array for the current year ! as a single CO2 value. ! site % CO2 = site % CO2VALS ( CurYear ) site % Ndep = site % NdepVALS ( CurYear ) site % Pdep = site % PdepVALS ( CurYear ) END IF END SUBROUTINE site_GET_CO2_Ndep !************************************************************************************************** END MODULE CABLE_SITE","tags":"","loc":"sourcefile/cable_site.f90.html"},{"title":"cable_weathergenerator.F90 – CABLE","text":"Contents Modules CABLE_WEATHERGENERATOR Source Code cable_weathergenerator.F90 Source Code MODULE CABLE_WEATHERGENERATOR IMPLICIT NONE ! Parameters INTEGER , PARAMETER , PRIVATE :: sp = 8 REAL ( sp ), PARAMETER , PRIVATE :: & Pi = 3.14159265 ,& ! Pi PiBy2 = 1.57079632 ,& ! Pi/2 SecDay = 8640 0.0 ,& ! Seconds/day SolarConst = 1370 * SecDay / 1e6 ,& ! Solar constant [MJ/m2/day] epsilon = 0.736 ,& SBoltz = 5.67e-8 ! Stefan-Boltzmann constant [W/m2/K4] ! Global variables TYPE WEATHER_GENERATOR_TYPE ! general INTEGER :: np INTEGER :: ndtime ! number of subdiurnal steps in 24 hr REAL :: delT ! subdiurnal timestep (in s) REAL ( sp ), DIMENSION (:), ALLOCATABLE :: LatDeg ! Daily input REAL ( sp ), DIMENSION (:), ALLOCATABLE :: & WindDay ,& TempMinDay ,& ! Daily minimum air temp [degC] TempMaxDay ,& ! Daily maximum air temp [degC] TempMinDayNext ,& ! Daily minimum air temp tomorrow [degC] TempMaxDayPrev ,& ! Daily maximum air temp yesterday [degC] SolarMJDay ! Total daily down-ward irradiation [MJ/m2/d] (swdown) ! Daily constants REAL ( sp ) :: DecRad ! Declination in radians REAL ( sp ), DIMENSION (:), ALLOCATABLE :: & WindDark ,& ! Wind [m/s] during night hrs WindLite ,& ! Wind [m/s] during daylight hrs SolarNorm ,& ! (daily solar)/(solar const): geometry LatRad ,& ! Latitude in radians DayLength ,& TimeSunsetPrev ,& TimeSunrise ,& TimeMaxTemp ,& TimeSunset ,& TempSunsetPrev ,& TempSunset ,& TempNightRate ,& TempNightRatePrev ,& TempRangeDay ,& TempRangeAft ! Additional input to Subdiurnal met calculations !  Daily Met REAL ( sp ), DIMENSION (:), ALLOCATABLE :: & PrecipDay ,& ! 24hr-total precipitation [m/day] (current day = 24h from 0900 on previous day) SnowDay ,& ! 24hr-total precipitation [m/day] (current day = 24h from 0900 on previous day) !CLNx     PrecipDayNext   ,&  ! 24hr-total precipitation [m/day] (next day = 24 h from 0900 on current day) !CLNx     VapPmbDay       ,&  ! 24hr-av water vapour pressure [mb] !CLNx     VapPmb0900      ,&  ! 0900 water vapour pressure [mb] !CLNx     VapPmb1500      ,&  ! 1500 water vapour pressure [mb] !CLNx     VapPmb1500Prev  ,&  ! 1500 (prev day) water vapour pressure [mb] !CLNx     VapPmb0900Next  ,&  ! 0900(next day) water vapour pressure [mb] PmbDay ! 24hr-av pressure [mb] !   Solar and Temperature Params !   Hourly Met outgoing REAL ( sp ), DIMENSION (:), ALLOCATABLE :: & PhiSd ,& ! downward solar irradiance [W/m2] PhiLd ,& ! down longwave irradiance  [W/m2] Precip ,& ! precip [mm/h] Snow ,& ! precip [mm/h] Wind ,& ! wind   [m/s] Temp ,& ! temp   [degC] VapPmb ,& ! vapour pressure [mb] Pmb ,& ! pressure [mb] coszen ! cos(theta) END TYPE WEATHER_GENERATOR_TYPE CONTAINS !=============================================================================== SUBROUTINE WGEN_INIT ( WG , np , latitude , dels ) IMPLICIT NONE TYPE ( WEATHER_GENERATOR_TYPE ) :: WG INTEGER , INTENT ( IN ) :: np REAL , INTENT ( IN ) :: latitude ( np ), dels WG % np = np WG % delT = dels WG % ndtime = NINT ( REAL ( SecDay ) / dels ) ALLOCATE ( WG % LatDeg ( np ) ) ALLOCATE ( WG % WindDay ( np ) ) ALLOCATE ( WG % TempMinDay ( np ) ) ! Daily minimum air temp [degC] ALLOCATE ( WG % TempMaxDay ( np ) ) ! Daily maximum air temp [degC] ALLOCATE ( WG % TempMinDayNext ( np ) ) ! Daily minimum air temp tomorrow [degC] ALLOCATE ( WG % TempMaxDayPrev ( np ) ) ! Daily maximum air temp yesterday [degC] ALLOCATE ( WG % SolarMJDay ( np ) ) ALLOCATE ( WG % WindDark ( np ) ) ! Wind [m/s] during night hrs ALLOCATE ( WG % WindLite ( np ) ) ! Wind [m/s] during daylight hrs ALLOCATE ( WG % SolarNorm ( np ) ) ! (daily solar)/(solar const): geometry ALLOCATE ( WG % LatRad ( np ) ) ! Latitude in radians ALLOCATE ( WG % DayLength ( np ) ) ALLOCATE ( WG % TimeSunsetPrev ( np ) ) ALLOCATE ( WG % TimeSunrise ( np ) ) ALLOCATE ( WG % TimeMaxTemp ( np ) ) ALLOCATE ( WG % TimeSunset ( np ) ) ALLOCATE ( WG % TempSunsetPrev ( np ) ) ALLOCATE ( WG % TempSunset ( np ) ) ALLOCATE ( WG % TempNightRate ( np ) ) ALLOCATE ( WG % TempNightRatePrev ( np ) ) ALLOCATE ( WG % TempRangeDay ( np ) ) ALLOCATE ( WG % TempRangeAft ( np ) ) ALLOCATE ( WG % PrecipDay ( np ) ) ! 24hr-total precipitation [m/day] (current day = 24h from 0900 on previous day) ALLOCATE ( WG % SnowDay ( np ) ) ! [m/d] ALLOCATE ( WG % PmbDay ( np ) ) ! 24hr-av pressure [mb] ALLOCATE ( WG % PhiSd ( np ) ) ! downward solar irradiance [W/m2] ALLOCATE ( WG % PhiLd ( np ) ) ! down longwave irradiance  [W/m2] ALLOCATE ( WG % Precip ( np ) ) ! precip [mm/h] ALLOCATE ( WG % Snow ( np ) ) ! precip [mm/h] ALLOCATE ( WG % Wind ( np ) ) ! wind   [m/s] ALLOCATE ( WG % Temp ( np ) ) ! temp   [degC] ALLOCATE ( WG % VapPmb ( np ) ) ! vapour pressure [mb] ALLOCATE ( WG % Pmb ( np ) ) ! pressure [mb] ALLOCATE ( WG % coszen ( np ) ) ! cos(theta) WG % LatDeg (:) = latitude (:) END SUBROUTINE WGEN_INIT SUBROUTINE WGEN_DAILY_CONSTANTS ( WG , np , YearDay ) !------------------------------------------------------------------------------- ! Routine for calculating solar and met parameters that are constant over the ! the course of a 24hr day. These have been split off from version 01 of ! SubDiurnalMet which no longer calculates a day's worth of subdiurnal met in ! one call. Subdiurnal met for ntime times is now calculated using ntime calls, ! using the day-constants calculated here. !------------------------------------------------------------------------------- IMPLICIT NONE TYPE ( WEATHER_GENERATOR_TYPE ) :: WG INTEGER , INTENT ( IN ) :: np , YearDay ! Local variables REAL ( sp ) :: YearRad REAL ( sp ), DIMENSION ( np ) :: LatDeg1 REAL ( sp ), DIMENSION ( np ) :: TanTan REAL ( sp ), DIMENSION ( np ) :: HDLRad REAL ( sp ), DIMENSION ( np ) :: TimeSunriseNext REAL ( sp ) :: RatioWindLiteDark ! ------------------------- ! Downward solar irradiance ! ------------------------- LatDeg1 = SIGN ( MIN ( ABS ( WG % LatDeg ), 8 9.9 ), WG % LatDeg ) ! avoid singularity at pole WG % LatRad = LatDeg1 * Pi / 18 0.0 ! latitude in radians YearRad = 2.0 * Pi * ( YearDay - 1 ) / 36 5.0 ! day of year in radians !YearRadPrev = 2.0*Pi*(YearDay-2)/365.0          ! previous day of year in radians ! (Ok for YD - 2 = -1) ! DecRad = Declination in radians (+23.5 deg on 22 June, -23.5 deg on 22 Dec): WG % DecRad = 0.006918 - 0.399912 * COS ( YearRad ) + 0.070257 * SIN ( YearRad ) & - 0.006758 * COS ( 2.0 * YearRad ) + 0.000907 * SIN ( 2.0 * YearRad ) & - 0.002697 * COS ( 3.0 * YearRad ) + 0.001480 * SIN ( 3.0 * YearRad ) ! Paltridge and Platt eq [3.7] ! Daylength: HDLRad = Half Day Length in radians (dawn:noon = noon:dusk): TanTan = - TAN ( WG % LatRad ) * TAN ( WG % DecRad ) WHERE ( TanTan . LE . - 1.0 ) HDLRad = Pi ! polar summer: sun never sets ELSEWHERE ( TanTan . GE . 1.0 ) HDLRad = 0.0 ! polar winter: sun never rises ELSEWHERE HDLRad = ACOS ( TanTan ) ! Paltridge and Platt eq [3.21] END WHERE ! (HDLRad = their capital PI) WG % DayLength = 2 4.0 * 2.0 * HDLRad / ( 2.0 * Pi ) ! Daylength (dawn:dusk) in hours ! Daily solar irradiance without atmosphere, normalised by solar constant, ! with both energy fluxes in MJ/m2/day, calculated from solar geometry: WG % SolarNorm = & ! Paltridge and Platt eq [3.22] ( HDLRad * SIN ( WG % LatRad ) * SIN ( WG % DecRad ) + & COS ( WG % LatRad ) * COS ( WG % DecRad ) * SIN ( HDLRad )) / Pi ! ---- ! Wind ! ---- RatioWindLiteDark = 3.0 ! (daytime wind) / (nighttime wind) WG % WindDark = WG % WindDay / & ( ( 2 4.0 - WG % DayLength ) / 2 4.0 + RatioWindLiteDark * WG % DayLength / 2 4.0 ) WG % WindLite = WG % WindDay / & ( ( 1.0 / RatioWindLiteDark ) * ( 2 4.0 - WG % DayLength ) / 2 4.0 + WG % DayLength / 2 4.0 ) ! ----------- ! Temperature ! ----------- ! These are parameters required for the calculation of temperature according to ! Cesaraccio et al 2001 for sunrise-to-sunrise-next-day. Because we are calculating temp for ! midnight-to-midnight, we need to calculate midnight-to-sunrise temps using data for the ! previous day (-24h), hence the extra parameters denoted by *'s below which are not ! mentioned per se in Cesaraccio. Cesaraccio symbology for incoming met data is included ! here as comments for completeness: !                                                                 Sym in Cesaraccio et al 2001 ! TempMinDay                                                        Tn ! TempMaxDay                                                        Tx ! TempMinDayNext                                                    Tp ! TempMaxDayPrev !!$write(71, \"( 1000e16.6)\") WG%DecRad !!$   write(72, \"( 1000e16.6)\") TAN(WG%DecRad) !!$   write(73, \"( 1000e16.6)\") TAN(WG%LatRad) !!$ write(74, \"( 1000e16.6)\")  WG%DayLength WHERE ( WG % DayLength . LT . 0.01 ) ! Polar night WG % TimeSunrise = 9. ! Hn WG % TimeSunset = 1 6. ! Ho WG % TimeMaxTemp = 1 3. ! Hx ELSEWHERE ( WG % DayLength . GT . 2 3.0 ) ! Polar day WG % TimeSunrise = 1. ! Hn WG % TimeSunset = 2 3. ! Ho WG % TimeMaxTemp = 1 3. ! Hx ELSEWHERE WG % TimeSunrise = ( ACOS ( MIN ( TAN ( WG % LatRad ) * TAN ( WG % DecRad ), 0.9999 ))) * 1 2. / Pi ! Hn WG % TimeSunset = WG % TimeSunrise + WG % DayLength ! Ho WG % TimeMaxTemp = WG % TimeSunset - MIN ( 4. ,( WG % DayLength * 0.4 )) ! Hx END WHERE WG % TimeSunsetPrev = WG % TimeSunset - 2 4. ! * Ho-24h (a negative hour) TimeSunriseNext = WG % TimeSunrise + 2 4. ! Hp WG % TempSunset = WG % TempMaxDay - & ( 0.39 * ( WG % TempMaxDay - WG % TempMinDayNext )) ! To WG % TempSunsetPrev = WG % TempMaxDayPrev - & ( 0.39 * ( WG % TempMaxDayPrev - WG % TempMinDay )) ! * To-24h WG % TempRangeDay = WG % TempMaxDay - WG % TempMinDay ! alpha = Tx-Tn WG % TempRangeAft = WG % TempMaxDay - WG % TempSunset ! R = Tx-To WG % TempNightRate = ( WG % TempMinDayNext - WG % TempSunset ) / & SQRT ( TimeSunriseNext - WG % TimeSunset ) ! b = (Tp-To)/sqrt(Hp-Ho) WG % TempNightRatePrev = ( WG % TempMinDay - WG % TempSunsetPrev ) / & SQRT ( WG % TimeSunrise - WG % TimeSunsetPrev ) ! * b-24h = (Tn-(To-24h))/sqrt(Hn-(Ho-24h)) END SUBROUTINE WGEN_DAILY_CONSTANTS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE WGEN_SUBDIURNAL_MET ( WG , np , itime ) !------------------------------------------------------------------------------- ! Routine for downscaling daily met data to ntime subdiurnal values per day, ! at the instants ((it/ntime)*2400, it=1,ntime). ! ! ALGORITHMS: ! * Downward solar irradiance: !   * Fit a daily irradiance time series based on solar geometry, normalised to !     observed daily total SolarMJDay. Reference: Paltridge and Platt (1976). ! * Downward longwave irradiance: !   * Computed from downscaled air temperature using Swinbank (1963) formula. ! * Precipitation: !   * Assume steady through 24 hours at average value (needs improvement?) ! * Wind: !   * Set RatioWindLiteDark = (daytime wind) / (nighttime wind), a predetermined !     value, typically 3. Then calculate wind by day and wind by night (both !     steady, but different) to make the average work out right. ! * Temperature: !   * Fit a sine wave from sunrise (TempMinDay) to peak at TempMaxDay, another !     from TempMaxDay to sunset, TempMinDay, and a square-root function from !     sunset to sunrise the next day (Cesaraccio et al 2001). ! * Water Vapour Pressure, Air Pressure: !   * Hold constant. Return rel humidity at TempMinDay as a diagnostic on obs. ! ! HISTORY: ! * 04-sep-2003 (MRR): 01 Written and tested in Program SubDiurnalWeather ! * 30-nov-2007 (PRB): 02 Vectorise with deferred shape arrays, adding np dimension. ! * 11-dec-2007 (PRB): 03 Switch to Cesaraccio et al 2001 algorithm for temperature ! * 28/02/2012 (VH) :  04 cahnge precip from uniform distribution to evenly distributed over ! the periods 0600:0700; 0700:0800; 1500:1600; 1800:1900 !------------------------------------------------------------------------------- IMPLICIT NONE TYPE ( WEATHER_GENERATOR_TYPE ) :: WG INTEGER , INTENT ( IN ) :: np , itime ! Local variables REAL ( sp ) :: TimeNoon , test1 , test2 , adjust_fac ( np ) REAL ( sp ) :: TimeRad REAL ( sp ) :: rntime ! Real version of ntime REAL ( sp ) :: ritime ! Real version of current time REAL ( sp ), DIMENSION ( np ) :: PhiLd_Swinbank ! down longwave irradiance  [W/m2] !------------------------------------------------------------------------------- ritime = REAL ( itime ) * WG % delT / 360 0. ! Convert the current time to real rntime = REAL ( WG % ndtime ) * WG % delT / 360 0. ! Convert ntime to real ! Instantaneous downward hemispheric solar irradiance PhiSd TimeNoon = ritime / rntime - 0.5 ! Time in day frac (-0.5 to 0.5, zero at noon) TimeRad = 2.0 * Pi * TimeNoon ! Time in day frac (-Pi to Pi, zero at noon) WHERE ( ritime >= WG % TimeSunrise . AND . ritime <= WG % TimeSunset & . AND . WG % SolarNorm . GT . 1.e-3 ) ! Sun is up WG % PhiSd = MAX (( WG % SolarMJDay / WG % SolarNorm ) & ! PhiSd [MJ/m2/day] * ( SIN ( WG % DecRad ) * SIN ( WG % LatRad ) + COS ( WG % DecRad ) * COS ( WG % LatRad ) & * COS ( TimeRad ) ), 0.0 ) ! fix to avoid negative PhiSD vh 13/05/08 ! Paltridge and Platt eq [3.4] WG % coszen = ( SIN ( WG % DecRad ) * SIN ( WG % LatRad ) + COS ( WG % DecRad ) * COS ( WG % LatRad ) * COS ( TimeRad ) ) ELSEWHERE ! sun is down WG % PhiSd = 0.0 WG % coszen = 0.0 END WHERE WG % PhiSd = WG % PhiSd * 1e6 / SecDay ! Convert PhiSd: [MJ/m2/day] to [W/m2] ! ------------- ! Precipitation ! ------------- !Precip = PrecipDay*1000./rntime  ! convert from m/d to mm/h !Precip = (PrecipDay*1000.*9./24. + PrecipDayNext*1000.*15./24.)/rntime !Precip = (PrecipDay*1000.*9./24. + PrecipDayNext*1000.*15./24.)/24.  ! hourly precip [mm/h] IF ( ABS ( ritime - REAL ( INT ( ritime ))) . GT . 1e-7 ) THEN WRITE ( * , * ) \"Only works for integer hourly timestep! tstep = \" , ritime STOP \"cable_weathergenerator.F90!\" ENDIF IF (( ritime >= 1 5. . AND . ritime < 1 6. ). OR .( ritime >= 1 8. . AND . ritime < 1 9. )) THEN WG % Precip = WG % PrecipDay * 100 0. / 2. WG % Snow = WG % SnowDay * 100 0. / 2. ELSE WG % Precip = 0. WG % Snow = 0. ENDIF ! ---- ! Wind ! ---- WHERE ( ritime >= WG % TimeSunrise . AND . ritime <= WG % TimeSunset ) ! Sun is up WG % Wind = WG % WindLite ELSEWHERE ! Sun is down WG % Wind = WG % WindDark END WHERE ! ----------- ! Temperature ! ----------- ! Calculate temperature according to Cesaraccio et al 2001, including midnight to ! sunrise period using previous days info, and ignoring the period from after the ! following midnight to sunrise the next day, normally calculated by Cesaraccio. WHERE ( ritime <= WG % TimeSunrise ) ! Midnight to sunrise WG % Temp = WG % TempSunsetPrev + WG % TempNightRatePrev * SQRT ( ritime - WG % TimeSunsetPrev ) ELSEWHERE ( ritime > WG % TimeSunrise . AND . ritime <= WG % TimeMaxTemp ) ! Sunrise to time of maximum temperature WG % Temp = WG % TempMinDay + & WG % TempRangeDay * SIN ((( ritime - WG % TimeSunrise ) / & ( WG % TimeMaxTemp - WG % TimeSunrise )) * PiBy2 ) ELSEWHERE ( ritime > WG % TimeMaxTemp . AND . ritime <= WG % TimeSunset ) ! Time of maximum temperature to sunset WG % Temp = WG % TempSunset + & WG % TempRangeAft * SIN ( PiBy2 + (( ritime - WG % TimeMaxTemp ) / 4. * PiBy2 )) ELSEWHERE ( ritime > WG % TimeSunset ) ! Sunset to midnight WG % Temp = WG % TempSunset + WG % TempNightRate * SQRT ( ritime - WG % TimeSunset ) END WHERE ! ----------------------------------- ! Water Vapour Pressure, Air Pressure ! ----------------------------------- !CLN VapPmb = VapPmbDay !CLN Pmb    = PmbDay !CLN !CLN IF (ritime <= 9.) THEN !CLN    ! before 9am !CLN    VapPmb = VapPmb1500Prev + (VapPmb0900 - VapPmb1500Prev) * (9. + ritime)/18. !CLN ELSEIF (ritime > 9 .AND. ritime <= 15.) THEN !CLN ! between 9am and 15:00 !CLN    VapPmb = VapPmb0900 + (VapPmb1500 - VapPmb0900) * (ritime - 9.)/(15.-9.) !CLN ELSEIF (ritime > 15.) THEN !CLN ! after 15:00 !CLN   VapPmb  = VapPmb1500 + (VapPmb0900Next - VapPmb1500) * (ritime - 15.)/18. !CLN END IF ! ---------------------------- ! Downward longwave irradiance ! ---------------------------- PhiLd_Swinbank = 33 5.97 * ((( WG % Temp + 27 3.16 ) / 29 3.0 ) ** 6 ) ! [W/m2] (Swinbank 1963) ! ------------------------------- ! Alternate longwave formulation ! ---------------------------- WG % PhiLd = epsilon * SBoltz * ( WG % Temp + 27 3.16 ) ** 4 ! [W/m2] (Brutsaert) WHERE ( WG % PhiSd . GT . 5 0.0 ) adjust_fac = (( 1.17 ) ** ( WG % SolarNorm )) / 1.17 ELSEWHERE adjust_fac = 0.9 ENDWHERE WG % PhiLd = WG % PhiLd / adjust_fac * ( 1.0 + WG % PhiSd / 800 0. ) ! adjustment (formulation from Gab Abramowitz) WHERE (( WG % PhiLd . GT . 50 0.00 ). OR .( WG % PhiLd . LT . 10 0.00 )) WG % PhiLd = PhiLd_Swinbank ENDWHERE IF ( ANY (( WG % PhiLd . GT . 75 0.00 ). OR .( WG % PhiLd . LT . 10 0.00 ))) THEN !write(*,*) 'PhiLD out of range' ENDIF END SUBROUTINE WGEN_SUBDIURNAL_MET END MODULE CABLE_WEATHERGENERATOR","tags":"","loc":"sourcefile/cable_weathergenerator.f90.html"},{"title":"cable_parameters.F90 – CABLE","text":"Contents Modules cable_param_module Source Code cable_parameters.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose:       This module file reads default parameter sets and basic !                initialisations for CABLE. Parameters values are chosen based !                on a global map of vegetation and soil types, currently based !                on a 1x1-degree grid for offline case and host-model grid for !                online case. Default initialisations are obtained from monthly !                climatology in GSWP and Mk3L runs for offline and online !                respectively. ! ! Contact: Bernard.Pak@csiro.au ! ! History: Changes since v1.4b for global offline (GSWP) cases, read in new !          input files !          Two subroutines moved to cable_common (reading veg and soil parameter !          files) !          Addition of code for CASA-CNP ! ! ! ============================================================================== ! CALLed from:   cable_input.F90 ! ! MODULEs used:  cable_abort_module !                cable_common_module !                cable_def_types_mod !                casadimension !                casaparm !                cable_IO_vars_module !                phenvariable !                physical_constants !                netcdf ! CALLs:         get_default_params !                read_gridinfo !                spatialSoil !                NSflip !                countPatch !                write_default_params !                write_cnp_params !                derived_parameters !                check_parameter_values !                report_parameters ! MODULE cable_param_module USE cable_def_types_mod USE casadimension , ONLY : icycle USE casavariable USE phenvariable USE cable_abort_module USE cable_IO_vars_module USE cable_common_module , ONLY : cable_user , gw_params USE cable_pft_params_mod USE cable_soil_params_mod USE CABLE_LUC_EXPT , ONLY : LUC_EXPT , LUC_EXPT_TYPE , LUC_EXPT_SET_TILES IMPLICIT NONE PRIVATE PUBLIC get_default_params , write_default_params , derived_parameters , & check_parameter_values , report_parameters , parID_type , & write_cnp_params INTEGER :: patches_in_parfile = 4 ! # patches in default global parameter ! file CHARACTER ( LEN = 4 ) :: classification ! Variables below are temporary - for file read-in: INTEGER , DIMENSION (:, :, :), ALLOCATABLE :: inVeg REAL , DIMENSION (:, :, :), ALLOCATABLE :: inPFrac INTEGER , DIMENSION (:, :), ALLOCATABLE :: inSoil REAL , DIMENSION (:, :, :, :), ALLOCATABLE :: inWB REAL , DIMENSION (:, :, :, :), ALLOCATABLE :: inTGG REAL , DIMENSION (:), ALLOCATABLE :: inLon REAL , DIMENSION (:), ALLOCATABLE :: inLat REAL , DIMENSION (:, :, :, :), ALLOCATABLE :: inALB REAL , DIMENSION (:, :, :, :), ALLOCATABLE :: inSND REAL , DIMENSION (:, :, :), ALLOCATABLE :: inLAI REAL , DIMENSION (:, :), ALLOCATABLE :: inArea INTEGER , DIMENSION (:, :), ALLOCATABLE :: inSorder REAL , DIMENSION (:, :), ALLOCATABLE :: inNdep REAL , DIMENSION (:, :), ALLOCATABLE :: inNfix REAL , DIMENSION (:, :), ALLOCATABLE :: inPwea REAL , DIMENSION (:, :), ALLOCATABLE :: inPdust ! Temporary values for reading IGBP soil map Q.Zhang @ 12/20/2010 REAL , DIMENSION (:, :), ALLOCATABLE :: inswilt REAL , DIMENSION (:, :), ALLOCATABLE :: insfc REAL , DIMENSION (:, :), ALLOCATABLE :: inssat REAL , DIMENSION (:, :), ALLOCATABLE :: inbch REAL , DIMENSION (:, :), ALLOCATABLE :: inhyds REAL , DIMENSION (:, :), ALLOCATABLE :: insucs REAL , DIMENSION (:, :), ALLOCATABLE :: inrhosoil REAL , DIMENSION (:, :), ALLOCATABLE :: incss REAL , DIMENSION (:, :), ALLOCATABLE :: incnsd REAL , DIMENSION (:, :), ALLOCATABLE :: inclay REAL , DIMENSION (:, :), ALLOCATABLE :: insilt REAL , DIMENSION (:, :), ALLOCATABLE :: insand !MD temp vars for reading in aquifer properties LOGICAL :: found_explicit_gw_parameters REAL , DIMENSION (:, :), ALLOCATABLE :: inGWbch REAL , DIMENSION (:, :), ALLOCATABLE :: inGWssat REAL , DIMENSION (:, :), ALLOCATABLE :: inGWhyds REAL , DIMENSION (:, :), ALLOCATABLE :: inGWsucs REAL , DIMENSION (:, :), ALLOCATABLE :: inGWrhosoil REAL , DIMENSION (:, :), ALLOCATABLE :: inGWclay REAL , DIMENSION (:, :), ALLOCATABLE :: inGWsilt REAL , DIMENSION (:, :), ALLOCATABLE :: inGWsand REAL , DIMENSION (:, :), ALLOCATABLE :: inGWWatr REAL , DIMENSION (:, :), ALLOCATABLE :: inWatr REAL , DIMENSION (:, :), ALLOCATABLE :: inSlope REAL , DIMENSION (:, :), ALLOCATABLE :: inGWdz REAL , DIMENSION (:, :), ALLOCATABLE :: inSlopeSTD REAL , DIMENSION (:, :), ALLOCATABLE :: inORG ! vars intro for Ticket #27 INTEGER , DIMENSION (:, :), ALLOCATABLE :: inSoilColor CONTAINS SUBROUTINE get_default_params ( logn , vegparmnew , LUC_EXPT ) USE cable_common_module , ONLY : filename , & calcsoilalbedo , cable_user ! Load parameters for each veg type and each soil type. (get_type_parameters) ! Also read in initial information for each grid point. (read_gridinfo) ! Count to obtain 'landpt', 'max_vegpatches' and 'mp'. (countPatch) ! ! New input structure using netcdf and introduced 'month' to initialize ! soil profiles with the correct monthly average values (BP apr2010) IMPLICIT NONE INTEGER , INTENT ( IN ) :: logn ! log file unit number LOGICAL , INTENT ( IN ) :: vegparmnew ! new format input file (BP dec2007) TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT ! local variables INTEGER :: npatch INTEGER :: nlon INTEGER :: nlat WRITE ( logn , * ) ' Reading grid info from ' , TRIM ( filename % type ) WRITE ( logn , * ) ' And assigning C4 fraction according to veg classification.' WRITE ( logn , * ) IF ( exists % patch ) THEN CALL read_gridinfo ( nlon , nlat , nmetpatches ) !, & ELSE CALL read_gridinfo ( nlon , nlat , npatch ) END IF ! Overwrite veg type and inital patch frac with land-use info IF ( CABLE_USER % POPLUC ) THEN CALL get_land_index ( nlon , nlat ) CALL LUC_EXPT_SET_TILES ( inVeg , inPfrac , LUC_EXPT ) ENDIF IF ( soilparmnew ) THEN PRINT * , 'Use spatially-specific soil properties; ' , nlon , nlat WRITE ( logn , * ) 'Use spatially-specific soil properties; ' , nlon , nlat CALL spatialSoil ( nlon , nlat , logn ) ENDIF ! Get parameter values for all default veg and soil types: !CALL get_type_parameters(logn, vegparmnew, classification) CALL cable_pft_params () CALL cable_soil_params () ! include prescribed soil colour in determining albedo - Ticket #27 IF ( calcsoilalbedo ) THEN CALL read_soilcolor ( logn ) END IF ! count to obtain 'landpt', 'max_vegpatches' and 'mp' CALL countPatch ( nlon , nlat , npatch ) END SUBROUTINE get_default_params !============================================================================= SUBROUTINE read_gridinfo ( nlon , nlat , npatch ) ! Reads in veg type, patch fraction, soil type, soil moisture and temperature ! profiles; also grid area and nutrients ! ! Input variables: !   filename%type  - via cable_IO_vars_module !   classification - via cable_param_module ! Output variables: !   nlon           - # longitudes in input data set !   nlat           - # latitudes  in input data set !   npatch         - # patches in each grid from input data set !   inVeg          - via cable_param_module !   inPFrac        - via cable_param_module !   inSoil         - via cable_param_module !   inWB           - via cable_param_module !   inTGG          - via cable_param_module !   inLon          - via cable_param_module !   inLat          - via cable_param_module !   inALB          - via cable_param_module !   inSND          - via cable_param_module !   inLAI          - via cable_param_module ! ! New input structure using netcdf and introduced 'month' to initialize ! soil profiles with the correct monthly average values (BP apr2010) USE netcdf USE cable_common_module , ONLY : filename IMPLICIT NONE INTEGER , INTENT ( OUT ) :: nlon INTEGER , INTENT ( OUT ) :: nlat INTEGER , INTENT ( INOUT ) :: npatch ! local variables INTEGER :: ncid , ok INTEGER :: xID , yID , pID , sID , tID , bID INTEGER :: varID INTEGER :: nslayer , ntime , nband , lon , lat INTEGER :: ii , jj , kk , pp INTEGER , DIMENSION (:, :), ALLOCATABLE :: idummy REAL , DIMENSION (:, :), ALLOCATABLE :: rdummy REAL , DIMENSION (:, :, :), ALLOCATABLE :: r3dum , r3dum2 , r3dum3 , r3dum4 ok = NF90_OPEN ( filename % type , 0 , ncid ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error opening grid info file.' ) ok = NF90_INQ_DIMID ( ncid , 'longitude' , xID ) IF ( ok /= NF90_NOERR ) ok = NF90_INQ_DIMID ( ncid , 'x' , xID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring x dimension.' ) ok = NF90_INQUIRE_DIMENSION ( ncid , xID , LEN = nlon ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting x dimension.' ) ok = NF90_INQ_DIMID ( ncid , 'latitude' , yID ) IF ( ok /= NF90_NOERR ) ok = NF90_INQ_DIMID ( ncid , 'y' , yID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring y dimension.' ) ok = NF90_INQUIRE_DIMENSION ( ncid , yID , LEN = nlat ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting y dimension.' ) IF (. NOT . exists % patch ) THEN ok = NF90_INQ_DIMID ( ncid , 'patch' , pID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring patch dimension.' ) ok = NF90_INQUIRE_DIMENSION ( ncid , pID , LEN = npatch ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting patch dimension.' ) ENDIF ok = NF90_INQ_DIMID ( ncid , 'soil' , sID ) ok = NF90_INQUIRE_DIMENSION ( ncid , sID , LEN = nslayer ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting soil dimension.' ) ok = NF90_INQ_DIMID ( ncid , 'time' , tID ) ok = NF90_INQUIRE_DIMENSION ( ncid , tID , LEN = ntime ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting time dimension.' ) ok = NF90_INQ_DIMID ( ncid , 'rad' , bID ) ok = NF90_INQUIRE_DIMENSION ( ncid , bID , LEN = nband ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting rad dimension.' ) ! check dimensions of soil-layers and time !! vh_js !! IF ( ( nslayer /= ms ) . OR . ( ntime /= 12 )) THEN PRINT * , 'Variable dimensions do not match:' PRINT * , 'nslayer and ms = ' , nslayer , ms PRINT * , 'ntime not equal 12 months: ' , ntime IF ( ntime /= 12 ) THEN CALL abort ( 'Variable dimensions do not match (read_gridinfo)' ) ELSE PRINT * , 'warning: soil layers below nslayer will be initialsed with moisture' PRINT * , 'and temperature of lowest layer in grid_info' ENDIF END IF ALLOCATE ( inLon ( nlon ), inLat ( nlat ) ) ALLOCATE ( inVeg ( nlon , nlat , npatch ) ) ALLOCATE ( inPFrac ( nlon , nlat , npatch ) ) ALLOCATE ( inSoil ( nlon , nlat ) ) ALLOCATE ( idummy ( nlon , nlat ) ) ALLOCATE ( rdummy ( nlon , nlat ) ) ALLOCATE ( inWB ( nlon , nlat , nslayer , ntime ) ) ALLOCATE ( inTGG ( nlon , nlat , nslayer , ntime ) ) ALLOCATE ( inALB ( nlon , nlat , npatch , nband ) ) ALLOCATE ( inSND ( nlon , nlat , npatch , ntime ) ) ALLOCATE ( inLAI ( nlon , nlat , ntime ) ) ALLOCATE ( r3dum ( nlon , nlat , nband ) ) ALLOCATE ( r3dum2 ( nlon , nlat , ntime ) ) ok = NF90_INQ_VARID ( ncid , 'longitude' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error finding variable longitude.' ) ok = NF90_GET_VAR ( ncid , varID , inLon ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error reading variable longitude.' ) !ensure this longitude is -180->180 !as for GSWP3 it is 0-360 WHERE ( inLON > 18 0.0 ) inLON = inLON - 36 0.0 ENDWHERE ok = NF90_INQ_VARID ( ncid , 'latitude' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable latitude.' ) ok = NF90_GET_VAR ( ncid , varID , inLat ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable latitude.' ) IF (. NOT . exists % patch ) THEN ok = NF90_INQ_VARID ( ncid , 'iveg' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable iveg.' ) !CLN    ok = NF90_GET_VAR(ncid, varID, idummy) ok = NF90_GET_VAR ( ncid , varID , inVeg ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable iveg.' ) !CLN    inVeg(:, :, 1) = idummy(:,:) ! npatch=1 in 1x1 degree input ok = NF90_INQ_VARID ( ncid , 'patchfrac' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error finding variable patchfrac.' ) ok = NF90_GET_VAR ( ncid , varID , inPFrac ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error reading variable patchfrac.' ) !CLN    inPFrac(:, :, 1) = rdummy(:, :) ELSE !loop through lat and lon to fill patch and veg vars DO lon = 1 , nlon DO lat = 1 , nlat inPFrac ( lon , lat ,:) = vegpatch_metfile ( 1 ,:) !Anna: passing met patchfrac here inVeg ( lon , lat ,:) = vegtype_metfile ( 1 ,:) ENDDO ENDDO END IF ok = NF90_INQ_VARID ( ncid , 'isoil' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable isoil.' ) ok = NF90_GET_VAR ( ncid , varID , inSoil ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable isoil.' ) ok = NF90_INQ_VARID ( ncid , 'SoilMoist' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error finding variable SoilMoist.' ) ok = NF90_GET_VAR ( ncid , varID , inWB ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error reading variable SoilMoist.' ) ok = NF90_INQ_VARID ( ncid , 'SoilTemp' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable SoilTemp.' ) ok = NF90_GET_VAR ( ncid , varID , inTGG ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable SoilTemp.' ) ok = NF90_INQ_VARID ( ncid , 'Albedo' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable Albedo.' ) ok = NF90_GET_VAR ( ncid , varID , r3dum ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable Albedo.' ) !   DO kk = 1, nband !     inALB(:,:,1,kk) = r3dum(:,:,kk) !   ENDDO ! vh! DO kk = 1 , nband DO pp = 1 , npatch inALB (:,:, pp , kk ) = r3dum (:,:, kk ) ENDDO ENDDO ok = NF90_INQ_VARID ( ncid , 'SnowDepth' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error finding variable SnowDepth.' ) ok = NF90_GET_VAR ( ncid , varID , r3dum2 ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error reading variable SnowDepth.' ) ! DO kk = 1, ntime !   inSND(:, :, 1, kk) = r3dum2(:, :, kk) ! ENDDO DO kk = 1 , ntime DO pp = 1 , npatch inSND (:, :, pp , kk ) = r3dum2 (:, :, kk ) ENDDO ENDDO ok = NF90_INQ_VARID ( ncid , 'LAI' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable LAI.' ) ok = NF90_GET_VAR ( ncid , varID , inLAI ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable LAI.' ) IF ( icycle > 0 ) THEN ! casaCNP parameters ALLOCATE ( inArea ( nlon , nlat ) ) ALLOCATE ( inSorder ( nlon , nlat ) ) ALLOCATE ( inNdep ( nlon , nlat ) ) ALLOCATE ( inNfix ( nlon , nlat ) ) ALLOCATE ( inPwea ( nlon , nlat ) ) ALLOCATE ( inPdust ( nlon , nlat ) ) ok = NF90_INQ_VARID ( ncid , 'area' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding area.' ) ok = NF90_GET_VAR ( ncid , varID , inArea ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading area.' ) ok = NF90_INQ_VARID ( ncid , 'SoilOrder' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding SoilOrder.' ) ok = NF90_GET_VAR ( ncid , varID , inSorder ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading SoilOrder.' ) ok = NF90_INQ_VARID ( ncid , 'Ndep' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding Ndep.' ) ok = NF90_GET_VAR ( ncid , varID , inNdep ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading Ndep.' ) ok = NF90_INQ_VARID ( ncid , 'Nfix' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding Nfix.' ) ok = NF90_GET_VAR ( ncid , varID , inNfix ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading Nfix.' ) ok = NF90_INQ_VARID ( ncid , 'Pwea' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding Pwea.' ) ok = NF90_GET_VAR ( ncid , varID , inPwea ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading Pwea.' ) ok = NF90_INQ_VARID ( ncid , 'Pdust' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding Pdust.' ) ok = NF90_GET_VAR ( ncid , varID , inPdust ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading Pdust.' ) ! change units from g/m2/yr to g/m2/day inNdep = inNdep / 36 5.0 inNfix = inNfix / 36 5.0 inPwea = inPwea / 36 5.0 inPdust = inPdust / 36 5.0 ENDIF ok = NF90_CLOSE ( ncid ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error closing grid info file.' ) END SUBROUTINE read_gridinfo !============================================================================ SUBROUTINE spatialSoil ( nlon , nlat , logn ) ! Read in spatially-specific soil properties including snow-free albedo ! plus soil texture; all these from UM ancilliary file ! ! Input variables: !   nlon,nlat         - # longitudes and latitudes in the previous input file !   filename%soilIGBP - via cable_IO_vars_module ! Output variables: !   inswilt   - via cable_param_module !   insfc     - via cable_param_module !   inssat    - via cable_param_module !   inbch     - via cable_param_module !   inhyds    - via cable_param_module !   insucs    - via cable_param_module !   inrhosoil - via cable_param_module !   incss     - via cable_param_module !   incnsd    - via cable_param_module !   inclay    - via cable_param_module !   insilt    - via cable_param_module !   insand    - via cable_param_module !   inALB     - via cable_param_module USE netcdf USE cable_common_module , ONLY : filename IMPLICIT NONE INTEGER , INTENT ( IN ) :: nlon INTEGER , INTENT ( IN ) :: nlat INTEGER , INTENT ( IN ) :: logn ! log file unit number ! local variables INTEGER :: ncid , ok , ii , jj , kk , ok2 , ncid_elev INTEGER :: xID , yID , fieldID INTEGER :: xlon , xlat REAL , DIMENSION (:,:,:,:), ALLOCATABLE :: indummy REAL , DIMENSION (:,:), ALLOCATABLE :: sfact , dummy2 REAL , DIMENSION (:,:), ALLOCATABLE :: in2alb ok = NF90_OPEN ( filename % type , 0 , ncid ) ALLOCATE ( in2alb ( nlon , nlat ) ) ! local ALLOCATE ( dummy2 ( nlon , nlat ) ) ! local ALLOCATE ( sfact ( nlon , nlat ) ) ! local ALLOCATE ( inswilt ( nlon , nlat ) ) ALLOCATE ( insfc ( nlon , nlat ) ) ALLOCATE ( inssat ( nlon , nlat ) ) ALLOCATE ( inbch ( nlon , nlat ) ) ALLOCATE ( inhyds ( nlon , nlat ) ) ALLOCATE ( insucs ( nlon , nlat ) ) ALLOCATE ( inrhosoil ( nlon , nlat ) ) ALLOCATE ( incss ( nlon , nlat ) ) ALLOCATE ( incnsd ( nlon , nlat ) ) ALLOCATE ( inclay ( nlon , nlat ) ) ALLOCATE ( insilt ( nlon , nlat ) ) ALLOCATE ( insand ( nlon , nlat ) ) !MD Aquifer properties ALLOCATE ( inGWssat ( nlon , nlat ) ) ALLOCATE ( inGWbch ( nlon , nlat ) ) ALLOCATE ( inGWhyds ( nlon , nlat ) ) ALLOCATE ( inGWsucs ( nlon , nlat ) ) ALLOCATE ( inGWrhosoil ( nlon , nlat ) ) ALLOCATE ( inGWWatr ( nlon , nlat ) ) ALLOCATE ( inWatr ( nlon , nlat ) ) ALLOCATE ( inORG ( nlon , nlat ) ) ! 1 ok = NF90_INQ_VARID ( ncid , 'swilt' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable swilt.' ) ok = NF90_GET_VAR ( ncid , fieldID , inswilt ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable swilt.' ) ! 2 ok = NF90_INQ_VARID ( ncid , 'sfc' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable sfc.' ) ok = NF90_GET_VAR ( ncid , fieldID , insfc ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable sfc.' ) ! 3 ok = NF90_INQ_VARID ( ncid , 'ssat' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable ssat.' ) ok = NF90_GET_VAR ( ncid , fieldID , inssat ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable ssat.' ) ! 4 ok = NF90_INQ_VARID ( ncid , 'bch' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable bch.' ) ok = NF90_GET_VAR ( ncid , fieldID , inbch ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable bch.' ) ! 5 ok = NF90_INQ_VARID ( ncid , 'hyds' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable hyds.' ) ok = NF90_GET_VAR ( ncid , fieldID , inhyds ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable hyds.' ) ! 6 ok = NF90_INQ_VARID ( ncid , 'sucs' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable sucs.' ) ok = NF90_GET_VAR ( ncid , fieldID , insucs ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable sucs.' ) ! 7 ok = NF90_INQ_VARID ( ncid , 'rhosoil' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable rhosoil.' ) ok = NF90_GET_VAR ( ncid , fieldID , inrhosoil ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable rhosoil.' ) ! 8 ok = NF90_INQ_VARID ( ncid , 'cnsd' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable cnsd.' ) ok = NF90_GET_VAR ( ncid , fieldID , incnsd ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable cnsd.' ) ! 9 ok = NF90_INQ_VARID ( ncid , 'css' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable css.' ) ok = NF90_GET_VAR ( ncid , fieldID , incss ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable css.' ) ! 10 ok = NF90_INQ_VARID ( ncid , 'clay' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable clay.' ) ok = NF90_GET_VAR ( ncid , fieldID , inclay ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable clay.' ) ! 11 ok = NF90_INQ_VARID ( ncid , 'silt' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable silt.' ) ok = NF90_GET_VAR ( ncid , fieldID , insilt ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable silt.' ) ! 12 ok = NF90_INQ_VARID ( ncid , 'sand' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable sand.' ) ok = NF90_GET_VAR ( ncid , fieldID , insand ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable sand.' ) ! 13 UM albedo ok = NF90_INQ_VARID ( ncid , 'albedo2' , fieldID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable UM albedo' ) ok = NF90_GET_VAR ( ncid , fieldID , in2alb ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable UM albedo' ) !MD try to read aquifer properties from the file ! if they don't exist set aquifer properties to the same as the soil ok = NF90_INQ_VARID ( ncid , 'Watr' , fieldID ) WRITE ( * , * ) NF90_NOERR ok2 = ok IF ( ok . EQ . NF90_NOERR ) THEN ok2 = NF90_GET_VAR ( ncid , fieldID , inWatr ) END IF IF (( ok2 . NE . NF90_NOERR ) . OR . ( ok . NE . NF90_NOERR )) THEN inWatr (:,:) = 0.05 END IF found_explicit_gw_parameters = . TRUE . ok = NF90_INQ_VARID ( ncid , 'GWssat' , fieldID ) WRITE ( * , * ) NF90_NOERR ok2 = ok IF ( ok . EQ . NF90_NOERR ) THEN ok2 = NF90_GET_VAR ( ncid , fieldID , inGWssat ) END IF IF (( ok2 . NE . NF90_NOERR ) . OR . ( ok . NE . NF90_NOERR )) THEN inGWssat (:,:) = inssat (:,:) found_explicit_gw_parameters = . FALSE . END IF ok = NF90_INQ_VARID ( ncid , 'GWWatr' , fieldID ) ok2 = ok IF ( ok . EQ . NF90_NOERR ) THEN ok2 = NF90_GET_VAR ( ncid , fieldID , inGWssat ) END IF IF (( ok2 . NE . NF90_NOERR ) . OR . ( ok . NE . NF90_NOERR )) THEN inGWWatr (:,:) = 0.05 END IF ok = NF90_INQ_VARID ( ncid , 'GWsucs' , fieldID ) ok2 = ok IF ( ok . EQ . NF90_NOERR ) THEN ok2 = NF90_GET_VAR ( ncid , fieldID , inGWsucs ) END IF IF (( ok2 . NE . NF90_NOERR ) . OR . ( ok . NE . NF90_NOERR )) THEN inGWsucs (:,:) = ABS ( insucs (:,:)) * 100 0.0 found_explicit_gw_parameters = . FALSE . END IF ok = NF90_INQ_VARID ( ncid , 'GWbch' , fieldID ) ok2 = ok IF ( ok . EQ . NF90_NOERR ) THEN ok2 = NF90_GET_VAR ( ncid , fieldID , inGWbch ) END IF IF (( ok2 . NE . NF90_NOERR ) . OR . ( ok . NE . NF90_NOERR )) THEN inGWbch (:,:) = inbch (:,:) found_explicit_gw_parameters = . FALSE . END IF ok = NF90_INQ_VARID ( ncid , 'GWhyds' , fieldID ) ok2 = ok IF ( ok . EQ . NF90_NOERR ) THEN ok2 = NF90_GET_VAR ( ncid , fieldID , inGWhyds ) END IF IF (( ok2 . NE . NF90_NOERR ) . OR . ( ok . NE . NF90_NOERR )) THEN inGWhyds (:,:) = inhyds (:,:) * 100 0.0 found_explicit_gw_parameters = . FALSE . END IF ok = NF90_INQ_VARID ( ncid , 'GWrhosoil' , fieldID ) ok2 = ok IF ( ok . EQ . NF90_NOERR ) THEN ok2 = NF90_GET_VAR ( ncid , fieldID , inGWrhosoil ) END IF IF (( ok2 . NE . NF90_NOERR ) . OR . ( ok . NE . NF90_NOERR )) THEN inGWrhosoil (:,:) = inrhosoil (:,:) END IF ok = NF90_INQ_VARID ( ncid , 'organic' , fieldID ) ok2 = ok IF ( ok . EQ . NF90_NOERR ) THEN ok2 = NF90_GET_VAR ( ncid , fieldID , inORG ) WRITE ( logn , * ) 'READ FORG FROM THE DATA FILE, yeidling ' WRITE ( logn , * ) 'A maximum value of ' , MAXVAL ( inORG ), ' and min val of' , MINVAL ( inORG ) END IF IF (( ok2 . NE . NF90_NOERR ) . OR . ( ok . NE . NF90_NOERR )) THEN inORG (:,:) = 0.0 WRITE ( logn , * ) 'COULD NOT READ FORG FROM THR SRF FILE setting to 0.0' END IF ! Use this code if need to process original UM file soil fields into CABLE ! offline format !    ! 1 !    ok = NF90_INQ_VARID(ncid,'field329',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable swilt.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable swilt.') !    inswilt(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,inswilt) !    ! 2 !    ok = NF90_INQ_VARID(ncid,'field330',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable sfc.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable sfc.') !    insfc(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,insfc) !    ! 3 !    ok = NF90_INQ_VARID(ncid,'field332',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable ssat.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable ssat.') !    inssat(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,inssat) !    ! 4 !    ok = NF90_INQ_VARID(ncid,'field1381',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable bch.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable bch.') !    inbch(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,inbch) !    ! 5 !    ok = NF90_INQ_VARID(ncid,'field333',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable hyds.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable hyds.') !    inhyds(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,inhyds) !    ! 6 !    ok = NF90_INQ_VARID(ncid,'field342',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable sucs.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable sucs.') !    insucs(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,insucs) !    ! 7 !    ok = NF90_INQ_VARID(ncid,'field2011',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable rhosoil.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable rhosoil.') !    inrhosoil(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,inrhosoil) !    ! 8 !    ok = NF90_INQ_VARID(ncid,'field335',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable css.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable css.') !    incss(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,incss) !    ! 9 !    ok = NF90_INQ_VARID(ncid,'field336',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable cnsd.') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable cnsd.') !    incnsd(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,incnsd) !    ! 10 albedo !    ok = NF90_INQ_VARID(ncid,'field1395',fieldID) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error finding variable albedo') !    ok = NF90_GET_VAR(ncid,fieldID,indummy) !    IF (ok /= NF90_NOERR) CALL nc_abort(ok,'Error reading variable albedo') !    in2alb(:,:) = indummy(:,:,1,1) !    CALL NSflip(nlon,nlat,in2alb) ok = NF90_CLOSE ( ncid ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error closing IGBP soil map.' ) ! Code if using UM soil file ! unit change and glacial-point check were done in preprocessing !    ! change unit to m/s !    inhyds = inhyds * 1.0E-3 !    ! Assign values to glacial points which are zeroes !    WHERE(inswilt==0.)     inswilt = 0.216 !    WHERE( insfc ==0.)       insfc = 0.301 !    WHERE(inssat ==0.)      inssat = 0.479 !    WHERE( inbch ==0.)       inbch = 7.1 !    WHERE(inhyds ==0.)      inhyds = 1.E-3 !    WHERE(insucs ==0.)      insucs = 0.153 !    WHERE(inrhosoil==0.) inrhosoil = 1455 !    WHERE(incnsd ==0.)      incnsd = 0.272 !    WHERE(incss > 630000.0) !      incss = incss / inrhosoil   ! normal points need unit conversion !    ELSEWHERE !      incss = 2100.0   ! glacial points !    ENDWHERE ! Calculate albedo for radiation bands and overwrite previous ! initialization PRINT * , 'When choosing spatially-specific soil properties,' PRINT * , 'snow-free albedo is also overwritten by this data set.' WRITE ( logn , * ) 'When choosing spatially-specific soil properties,' WRITE ( logn , * ) 'snow-free albedo is also overwritten by this data set.' sfact = 0.68 WHERE ( in2alb <= 0.14 ) sfact = 0.5 ELSEWHERE ( in2alb > 0.14 ) sfact = 0.62 END WHERE WHERE ( in2alb > 1.0e19 ) ! ocean points in2alb = - 1.0 END WHERE dummy2 (:, :) = 2.0 * in2alb (:, :) / ( 1.0 + sfact (:, :)) inALB (:, :, 1 , 2 ) = dummy2 (:, :) inALB (:, :, 1 , 1 ) = sfact (:, :) * dummy2 (:, :) ALLOCATE ( inSlope ( nlon , nlat ), stat = ok ) IF ( ok . NE . 0 ) CALL nc_abort ( ok , 'Error allocating inSlope ' ) inSlope (:,:) = 0.0 ALLOCATE ( inSlopeSTD ( nlon , nlat ), stat = ok ) IF ( ok . NE . 0 ) CALL nc_abort ( ok , 'Error allocating inSlopeSTD ' ) inSlopeSTD (:,:) = 0.0 ALLOCATE ( inGWdz ( nlon , nlat ), stat = ok ) IF ( ok . NE . 0 ) CALL nc_abort ( ok , 'Error allocating inGWdz ' ) inGWdz (:,:) = 2 0.0 IF ( cable_user % GW_MODEL ) THEN ok = NF90_OPEN ( TRIM ( filename % gw_elev ), NF90_NOWRITE , ncid_elev ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error opening GW elev param file.' ) ok = NF90_INQ_VARID ( ncid_elev , 'slope' , fieldID ) IF ( ok /= NF90_NOERR ) WRITE ( logn , * ) 'Error finding variable slope' ok = NF90_GET_VAR ( ncid_elev , fieldID , inSlope ) IF ( ok /= NF90_NOERR ) THEN inSlope = 0.0 WRITE ( logn , * ) 'Could not read slope data for SSGW, set to 0.0' END IF ok = NF90_INQ_VARID ( ncid_elev , 'slope_std' , fieldID ) !slope_std IF ( ok /= NF90_NOERR ) WRITE ( logn , * ) 'Error finding variable slope std' ok = NF90_GET_VAR ( ncid_elev , fieldID , inSlopeSTD ) IF ( ok /= NF90_NOERR ) THEN inSlopeSTD = 0.0 WRITE ( logn , * ) 'Could not read slope stddev data for SSGW, set to 0.0' END IF ok = NF90_INQ_VARID ( ncid_elev , 'dtb' , fieldID ) IF ( ok /= NF90_NOERR ) WRITE ( logn , * ) 'Error finding variable dtb' ok = NF90_GET_VAR ( ncid_elev , fieldID , inGWdz ) IF ( ok /= NF90_NOERR ) THEN inGWdz = 2 0.0 WRITE ( logn , * ) 'Could not read dtb data for SSGW, set to 0.0' END IF ok = NF90_CLOSE ( ncid_elev ) ENDIF !running gw model DEALLOCATE ( in2alb , sfact , dummy2 ) !    DEALLOCATE(in2alb,sfact,dummy2,indummy) END SUBROUTINE spatialSoil !============================================================================= !subr to read soil color for albed o calc - Ticket #27 SUBROUTINE read_soilcolor ( logn ) ! Read soil color ! ! Input variables: !   filename%soilcolor  - via cable_IO_vars_module ! Output variables: !   soilcol    - via cable_param_module ! ! New input structure using netcdf USE netcdf USE cable_common_module , ONLY : filename , calcsoilalbedo ! USE cable_IO_vars_module, ONLY : soilcol IMPLICIT NONE ! INTEGER, DIMENSION(:), INTENT(INOUT) :: soilcol ! TYPE (soil_parameter_type), INTENT(OUT) :: soil INTEGER , INTENT ( IN ) :: logn ! log file unit number ! local variables ! INTEGER, DIMENSION(:, :),     ALLOCATABLE :: inSoilColor INTEGER :: ncid , ok INTEGER :: nlon INTEGER :: nlat INTEGER :: xID , yID INTEGER :: varID INTEGER :: r , e REAL , DIMENSION (:), ALLOCATABLE :: inLonSoilCol REAL , DIMENSION (:), ALLOCATABLE :: inLatSoilCol ok = NF90_OPEN ( filename % soilcolor , 0 , ncid ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error opening soil color file.' ) ok = NF90_INQ_DIMID ( ncid , 'longitude' , xID ) IF ( ok /= NF90_NOERR ) ok = NF90_INQ_DIMID ( ncid , 'x' , xID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring x dimension.' ) ok = NF90_INQUIRE_DIMENSION ( ncid , xID , LEN = nlon ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting x dimension.' ) ok = NF90_INQ_DIMID ( ncid , 'latitude' , yID ) IF ( ok /= NF90_NOERR ) ok = NF90_INQ_DIMID ( ncid , 'y' , yID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring y dimension.' ) ok = NF90_INQUIRE_DIMENSION ( ncid , yID , LEN = nlat ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting y dimension.' ) ALLOCATE ( inLonSoilCol ( nlon ), inLatSoilCol ( nlat ) ) ALLOCATE ( inSoilColor ( nlon , nlat ) ) ! ALLOCATE( soilcol(mp) ) ok = NF90_INQ_VARID ( ncid , 'longitude' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error finding variable longitude.' ) ok = NF90_GET_VAR ( ncid , varID , inLonSoilCol ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error reading variable longitude.' ) DO r = 1 , nlon IF ( inLonSoilCol ( r ) /= inLon ( r ) ) CALL nc_abort ( ok , & 'Wrong resolution in longitude.' ) END DO ok = NF90_INQ_VARID ( ncid , 'latitude' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable latitude.' ) ok = NF90_GET_VAR ( ncid , varID , inLatSoilCol ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable latitude.' ) DO r = 1 , nlat IF ( inLatSoilCol ( r ) /= inLat ( r ) ) CALL nc_abort ( ok , & 'Wrong resolution in latitude.' ) END DO ok = NF90_INQ_VARID ( ncid , 'SOIL_COLOR' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding variable soil color.' ) ok = NF90_GET_VAR ( ncid , varID , inSoilColor ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading variable soil color.' ) ok = NF90_CLOSE ( ncid ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error closing soil color file.' ) END SUBROUTINE read_soilcolor !============================================================================= SUBROUTINE NSflip ( nlon , nlat , invar ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: nlon INTEGER , INTENT ( IN ) :: nlat REAL , INTENT ( INOUT ) :: invar ( nlon , nlat ) ! local variables INTEGER :: ii , jj REAL :: rdummy ( nlon , nlat ) DO jj = 1 , nlat DO ii = 1 , nlon rdummy ( ii , jj ) = invar ( ii , nlat - jj + 1 ) ENDDO ENDDO invar (:, :) = rdummy (:, :) END SUBROUTINE NSflip !============================================================================= SUBROUTINE get_land_index ( nlon , nlat ) ! ! fill the index variable 'landpt%ilat, landpt%ilon' ! ! Input variables: !   nlon           - # longitudes in input data set !   nlat           - # latitudes  in input data set !   npatch         - # patches in each grid from input data set !   inLon          - via cable_param_module !   inLat          - via cable_param_module !   longitude      - via cable_IO_vars_module, dim(mland), not patches !   latitude       - via cable_IO_vars_module, dim(mland), not patches !   nmetpatches    - via cable_IO_vars_module !   vegtype_metfile - via cable_IO_vars_module, dim(mland,nmetpatches) !   soiltype_metfile- via cable_IO_vars_module, dim(mland,nmetpatches) ! Output variables: !   max_vegpatches - via cable_IO_vars_module !   landpt%type    - via cable_IO_vars_module (%nap,cstart,cend,ilon,ilat) IMPLICIT NONE INTEGER , INTENT ( IN ) :: nlon , nlat ! local variables REAL :: lon2 , distance , newLength INTEGER :: ii , jj , kk , tt , ncount ! range of longitudes from input file (inLon) should be -180 to 180, ! and longitude(:) has already been converted to -180 to 180 for CABLE. landpt (:)% ilon = - 999 landpt (:)% ilat = - 999 ncount = 0 DO kk = 1 , mland distance = 530 0.0 ! initialise, units are degrees DO jj = 1 , nlat DO ii = 1 , nlon IF ( inVeg ( ii , jj , 1 ) > 0 ) THEN newLength = SQRT (( inLon ( ii ) - longitude ( kk )) ** 2 & + ( inLat ( jj ) - latitude ( kk )) ** 2 ) IF ( newLength < distance ) THEN distance = newLength landpt ( kk )% ilon = ii landpt ( kk )% ilat = jj END IF END IF END DO END DO IF ( landpt ( kk )% ilon < - 900 . OR . landpt ( kk )% ilat < - 900 ) THEN PRINT * , 'Land point ' , kk , ' cannot find the nearest grid!' PRINT * , 'lon, lat = ' , longitude ( kk ), latitude ( kk ) PRINT * , 'inLon range:' , MINVAL ( inLon ), MAXVAL ( inLon ) PRINT * , 'inLat range:' , MINVAL ( inLat ), MAXVAL ( inLat ) STOP END IF END DO END SUBROUTINE get_land_index !============================================================================= SUBROUTINE countPatch ( nlon , nlat , npatch ) ! count the total number of active patches and ! fill the index variable 'landpt' ! ! Input variables: !   nlon           - # longitudes in input data set !   nlat           - # latitudes  in input data set !   npatch         - # patches in each grid from input data set !   inLon          - via cable_param_module !   inLat          - via cable_param_module !   longitude      - via cable_IO_vars_module, dim(mland), not patches !   latitude       - via cable_IO_vars_module, dim(mland), not patches !   nmetpatches    - via cable_IO_vars_module !   vegtype_metfile - via cable_IO_vars_module, dim(mland,nmetpatches) !   soiltype_metfile- via cable_IO_vars_module, dim(mland,nmetpatches) ! Output variables: !   max_vegpatches - via cable_IO_vars_module !   landpt%type    - via cable_IO_vars_module (%nap,cstart,cend,ilon,ilat) IMPLICIT NONE INTEGER , INTENT ( IN ) :: nlon , nlat , npatch ! local variables REAL :: lon2 , distance , newLength INTEGER :: ii , jj , kk , tt , ncount ! range of longitudes from input file (inLon) should be -180 to 180, ! and longitude(:) has already been converted to -180 to 180 for CABLE. landpt (:)% ilon = - 999 landpt (:)% ilat = - 999 ncount = 0 DO kk = 1 , mland distance = 30 0.0 ! initialise, units are degrees DO jj = 1 , nlat DO ii = 1 , nlon IF ( inVeg ( ii , jj , 1 ) > 0 ) THEN newLength = SQRT (( inLon ( ii ) - longitude ( kk )) ** 2 & + ( inLat ( jj ) - latitude ( kk )) ** 2 ) IF ( newLength < distance ) THEN distance = newLength landpt ( kk )% ilon = ii landpt ( kk )% ilat = jj END IF END IF END DO END DO IF ( landpt ( kk )% ilon < - 900 . OR . landpt ( kk )% ilat < - 900 ) THEN PRINT * , 'Land point ' , kk , ' cannot find the nearest grid!' PRINT * , 'lon, lat = ' , longitude ( kk ), latitude ( kk ) PRINT * , 'inLon range:' , MINVAL ( inLon ), MAXVAL ( inLon ) PRINT * , 'inLat range:' , MINVAL ( inLat ), MAXVAL ( inLat ) STOP END IF landpt ( kk )% nap = 0 landpt ( kk )% cstart = ncount + 1 IF ( ASSOCIATED ( vegtype_metfile )) THEN DO tt = 1 , nmetpatches IF ( vegtype_metfile ( kk , tt ) > 0 ) ncount = ncount + 1 landpt ( kk )% nap = landpt ( kk )% nap + 1 END DO landpt ( kk )% cend = ncount IF ( landpt ( kk )% cend < landpt ( kk )% cstart ) THEN PRINT * , 'Land point ' , kk , ' does not have veg type!' PRINT * , 'landpt%cstart, cend = ' , landpt ( kk )% cstart , landpt ( kk )% cend PRINT * , 'vegtype_metfile = ' , vegtype_metfile ( kk ,:) STOP END IF ! CLN added for npatches ELSE IF ( npatch . GT . 1 ) THEN landpt ( kk )% nap = 0 DO tt = 1 , npatch IF ( inVeg ( landpt ( kk )% ilon , landpt ( kk )% ilat , tt ) > 0 ) THEN landpt ( kk )% nap = landpt ( kk )% nap + 1 ENDIF END DO ncount = ncount + landpt ( kk )% nap landpt ( kk )% cend = ncount IF ( landpt ( kk )% cend < landpt ( kk )% cstart ) THEN PRINT * , 'Land point ' , kk , ' does not have veg type!' PRINT * , 'landpt%cstart, cend = ' , landpt ( kk )% cstart , landpt ( kk )% cend PRINT * , 'vegtype_metfile = ' , vegtype_metfile ( kk ,:) STOP END IF ELSE ! assume nmetpatches to be 1 IF ( nmetpatches == 1 ) THEN ncount = ncount + 1 landpt ( kk )% nap = 1 landpt ( kk )% cend = ncount ELSE PRINT * , 'nmetpatches = ' , nmetpatches , '. Should be 1.' PRINT * , 'If soil patches exist, add new code.' STOP END IF END IF END DO ! CLN IF (ncount > mland * nmetpatches) THEN IF ( ncount > mland * nmetpatches . AND . npatch == 1 ) THEN PRINT * , ncount , ' should not be greater than mland*nmetpatches.' PRINT * , 'mland, nmetpatches = ' , mland , nmetpatches STOP END IF DEALLOCATE ( inLon , inLat ) ! Set the maximum number of active patches to that read from met file: max_vegpatches = MAXVAL ( landpt (:)% nap ) !CLN    IF (max_vegpatches /= nmetpatches) THEN IF ( max_vegpatches /= nmetpatches . AND . npatch == 1 ) THEN PRINT * , 'Error! Met file claiming to have more active patches than' PRINT * , 'it really has. Check met file.' STOP END IF IF ( npatch < nmetpatches ) THEN PRINT * , 'Warning! Met file data have more patches than the global file.' PRINT * , 'Remember to check final veg type and patch fractions.' END IF ! Write to total # patches - used to allocate all of CABLE's variables: mp = ncount PRINT * , 'Total number of patches (countPatch): ' , ncount END SUBROUTINE countPatch !============================================================================= SUBROUTINE write_default_params ( met , air , ssnow , veg , bgc , & soil , canopy , rough , rad , logn , & vegparmnew , month , TFRZ , LUC_EXPT ) ! Initialize many canopy_type, soil_snow_type, soil_parameter_type and ! roughness_type variables; ! Calculate 'froot' from 'rootbeta' parameter; ! Assign values from input file to their proper variables in soil_snow_type, ! soil_parameter_type, veg_parameter_type and patch_type; ! Prescribe parameters for each point based on its veg/soil type. ! ! New input structure using netcdf and introduced 'month' to initialize ! soil profiles with the correct monthly average values (BP apr2010) ! ! Input variables: !   longitude      - via cable_IO_vars_module, dim(mland), not patches !   latitude       - via cable_IO_vars_module, dim(mland), not patches !   nmetpatches    - via cable_IO_vars_module !   vegtype_metfile - via cable_IO_vars_module, dim(mland,nmetpatches) !   soiltype_metfile- via cable_IO_vars_module, dim(mland,nmetpatches) ! Output variables: !   max_vegpatches - via cable_IO_vars_module !   landpt(mp)%type- via cable_IO_vars_module (%nap,cstart,cend,ilon,ilat) !   patch(mp)%type - via cable_IO_vars_module (%frac,longitude,latitude) USE cable_common_module , ONLY : calcsoilalbedo , cable_user IMPLICIT NONE INTEGER , INTENT ( IN ) :: logn ! log file unit number INTEGER , INTENT ( IN ) :: month ! month of year LOGICAL , INTENT ( IN ) :: vegparmnew ! new format input REAL , INTENT ( IN ) :: TFRZ TYPE ( met_type ), INTENT ( INOUT ) :: met TYPE ( air_type ), INTENT ( INOUT ) :: air TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg TYPE ( bgc_pool_type ), INTENT ( INOUT ) :: bgc TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy TYPE ( roughness_type ), INTENT ( INOUT ) :: rough TYPE ( radiation_type ), INTENT ( INOUT ) :: rad TYPE ( LUC_EXPT_TYPE ), INTENT ( IN ) :: LUC_EXPT INTEGER , DIMENSION (:), ALLOCATABLE :: ALLVEG INTEGER :: e , f , h , i , klev ! do loop counter INTEGER :: is ! YP oct07 INTEGER :: ir ! BP sep2010 REAL :: totdepth ! YP oct07 REAL :: tmp ! BP sep2010 !    The following is for the alternate method to calculate froot by Zeng 2001 !    REAL :: term1(17), term2(17)                ! (BP may2010) !    REAL :: aa(17), bb(17)   ! new parameter values for IGBP types !    DATA aa /6.706,7.344,7.066,5.990,4.453,6.326,7.718,7.604,8.235,10.740, !    10.740,5.558,5.558,5.558,4.372,4.372,4.372/ !    DATA bb /2.175,1.303,1.953,1.955,1.631,1.567,1.262,2.300,1.627,2.608, !    2.608,2.614,2.614,2.614,0.978,0.978,0.978/ !    (BP may2010) ! ******************************************************************* ! Site independent initialisations (all gridcells): canopy % cansto = 0.0 ! canopy water storage (mm or kg/m2) canopy % sghflux = 0.0 canopy % ghflux = 0.0 ssnow % ssdn = 12 0.0 ! snow density per layer (kg/m3) ssnow % ssdnn = 12 0.0 ! overall snow density (kg/m3) ssnow % tggsn = tfrz ! snow temperature per layer (K) ssnow % isflag = 0 ! snow layer scheme flag (0 = no/little snow, 1=snow) ssnow % snowd = 0.0 ! snow liquid water equivalent depth (mm or kg/m2) ssnow % osnowd = 0.0 ! snow depth prev timestep (mm or kg/m2) ssnow % sdepth = 0.0 ! snow depth for each snow layer (BP jul2010) ssnow % snage = 0.0 ! snow age ssnow % wbice = 0.0 ! soil ice ssnow % thetai = 0.0 ! soil ice ssnow % smass = 0.0 ! snow mass per layer (kg/m&#94;2) ssnow % runoff = 0.0 ! runoff total = subsurface + surface runoff ssnow % rnof1 = 0.0 ! surface runoff (mm/timestepsize) ssnow % rnof2 = 0.0 ! deep drainage (mm/timestepsize) ssnow % rtsoil = 10 0.0 ! turbulent resistance for soil ssnow % wb_lake = 0.0 canopy % ga = 0.0 ! ground heat flux (W/m2) canopy % dgdtg = 0.0 ! derivative of ground heat flux wrt soil temp canopy % fev = 0.0 ! latent heat flux from vegetation (W/m2) canopy % fes = 0.0 ! latent heat flux from soil (W/m2) canopy % fhs = 0.0 ! sensible heat flux from soil (W/m2) !! vh_js !! canopy % us = 0.1 ! friction velocity (needed in roughness before first call to canopy: should in be retart? canopy % fh = 0.0 ! sensible heat flux canopy % fe = 0.0 ! sensible heat flux !mrd ssnow % qrecharge = 0.0 ssnow % GWwb = - 1.0 ssnow % wtd = 1.0 canopy % sublayer_dz = 0.001 !could go into restart to ensure starting/stopping runs gives identical results !however the impact is negligible !IF(hide%Ticket49Bug2) THEN canopy % ofes = 0.0 ! latent heat flux from soil (W/m2) canopy % fevc = 0.0 !vh! canopy % fevw = 0.0 !vh! canopy % fns = 0.0 canopy % fnv = 0.0 canopy % fhv = 0.0 canopy % fwsoil = 1.0 ! vh -should be calculated from soil moisture or ! be in restart file ssnow % kth = 0.3 ! vh ! should be calculated from soil moisture or be in restart file ssnow % sconds (:,:) = 0.06_r_2 ! vh snow thermal cond (W m-2 K-1), ! should be in restart file ! parameters that are not spatially dependent SELECT CASE ( ms ) CASE ( 6 ) soil % zse = ( / . 022 , . 058 , . 154 , . 409 , 1.085 , 2.872 / ) ! layer thickness nov03 CASE ( 12 ) soil % zse = ( / . 022 , 0.0500 , 0.1300 , 0.3250 , 0.3250 , 0.3000 , & 0.3000 , 0.3000 , 0.3000 , 0.3000 , 0.7500 , 1.50 / ) CASE ( 13 ) soil % zse = ( / . 02 , 0.0500 , 0.06 , 0.1300 , 0.300 , 0.300 , 0.3000 , & 0.3000 , 0.3000 , 0.3000 , 0.3000 , 0.7500 , 1.50 / ) END SELECT !ELSE !   ! parameters that are not spatially dependent !   soil%zse = (/.022, .058, .154, .409, 1.085, 2.872/) ! layer thickness nov03 !ENDIF rough % za_uv = 4 0.0 ! lowest atm. model layer/reference height rough % za_tq = 4 0.0 veg % meth = 1 ! canopy turbulence parameterisation method: 0 or 1 !! I brought this in with manual merge of #199 BUT Am i bringing this back in ? !!! calculate vegin%froot from using rootbeta and soil depth !!! (Jackson et al. 1996, Oceologica, 108:389-411) !!totdepth = 0.0 !!DO is = 1, ms !!   totdepth = totdepth + soil%zse(is) * 100.0  ! unit in centimetres !!   vegin%froot(is, :) = MIN(1.0, 1.0-vegin%rootbeta(:)**totdepth) !!END DO !!DO is = ms, 2, -1 !!   vegin%froot(is, :) = vegin%froot(is, :)-vegin%froot(is-1, :) !!END DO ALLOCATE ( defaultLAI ( mp , 12 )) DO e = 1 , mland ! over all land grid points ! Write to CABLE variables from temp variables saved in ! get_default_params veg % iveg ( landpt ( e )% cstart : landpt ( e )% cend ) = & inVeg ( landpt ( e )% ilon , landpt ( e )% ilat , 1 : landpt ( e )% nap ) patch ( landpt ( e )% cstart : landpt ( e )% cend )% frac = & inPFrac ( landpt ( e )% ilon , landpt ( e )% ilat , 1 : landpt ( e )% nap ) WRITE ( * , * ) 'iveg' , e , veg % iveg ( landpt ( e )% cstart : landpt ( e )% cend ) WRITE ( * , * ) 'patchfrac' , e , patch ( landpt ( e )% cstart : landpt ( e )% cend )% frac ! set land use (1 = primary; 2 = secondary, 3 = open) IF ( cable_user % popluc ) THEN veg % iLU ( landpt ( e )% cstart : landpt ( e )% cend ) = 1 IF ( landpt ( e )% nap . EQ . 3 . AND . veg % iveg ( landpt ( e )% cstart ) <= 5 ) THEN veg % iLU ( landpt ( e )% cstart + 1 ) = 2 veg % iLU ( landpt ( e )% cend ) = 3 ENDIF ENDIF ! Check that patch fractions total to 1 tmp = 0 IF ( landpt ( e )% cstart == landpt ( e )% cend ) THEN patch ( landpt ( e )% cstart )% frac = 1.0 ELSE DO is = landpt ( e )% cstart , landpt ( e )% cend tmp = tmp + patch ( is )% frac END DO IF ( ABS ( 1.0 - tmp ) > 0.001 ) THEN IF (( 1.0 - tmp ) < - 0.001 . OR . ( 1.0 - tmp ) > 0.5 ) THEN PRINT * , 'Investigate the discrepancy in patch fractions:' PRINT * , 'patch%frac = ' , & patch ( landpt ( e )% cstart : landpt ( e )% cend )% frac PRINT * , 'landpoint # ' , e PRINT * , 'veg types = ' , veg % iveg ( landpt ( e )% cstart : landpt ( e )% cend ) STOP END IF patch ( landpt ( e )% cstart )% frac = patch ( landpt ( e )% cstart )% frac + 1.0 & - tmp END IF END IF patch ( landpt ( e )% cstart : landpt ( e )% cend )% longitude = longitude ( e ) patch ( landpt ( e )% cstart : landpt ( e )% cend )% latitude = latitude ( e ) soil % isoilm ( landpt ( e )% cstart : landpt ( e )% cend ) = & inSoil ( landpt ( e )% ilon , landpt ( e )% ilat ) ! Set initial soil temperature and moisture according to starting month !! vh_js !! !IF(hide%Ticket49Bug3) THEN ! Set initial soil temperature and moisture according to starting month DO is = 1 , ms ! Work around set everything above last input layer to the last input layer ssnow % tgg ( landpt ( e )% cstart : landpt ( e )% cend , is ) = & inTGG ( landpt ( e )% ilon , landpt ( e )% ilat , MIN ( is , SIZE ( inTGG , 3 )), month ) ssnow % wb ( landpt ( e )% cstart : landpt ( e )% cend , is ) = & inWB ( landpt ( e )% ilon , landpt ( e )% ilat , MIN ( is , SIZE ( inTGG , 3 )), month ) END DO !ELSE !   DO is = 1, ms !     ssnow%tgg(landpt(e)%cstart:landpt(e)%cend, is) =                       & !                              inTGG(landpt(e)%ilon,landpt(e)%ilat, is, month) !     ssnow%wb(landpt(e)%cstart:landpt(e)%cend, is) =                        & !                              inWB(landpt(e)%ilon, landpt(e)%ilat, is, month) !   END DO !ENDIF ! Set initial snow depth and snow-free soil albedo DO is = 1 , landpt ( e )% cend - landpt ( e )% cstart + 1 ! each patch DO ir = 1 , nrb IF ( CABLE_USER % POPLUC ) THEN !vh! use same soilalbedo for all land-use tiles ssnow % albsoilsn ( landpt ( e )% cstart + is - 1 , ir ) & = inALB ( landpt ( e )% ilon , landpt ( e )% ilat , 1 , ir ) ! various rad band ELSE ! each band ssnow % albsoilsn ( landpt ( e )% cstart + is - 1 , ir ) & = inALB ( landpt ( e )% ilon , landpt ( e )% ilat , is , ir ) ! various rad band ENDIF END DO ! total depth, change from m to mm !see Ticket #57 ssnow % snowd ( landpt ( e )% cstart + is - 1 ) & = inSND ( landpt ( e )% ilon , landpt ( e )% ilat , is , month ) * 14 0.0 END DO ! Set default LAI values DO is = 1 , 12 defaultLAI ( landpt ( e )% cstart : landpt ( e )% cend , is ) = & inLAI ( landpt ( e )% ilon , landpt ( e )% ilat , is ) END DO ! Set IGBP soil texture values, Q.Zhang @ 12/20/2010. IF ( soilparmnew ) THEN soil % swilt ( landpt ( e )% cstart : landpt ( e )% cend ) = & inswilt ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % sfc ( landpt ( e )% cstart : landpt ( e )% cend ) = & insfc ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % ssat ( landpt ( e )% cstart : landpt ( e )% cend ) = & inssat ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % bch ( landpt ( e )% cstart : landpt ( e )% cend ) = & inbch ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % hyds ( landpt ( e )% cstart : landpt ( e )% cend ) = & inhyds ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % sucs ( landpt ( e )% cstart : landpt ( e )% cend ) = & - 1. * ABS ( insucs ( landpt ( e )% ilon , landpt ( e )% ilat )) !ensure negative soil % rhosoil ( landpt ( e )% cstart : landpt ( e )% cend ) = & inrhosoil ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % css ( landpt ( e )% cstart : landpt ( e )% cend ) = & incss ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % cnsd ( landpt ( e )% cstart : landpt ( e )% cend ) = & incnsd ( landpt ( e )% ilon , landpt ( e )% ilat ) !possibly heterogeneous soil properties DO klev = 1 , ms soil % clay_vec ( landpt ( e )% cstart : landpt ( e )% cend , klev ) = & REAL ( inclay ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % sand_vec ( landpt ( e )% cstart : landpt ( e )% cend , klev ) = & REAL ( insand ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % silt_vec ( landpt ( e )% cstart : landpt ( e )% cend , klev ) = & REAL ( insilt ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % rhosoil_vec ( landpt ( e )% cstart : landpt ( e )% cend , klev ) = & REAL ( inrhosoil ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % org_vec ( landpt ( e )% cstart : landpt ( e )% cend , klev ) = & REAL ( inORG ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % watr ( landpt ( e )% cstart : landpt ( e )% cend , klev ) = & REAL ( inWatr ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) END DO !Aquifer properties  same as bottom soil layer for now soil % GWsucs_vec ( landpt ( e )% cstart : landpt ( e )% cend ) = & REAL ( inGWsucs ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % GWhyds_vec ( landpt ( e )% cstart : landpt ( e )% cend ) = & REAL ( inGWhyds ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % GWbch_vec ( landpt ( e )% cstart : landpt ( e )% cend ) = & REAL ( inGWbch ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % GWrhosoil_vec ( landpt ( e )% cstart : landpt ( e )% cend ) = & REAL ( inGWrhosoil ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % GWssat_vec ( landpt ( e )% cstart : landpt ( e )% cend ) = & REAL ( inGWssat ( landpt ( e )% ilon , landpt ( e )% ilat ), r_2 ) soil % GWwatr ( landpt ( e )% cstart : landpt ( e )% cend ) = & soil % watr ( landpt ( e )% cstart : landpt ( e )% cend , ms ) soil % slope ( landpt ( e )% cstart : landpt ( e )% cend ) = & MIN ( MAX ( inSlope ( landpt ( e )% ilon , landpt ( e )% ilat ), 1e-8 ), 0.95 ) soil % slope_std ( landpt ( e )% cstart : landpt ( e )% cend ) = & MIN ( MAX ( inSlopeSTD ( landpt ( e )% ilon , landpt ( e )% ilat ), 1e-8 ), 0.95 ) soil % GWdz ( landpt ( e )% cstart : landpt ( e )% cend ) = & inGWdz ( landpt ( e )% ilon , landpt ( e )% ilat ) ! vh ! soil % silt ( landpt ( e )% cstart : landpt ( e )% cend ) = & insilt ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % sand ( landpt ( e )% cstart : landpt ( e )% cend ) = & insand ( landpt ( e )% ilon , landpt ( e )% ilat ) soil % clay ( landpt ( e )% cstart : landpt ( e )% cend ) = & inclay ( landpt ( e )% ilon , landpt ( e )% ilat ) ENDIF ! vars intro for Ticket #27 IF ( calcsoilalbedo ) THEN soil % soilcol ( landpt ( e )% cstart : landpt ( e )% cend ) = & inSoilColor ( landpt ( e )% ilon , landpt ( e )% ilat ) END IF ! offline only below ! If user defined veg types are present in the met file then use them. ! This means that if met file just has veg type and no other parameters, ! the other veg parameters will be chosen as a function of this type: ! N.B. for offline run only IF ( ASSOCIATED ( vegtype_metfile )) THEN ! i.e. iveg found in the met file ! Overwrite iveg for those patches available in met file, ! which are currently set to def values above: veg % iveg ( landpt ( e )% cstart : landpt ( e )% cstart + nmetpatches - 1 ) = & vegtype_metfile ( e , :) IF ( exists % patch ) & patch ( landpt ( e )% cstart : landpt ( e )% cstart )% frac = & vegpatch_metfile ( e , landpt ( e )% cstart : landpt ( e )% cstart ) ! In case gridinfo file provides more patches than met file(BP may08) DO f = nmetpatches + 1 , landpt ( e )% nap IF ( patch ( landpt ( e )% cstart + f - 1 )% frac > 0.0 ) THEN patch ( landpt ( e )% cstart )% frac = patch ( landpt ( e )% cstart )% frac & + patch ( landpt ( e )% cstart + f - 1 )% frac patch ( landpt ( e )% cstart + f - 1 )% frac = 0.0 END IF END DO END IF ! Similarly, if user defined soil types are present then use them: IF ( ASSOCIATED ( soiltype_metfile )) THEN ! i.e. isoil found in the met file soil % isoilm ( landpt ( e )% cstart : landpt ( e )% cstart + nmetpatches - 1 ) = & soiltype_metfile ( e , :) END IF ! offline only above !call veg% init that is common CALL init_veg_from_vegin ( landpt ( e )% cstart , landpt ( e )% cend , veg , soil % zse ) ! Prescribe parameters for current gridcell based on veg/soil type (which ! may have loaded from default value file or met file): DO h = landpt ( e )% cstart , landpt ( e )% cend ! over each patch in current grid bgc % cplant ( h , 1 ) = vegin % cplant1 ( veg % iveg ( h )) bgc % cplant ( h , 2 ) = vegin % cplant2 ( veg % iveg ( h )) bgc % cplant ( h , 3 ) = vegin % cplant3 ( veg % iveg ( h )) bgc % csoil ( h , 1 ) = vegin % csoil1 ( veg % iveg ( h )) bgc % csoil ( h , 2 ) = vegin % csoil2 ( veg % iveg ( h )) bgc % ratecp ( 1 ) = vegin % ratecp1 ( veg % iveg ( h )) bgc % ratecp ( 2 ) = vegin % ratecp2 ( veg % iveg ( h )) bgc % ratecp ( 3 ) = vegin % ratecp3 ( veg % iveg ( h )) bgc % ratecs ( 1 ) = vegin % ratecs1 ( veg % iveg ( h )) bgc % ratecs ( 2 ) = vegin % ratecs2 ( veg % iveg ( h )) IF (. NOT . soilparmnew ) THEN ! Q,Zhang @ 12/20/2010 soil % swilt ( h ) = soilin % swilt ( soil % isoilm ( h )) soil % sfc ( h ) = soilin % sfc ( soil % isoilm ( h )) soil % ssat ( h ) = soilin % ssat ( soil % isoilm ( h )) soil % bch ( h ) = soilin % bch ( soil % isoilm ( h )) soil % hyds ( h ) = soilin % hyds ( soil % isoilm ( h )) soil % sucs ( h ) = soilin % sucs ( soil % isoilm ( h )) soil % rhosoil ( h ) = soilin % rhosoil ( soil % isoilm ( h )) soil % css ( h ) = soilin % css ( soil % isoilm ( h )) soil % silt ( h ) = soilin % silt ( soil % isoilm ( h )) soil % clay ( h ) = soilin % clay ( soil % isoilm ( h )) soil % sand ( h ) = soilin % sand ( soil % isoilm ( h )) !MDeck DO klev = 1 , ms soil % clay_vec ( h , klev ) = REAL ( soilin % clay ( soil % isoilm ( h )), r_2 ) soil % sand_vec ( h , klev ) = REAL ( soilin % sand ( soil % isoilm ( h )), r_2 ) soil % silt_vec ( h , klev ) = REAL ( soilin % silt ( soil % isoilm ( h )), r_2 ) soil % rhosoil_vec ( h , klev ) = REAL ( soilin % rhosoil ( soil % isoilm ( h )), r_2 ) soil % watr ( h , klev ) = 0.01 END DO soil % GWsucs_vec ( h ) = REAL ( ABS ( soilin % sucs ( soil % isoilm ( h ))) * 100 0.0 , r_2 ) soil % GWhyds_vec ( h ) = REAL ( soilin % hyds ( soil % isoilm ( h )) * 100 0.0 , r_2 ) soil % GWbch_vec ( h ) = REAL ( soilin % bch ( soil % isoilm ( h )), r_2 ) soil % GWrhosoil_vec ( h ) = REAL ( soilin % rhosoil ( soil % isoilm ( h )), r_2 ) soil % GWssat_vec ( h ) = REAL ( soilin % ssat ( soil % isoilm ( h )), r_2 ) soil % GWwatr ( h ) = 0.01 END IF rad % latitude ( h ) = latitude ( e ) !IF(hide%Ticket49Bug4) & rad % longitude ( h ) = longitude ( e ) !jhan:is this done online? YES veg % ejmax ( h ) = 2.0 * veg % vcmax ( h ) END DO ! over each veg patch in land point END DO ! over all land points soil % albsoil = ssnow % albsoilsn ! check tgg and alb IF ( ANY ( ssnow % tgg > 35 0.0 ) . OR . ANY ( ssnow % tgg < 18 0.0 )) & CALL abort ( 'Soil temps nuts' ) IF ( ANY ( ssnow % albsoilsn > 1.0 ) . OR . ANY ( ssnow % albsoilsn < 0.0 )) & CALL abort ( 'Albedo nuts' ) WRITE ( logn , * ) IF ( cable_user % GSWP3 ) THEN rough % za_uv = 2.0 + veg % hc ! lowest atm. model layer/reference height rough % za_tq = 2.0 + veg % hc END IF ! Deallocate temporary variables: IF ( soilparmnew ) DEALLOCATE ( inswilt , insfc , inssat , inbch , inhyds , & insucs , inrhosoil , incss , incnsd ) ! Q,Zhang @ 12/20/2010 IF ( calcsoilalbedo ) DEALLOCATE ( inSoilColor ) ! vars intro for Ticket #27 DEALLOCATE ( inVeg , inPFrac , inSoil , inWB , inTGG ) DEALLOCATE ( inLAI , inSND , inALB ) !    DEALLOCATE(soiltemp_temp,soilmoist_temp,patchfrac_temp,isoilm_temp,& !         frac4_temp,iveg_temp) !    IF(ASSOCIATED(vegtype_metfile)) DEALLOCATE(vegtype_metfile) !    IF(ASSOCIATED(soiltype_metfile)) DEALLOCATE(soiltype_metfile) !    DEALLOCATE(soilin%silt, soilin%clay, soilin%sand, soilin%swilt,            & !               soilin%sfc, soilin%ssat, soilin%bch, soilin%hyds, soilin%sucs,  & !               soilin%rhosoil, soilin%css, vegin%canst1, vegin%dleaf,          & !               vegin%vcmax, vegin%ejmax, vegin%hc, vegin%xfang, vegin%rp20,    & !               vegin%rpcoef, vegin%rs20, vegin%shelrb, vegin%frac4,            & !               vegin%wai, vegin%vegcf, vegin%extkn, vegin%tminvj,              & !               vegin%tmaxvj, vegin%vbeta,vegin%clitt, vegin%zr, vegin%rootbeta, vegin%froot,         & !               vegin%cplant, vegin%csoil, vegin%ratecp, vegin%ratecs,          & !               vegin%xalbnir, vegin%length, vegin%width,                       & !               vegin%g0, vegin%g1,                                             & !               vegin%a1gs, vegin%d0gs, vegin%alpha, vegin%convex, vegin%cfrd,  & !               vegin%gswmin, vegin%conkc0,vegin%conko0,vegin%ekc,vegin%eko   ) !    !         vegf_temp,urbanf_temp,lakef_temp,icef_temp, & IF ( ALLOCATED ( inGWsucs )) DEALLOCATE ( inGWsucs ) IF ( ALLOCATED ( inGWhyds )) DEALLOCATE ( inGWhyds ) IF ( ALLOCATED ( inGWbch )) DEALLOCATE ( inGWbch ) IF ( ALLOCATED ( inGWsilt )) DEALLOCATE ( inGWsilt ) IF ( ALLOCATED ( inGWsand )) DEALLOCATE ( inGWsand ) IF ( ALLOCATED ( inGWclay )) DEALLOCATE ( inGWclay ) IF ( ALLOCATED ( inGWssat )) DEALLOCATE ( inGWssat ) IF ( ALLOCATED ( inGWWatr )) DEALLOCATE ( inGWWatr ) IF ( ALLOCATED ( inWatr )) DEALLOCATE ( inWatr ) IF ( ALLOCATED ( inSlope )) DEALLOCATE ( inSlope ) IF ( ALLOCATED ( inSlopeSTD )) DEALLOCATE ( inSlopeSTD ) IF ( ALLOCATED ( inORG )) DEALLOCATE ( inORG ) ! if using old format veg_parm input file, need to define veg%deciduous ! BP dec 2007 !    IF (.NOT. vegparmnew) THEN veg % deciduous = . FALSE . IF ( mvtype == 13 ) THEN WHERE ( veg % iveg == 2 . OR . veg % iveg == 5 ) veg % deciduous = . TRUE . ELSE IF ( mvtype == 15 . OR . mvtype == 16 . OR . mvtype == 17 ) THEN WHERE ( veg % iveg == 3 . OR . veg % iveg == 4 ) veg % deciduous = . TRUE . ELSE STOP 'Warning. Check number of vegetation types.' END IF !    END IF ! Only the following snow inits are necessary, ! soilsnow will update other variables. WHERE ( ssnow % snowd (:) > 0.0 ) ! in cm ssnow % ssdnn (:) = 12 0.0 ! overall snow density (kg/m3) ssnow % ssdn (:, 1 ) = 12 0.0 ! snow density per layer (kg/m3) ssnow % ssdn (:, 2 ) = 12 0.0 ! snow density per layer (kg/m3) ssnow % ssdn (:, 3 ) = 12 0.0 ! snow density per layer (kg/m3) ssnow % snage (:) = 0.0 ! snow age (fresh) ssnow % isflag (:) = 0 ELSEWHERE ssnow % ssdnn (:) = 14 0.0 ! overall snow density (kg/m3) ssnow % osnowd (:) = 0.0 ! snow depth prev timestep (mm or kg/m2) ssnow % snage (:) = 0.0 ! snow age ssnow % isflag (:) = 0 ! snow layer scheme flag ! (0 = no/little snow, 1=snow) ssnow % tggsn (:, 1 ) = 27 3.1 ! snow temperature per layer (K) ssnow % tggsn (:, 2 ) = 27 3.1 ! snow temperature per layer (K) ssnow % tggsn (:, 3 ) = 27 3.1 ! snow temperature per layer (K) ssnow % ssdn (:, 1 ) = 14 0.0 ! snow density per layer (kg/m3) ssnow % ssdn (:, 2 ) = 14 0.0 ! snow density per layer (kg/m3) ssnow % ssdn (:, 3 ) = 14 0.0 ! snow density per layer (kg/m3) ssnow % smass (:, 1 ) = 0.0 ! snow mass per layer (kg/m&#94;2) ssnow % smass (:, 2 ) = 0.0 ! snow mass per layer (kg/m&#94;2) ssnow % smass (:, 3 ) = 0.0 ! snow mass per layer (kg/m&#94;2) ENDWHERE ! Soil ice: WHERE ( ssnow % tgg (:, :) < 27 3.15 ) ssnow % wbice (:,:) = ssnow % wb (:, :) * 0.8 ELSEWHERE ssnow % wbice (:, :) = 0.0 END WHERE ssnow % Qrecharge = 0.0 canopy % sublayer_dz = 0.0 ssnow % rtevap_sat = 0.0 ssnow % rtevap_unsat = 0.0 ssnow % satfrac = 0.5 ssnow % wbliq = ssnow % wb - ssnow % wbice ssnow % GWwb = 0.9 * soil % ssat !IF(hide%Ticket49Bug5) THEN !! vh_js !! neeed to remove this if to enable the code below ! SLI specific initialisations: !  IF(cable_user%SOIL_STRUC=='sli') THEN ssnow % h0 (:) = 0.0 ssnow % S (:,:) = ssnow % wb (:,:) / SPREAD ( soil % ssat , 2 , ms ) ssnow % snowliq (:,:) = 0.0 ssnow % Tsurface = 2 5.0 ssnow % nsnow = 0 ssnow % Tsoil = ssnow % tgg - 27 3.15 ssnow % thetai = 0.0 soil % zeta = 0.0 soil % fsatmax = 0.0 !   END IF IF ( cable_user % SOIL_STRUC == 'sli' ) THEN soil % nhorizons = 1 ! use 1 soil horizon globally veg % F10 = 0.85 veg % ZR = 5.0 END IF IF ( cable_user % SOIL_STRUC == 'sli' . OR . cable_user % FWSOIL_SWITCH == 'Haverd2013' ) THEN veg % gamma = 3.e-2 ENDIF !! vh_js !! IF ( cable_user % CALL_POP ) THEN veg % disturbance_interval = 100 veg % disturbance_intensity = 0. ENDIF soil % GWdz = MAX ( 1.0 , MIN ( 2 0.0 , soil % GWdz - SUM ( soil % zse , dim = 1 ))) !set vectorized versions as same as defaut for now soil % swilt_vec (:,:) = REAL ( SPREAD ( soil % swilt (:), 2 , ms ), r_2 ) soil % sfc_vec (:,:) = REAL ( SPREAD ( soil % sfc (:), 2 , ms ), r_2 ) soil % sucs_vec (:,:) = REAL ( SPREAD ( soil % sucs (:), 2 , ms ), r_2 ) soil % bch_vec (:,:) = REAL ( SPREAD ( soil % bch (:), 2 , ms ), r_2 ) soil % ssat_vec (:,:) = REAL ( SPREAD ( soil % ssat (:), 2 , ms ), r_2 ) soil % hyds_vec (:,:) = REAL ( SPREAD ( soil % hyds (:), 2 , ms ), r_2 ) END SUBROUTINE write_default_params !============================================================================= SUBROUTINE write_cnp_params ( veg , casaflux , casamet ) ! Input variables: !   landpt(mp)%type- via cable_IO_vars_module (%cstart,cend,ilon,ilat) !   patch(mp)%type - via cable_IO_vars_module (%frac) !   inSorder       - via cable_param_module !   inArea         - via cable_param_module !   inNdep         - via cable_param_module !   inNfix         - via cable_param_module !   inPdust        - via cable_param_module !   inPwea         - via cable_param_module USE casaparm , ONLY : cropland , croplnd2 IMPLICIT NONE TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet ! local variables INTEGER :: ee , hh DO ee = 1 , mland ! over all land grid points casamet % isorder ( landpt ( ee )% cstart : landpt ( ee )% cend ) = & inSorder ( landpt ( ee )% ilon , landpt ( ee )% ilat ) DO hh = landpt ( ee )% cstart , landpt ( ee )% cend ! each patch in current grid casamet % lon ( hh ) = patch ( hh )% longitude casamet % lat ( hh ) = patch ( hh )% latitude casamet % areacell ( hh ) = patch ( hh )% frac & * inArea ( landpt ( ee )% ilon , landpt ( ee )% ilat ) casaflux % Nmindep ( hh ) = patch ( hh )% frac & * inNdep ( landpt ( ee )% ilon , landpt ( ee )% ilat ) casaflux % Nminfix ( hh ) = patch ( hh )% frac & * inNfix ( landpt ( ee )% ilon , landpt ( ee )% ilat ) casaflux % Pdep ( hh ) = patch ( hh )% frac & * inPdust ( landpt ( ee )% ilon , landpt ( ee )% ilat ) casaflux % Pwea ( hh ) = patch ( hh )% frac & * inPwea ( landpt ( ee )% ilon , landpt ( ee )% ilat ) !! vh !! fluxes shouldn't be weighted by patch frac. !   IF (CABLE_USER%POPLUC) then casaflux % Nmindep ( hh ) = inNdep ( landpt ( ee )% ilon , landpt ( ee )% ilat ) casaflux % Nminfix ( hh ) = MAX ( inNfix ( landpt ( ee )% ilon , landpt ( ee )% ilat ), & 8.0e-4 ) !vh ! minimum fixation rate of 3 kg N ha-1y-1 (8e-4 g N m-2 d-1) ! Cleveland, Cory C., et al. \"Global patterns of terrestrial biological nitrogen (N2) & !fixation in natural ecosystems.\" Global biogeochemical cycles 13.2 (1999): 623-645. casaflux % Pdep ( hh ) = inPdust ( landpt ( ee )% ilon , landpt ( ee )% ilat ) casaflux % Pwea ( hh ) = inPwea ( landpt ( ee )% ilon , landpt ( ee )% ilat ) !  ENDIF ! fertilizer addition is included here IF ( veg % iveg ( hh ) == cropland . OR . veg % iveg ( hh ) == croplnd2 ) THEN ! P fertilizer =13 Mt P globally in 1994 casaflux % Pdep ( hh ) = casaflux % Pdep ( hh ) & + 0.7 / 36 5.0 casaflux % Nmindep ( hh ) = casaflux % Nmindep ( hh ) & + 4.0 / 36 5.0 ENDIF ENDDO ENDDO DEALLOCATE ( inSorder , inArea , inNdep , inNfix , inPwea , inPdust ) !write(668,*) 'in write_cnp_params: Ndep, Nfix', casaflux%Nmindep(1), casaflux%Nminfix(1) END SUBROUTINE write_cnp_params !============================================================================ SUBROUTINE derived_parameters ( soil , sum_flux , bal , ssnow , veg , rough ) ! Gives values to parameters that are derived from other parameters. TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil TYPE ( sum_flux_type ), INTENT ( INOUT ) :: sum_flux TYPE ( balances_type ), INTENT ( INOUT ) :: bal TYPE ( roughness_type ), INTENT ( INOUT ) :: rough INTEGER :: j , i , klev ! do loop counter REAL ( r_2 ) :: temp ( mp ) REAL :: tmp2 ( mp ) REAL ( r_2 ), DIMENSION ( mp , ms ) :: perc_frac REAL ( r_2 ), DIMENSION ( 17 ) :: psi_o , psi_c REAL ( r_2 ), DIMENSION ( mp , ms ) :: psi_tmp REAL ( r_2 ), DIMENSION ( ms ) :: soil_depth soil_depth ( 1 ) = REAL ( soil % zse ( 1 ), r_2 ) DO klev = 2 , ms soil_depth ( klev ) = soil_depth ( klev - 1 ) + REAL ( soil % zse ( klev ), r_2 ) END DO psi_o ( 1 : 3 ) = - 6600 0._r_2 psi_o ( 4 ) = - 3500 0._r_2 psi_o ( 5 ) = - 8300 0._r_2 psi_o ( 6 : 17 ) = - 7400 0._r_2 psi_c ( 1 : 3 ) = - 255000 0._r_2 psi_c ( 4 ) = - 224000 0._r_2 psi_c ( 5 ) = - 428000 0._r_2 psi_c ( 6 : 17 ) = - 275000 0._r_2 ! Construct derived parameters and zero initialisations, ! regardless of where parameters and other initialisations ! have loaded from: soil % zshh ( 1 ) = 0.5 * soil % zse ( 1 ) ! distance between consecutive layer ! midpoints: soil % zshh ( ms + 1 ) = 0.5 * soil % zse ( ms ) soil % zshh ( 2 : ms ) = 0.5 * ( soil % zse ( 1 : ms - 1 ) + soil % zse ( 2 : ms )) !MD aquifer node depth soil % GWz = 0.5 * soil % GWdz + SUM ( soil % zse ) !node is halfway through aquifer depth IF ( cable_user % GW_MODEL ) THEN DO klev = 1 , ms soil % hyds_vec (:, klev ) = 0.0070556 * 1 0.0 ** ( - 0.884 + 0.0153 * soil % Sand_Vec (:, klev ) * 10 0.0 ) * & EXP ( - gw_params % hkrz * ( MAX ( 0. , soil_depth ( klev ) - gw_params % zdepth ))) soil % sucs_vec (:, klev ) = 1 0.0 * 1 0.0 ** ( 1.88 - 0.0131 * soil % Sand_Vec (:, klev ) * 10 0.0 ) soil % bch_vec (:, klev ) = 2.91 + 0.159 * soil % Clay_Vec (:, klev ) * 10 0.0 soil % ssat_vec (:, klev ) = 0.489 - 0.00126 * soil % Sand_Vec (:, klev ) * 10 0.0 soil % watr (:, klev ) = 0.02 + 0.00018 * soil % Clay_Vec (:, klev ) * 10 0.0 ENDDO !aquifer share non-organic with last layer if not found in param file IF ( found_explicit_gw_parameters . EQV . . FALSE .) THEN soil % GWhyds_vec (:) = soil % hyds_vec (:, ms ) soil % GWsucs_vec (:) = soil % sucs_vec (:, ms ) soil % GWbch_vec (:) = soil % bch_vec (:, ms ) soil % GWssat_vec (:) = soil % ssat_vec (:, ms ) soil % GWwatr (:) = soil % watr (:, ms ) ENDIF !include organin impact.  fraction of grid cell where percolation through !organic macropores dominates soil % Org_Vec = MAX ( 0._r_2 , soil % Org_Vec ) soil % Org_Vec = MIN ( 1._r_2 , soil % Org_Vec ) DO klev = 1 , 3 !0-23.3 cm, data really is to 30cm soil % hyds_vec (:, klev ) = ( 1. - soil % Org_Vec (:, klev )) * soil % hyds_vec (:, klev ) + & soil % Org_Vec (:, klev ) * gw_params % org % hyds_vec_organic soil % sucs_vec (:, klev ) = ( 1. - soil % Org_Vec (:, klev )) * soil % sucs_vec (:, klev ) + & soil % Org_Vec (:, klev ) * gw_params % org % sucs_vec_organic soil % bch_vec (:, klev ) = ( 1. - soil % Org_Vec (:, klev )) * soil % bch_vec (:, klev ) + & soil % Org_Vec (:, klev ) * gw_params % org % clappb_organic soil % ssat_vec (:, klev ) = ( 1. - soil % Org_Vec (:, klev )) * soil % ssat_vec (:, klev ) + & soil % Org_Vec (:, klev ) * gw_params % org % ssat_vec_organic soil % watr (:, klev ) = ( 1. - soil % Org_Vec (:, klev )) * soil % watr (:, klev ) + & soil % Org_Vec (:, klev ) * gw_params % org % watr_organic END DO !!vegetation dependent field capacity (point plants get stressed) and !wilting point DO i = 1 , mp psi_tmp ( i ,:) = - psi_c ( veg % iveg ( i )) END DO soil % sfc_vec = ( soil % ssat_vec - soil % watr ) * ( ABS ( psi_tmp ) / ( ABS ( soil % sucs_vec ))) ** ( - 1.0 / soil % bch_vec ) + & soil % watr DO i = 1 , mp psi_tmp ( i ,:) = - psi_c ( veg % iveg ( i )) END DO soil % swilt_vec = ( soil % ssat_vec - soil % watr ) * ( ABS ( psi_tmp ) / ( ABS ( soil % sucs_vec ))) ** ( - 1.0 / soil % bch_vec ) + & soil % watr !set the non-vectored values to srf value soil % sfc (:) = REAL ( soil % sfc_vec (:, 1 )) soil % swilt (:) = REAL ( soil % swilt_vec (:, 1 )) !convert the units back to what default uses and GW only uses the !vectored versions soil % hyds = REAL ( soil % hyds_vec (:, 1 )) / 100 0.0 soil % sucs = REAL ( soil % sucs_vec (:, 1 )) / 100 0.0 soil % ssat = REAL ( soil % ssat_vec (:, 1 )) soil % bch = REAL ( soil % bch_vec (:, 1 )) DO i = 1 , mp soil % slope ( i ) = MIN ( 0.9 , MAX ( 1e-9 , soil % slope ( i ))) soil % slope_std ( i ) = MIN ( 0.9 , MAX ( 1e-9 , soil % slope_std ( i ))) END DO IF (( gw_params % MaxSatFraction . LT . - 999 9.9 ) . AND . ( mp . EQ . 1 )) soil % slope (:) = 0.01 ELSE soil % sfc_vec = REAL ( SPREAD ( soil % sfc (:), 2 , ms ), r_2 ) soil % swilt_vec = REAL ( SPREAD ( soil % swilt (:), 2 , ms ), r_2 ) !These are not used when gw_model == false soil % watr = 0._r_2 soil % GWwatr = 0._r_2 END IF IF ( . NOT . soilparmnew ) THEN ! Q,Zhang @ 12/20/2010 soil % cnsd = soil % sand * 0.3 + soil % clay * 0.25 & + soil % silt * 0.265 ! set dry soil thermal conductivity ! [W/m/K] END IF soil % hsbh = soil % hyds * ABS ( soil % sucs ) * soil % bch ! difsat*etasat soil % ibp2 = NINT ( soil % bch ) + 2 ! Ticket #66 WHERE ( soil % ssat > 0. ) & ! Avoid divide by soil % pwb_min = ( soil % swilt / soil % ssat ) ** soil % ibp2 soil % i2bp3 = 2 * NINT ( soil % bch ) + 3 rough % hruff = MAX ( 0.01 , veg % hc - 1.2 * ssnow % snowd / MAX ( ssnow % ssdnn , 10 0. )) rough % hruff_grmx = rough % hruff ! owetfac introduced by EAK apr2009 ssnow % owetfac = MAX ( 0.0 , MIN ( 1.0 , & ( REAL ( ssnow % wb (:, 1 )) - soil % swilt ) / & ( soil % sfc - soil % swilt ))) temp (:) = 0.0 tmp2 (:) = 0.0 WHERE ( ssnow % wbice (:, 1 ) > 0. ) ! Prevents divide by zero at glaciated ! points where wb and wbice=0. temp (:) = ssnow % wbice (:, 1 ) / ssnow % wb (:, 1 ) tmp2 (:) = REAL ( temp (:)) ssnow % owetfac = ssnow % owetfac * ( 1.0 - tmp2 (:)) ** 2 END WHERE ssnow % pudsto = 0.0 ssnow % pudsmx = 0.0 ! Initialise sum flux variables: sum_flux % sumpn = 0.0 sum_flux % sumrp = 0.0 sum_flux % sumrpw = 0.0 sum_flux % sumrpr = 0.0 sum_flux % sumrs = 0.0 sum_flux % sumrd = 0.0 sum_flux % dsumpn = 0.0 sum_flux % dsumrp = 0.0 sum_flux % dsumrd = 0.0 ! Initialise conservation variables: bal % precip_tot = 0.0 bal % rnoff_tot = 0.0 bal % evap_tot = 0.0 bal % wbal_tot = 0.0 bal % ebal_tot = 0.0 bal % ebal_tot_cncheck = 0.0 bal % drybal = 0.0 bal % wetbal = 0.0 bal % wbtot0 = 0.0 bal % RadbalSum = 0.0 DO j = 1 , ms bal % wbtot0 = bal % wbtot0 + REAL ( ssnow % wb (:, j )) * soil % zse ( j ) & * 100 0.0 END DO bal % osnowd0 = ssnow % osnowd !! vh_js !! comment out hide% condition ! IF (hide%Ticket49Bug6) THEN IF ( cable_user % SOIL_STRUC == 'sli' ) THEN ! Only 1 horizon by default ! soil % nhorizons = 1 soil % ishorizon = 1 END IF ! END IF END SUBROUTINE derived_parameters !============================================================================ SUBROUTINE check_parameter_values ( soil , veg , ssnow ) ! Checks for basic inconsistencies in parameter values ! INH - changed soil & veg to INOUT. TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameter data TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameter ! data TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow ! soil and snow ! variables INTEGER :: i , j ! do loop counter DO i = 1 , mland ! Check all veg types make sense: IF ( ANY ( veg % iveg ( landpt ( i )% cstart :( landpt ( i )% cstart + landpt ( i )% nap & - 1 )) < 1 ) . OR . ANY ( veg % iveg ( landpt ( i )% cstart :( landpt ( i )% cstart + & landpt ( i )% nap - 1 )) > mvtype )) THEN WRITE ( * , * ) 'SUBROUTINE load_parameters:' WRITE ( * , * ) 'Land point number:' , i WRITE ( * , * ) 'Veg types:' , veg % iveg ( landpt ( i )% cstart : & ( landpt ( i )% cstart + landpt ( i )% nap - 1 )) CALL abort ( 'Unknown vegetation type! Aborting.' ) END IF ! Check all soil types make sense: IF ( ANY ( soil % isoilm ( landpt ( i )% cstart :( landpt ( i )% cstart + landpt ( i )% nap & - 1 )) < 1 ) . OR . ANY ( soil % isoilm ( landpt ( i )% cstart :( landpt ( i )% cstart & + landpt ( i )% nap - 1 )) > mstype )) THEN WRITE ( * , * ) 'SUBROUTINE load_parameters:' WRITE ( * , * ) 'Land point number:' , i CALL abort ( 'Unknown soil type! Aborting.' ) END IF ! Check patch fractions sum to 1 in each grid cell: IF (( SUM ( patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) - 1.0 ) & > 1.0E-6 ) THEN WRITE ( * , * ) 'SUBROUTINE load_parameters:' WRITE ( * , * ) 'At land point number' , i WRITE ( * , * ) 'And patch numbers:  ' , landpt ( i )% cstart , landpt ( i )% cend WRITE ( * , * ) 'patchfrac values are: ' , & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac WRITE ( * , * ) 'veg types are:        ' , & veg % iveg ( landpt ( i )% cstart : landpt ( i )% cend ) WRITE ( * , * ) 'patch longitudes are: ' , & patch ( landpt ( i )% cstart : landpt ( i )% cend )% longitude WRITE ( * , * ) 'patch latitudes are:  ' , & patch ( landpt ( i )% cstart : landpt ( i )% cend )% latitude CALL abort ( 'Sum of fractional coverage of vegetation patches /= 1!' ) END IF !      ! Check sum of surface type fractions is 1: !      IF(landpt(i)%veg%frac + landpt(i)%urban%frac +                   & !         landpt(i)%lake%frac + landpt(i)%ice%frac /= 1) THEN !        WRITE(*,*) 'SUBROUTINE load_parameters:' !        WRITE(*,*) 'At land point number', i !        CALL abort ('Sum of fractional coverage of surface types /= 1!') !      END IF END DO ! Check sand+soil+clay fractions sum to 1: DO i = 1 , mland DO j = 1 , landpt ( i )% nap ! vh changed limits from 1.0000001, 0.999999 to 1.01 and 0.99 for compatibility with gridinfo IF (( soil % sand ( landpt ( i )% cstart + j - 1 ) & + soil % silt ( landpt ( i )% cstart + j - 1 ) & + soil % clay ( landpt ( i )% cstart + j - 1 )) > 1.01 . OR . & ( soil % sand ( landpt ( i )% cstart + j - 1 ) & + soil % silt ( landpt ( i )% cstart + j - 1 ) & + soil % clay ( landpt ( i )% cstart + j - 1 )) < 0.99 ) THEN WRITE ( * , * ) 'SUBROUTINE load_parameters:' WRITE ( * , * ) 'At land point number:' , i WRITE ( * , * ) '        patch number:' , j WRITE ( * , * ) 'Clay fraction is ' , soil % clay ( landpt ( i )% cstart + j - 1 ) WRITE ( * , * ) 'Sand fraction is ' , soil % sand ( landpt ( i )% cstart + j - 1 ) WRITE ( * , * ) 'Silt fraction is ' , soil % silt ( landpt ( i )% cstart + j - 1 ) WRITE ( * , * ) 'SUM:' , soil % sand ( landpt ( i )% cstart + j - 1 ) & + soil % silt ( landpt ( i )% cstart + j - 1 ) & + soil % clay ( landpt ( i )% cstart + j - 1 ) !mrd561 error where fraction was slightly off summing to 1.  Fix rather than abort. soil % silt ( landpt ( i )% cstart + j - 1 ) = 1.0 - & soil % clay ( landpt ( i )% cstart + j - 1 ) - & soil % sand ( landpt ( i )% cstart + j - 1 ) END IF END DO END DO ! Check that fraction of roots in each layer sum to 1: DO i = 1 , mland DO j = 1 , landpt ( i )% nap IF ( ABS ( 1 - SUM ( veg % froot (( landpt ( i )% cstart + j - 1 ), :))) & > 0.00001 ) THEN WRITE ( * , * ) 'SUBROUTINE load_parameters:' WRITE ( * , * ) 'At land point number:' , i , 'patch:' , j WRITE ( * , * ) 'Froot:' , veg % froot (( landpt ( i )% cstart + j - 1 ), :) veg % froot (( landpt ( i )% cstart + j - 1 ), ms ) = veg % froot (( landpt ( i )% cstart + j - 1 ), ms ) + & ( 1. - SUM ( veg % froot (( landpt ( i )% cstart + j - 1 ), :))) END IF END DO END DO ! Check that wilting pt < field capacity < saturation value: IF ( ANY ( soil % swilt > soil % sfc ) . OR . ANY ( soil % sfc > soil % ssat )) THEN DO i = 1 , mland DO j = 1 , landpt ( i )% nap IF ( soil % swilt ( landpt ( i )% cstart + j - 1 ) > & soil % sfc ( landpt ( i )% cstart + j - 1 ) & . OR . soil % sfc ( landpt ( i )% cstart + j - 1 ) > & soil % ssat ( landpt ( i )% cstart + j - 1 )) THEN WRITE ( * , * ) 'SUBROUTINE load_parameters:' WRITE ( * , * ) 'At land point number' , i , 'patch:' , j CALL abort ( 'Wilting pt < field capacity < saturation ' // & 'violated!' ) END IF END DO END DO END IF ! Ensure soil moisture values are reasonable (possible restart precision ! issue): !actually if denliq .ne. denice than ssnow%wb > ssat_vec is possible due to !the expansion during freezing !mrd561 Left using a real to set wb since that is what trunk does WHERE ( ssnow % wb > REAL ( soil % ssat_vec )) ! Can only happen due to i/o issues ssnow % wb = 0.9999 * REAL ( soil % ssat_vec ) END WHERE END SUBROUTINE check_parameter_values !=============================================================================== SUBROUTINE report_parameters ( logn , soil , veg , bgc , rough , & ssnow , canopy , casamet , casapool , casaflux , & phen , vegparmnew , verbose ) USE cable_pft_params_mod , ONLY : veg_desc USE cable_soil_params_mod , ONLY : soil_desc IMPLICIT NONE INTEGER , INTENT ( IN ) :: logn ! log file unit number LOGICAL , INTENT ( IN ) :: vegparmnew ! are we using the new format? LOGICAL , INTENT ( IN ) :: verbose ! write all parameter details to ! log file? TYPE ( soil_parameter_type ), INTENT ( IN ) :: soil TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg TYPE ( bgc_pool_type ), INTENT ( IN ) :: bgc TYPE ( roughness_type ), INTENT ( IN ) :: rough TYPE ( soil_snow_type ), INTENT ( IN ) :: ssnow TYPE ( canopy_type ), INTENT ( IN ) :: canopy TYPE ( casa_met ) , INTENT ( IN ) :: casamet TYPE ( casa_pool ) , INTENT ( IN ) :: casapool TYPE ( casa_flux ) , INTENT ( IN ) :: casaflux TYPE ( phen_variable ), INTENT ( IN ) :: phen INTEGER :: e , f , g ! do loop counter CHARACTER ( LEN = 16 ) :: patchfmtr ! patch format specifier for real numbers CHARACTER ( LEN = 14 ) :: patchfmti ! patch format specifier for integer ! numbers CHARACTER ( LEN = 16 ) :: patchfmte ! patch format specifier for expon. numbers CHARACTER ( LEN = 16 ) :: patchfmte2 ! patch format specifier for expon. numbers ! Get vegetation/soil type descriptions in case they haven't yet been ! loaded (i.e. if restart file + met file contains all parameter/init/LAI ! info). This will not overwrite any parameter values. ! CALL get_type_parameters(filename_veg, filename_soil, logn, vegparmnew) CALL cable_pft_params () CALL cable_soil_params () ! Only report parameters for active vegetation patches: DO e = 1 , mland WRITE ( logn , * ) '===================================================' // & '======' WRITE ( logn , '(A36, I8, 1X, A1)' ) ' CABLE setup details for land' // & ' point ' , e , ':' WRITE ( logn , * ) '===================================================' // & '======' !      WRITE(logn,'(A21)') ' Surface type ratios:' !      WRITE(logn,*) '---------------------------------------------'//  & !                    '------------' !      ! Write surface type ratios to log file: !      WRITE(logn,'(A30,I3,A1)') '                   vegetated: ',& !           INT(landpt(e)%veg%frac*100.0),'%' !      WRITE(logn,'(A30,I3,A1)') '                       urban: ',& !           INT(landpt(e)%urban%frac*100.0),'%' !      WRITE(logn,'(A30,I3,A1)') '                       lakes: ',& !           INT(landpt(e)%lake%frac*100.0),'%' !      WRITE(logn,'(A30,I3,A1)') '                    land ice: ',& !           INT(landpt(e)%ice%frac*100.0),'%' !      ! Report patch details to log file: !      WRITE(logn,*) '---------------------------------------------'//  & !                    '------------' WRITE ( logn , '(A43)' ) ' Proportions of each active veg/soil patch:' WRITE ( logn , * ) '---------------------------------------------------' // & '------' DO g = 1 , landpt ( e )% nap WRITE ( logn , '(A7, I2, A3, F6.2, A11, I3, 1X, A30)' ) ' patch ' , & g , ':  ' , patch ( landpt ( e )% cstart + g - 1 )% frac * 10 0.0 , & '% veg type ' , veg % iveg ( landpt ( e )% cstart + g - 1 ), & TRIM ( veg_desc ( veg % iveg ( landpt ( e )% cstart + g - 1 ))) WRITE ( logn , '(18X, A11, I3, 1X, A45)' ) '  soil type' , & soil % isoilm ( landpt ( e )% cstart + g - 1 ), & TRIM ( soil_desc ( soil % isoilm ( landpt ( e )% cstart + g - 1 ))) END DO IF ( verbose ) THEN ! Set up format specifier for writing active patch details below: WRITE ( patchfmtr , '(A8, I2, A6)' ) '(4X,A50,' , landpt ( e )% nap , 'F12.4)' WRITE ( patchfmti , '(A8, I2, A4)' ) '(4X,A50,' , landpt ( e )% nap , 'I12)' WRITE ( patchfmte , '(A8, I2, A6)' ) '(4X,A50,' , landpt ( e )% nap , 'E12.4)' WRITE ( patchfmte2 , '(A8, I2, A6)' ) '(4X,A50,' , landpt ( e )% nap , 'E12.4)' ! Write parameter set details to log file: WRITE ( logn , * ) '------------------------------------------------' // & '---------' WRITE ( logn , '(A36, I8, 1X, A2)' ) ' CABLE parameter values (land ' // & 'point ' , e , '):' WRITE ( logn , * ) '------------------------------------------------' // & '---------' WRITE ( logn , '(4X, A50, 2F10.4)' ) 'reference height (m): ' , & ! AJA MODIFIED ! rough%za(e*max_vegpatches) rough % za_uv ( landpt ( e )% cend - landpt ( e )% cstart + 1 ), & rough % za_tq ( landpt ( e )% cend - landpt ( e )% cstart + 1 ) WRITE ( logn , * ) ' Vegetation parameters: ' WRITE ( logn , patchfmti ) 'Veg type for each active (>0% gridcell) ' // & 'patch: ' , veg % iveg ( landpt ( e )% cstart : landpt ( e )% cend ) WRITE ( logn , patchfmtr ) 'Vegetation height (m): ' , & veg % hc ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Fraction of roots in layer 1 (-): ' , & veg % froot ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Fraction of roots in layer 2 (-): ' , & veg % froot ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 2 ) WRITE ( logn , patchfmtr ) 'Fraction of roots in layer 3 (-): ' , & veg % froot ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 3 ) WRITE ( logn , patchfmtr ) 'Fraction of roots in layer 4 (-): ' , & veg % froot ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 4 ) WRITE ( logn , patchfmtr ) 'Fraction of roots in layer 5 (-): ' , & veg % froot ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 5 ) WRITE ( logn , patchfmtr ) 'Fraction of roots in layer 6 (-): ' , & veg % froot ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 6 ) WRITE ( logn , patchfmtr ) 'Fraction of plants which are C4 (-): ' , & veg % frac4 ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Maximum canopy water storage (mm/LAI): ' , & veg % canst1 ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmte ) & 'Max pot elec transport rate top leaf (mol/m2/s): ' , & veg % ejmax ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmte ) & 'Max RuBP carboxylation rate top leaf (mol/m&#94;2/s): ' , & veg % vcmax ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Plant respiration coeff @ 20 C ' // & '(mol/m&#94;2/s): ' , veg % rp20 ( landpt ( e )% cstart :( landpt ( e )% cstart & + landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) & 'Temperature coef nonleaf plant respiration (1/C): ' , & veg % rpcoef ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Sheltering factor (-): ' , & veg % shelrb ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Chararacteristic legnth of leaf (m): ' , & veg % dleaf ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Leaf angle parameter (-): ' , & veg % xfang ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) & 'Min temperature for start of photosynthesis (C): ' , & veg % tminvj ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) & 'Max temperature for start of photosynthesis (C): ' , & veg % tmaxvj ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Stomatal sensitivity to soil water: ' , & veg % vbeta ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Modifier for surface albedo in near IR ' // & 'band: ' , veg % xalbnir ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'a1 parameter in leaf stomatal model  ' , & veg % a1gs ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'd0 parameter in leaf stomatal model  ' , & veg % d0gs ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) IF ( icycle == 0 ) THEN WRITE ( logn , '(4X, A50, F12.4)' ) & 'Plant carbon rate constant pool 1 (1/year): ' , bgc % ratecp ( 1 ) WRITE ( logn , '(4X, A50, F12.4)' ) & 'Plant carbon rate constant pool 2 (1/year): ' , bgc % ratecp ( 2 ) WRITE ( logn , '(4X, A50, F12.4)' ) & 'Plant carbon rate constant pool 3 (1/year): ' , bgc % ratecp ( 3 ) ENDIF WRITE ( logn , * ) '------------------------------------------------' // & '---------' WRITE ( logn , * ) ' Soil parameters: ' WRITE ( logn , patchfmti ) 'Soil type for each active (>0%) ' // & 'patch: ' , soil % isoilm ( landpt ( e )% cstart : landpt ( e )% cend ) WRITE ( logn , patchfmtr ) 'Fraction of soil which is sand (-): ' , & soil % sand ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Fraction of soil which is silt (-): ' , & soil % silt ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Fraction of soil which is clay (-): ' , & soil % clay ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) & 'Volumetric soil moisture at saturation (m&#94;3/m&#94;3): ' , & soil % ssat ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) & 'Vol. soil moisture at field capacity (m&#94;3/m&#94;3): ' , & soil % sfc ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Vol. soil moisture at wilting point ' // & '(m&#94;3/m&#94;3): ' , soil % swilt ( landpt ( e )% cstart :( landpt ( e )% cstart & + landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Soil respiration coeff @ 20C (mol/m&#94;2/s): ' , & veg % rs20 ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap - 1 )) !              soil%rs20(landpt(e)%cstart:(landpt(e)%cstart+landpt(e)%nap-1)) WRITE ( logn , patchfmtr ) 'Suction at saturation (m): ' , & soil % sucs ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Soil density (kg/m&#94;3): ' , & soil % rhosoil ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Soil specific heat capacity (kJ/kg/K): ' , & soil % css ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmtr ) 'Parameter b in Campbell equation: ' , & soil % bch ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 )) WRITE ( logn , patchfmte2 ) 'Hydraulic conductivity @ saturation ' // & '(m/s): ' , soil % hyds ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) IF ( icycle == 0 ) THEN WRITE ( logn , '(4X, A50, F12.4)' ) & 'Soil carbon rate constant pool 1 (1/year): ' , bgc % ratecs ( 1 ) WRITE ( logn , '(4X, A50, F12.4)' ) & 'Soil carbon rate constant pool 2 (1/year): ' , bgc % ratecs ( 2 ) ENDIF WRITE ( logn , patchfmtr ) 'Bare soil albedo, vis (-): ' , & soil % albsoil ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Bare soil albedo, nir (-): ' , & soil % albsoil ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , * ) '------------------------------------------------' // & '---------' WRITE ( logn , '(A35, I8, 1X, A2)' ) ' CABLE initialisations (land ' // & 'point ' , e , '):' WRITE ( logn , * ) '------------------------------------------------' // & '---------' WRITE ( logn , * ) ' Soil-specific initialisations, per patch: -----' // & '---------' WRITE ( logn , patchfmtr ) 'Soil moisture, layer 1: ' , & ssnow % wb ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Soil moisture, layer 2: ' , & ssnow % wb ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 2 ) WRITE ( logn , patchfmtr ) 'Soil moisture, layer 3: ' , & ssnow % wb ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 3 ) WRITE ( logn , patchfmtr ) 'Soil moisture, layer 4: ' , & ssnow % wb ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 4 ) WRITE ( logn , patchfmtr ) 'Soil moisture, layer 5: ' , & ssnow % wb ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 5 ) WRITE ( logn , patchfmtr ) 'Soil moisture, layer 6: ' , & ssnow % wb ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 6 ) DO f = landpt ( e )% cstart , ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) IF ( ANY ( ssnow % wb ( f , :) < soil % swilt ( f ))) & WRITE ( logn , '(3X, A6, I2, A47)' ) & 'PATCH ' , f - landpt ( e )% cstart + 1 , & ' SOIL MOISTURE INITIALISED BELOW WILTING POINT!' IF ( ANY ( ssnow % wb ( f ,:) > soil % ssat ( f ))) & WRITE ( logn , '(3X, A6, I2, A50)' ) & 'PATCH ' , f - landpt ( e )% cstart + 1 , & ' SOIL MOISTURE INITIALISED ABOVE SATURATION VALUE!' END DO WRITE ( logn , patchfmtr ) 'Soil temperature, layer 1: ' , & ssnow % tgg ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Soil temperature, layer 2: ' , & ssnow % tgg ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 2 ) WRITE ( logn , patchfmtr ) 'Soil temperature, layer 3: ' , & ssnow % tgg ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 3 ) WRITE ( logn , patchfmtr ) 'Soil temperature, layer 4: ' , & ssnow % tgg ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 4 ) WRITE ( logn , patchfmtr ) 'Soil temperature, layer 5: ' , & ssnow % tgg ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 5 ) WRITE ( logn , patchfmtr ) 'Soil temperature, layer 6: ' , & ssnow % tgg ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 6 ) IF ( icycle == 0 ) THEN WRITE ( logn , patchfmtr ) 'Soil carbon pool size (g C/m2), pool 1: ' ,& bgc % csoil ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Soil carbon pool size (g C/m2), pool 2: ' ,& bgc % csoil ( landpt ( e )% cstart :( landpt ( e )% cstart + landpt ( e )% nap & - 1 ), 2 ) ENDIF WRITE ( logn , patchfmtr ) 'Volumetric soil ice, layer 1: ' , & ssnow % wbice ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Volumetric soil ice, layer 2: ' , & ssnow % wbice ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) 'Volumetric soil ice, layer 3: ' , & ssnow % wbice ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) 'Volumetric soil ice, layer 4: ' , & ssnow % wbice ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 4 ) WRITE ( logn , patchfmtr ) 'Volumetric soil ice, layer 5: ' , & ssnow % wbice ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 5 ) WRITE ( logn , patchfmtr ) 'Volumetric soil ice, layer 6: ' , & ssnow % wbice ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 6 ) WRITE ( logn , patchfmtr ) 'Turbulent resistance for soil: ' , & ssnow % rtsoil ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , * ) ' Snow-specific initialisations, per patch: ' // & '--------------' WRITE ( logn , patchfmtr ) 'Snow liquid water equivalent depth (mm): ' , & ssnow % snowd ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) & 'Snow liq. water equiv. depth previous tstep (mm): ' , & ssnow % osnowd ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Overall snow density (kg/m&#94;3): ' , & ssnow % ssdnn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Snow age (-): ' , & ssnow % snage ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Snow temperature (K), layer 1: ' , & ssnow % tggsn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Snow temperature (K), layer 2: ' , & ssnow % tggsn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) 'Snow temperature (K), layer 3: ' , & ssnow % tggsn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) 'Snow density (kg/m&#94;3), layer 1: ' , & ssnow % ssdn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Snow density (kg/m&#94;3), layer 2: ' , & ssnow % ssdn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) 'Snow density (kg/m&#94;3), layer 3: ' , & ssnow % ssdn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) 'Snow mass (kg/m&#94;2), layer 1: ' , & ssnow % smass ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Snow mass (kg/m&#94;2), layer 2: ' , & ssnow % smass ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) 'Snow mass (kg/m&#94;2), layer 3: ' , & ssnow % smass ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmti ) 'Snow layer scheme flag: ' , & ssnow % isflag ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , * ) ' Vegetation-specific initialisations, per patch:' // & ' --------' WRITE ( logn , patchfmtr ) 'Canopy surface water storage (mm): ' , & canopy % cansto ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , * ) '                 default monthly Leaf area index: ' DO f = 1 , 12 WRITE ( logn , patchfmtr ) ' ' , defaultLAI ( e , f ) ENDDO IF ( exists % LAI ) THEN WRITE ( logn , * ) 'Check LAI in output for values provided in met file.' ELSE WRITE ( logn , * ) 'These default values are used as no LAI in met file.' ENDIF IF ( icycle == 0 ) THEN WRITE ( logn , patchfmtr ) & 'Plant carbon pool size (g C/m2), pool 1: ' , & bgc % cplant ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) & 'Plant carbon pool size (g C/m2), pool 2: ' , & bgc % cplant ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 2 ) ENDIF WRITE ( logn , * ) ' Other initialisations, per patch: ' // & '----------------------' WRITE ( logn , patchfmtr ) 'Soil+snow albedo (-), visible: ' , & ssnow % albsoilsn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) 'Soil+snow albedo (-), near infrared: ' , & ssnow % albsoilsn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) 'Soil+snow albedo (-), thermal: ' , & ssnow % albsoilsn ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) 'Runoff total (mm/time step): ' , & ssnow % runoff ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Surface runoff (mm/time step): ' , & ssnow % rnof1 ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , patchfmtr ) 'Deep drainage runoff (mm/time step): ' , & ssnow % rnof2 ( landpt ( e )% cstart :( landpt ( e )% cstart + & landpt ( e )% nap - 1 )) WRITE ( logn , * ) '================================================' // & '=========' WRITE ( logn , * ) '================================================' // & '=========' WRITE ( logn , * ) !jhan:reviewformatting.spacing of whole module IF ( icycle >= 1 ) THEN WRITE ( logn , * ) 'CASA-CNP initialisations, per patch:' WRITE ( logn , patchfmti ) & '  veg class (0=noveg,1=grassy,2=shrub,3=woody): ' , & casamet % iveg2 ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmti ) & '                                    soil order: ' , & casamet % isorder ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & ' patch area (10&#94;9 m&#94;2): ' , & casamet % areacell ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) * 1.0e-9 WRITE ( logn , patchfmtr ) & '          Nitrogen deposition   (g N/m&#94;2/year): ' , & casaflux % Nmindep ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & '          Nitrogen fixation     (g N/m&#94;2/year): ' , & casaflux % Nminfix ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & '          Phosphorus weathering (g P/m&#94;2/year): ' , & casaflux % Pwea ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & '          Phosphorus in dust    (g P/m&#94;2/year): ' , & casaflux % Pdep ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & '  Leaf area index in CASA-CNP: ' , & casamet % glai ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmti ) & '  Phenological phase: ' , & phen % phase ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & '  Carbon pools (g C/m&#94;2)       - labile: ' , & casapool % clabile ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & '               - plant - Leaf: ' , & casapool % cplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) & '               - plant - Wood: ' , & casapool % cplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) & '               - plant - Root: ' , & casapool % cplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) & '               - litter - MTB: ' , & casapool % clitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) & '               - litter - STR: ' , & casapool % clitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) & '               - litter - CWD: ' , & casapool % clitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) & '               - soil - micro: ' , & casapool % csoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) & '               - soil -  slow: ' , & casapool % csoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) & '               - soil - passv: ' , & casapool % csoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) ENDIF IF ( icycle >= 2 ) THEN WRITE ( logn , patchfmtr ) '  Nitrogen pools (g N/m&#94;2) - plant - Leaf: ' ,& casapool % nplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) '               - plant - Wood: ' , & casapool % nplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) '               - plant - Root: ' , & casapool % nplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) '               - litter - MTB: ' , & casapool % nlitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) '               - litter - STR: ' , & casapool % nlitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) '               - litter - CWD: ' , & casapool % nlitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) '               - soil - micro: ' , & casapool % nsoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) '               - soil -  slow: ' , & casapool % nsoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) '               - soil - passv: ' , & casapool % nsoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) '  Mineral nitrogen (inorganic): ' , & casapool % nsoilmin ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) ENDIF IF ( icycle == 3 ) THEN WRITE ( logn , patchfmtr ) & '  Phosphorus pools (g P/m&#94;2) - plant - Leaf: ' , & casapool % pplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) & '                   - plant - Wood: ' , & casapool % pplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) & '                   - plant - Root: ' , & casapool % pplant ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) & '                   - litter - MTB: ' , & casapool % plitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) & '                   - litter - STR: ' , & casapool % plitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) & '                   - litter - CWD: ' , & casapool % plitter ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) & '                   - soil - micro: ' , & casapool % psoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 1 ) WRITE ( logn , patchfmtr ) & '                   - soil -  slow: ' , & casapool % psoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 2 ) WRITE ( logn , patchfmtr ) & '                   - soil - passv: ' , & casapool % psoil ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ), 3 ) WRITE ( logn , patchfmtr ) & '  Mineral phosphorus -  Labile: ' , & casapool % psoillab ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & '  - Adsorbed: ' , & casapool % psoilsorb ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) WRITE ( logn , patchfmtr ) & '  - Occluded: ' , & casapool % psoilocc ( landpt ( e )% cstart : & ( landpt ( e )% cstart + landpt ( e )% nap - 1 ) ) ENDIF WRITE ( logn , * ) '=========================================================' WRITE ( logn , * ) '=========================================================' WRITE ( logn , * ) END IF ! if verbose END DO END SUBROUTINE report_parameters SUBROUTINE init_veg_from_vegin ( ifmp , fmp , veg , soil_zse ) USE cable_def_types_mod , ONLY : veg_parameter_type , ms INTEGER :: ifmp , & ! start local mp, # landpoints (jhan:when is this not 1 ) fmp ! local mp, # landpoints REAL , DIMENSION ( ms ) :: soil_zse TYPE ( veg_parameter_type ) :: veg INTEGER :: is REAL :: totdepth INTEGER :: h ! Prescribe parameters for current gridcell based on veg/soil type (which ! may have loaded from default value file or met file): DO h = ifmp , fmp ! over each patch in current grid veg % frac4 ( h ) = vegin % frac4 ( veg % iveg ( h )) veg % taul ( h , 1 ) = vegin % taul1 ( veg % iveg ( h )) veg % taul ( h , 2 ) = vegin % taul2 ( veg % iveg ( h )) veg % refl ( h , 1 ) = vegin % refl1 ( veg % iveg ( h )) veg % refl ( h , 2 ) = vegin % refl2 ( veg % iveg ( h )) veg % canst1 ( h ) = vegin % canst1 ( veg % iveg ( h )) veg % dleaf ( h ) = vegin % dleaf ( veg % iveg ( h )) veg % vcmax ( h ) = vegin % vcmax ( veg % iveg ( h )) veg % ejmax ( h ) = vegin % ejmax ( veg % iveg ( h )) veg % hc ( h ) = vegin % hc ( veg % iveg ( h )) veg % xfang ( h ) = vegin % xfang ( veg % iveg ( h )) veg % vbeta ( h ) = vegin % vbeta ( veg % iveg ( h )) veg % xalbnir ( h ) = vegin % xalbnir ( veg % iveg ( h )) veg % rp20 ( h ) = vegin % rp20 ( veg % iveg ( h )) veg % rpcoef ( h ) = vegin % rpcoef ( veg % iveg ( h )) veg % rs20 ( h ) = vegin % rs20 ( veg % iveg ( h )) veg % shelrb ( h ) = vegin % shelrb ( veg % iveg ( h )) veg % wai ( h ) = vegin % wai ( veg % iveg ( h )) veg % a1gs ( h ) = vegin % a1gs ( veg % iveg ( h )) veg % d0gs ( h ) = vegin % d0gs ( veg % iveg ( h )) veg % vegcf ( h ) = vegin % vegcf ( veg % iveg ( h )) veg % extkn ( h ) = vegin % extkn ( veg % iveg ( h )) veg % tminvj ( h ) = vegin % tminvj ( veg % iveg ( h )) veg % tmaxvj ( h ) = vegin % tmaxvj ( veg % iveg ( h )) veg % g0 ( h ) = vegin % g0 ( veg % iveg ( h )) ! Ticket #56 veg % g1 ( h ) = vegin % g1 ( veg % iveg ( h )) ! Ticket #56 veg % a1gs ( h ) = vegin % a1gs ( veg % iveg ( h )) veg % d0gs ( h ) = vegin % d0gs ( veg % iveg ( h )) veg % alpha ( h ) = vegin % alpha ( veg % iveg ( h )) veg % convex ( h ) = vegin % convex ( veg % iveg ( h )) veg % cfrd ( h ) = vegin % cfrd ( veg % iveg ( h )) veg % gswmin ( h ) = vegin % gswmin ( veg % iveg ( h )) veg % conkc0 ( h ) = vegin % conkc0 ( veg % iveg ( h )) veg % conko0 ( h ) = vegin % conko0 ( veg % iveg ( h )) veg % ekc ( h ) = vegin % ekc ( veg % iveg ( h )) veg % eko ( h ) = vegin % eko ( veg % iveg ( h )) veg % rootbeta ( h ) = vegin % rootbeta ( veg % iveg ( h )) veg % zr ( h ) = vegin % zr ( veg % iveg ( h )) veg % clitt ( h ) = vegin % clitt ( veg % iveg ( h )) END DO ! over each veg patch in land point ! calculate vegin%froot from using rootbeta and soil depth ! (Jackson et al. 1996, Oceologica, 108:389-411) totdepth = 0.0 DO is = 1 , ms - 1 totdepth = totdepth + soil_zse ( is ) * 10 0.0 ! unit in centimetres veg % froot (:, is ) = MIN ( 1.0 , 1.0 - veg % rootbeta (:) ** totdepth ) END DO veg % froot (:, ms ) = 1.0 - veg % froot (:, ms - 1 ) DO is = ms - 1 , 2 , - 1 veg % froot (:, is ) = veg % froot (:, is ) - veg % froot (:, is - 1 ) END DO END SUBROUTINE init_veg_from_vegin END MODULE cable_param_module","tags":"","loc":"sourcefile/cable_parameters.f90.html"},{"title":"cable_driver.F90 – CABLE","text":"subroutine for reading LU input data, zeroing biomass in empty secondary forest tiles\n and tranferring LUC-based age weights for secondary forest to POP structure Contents Programs cable_offline_driver Subroutines prepareFiles renameFiles LUCdriver Source Code cable_driver.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Offline driver for CABLE ! Contact: Bernard.Pak@csiro.au ! ! History: Since 1.4b, capability to run global offline (ncciy = YEAR), !\t   inclusion of call to CASA-CNP (icycle>0) !\t   exclusion of call to cbm (icycle>10) !\t   soil_snow_type now ssnow (instead of ssoil) ! ! ! ========================================untitled====================================== ! Uses:\t\t  cable_def_types_mod !\t\t  cable_IO_vars_module !\t\t  cable_common_module !\t\t  cable_input_module !\t\t  cable_output_module !\t\t  cable_cbm_module !\t\t  casadimension !\t\t  casavariable ! ! CALLs:       open_met_file !\t       load_parameters !\t       open_output_file !\t       get_met_data !\t       casa_feedback !\t       cbm !\t       bgcdriver !\t       sumcflux !\t       write_output !\t       casa_poolout !\t       casa_fluxout !\t       create_restart !\t       close_met_file !\t       close_output_file !\t       prepareFiles ! ! ! input\t file: [SiteName].nc !\t       poolcnpIn[SiteName].csv -- for CASA-CNP only !\t       gridinfo_CSIRO_1x1.nc !\t       def_veg_params.txt !\t       def_soil_params.txt -- nearly redundant, can be switched on !\t       restart_in.nc -- not strictly required ! ! output file: log_cable.txt !\t       out_cable.nc !\t       restart_out.nc !\t       poolcnpOut.csv -- from CASA-CNP !============================================================================== PROGRAM cable_offline_driver USE cable_def_types_mod USE cable_IO_vars_module , ONLY : logn , gswpfile , ncciy , leaps , & verbose , fixedCO2 , output , check , patchout , & patch_type , landpt , soilparmnew ,& defaultLAI , sdoy , smoy , syear , timeunits , exists , calendar USE casa_ncdf_module , ONLY : is_casa_time USE cable_common_module , ONLY : ktau_gl , kend_gl , knode_gl , cable_user , & cable_runtime , filename , myhome , & redistrb , wiltParam , satuParam , CurYear , & IS_LEAPYEAR , calcsoilalbedo , & kwidth_gl , gw_params USE cable_namelist_util , ONLY : get_namelist_file_name ,& CABLE_NAMELIST , arg_not_namelist ! physical constants USE cable_phys_constants_mod , ONLY : CTFRZ => TFRZ USE cable_phys_constants_mod , ONLY : CEMLEAF => EMLEAF USE cable_phys_constants_mod , ONLY : CEMSOIL => EMSOIL USE cable_phys_constants_mod , ONLY : CSBOLTZ => SBOLTZ USE cable_input_module , ONLY : open_met_file , load_parameters , & get_met_data , close_met_file , & ncid_rain , & ncid_snow , & ncid_lw , & ncid_sw , & ncid_ps , & ncid_qa , & ncid_ta , & ncid_wd , ncid_mask USE cable_output_module , ONLY : create_restart , open_output_file , & write_output , close_output_file USE cable_write_module , ONLY : nullify_write USE cable_IO_vars_module , ONLY : timeunits , calendar USE cable_cbm_module , ONLY : cbm !mpidiff USE cable_climate_mod ! modules related to CASA-CNP USE casadimension , ONLY : icycle USE casavariable , ONLY : casafile , casa_biome , casa_pool , casa_flux , & !mpidiff casa_met , casa_balance , zero_sum_casa , update_sum_casa USE phenvariable , ONLY : phen_variable !! vh_js !! ! modules related to POP USE POP_Types , ONLY : POP_TYPE USE POPLUC_Types , ONLY : POPLUC_Type USE POPLUC_Module , ONLY : WRITE_LUC_OUTPUT_NC , WRITE_LUC_OUTPUT_GRID_NC , & POP_LUC_CASA_transfer , WRITE_LUC_RESTART_NC , POPLUC_set_patchfrac USE POP_Constants , ONLY : HEIGHT_BINS , NCOHORT_MAX ! PLUME-MIP only USE CABLE_PLUME_MIP , ONLY : PLUME_MIP_TYPE , PLUME_MIP_GET_MET ,& PLUME_MIP_INIT USE CABLE_CRU , ONLY : CRU_TYPE , CRU_GET_SUBDIURNAL_MET , CRU_INIT USE CABLE_site , ONLY : site_TYPE , site_INIT , site_GET_CO2_Ndep ! LUC_EXPT only USE CABLE_LUC_EXPT , ONLY : LUC_EXPT_TYPE , LUC_EXPT_INIT #ifdef NAG USE F90_UNIX #endif USE casa_inout_module USE casa_cable USE cbl_soil_snow_init_special_module USE landuse_constant , ONLY : mstate , mvmax , mharvw USE landuse_variable IMPLICIT NONE ! CABLE namelist: model configuration, runtime/user switches !CHARACTER(LEN=200), PARAMETER :: CABLE_NAMELIST='cable.nml' ! try to read in namelist from command line argument ! allows simple way of not hard coding cable.nml ! defaults to using cable.nml if no file specified ! timing variables INTEGER , PARAMETER :: kstart = 1 ! start of simulation INTEGER , PARAMETER :: mloop = 30 ! CASA-CNP PreSpinup loops INTEGER :: LALLOC ! allocation coefficient for passing to spincasa INTEGER :: & ktau , & ! increment equates to timestep, resets if spinning up ktau_tot , & ! NO reset when spinning up, total timesteps by model kend , & ! no. of time steps in run !CLN\t  kstart = 1, &\t ! timestep to start at koffset = 0 , & ! timestep to start at koffset_met = 0 , & !offfset for site met data ('site' only) ktauday , & ! day counter for CASA-CNP idoy , & ! day of year (1:365) counter for CASA-CNP nyear , & ! year counter for CASA-CNP casa_it , & ! number of calls to CASA-CNP YYYY , & ! RYEAR , & ! RRRR , & ! NRRRR , & ! ctime , & ! day count for casacnp LOY , & ! days in year count_sum_casa , & ! number of time steps over which casa pools & !and fluxes are aggregated (for output) wlogn = 10001 REAL :: dels ! time step size in seconds INTEGER , DIMENSION (:,:), ALLOCATABLE :: GSWP_MID CHARACTER :: dum * 9 , str1 * 9 , str2 * 9 , str3 * 9 ! CABLE variables TYPE ( met_type ) :: met ! met input variables TYPE ( air_type ) :: air ! air property variables TYPE ( canopy_type ) :: canopy ! vegetation variables TYPE ( radiation_type ) :: rad ! radiation variables TYPE ( roughness_type ) :: rough ! roughness varibles TYPE ( balances_type ) :: bal ! energy and water balance variables TYPE ( soil_snow_type ) :: ssnow ! soil and snow variables !mpidiff TYPE ( climate_type ) :: climate ! climate variables ! CABLE parameters TYPE ( soil_parameter_type ) :: soil ! soil parameters TYPE ( veg_parameter_type ) :: veg ! vegetation parameters TYPE ( sum_flux_type ) :: sum_flux ! cumulative flux variables TYPE ( bgc_pool_type ) :: bgc ! carbon pool variables ! CASA-CNP variables TYPE ( casa_biome ) :: casabiome TYPE ( casa_pool ) :: casapool TYPE ( casa_flux ) :: casaflux TYPE ( casa_pool ) :: sum_casapool TYPE ( casa_flux ) :: sum_casaflux TYPE ( casa_met ) :: casamet TYPE ( casa_balance ) :: casabal TYPE ( phen_variable ) :: phen !! vh_js !! TYPE ( POP_TYPE ) :: POP TYPE ( POPLUC_TYPE ) :: POPLUC TYPE ( PLUME_MIP_TYPE ) :: PLUME TYPE ( CRU_TYPE ) :: CRU TYPE ( site_TYPE ) :: site TYPE ( LUC_EXPT_TYPE ) :: LUC_EXPT TYPE ( landuse_mp ) :: lucmp CHARACTER :: cyear * 4 CHARACTER :: ncfile * 99 ! declare vars for switches (default .FALSE.) etc declared thru namelist LOGICAL , SAVE :: & vegparmnew = . FALSE ., & ! using new format input file (BP dec 2007) spinup = . FALSE ., & ! model spinup to soil state equilibrium? spinConv = . FALSE ., & ! has spinup converged? spincasa = . FALSE ., & ! TRUE: CASA-CNP Will spin mloop times, ! FALSE: no spin up l_casacnp = . FALSE ., & ! using CASA-CNP with CABLE l_landuse = . FALSE ., & ! using CASA-CNP with CABLE l_laiFeedbk = . FALSE ., & ! using prognostic LAI l_vcmaxFeedbk = . FALSE ., & ! using prognostic Vcmax CASAONLY = . FALSE ., & ! ONLY Run CASA-CNP CALL1 = . TRUE ., & SPINon = . TRUE . REAL :: & delsoilM , & ! allowed variation in soil moisture for spin up delsoilT ! allowed variation in soil temperature for spin up INTEGER :: Metyear , Y , LOYtmp REAL :: delgwM = 1e-4 ! temporary storage for soil moisture/temp. in spin up mode REAL , ALLOCATABLE , DIMENSION (:,:) :: & soilMtemp , & soilTtemp REAL , ALLOCATABLE , DIMENSION (:) :: GWtemp ! timing REAL :: etime ! Declare the type of etime(), For receiving user and system time, total time REAL , allocatable :: heat_cap_lower_limit (:,:) ! switches etc defined thru namelist (by default cable.nml) NAMELIST / CABLE / & filename , & ! TYPE, containing input filenames vegparmnew , & ! use new soil param. method soilparmnew , & ! use new soil param. method calcsoilalbedo , & ! albedo considers soil color Ticket #27 spinup , & ! spinup model (soil) to steady state delsoilM , delsoilT ,& ! delgwM , & output , & patchout , & check , & verbose , & leaps , & logn , & fixedCO2 , & spincasa , & l_casacnp , & l_landuse , & l_laiFeedbk , & l_vcmaxFeedbk , & icycle , & casafile , & ncciy , & gswpfile , & redistrb , & wiltParam , & satuParam , & cable_user , & ! additional USER switches gw_params !mpidiff INTEGER :: i , x , kk , m , np , ivt ! Vars for standard for quasi-bitwise reproducability b/n runs ! Check triggered by cable_user%consistency_check = .TRUE. in cable.nml CHARACTER ( len = 30 ), PARAMETER :: & Ftrunk_sumbal = \".trunk_sumbal\" , & Fnew_sumbal = \"new_sumbal\" DOUBLE PRECISION :: & trunk_sumbal = 0.0 , & ! new_sumbal = 0.0 , & new_sumfpn = 0.0 , & new_sumfe = 0.0 !For consistency w JAC REAL , ALLOCATABLE , SAVE :: c1 (:,:) REAL , ALLOCATABLE , SAVE :: rhoch (:,:) REAL , ALLOCATABLE , SAVE :: xk (:,:) INTEGER :: nkend = 0 INTEGER :: ioerror INTEGER :: count_bal = 0 ! for landuse integer mlon , mlat , mpx real ( r_2 ), dimension (:,:,:), allocatable , save :: luc_atransit real ( r_2 ), dimension (:,:), allocatable , save :: luc_fharvw real ( r_2 ), dimension (:,:,:), allocatable , save :: luc_xluh2cable real ( r_2 ), dimension (:), allocatable , save :: arealand integer , dimension (:,:), allocatable , save :: landmask integer , dimension (:), allocatable , save :: cstart , cend , nap real ( r_2 ), dimension (:,:,:), allocatable , save :: patchfrac_new ! END header cable_runtime % offline = . TRUE . !check to see if first argument passed to cable is !the name of the namelist file !if not use cable.nml CALL get_namelist_file_name () WRITE ( * , * ) \"THE NAME LIST IS \" , CABLE_NAMELIST ! Open, read and close the namelist file. OPEN ( 10 , FILE = CABLE_NAMELIST ) READ ( 10 , NML = CABLE ) !where NML=CABLE defined above CLOSE ( 10 ) ! Open, read and close the consistency check file. ! Check triggered by cable_user%consistency_check = .TRUE. in cable.nml IF ( cable_user % consistency_check ) THEN OPEN ( 11 , FILE = Ftrunk_sumbal , STATUS = 'old' , ACTION = 'READ' , IOSTAT = ioerror ) IF ( ioerror == 0 ) THEN READ ( 11 , * ) trunk_sumbal ! written by previous trunk version ENDIF CLOSE ( 11 ) ENDIF ! Open log file: OPEN ( logn , FILE = filename % log ) IF ( ( IARGC () > 0 ) . AND . ( arg_not_namelist )) THEN CALL GETARG ( 1 , filename % met ) CALL GETARG ( 2 , casafile % cnpipool ) ENDIF ! INITIALISATION depending on nml settings IF ( TRIM ( cable_user % MetType ) . EQ . 'gswp' . OR . TRIM ( cable_user % MetType ) . EQ . 'gswp3' ) THEN IF ( CABLE_USER % YearStart . EQ . 0 . AND . ncciy . GT . 0 ) THEN CABLE_USER % YearStart = ncciy CABLE_USER % YearEnd = ncciy ELSEIF ( CABLE_USER % YearStart . EQ . 0 . AND . ncciy . EQ . 0 ) THEN PRINT * , 'undefined start year for gswp met: ' PRINT * , 'enter value for ncciy or' PRINT * , '(CABLE_USER%YearStart and  CABLE_USER%YearEnd) & in cable.nml' WRITE ( logn , * ) 'undefined start year for gswp met: ' WRITE ( logn , * ) 'enter value for ncciy or' WRITE ( logn , * ) '(CABLE_USER%YearStart and  CABLE_USER%YearEnd) & in cable.nml' STOP ENDIF ENDIF CurYear = CABLE_USER % YearStart IF ( icycle . GE . 11 ) THEN icycle = icycle - 10 CASAONLY = . TRUE . CABLE_USER % CASA_DUMP_READ = . TRUE . CABLE_USER % CASA_DUMP_WRITE = . FALSE . ELSEIF ( icycle . EQ . 0 ) THEN CABLE_USER % CASA_DUMP_READ = . FALSE . spincasa = . FALSE . !! vh_js !! CABLE_USER % CALL_POP = . FALSE . ENDIF !! vh_js !! IF ( icycle . GT . 0 ) THEN l_casacnp = . TRUE . ELSE l_casacnp = . FALSE . ENDIF !! vh_js !! suggest LALLOC should ulitmately be a switch in the .nml file IF ( CABLE_USER % CALL_POP ) THEN LALLOC = 3 ! for use with POP: makes use of pipe model to partition between stem and leaf ELSE LALLOC = 0 ! default ENDIF !!$   IF ( .NOT. spinup ) THEN !!$\t IF ( spincasa ) THEN !!$\t    spincasa = .FALSE. !!$\t    WRITE(*,*)\t \"spinup == .FALSE. -> spincasa set to .F.\" !!$\t    WRITE(logn,*)\"spinup == .FALSE. -> spincasa set to .F.\" !!$\t ENDIF !!$   ENDIF !!$ IF ( TRIM ( cable_user % MetType ) . EQ . 'gpgs' ) THEN leaps = . TRUE . calendar = \"standard\" cable_user % MetType = 'gswp' ENDIF IF ( l_casacnp . AND . ( icycle == 0 . OR . icycle > 3 ) ) & STOP 'icycle must be 1 to 3 when using casaCNP' !IF( ( l_laiFeedbk .OR. l_vcmaxFeedbk ) )\t  & !   STOP 'casaCNP required to get prognostic LAI or Vcmax' IF ( l_vcmaxFeedbk . AND . icycle < 1 ) & STOP 'icycle must be 2 to 3 to get prognostic Vcmax' IF ( icycle > 0 . AND . ( . NOT . soilparmnew ) ) & STOP 'casaCNP must use new soil parameters' NRRRR = MERGE ( MAX ( CABLE_USER % CASA_NREP , 1 ), 1 , CASAONLY ) ! casa time count ctime = 0 !!!! INISTUFF ! Open met data and get site information from netcdf file. (NON-GSWP ONLY!) ! This retrieves time step size, number of timesteps, starting date, ! latitudes, longitudes, number of sites. IF ( TRIM ( cable_user % MetType ) . EQ . 'site' ) THEN IF ( l_casacnp ) THEN CALL open_met_file ( dels , koffset , kend , spinup , CTFRZ ) IF ( koffset . NE . 0 . AND . CABLE_USER % CALL_POP ) THEN WRITE ( * , * ) \"When using POP, episode must start at Jan 1st!\" STOP 991 ENDIF ELSE WRITE ( * , * ) \"MetType=site only works with CASA-CNP turned on\" STOP 991 ENDIF !l_casacnp ELSEIF ( TRIM ( cable_user % MetType ) . EQ . '' ) THEN CALL open_met_file ( dels , koffset , kend , spinup , CTFRZ ) IF ( koffset . NE . 0 . AND . CABLE_USER % CALL_POP ) THEN WRITE ( * , * ) \"When using POP, episode must start at Jan 1st!\" STOP 991 ENDIF ELSE IF ( NRRRR . GT . 1 ) THEN IF (. NOT . ALLOCATED ( GSWP_MID )) & ALLOCATE ( GSWP_MID ( 8 , CABLE_USER % YearStart : CABLE_USER % YearEnd ) ) ENDIF !cable_user%MetType ! outer loop - spinup loop no. ktau_tot : RYEAR = 0 ktau_tot = 0 SPINon = . TRUE . !!$  YearStart = CABLE_USER%YearStart !!$  YearEnd = CABLE_USER%YearEnd !!$  cable_user%CASA_SPIN_ENDYEAR SPINLOOP : DO WHILE ( SPINon ) NREP : DO RRRR = 1 , NRRRR YEAR : DO YYYY = CABLE_USER % YearStart , CABLE_USER % YearEnd CurYear = YYYY IF ( leaps . AND . IS_LEAPYEAR ( YYYY ) ) THEN LOY = 366 calendar = \"standard\" ELSE LOY = 365 calendar = \"noleap\" ENDIF ! Check for gswp run IF ( TRIM ( cable_user % MetType ) . EQ . 'gswp' ) THEN ncciy = CurYear CALL prepareFiles ( ncciy ) IF ( RRRR . EQ . 1 ) THEN CALL open_met_file ( dels , koffset , kend , spinup , CTFRZ ) IF ( leaps . AND . is_leapyear ( YYYY ). AND . kend . EQ . 2920 ) THEN STOP 'LEAP YEAR INCOMPATIBILITY WITH INPUT MET !!!' ENDIF IF ( NRRRR . GT . 1 ) THEN GSWP_MID ( 1 , YYYY ) = ncid_rain GSWP_MID ( 2 , YYYY ) = ncid_snow GSWP_MID ( 3 , YYYY ) = ncid_lw GSWP_MID ( 4 , YYYY ) = ncid_sw GSWP_MID ( 5 , YYYY ) = ncid_ps GSWP_MID ( 6 , YYYY ) = ncid_qa GSWP_MID ( 7 , YYYY ) = ncid_ta GSWP_MID ( 8 , YYYY ) = ncid_wd ENDIF ELSE ncid_rain = GSWP_MID ( 1 , YYYY ) ncid_snow = GSWP_MID ( 2 , YYYY ) ncid_lw = GSWP_MID ( 3 , YYYY ) ncid_sw = GSWP_MID ( 4 , YYYY ) ncid_ps = GSWP_MID ( 5 , YYYY ) ncid_qa = GSWP_MID ( 6 , YYYY ) ncid_ta = GSWP_MID ( 7 , YYYY ) ncid_wd = GSWP_MID ( 8 , YYYY ) kend = ktauday * LOY ENDIF IF ( leaps ) THEN calendar = \"standard\" ELSE calendar = \"noleap\" ENDIF ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'plum' ) THEN ! PLUME experiment setup using WATCH IF ( CALL1 ) THEN CALL CPU_TIME ( etime ) CALL PLUME_MIP_INIT ( PLUME ) dels = PLUME % dt koffset = 0 leaps = PLUME % LeapYears WRITE ( str1 , '(i4)' ) CurYear str1 = ADJUSTL ( str1 ) WRITE ( str2 , '(i2)' ) 1 str2 = ADJUSTL ( str2 ) WRITE ( str3 , '(i2)' ) 1 str3 = ADJUSTL ( str3 ) timeunits = \"seconds since \" // TRIM ( str1 ) // \"-\" // TRIM ( str2 ) // \"-\" // TRIM ( str3 ) // \" & 00:00\" IF ( leaps ) THEN calendar = \"standard\" ELSE calendar = \"noleap\" ENDIF ENDIF IF ( . NOT . PLUME % LeapYears ) LOY = 365 kend = NINT ( 2 4.0 * 360 0.0 / dels ) * LOY ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'cru' ) THEN ! TRENDY experiment using CRU-NCEP IF ( CALL1 ) THEN CALL CPU_TIME ( etime ) CALL CRU_INIT ( CRU ) dels = CRU % dtsecs koffset = 0 leaps = . FALSE . ! No leap years in CRU-NCEP exists % Snowf = . FALSE . ! No snow in CRU-NCEP, so ensure it will ! be determined from temperature in CABLE WRITE ( str1 , '(i4)' ) CurYear str1 = ADJUSTL ( str1 ) WRITE ( str2 , '(i2)' ) 1 str2 = ADJUSTL ( str2 ) WRITE ( str3 , '(i2)' ) 1 str3 = ADJUSTL ( str3 ) timeunits = \"seconds since \" // TRIM ( str1 ) // \"-\" // TRIM ( str2 ) // \"-\" // TRIM ( str3 ) // \" & 00:00\" calendar = \"noleap\" ENDIF LOY = 365 kend = NINT ( 2 4.0 * 360 0.0 / dels ) * LOY ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'site' ) THEN ! site experiment eg AmazonFace (spinup or  transient run type) IF ( CALL1 ) THEN CALL CPU_TIME ( etime ) CALL site_INIT ( site ) WRITE ( str1 , '(i4)' ) CurYear str1 = ADJUSTL ( str1 ) WRITE ( str2 , '(i2)' ) 1 str2 = ADJUSTL ( str2 ) WRITE ( str3 , '(i2)' ) 1 str3 = ADJUSTL ( str3 ) timeunits = \"seconds since \" // TRIM ( str1 ) // \"-\" // TRIM ( str2 ) // \"-\" // TRIM ( str3 ) // \" & 00:00\" calendar = 'standard' ENDIF LOY = 365 IF ( IS_LEAPYEAR ( CurYear )) LOY = 366 kend = NINT ( 2 4.0 * 360 0.0 / dels ) * LOY ! get koffset to add to time-step of sitemet IF ( TRIM ( site % RunType ) == 'historical' ) THEN MetYear = CurYear ELSEIF ( TRIM ( site % RunType ) == 'spinup' . OR . TRIM ( site % RunType ) == 'transient' ) THEN ! setting met year so we end the spin-up at the end of the site data-years. MetYear = site % spinstartyear + & MOD ( CurYear - & ( site % spinstartyear - ( site % spinendyear - site % spinstartyear + 1 ) * 100 ), & ( site % spinendyear - site % spinstartyear + 1 )) ENDIF WRITE ( * , * ) 'MetYear: ' , MetYear WRITE ( * , * ) 'Simulation Year: ' , CurYear koffset_met = 0 IF ( MetYear . GT . site % spinstartyear ) THEN DO Y = site % spinstartyear , MetYear - 1 LOYtmp = 365 IF ( IS_LEAPYEAR ( Y )) LOYtmp = 366 koffset_met = koffset_met + INT ( REAL ( LOYtmp ) * 8640 0. / REAL ( dels ) ) ENDDO ENDIF ENDIF ! somethings (e.g. CASA-CNP) only need to be done once per day ktauday = INT ( 2 4.0 * 360 0.0 / dels ) !! Checks where parameters and initialisations should be loaded from. ! If they can be found in either the met file or restart file, they will ! load from there, with the met file taking precedence. Otherwise, they'll ! be chosen from a coarse global grid of veg and soil types, based on ! the lat/lon coordinates. Allocation of CABLE's main variables also here. IF ( CALL1 ) THEN IF ( cable_user % POPLUC ) THEN CALL LUC_EXPT_INIT ( LUC_EXPT ) ENDIF !! vh_js !! CALL load_parameters ( met , air , ssnow , veg , climate , bgc , & soil , canopy , rough , rad , sum_flux , & bal , logn , vegparmnew , casabiome , casapool , & casaflux , sum_casapool , sum_casaflux , & casamet , casabal , phen , POP , spinup , & CEMSOIL , CTFRZ , LUC_EXPT , POPLUC ) IF ( CABLE_USER % POPLUC . AND . TRIM ( CABLE_USER % POPLUC_RunType ) . EQ . 'static' ) & CABLE_USER % POPLUC = . FALSE . ! Open output file: IF (. NOT . CASAONLY ) THEN IF ( TRIM ( filename % out ) . EQ . '' ) THEN IF ( CABLE_USER % YEARSTART . GT . 0 ) THEN WRITE ( dum , FMT = \"(I4,'_',I4)\" ) CABLE_USER % YEARSTART , & CABLE_USER % YEAREND filename % out = TRIM ( filename % path ) // '/' // & TRIM ( cable_user % RunIden ) // '_' // & TRIM ( dum ) // '_cable_out.nc' ELSE filename % out = TRIM ( filename % path ) // '/' // & TRIM ( cable_user % RunIden ) // '_cable_out.nc' ENDIF ENDIF IF ( RRRR . EQ . 1 ) THEN CALL nullify_write () ! nullify pointers CALL open_output_file ( dels , soil , veg , bgc , rough ) ENDIF ENDIF ssnow % otss_0 = ssnow % tgg (:, 1 ) ssnow % otss = ssnow % tgg (:, 1 ) ssnow % tss = ssnow % tgg (:, 1 ) canopy % fes_cor = 0. canopy % fhs_cor = 0. met % ofsd = 0.1 CALL zero_sum_casa ( sum_casapool , sum_casaflux ) count_sum_casa = 0 IF ( cable_user % call_climate ) CALL climate_init ( climate , mp , ktauday ) IF ( cable_user % call_climate . AND .(. NOT . cable_user % climate_fromzero )) & CALL READ_CLIMATE_RESTART_NC ( climate , ktauday ) spinConv = . FALSE . ! initialise spinup convergence variable IF (. NOT . spinup ) spinConv = . TRUE . IF ( icycle > 0 . AND . spincasa ) THEN PRINT * , 'EXT spincasacnp enabled with mloop= ' , mloop CALL spincasacnp ( dels , kstart , kend , mloop , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC ) SPINon = . FALSE . SPINconv = . FALSE . ELSEIF ( casaonly . AND . (. NOT . spincasa ) ) THEN !.AND. cable_user%popluc) THEN CALL CASAONLY_LUC ( dels , kstart , kend , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , LUC_EXPT , POPLUC , & sum_casapool , sum_casaflux ) SPINon = . FALSE . SPINconv = . FALSE . ktau = kend ENDIF ENDIF ! CALL 1 ! globally (WRT code) accessible kend through USE cable_common_module kwidth_gl = INT ( dels ) kend_gl = kend knode_gl = 0 IF ( casaonly ) THEN EXIT ENDIF if ( . NOT . allocated ( heat_cap_lower_limit ) ) then allocate ( heat_cap_lower_limit ( mp , ms ) ) heat_cap_lower_limit = 0.01 end if call spec_init_soil_snow ( dels , soil , ssnow , canopy , met , bal , veg , heat_cap_lower_limit ) ! time step loop over ktau DO ktau = kstart , kend WRITE ( logn , * ) 'Progress -' , REAL ( ktau ) / REAL ( kend ) * 10 0.0 ! increment total timstep counter ktau_tot = ktau_tot + 1 ! globally (WRT code) accessible kend through USE cable_common_module ktau_gl = ktau_tot idoy = INT ( MOD ( REAL ( CEILING ( REAL (( ktau + koffset ) / ktauday ))), REAL ( LOY ))) IF ( idoy . EQ . 0 ) idoy = LOY ! needed for CASA-CNP nyear = INT (( kend + koffset ) / ( LOY * ktauday )) ! Get met data and LAI, set time variables. ! Rainfall input may be augmented for spinup purposes: IF ( TRIM ( cable_user % MetType ) . EQ . 'plum' ) THEN IF (( . NOT . CASAONLY ) . OR . ( CASAONLY . AND . CALL1 )) THEN CALL PLUME_MIP_GET_MET ( PLUME , MET , YYYY , ktau , kend , & ( YYYY . EQ . CABLE_USER % YearEnd . AND . ktau . EQ . kend )) ENDIF ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'cru' ) THEN IF (( . NOT . CASAONLY ). OR . ( CASAONLY . AND . CALL1 )) THEN CALL CRU_GET_SUBDIURNAL_MET ( CRU , met , & YYYY , ktau , kend , & YYYY . EQ . CABLE_USER % YearEnd ) ENDIF ELSE IF ( TRIM ( cable_user % MetType ) . EQ . 'site' ) & CALL get_met_data ( spinup , spinConv , met , soil , & rad , veg , kend , dels , CTFRZ , ktau + koffset_met , & kstart + koffset_met ) IF ( TRIM ( cable_user % MetType ) . EQ . '' ) & CALL get_met_data ( spinup , spinConv , met , soil , & rad , veg , kend , dels , CTFRZ , ktau + koffset , & kstart + koffset ) IF ( TRIM ( cable_user % MetType ) . EQ . 'site' ) THEN CALL site_get_CO2_Ndep ( site ) ! Two options: (i) if we have sub-annual varying CO2, then ! these data should be put into the met file and in site.nml ! CO2 should be set to -9999; or (ii) if we only have annual ! CO2 numbers then these should be read from the site csv file WHERE ( met % ca . EQ . fixedCO2 / 100000 0.0 ) met % ca = site % CO2 / 1.e+6 END WHERE met % Ndep = site % Ndep * 100 0. / 1000 0. / 36 5. ! kg ha-1 y-1 > g m-2 d-1 met % Pdep = site % Pdep * 100 0. / 1000 0. / 36 5. ! kg ha-1 y-1 > g m-2 d-1 met % fsd = MAX ( met % fsd , 0.0 ) ENDIF ENDIF IF ( TRIM ( cable_user % MetType ). EQ . '' ) THEN CurYear = met % year ( 1 ) IF ( leaps . AND . IS_LEAPYEAR ( CurYear ) ) THEN LOY = 366 ELSE LOY = 365 ENDIF ENDIF met % ofsd = met % fsd (:, 1 ) + met % fsd (:, 2 ) canopy % oldcansto = canopy % cansto ! Zero out lai where there is no vegetation acc. to veg. index WHERE ( veg % iveg (:) . GE . 14 ) veg % vlai = 0. ! At first time step of year, set tile area according to updated LU areas ! and zero casa fluxes IF ( ktau == 1 ) THEN IF ( icycle > 1 ) CALL casa_cnpflux ( casaflux , casapool , casabal ,. TRUE .) IF ( CABLE_USER % POPLUC ) CALL POPLUC_set_patchfrac ( POPLUC , LUC_EXPT ) ENDIF IF ( . NOT . CASAONLY ) THEN ! Feedback prognostic vcmax and daily LAI from casaCNP to CABLE IF ( l_vcmaxFeedbk ) CALL casa_feedback ( ktau , veg , casabiome , & casapool , casamet ) IF ( l_laiFeedbk . AND . icycle > 0 ) veg % vlai (:) = casamet % glai (:) IF (. NOT . allocated ( c1 )) ALLOCATE ( c1 ( mp , nrb ), rhoch ( mp , nrb ), xk ( mp , nrb ) ) ! Call land surface scheme for this timestep, all grid points: CALL cbm ( ktau , dels , air , bgc , canopy , met , bal , & rad , rough , soil , ssnow , sum_flux , veg , climate , xk , c1 , rhoch ) IF ( cable_user % CALL_climate ) & CALL cable_climate ( ktau_tot , kstart , kend , ktauday , idoy , LOY , met , & climate , canopy , air , rad , dels , mp ) ssnow % smelt = ssnow % smelt * dels ssnow % rnof1 = ssnow % rnof1 * dels ssnow % rnof2 = ssnow % rnof2 * dels ssnow % runoff = ssnow % runoff * dels ELSE IF ( IS_CASA_TIME ( \"dread\" , yyyy , ktau , kstart , & koffset , kend , ktauday , logn ) ) THEN ! CLN READ FROM FILE INSTEAD ! WRITE ( CYEAR , FMT = \"(I4)\" ) CurYear + INT (( ktau - kstart + koffset ) / ( LOY * ktauday )) ncfile = TRIM ( casafile % c2cdumppath ) // 'c2c_' // CYEAR // '_dump.nc' casa_it = NINT ( REAL ( ktau / ktauday ) ) CALL read_casa_dump ( ncfile , casamet , casaflux , phen , climate , casa_it , kend , . FALSE . ) ENDIF !jhan this is insufficient testing. condition for !spinup=.false. & we want CASA_dump.nc (spinConv=.true.) IF ( icycle > 0 . OR . CABLE_USER % CASA_DUMP_WRITE ) THEN !! vh_js !! CALL bgcdriver ( ktau , kstart , kend , dels , met , & ssnow , canopy , veg , soil , climate , casabiome , & casapool , casaflux , casamet , casabal , & phen , pop , spinConv , spinup , ktauday , idoy , loy , & CABLE_USER % CASA_DUMP_READ , CABLE_USER % CASA_DUMP_WRITE , & LALLOC ) IF ( MOD (( ktau - kstart + 1 ), ktauday ) == 0 ) THEN !mpidiff ! update time-aggregates of casa pools and fluxes CALL update_sum_casa ( sum_casapool , sum_casaflux , casapool , casaflux , & & . TRUE . , . FALSE ., 1 ) count_sum_casa = count_sum_casa + 1 ENDIF IF ( (( MOD (( ktau - kstart + 1 ), ktauday ) == 0 ) . AND . & MOD (( ktau - kstart + 1 ) / ktauday , LOY ) == 0 ) ) THEN ! end of year IF ( CABLE_USER % POPLUC ) THEN ! Dynamic LUC CALL LUCdriver ( casabiome , casapool , casaflux , POP , & LUC_EXPT , POPLUC , veg ) ENDIF ! one annual time-step of POP CALL POPdriver ( casaflux , casabal , veg , POP ) IF ( CABLE_USER % POPLUC ) THEN ! Dynamic LUC: update casa pools according to LUC transitions CALL POP_LUC_CASA_transfer ( POPLUC , POP , LUC_EXPT , casapool , casabal , casaflux , ktauday ) ! Dynamic LUC: write output CALL WRITE_LUC_OUTPUT_NC ( POPLUC , YYYY , ( YYYY . EQ . cable_user % YearEnd )) ENDIF ENDIF ENDIF ! WRITE CASA OUTPUT IF ( icycle > 0 ) THEN IF ( IS_CASA_TIME ( \"write\" , yyyy , ktau , kstart , & koffset , kend , ktauday , logn ) ) THEN ctime = ctime + 1 !mpidiff CALL update_sum_casa ( sum_casapool , sum_casaflux , casapool , casaflux , & . FALSE . , . TRUE . , count_sum_casa ) CALL WRITE_CASA_OUTPUT_NC ( veg , casamet , sum_casapool , casabal , sum_casaflux , & CASAONLY , ctime , ( ktau . EQ . kend . AND . YYYY . EQ . & cable_user % YearEnd . AND . RRRR . EQ . NRRRR ) ) !mpidiff count_sum_casa = 0 CALL zero_sum_casa ( sum_casapool , sum_casaflux ) ENDIF IF (((. NOT . spinup ). OR .( spinup . AND . spinConv )). AND . & MOD (( ktau - kstart + 1 ), ktauday ) == 0 ) THEN IF ( CABLE_USER % CASA_DUMP_WRITE ) THEN IF ( TRIM ( cable_user % MetType ). EQ . '' . OR . & TRIM ( cable_user % MetType ). EQ . 'site' ) THEN WRITE ( CYEAR , FMT = \"(I4)\" ) CurYear ELSE !CLN CHECK FOR LEAP YEAR WRITE ( CYEAR , FMT = \"(I4)\" ) CurYear + INT (( ktau - kstart ) / ( LOY * ktauday )) ENDIF ncfile = TRIM ( casafile % c2cdumppath ) // 'c2c_' // CYEAR // '_dump.nc' IF ( TRIM ( cable_user % MetType ). EQ . '' ) THEN !jhan:assuming doy for mp=1 is same as .... CALL write_casa_dump ( ncfile , casamet , casaflux , phen , climate ,& INT ( met % doy ( 1 )), LOY ) ELSE CALL write_casa_dump ( ncfile , casamet , casaflux , & phen , climate , idoy , kend / ktauday ) ENDIF ENDIF ENDIF ENDIF IF ( . NOT . CASAONLY ) THEN ! sumcflux is pulled out of subroutine cbm ! so that casaCNP can be called before adding the fluxes ! (Feb 2008, YP) CALL sumcflux ( ktau , kstart , kend , dels , bgc , & canopy , soil , ssnow , sum_flux , veg , & met , casaflux , l_vcmaxFeedbk ) ENDIF ! Write timestep's output to file if either: we're not spinning up ! or we're spinning up and the spinup has converged: IF ( (. NOT . CASAONLY ) . AND . spinConv ) THEN !mpidiff IF ( TRIM ( cable_user % MetType ) . EQ . 'plum' . OR . & TRIM ( cable_user % MetType ) . EQ . 'cru' . OR . & TRIM ( cable_user % MetType ) . EQ . 'bios' . OR . & TRIM ( cable_user % MetType ) . EQ . 'gswp' . OR . & TRIM ( cable_user % MetType ) . EQ . 'site' ) THEN CALL write_output ( dels , ktau_tot , met , canopy , casaflux , casapool , casamet , & ssnow , rad , bal , air , soil , veg , CSBOLTZ , CEMLEAF , CEMSOIL ) ELSE CALL write_output ( dels , ktau , met , canopy , casaflux , casapool , casamet , & ssnow , rad , bal , air , soil , veg , CSBOLTZ , CEMLEAF , CEMSOIL ) ENDIF ENDIF ! Check triggered by cable_user%consistency_check = .TRUE. in cable.nml IF ( cable_user % consistency_check ) THEN count_bal = count_bal + 1 ; new_sumbal = new_sumbal + SUM ( bal % wbal ) / mp + SUM ( bal % ebal ) / mp new_sumfpn = new_sumfpn + SUM ( canopy % fpn ) / mp new_sumfe = new_sumfe + SUM ( canopy % fe ) / mp IF ( ktau == kend ) PRINT * IF ( ktau == kend ) PRINT * , \"time-space-averaged energy & water balances\" IF ( ktau == kend ) PRINT * , \"Ebal_tot[Wm-2], Wbal_tot[mm per timestep]\" , & SUM ( bal % ebal_tot ) / mp / count_bal , SUM ( bal % wbal_tot ) / mp / count_bal IF ( ktau == kend ) PRINT * , \"time-space-averaged latent heat and & net photosynthesis\" IF ( ktau == kend ) PRINT * , \"sum_fe[Wm-2], sum_fpn[umol/m2/s]\" , & new_sumfe / count_bal , new_sumfpn / count_bal IF ( ktau == kend ) WRITE ( logn , * ) IF ( ktau == kend ) WRITE ( logn , * ), \"time-space-averaged energy & water balances\" IF ( ktau == kend ) WRITE ( logn , * ), \"Ebal_tot[Wm-2], Wbal_tot[mm per timestep]\" , & SUM ( bal % ebal_tot ) / mp / count_bal , SUM ( bal % wbal_tot ) / mp / count_bal IF ( ktau == kend ) WRITE ( logn , * ), \"time-space-averaged latent heat and & net photosynthesis\" IF ( ktau == kend ) WRITE ( logn , * ), \"sum_fe[Wm-2], sum_fpn[umol/m2/s]\" , & new_sumfe / count_bal , new_sumfpn / count_bal ! vh ! commented code below detects Nans in evaporation flux and stops if there are any. !!$\t      do kk=1,mp !!$\t\t if( canopy%fe(kk).NE.( canopy%fe(kk))) THEN !!$\t\t    write(*,*) 'fe nan', kk, ktau,met%qv(kk), met%precip(kk),met%precip_sn(kk), & !!$\t\t\t met%fld(kk), met%fsd(kk,:), met%tk(kk), met%ua(kk), ssnow%potev(kk), met%pmb(kk), & !!$\t\t\t canopy%ga(kk), ssnow%tgg(kk,:), canopy%fwsoil(kk) !!$ !!$ !!$\t\t    stop !!$\t\t endif !!$\t\t if ( casaflux%cnpp(kk).NE. casaflux%cnpp(kk)) then !!$\t\t    write(*,*) 'npp nan', kk, ktau,  casaflux%cnpp(kk) !!$\t\t    stop !!$ !!$\t\t endif !!$ !!$ !!$\t\t !if (canopy%fwsoil(kk).eq.0.0) then !!$\t\t !   write(*,*) 'zero fwsoil', ktau, canopy%fpn(kk) !!$\t\t !endif !!$ !!$ !!$\t      enddo IF ( ktau == kend ) THEN nkend = nkend + 1 IF ( ABS ( new_sumbal - trunk_sumbal ) < 1.e-7 ) THEN PRINT * , \"\" PRINT * , & \"NB. Offline-serial runs spinup cycles:\" , nkend PRINT * , & \"Internal check shows this version reproduces the trunk sumbal\" ELSE PRINT * , \"\" PRINT * , & \"NB. Offline-serial runs spinup cycles:\" , nkend PRINT * , & \"Internal check shows in this version new_sumbal != trunk sumbal\" PRINT * , & \"Writing new_sumbal to the file:\" , TRIM ( Fnew_sumbal ) OPEN ( 12 , FILE = Fnew_sumbal ) WRITE ( 12 , '(F20.7)' ) new_sumbal ! written by previous trunk version CLOSE ( 12 ) ENDIF ENDIF ENDIF CALL1 = . FALSE . END DO ! END Do loop over timestep ktau CALL1 = . FALSE . !jhan this is insufficient testing. condition for !spinup=.false. & we want CASA_dump.nc (spinConv=.true.) ! see if spinup (if conducting one) has converged: !IF(spinup.AND..NOT.spinConv) THEN IF ( spinup . AND .(. NOT . spinConv ). AND .(. NOT . CASAONLY ) ) THEN ! Write to screen and log file: WRITE ( * , '(A18,I3,A24)' ) ' Spinning up: run ' , INT ( ktau_tot / kend ),& ' of data set complete...' WRITE ( logn , '(A18,I3,A24)' ) ' Spinning up: run ' , & INT ( ktau_tot / kend ), ' of data set complete...' ! IF not 1st run through whole dataset: !!$\t      IF( MOD( ktau_tot, kend ) .EQ. 0 .AND. ktau_Tot .GT. kend .AND. & !!$\t\t   YYYY.EQ. CABLE_USER%YearEnd .OR. ( NRRRR .GT. 1 .AND. & !!$\t\t   RRRR.EQ. NRRRR) ) THEN IF ( MOD ( ktau_tot , kend ) . EQ . 0 . AND . ktau_Tot . GT . kend . AND . & YYYY . EQ . CABLE_USER % YearEnd ) THEN ! evaluate spinup IF ( ANY ( ABS ( ssnow % wb - soilMtemp ) > delsoilM ). OR . & ANY ( ABS ( ssnow % tgg - soilTtemp ) > delsoilT ) . OR . & MAXVAL ( ABS ( ssnow % GWwb - GWtemp ), dim = 1 ) > delgwM ) THEN ! No complete convergence yet PRINT * , 'ssnow%wb : ' , ssnow % wb PRINT * , 'soilMtemp: ' , soilMtemp PRINT * , 'ssnow%tgg: ' , ssnow % tgg PRINT * , 'soilTtemp: ' , soilTtemp IF ( cable_user % gw_model ) THEN PRINT * , 'ssnow%GWwb : ' , ssnow % GWwb PRINT * , 'GWtemp: ' , GWtemp ENDIF ELSE ! spinup has converged spinConv = . TRUE . ! Write to screen and log file: WRITE ( * , '(A33)' ) ' Spinup has converged - final run' WRITE ( logn , '(A52)' ) & ' Spinup has converged - final run - writing all data' WRITE ( logn , '(A37,F8.5,A28)' ) & ' Criteria: Change in soil moisture < ' , & delsoilM , ' in any layer over whole run' WRITE ( logn , '(A40,F8.5,A28)' ) & '\t     Change in soil temperature < ' , & delsoilT , ' in any layer over whole run' END IF ELSE ! allocate variables for storage IF (. NOT . ALLOCATED ( soilMtemp )) ALLOCATE ( soilMtemp ( mp , ms ) ) IF (. NOT . ALLOCATED ( soilTtemp )) ALLOCATE ( soilTtemp ( mp , ms ) ) IF (. NOT . ALLOCATED ( GWtemp ) ) ALLOCATE ( GWtemp ( mp ) ) END IF IF ( cable_user % max_spins . GT . 0 ) THEN IF (( ktau_tot / kend . GE . cable_user % max_spins )) THEN spinConv = . TRUE . WRITE ( logn , * ) 'Past ' , cable_user % max_spins , ' spin cycles, running anyways' END IF END IF ! store soil moisture and temperature IF ( YYYY . EQ . CABLE_USER % YearEnd ) THEN soilTtemp = ssnow % tgg soilMtemp = REAL ( ssnow % wb ) GWtemp = ssnow % GWwb ENDIF ELSE ! if not spinning up, or spin up has converged, exit: IF ( SpinOn ) THEN PRINT * , \"setting SPINON -> FALSE\" , YYYY , RRRR SPINon = . FALSE . END IF END IF IF ((. NOT .( spinup . OR . casaonly )). OR .( spinup . AND . spinConv )) THEN IF ( icycle > 0 ) THEN CALL casa_fluxout ( nyear , veg , soil , casabal , casamet ) END IF ENDIF IF ( . NOT . ( spinup . OR . casaonly ) . OR . spinconv ) THEN IF ( NRRRR . GT . 1 ) THEN RYEAR = YYYY + ( CABLE_USER % YearEnd - CABLE_USER % YearStart + 1 ) & * ( RRRR - 1 ) ELSE RYEAR = YYYY END IF IF ( cable_user % CALL_POP . AND . POP % np . GT . 0 ) THEN IF ( TRIM ( cable_user % POP_out ). EQ . 'epi' ) THEN CALL POP_IO ( pop , casamet , RYEAR , 'WRITE_EPI' , & ( YYYY . EQ . CABLE_USER % YearEnd . AND . RRRR . EQ . NRRRR ) ) ENDIF ENDIF ENDIF ! Close met data input file: IF ( TRIM ( cable_user % MetType ) . EQ . \"gswp\" . AND . & RRRR . EQ . NRRRR ) THEN CALL close_met_file IF ( YYYY . EQ . CABLE_USER % YearEnd . AND . & NRRRR . GT . 1 ) DEALLOCATE ( GSWP_MID ) ENDIF IF (( icycle . GT . 0 ). AND .(. NOT . casaonly )) THEN ! re-initalise annual flux sums casabal % FCgppyear = 0.0 casabal % FCrpyear = 0.0 casabal % FCnppyear = 0 casabal % FCrsyear = 0.0 casabal % FCneeyear = 0.0 ENDIF CALL CPU_TIME ( etime ) PRINT * , 'Finished. ' , etime , ' seconds needed for year' END DO YEAR END DO NREP END DO SPINLOOP l_landuse = . false . IF ( SpinConv . AND . . NOT . CASAONLY ) THEN ! Close output file and deallocate main variables: CALL close_output_file ( bal , air , bgc , canopy , met , & rad , rough , soil , ssnow , & sum_flux , veg ) ENDIF IF ( cable_user % CALL_POP . AND . POP % np . GT . 0 ) THEN !mpidiff IF ( CASAONLY . OR . cable_user % pop_fromzero & . OR . TRIM ( cable_user % POP_out ). EQ . 'ini' ) THEN CALL POP_IO ( pop , casamet , RYEAR + 1 , 'WRITE_INI' , . TRUE .) ELSE CALL POP_IO ( pop , casamet , RYEAR + 1 , 'WRITE_RST' , . TRUE .) ENDIF ENDIF IF ( icycle > 0. and . . not . l_landuse ) THEN !CALL casa_poolout( ktau, veg, soil, casabiome,\t\t  & ! casapool, casaflux, casamet, casabal, phen ) CALL write_casa_restart_nc ( casamet , casapool , casaflux , phen , CASAONLY ) END IF IF ( l_landuse . AND . . NOT . CASAONLY ) THEN mlon = maxval ( landpt ( 1 : mp )% ilon ) mlat = maxval ( landpt ( 1 : mp )% ilat ) print * , 'before landuse: mlon mlat ' , mlon , mlat allocate ( luc_atransit ( mland , mvmax , mvmax )) allocate ( luc_fharvw ( mland , mharvw )) allocate ( luc_xluh2cable ( mland , mvmax , mstate )) allocate ( landmask ( mlon , mlat )) allocate ( arealand ( mland )) allocate ( patchfrac_new ( mlon , mlat , mvmax )) allocate ( cstart ( mland ), cend ( mland ), nap ( mland )) do m = 1 , mland cstart ( m ) = landpt ( m )% cstart cend ( m ) = landpt ( m )% cend nap ( m ) = landpt ( m )% nap enddo call landuse_data ( mlon , mlat , landmask , arealand , luc_atransit , luc_fharvw , luc_xluh2cable ) call landuse_driver ( mlon , mlat , landmask , arealand , ssnow , soil , veg , bal , canopy , & phen , casapool , casabal , casamet , casabiome , casaflux , bgc , rad , & cstart , cend , nap , lucmp ) do m = 1 , mland do np = cstart ( m ), cend ( m ) ivt = lucmp % iveg ( np ) if ( ivt < 1. or . ivt > mvmax ) then print * , 'landuse: error in vegtype' , m , np , ivt stop endif patchfrac_new ( landpt ( m )% ilon , landpt ( m )% ilat , ivt ) = lucmp % patchfrac ( np ) enddo enddo call create_new_gridinfo ( filename % type , filename % gridnew , mlon , mlat , landmask , patchfrac_new ) print * , 'writing casapools: land use' call WRITE_LANDUSE_CASA_RESTART_NC ( cend ( mland ), lucmp , CASAONLY ) print * , 'writing cable restart: land use' call create_landuse_cable_restart ( logn , dels , ktau , soil , cend ( mland ), lucmp , cstart , cend , nap ) print * , 'deallocating' call landuse_deallocate_mp ( cend ( mland ), ms , msn , nrb , mplant , mlitter , msoil , mwood , lucmp ) ENDIF IF ( cable_user % POPLUC . AND . . NOT . CASAONLY ) THEN CALL WRITE_LUC_RESTART_NC ( POPLUC , YYYY ) ENDIF IF ( . NOT . CASAONLY . and . . not . l_landuse ) THEN ! Write restart file if requested: IF ( output % restart ) & CALL create_restart ( logn , dels , ktau , soil , veg , ssnow , & canopy , rough , rad , bgc , bal , met ) !mpidiff IF ( cable_user % CALL_climate ) & CALL WRITE_CLIMATE_RESTART_NC ( climate , ktauday ) !--- LN ------------------------------------------[ ENDIF IF ( TRIM ( cable_user % MetType ) . NE . \"gswp\" . AND . & TRIM ( cable_user % MetType ) . NE . \"plum\" . AND . & TRIM ( cable_user % MetType ) . NE . \"cru\" ) CALL close_met_file !WRITE(logn,*) bal%wbal_tot, bal%ebal_tot, bal%ebal_tot_cncheck CALL CPU_TIME ( etime ) WRITE ( logn , * ) 'Finished. ' , etime , ' seconds needed for ' , kend , ' hours' ! Close log file CLOSE ( logn ) CALL CPU_TIME ( etime ) PRINT * , 'Finished. ' , etime , ' seconds needed for ' , kend , ' hours' END PROGRAM cable_offline_driver SUBROUTINE prepareFiles ( ncciy ) USE cable_IO_vars_module , ONLY : logn , gswpfile IMPLICIT NONE INTEGER , INTENT ( IN ) :: ncciy WRITE ( logn , * ) 'CABLE offline global run using gswp forcing for ' , ncciy PRINT * , 'CABLE offline global run using gswp forcing for ' , ncciy CALL renameFiles ( logn , gswpfile % rainf , ncciy , 'rainf' ) CALL renameFiles ( logn , gswpfile % snowf , ncciy , 'snowf' ) CALL renameFiles ( logn , gswpfile % LWdown , ncciy , 'LWdown' ) CALL renameFiles ( logn , gswpfile % SWdown , ncciy , 'SWdown' ) CALL renameFiles ( logn , gswpfile % PSurf , ncciy , 'PSurf' ) CALL renameFiles ( logn , gswpfile % Qair , ncciy , 'Qair' ) CALL renameFiles ( logn , gswpfile % Tair , ncciy , 'Tair' ) CALL renameFiles ( logn , gswpfile % wind , ncciy , 'wind' ) END SUBROUTINE prepareFiles SUBROUTINE renameFiles ( logn , inFile , ncciy , inName ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: logn , ncciy INTEGER :: nn CHARACTER ( LEN = 200 ), INTENT ( INOUT ) :: inFile CHARACTER ( LEN =* ), INTENT ( IN ) :: inName INTEGER :: idummy nn = INDEX ( inFile , '19' ) READ ( inFile ( nn : nn + 3 ), '(i4)' ) idummy WRITE ( inFile ( nn : nn + 3 ), '(i4.4)' ) ncciy WRITE ( logn , * ) TRIM ( inName ), ' global data from ' , TRIM ( inFile ) END SUBROUTINE renameFiles !*************************************************************************************** ! subroutine for reading LU input data, zeroing biomass in empty secondary forest tiles ! and tranferring LUC-based age weights for secondary forest to POP structure SUBROUTINE LUCdriver ( casabiome , casapool , & casaflux , POP , LUC_EXPT , POPLUC , veg ) USE cable_def_types_mod , ONLY : veg_parameter_type , mland USE cable_carbon_module USE cable_common_module , ONLY : CABLE_USER , CurYear USE casa_ncdf_module , ONLY : is_casa_time USE cable_IO_vars_module , ONLY : logn , landpt , patch USE casadimension USE casaparm USE casavariable USE POP_Types , ONLY : POP_TYPE USE POPMODULE , ONLY : POPStep , POP_init_single USE TypeDef , ONLY : i4b , dp USE CABLE_LUC_EXPT , ONLY : LUC_EXPT_TYPE , read_LUH2 ,& ptos , ptog , stog , gtos , grassfrac , pharv , smharv , syharv USE POPLUC_Types USE POPLUC_Module , ONLY : POPLUCStep , POPLUC_weights_Transfer , WRITE_LUC_OUTPUT_NC , & POP_LUC_CASA_transfer , WRITE_LUC_RESTART_NC , READ_LUC_RESTART_NC IMPLICIT NONE TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters INTEGER :: k , j , l , yyyy WRITE ( * , * ) 'cablecasa_LUC' , CurYear yyyy = CurYear LUC_EXPT % CTSTEP = yyyy - LUC_EXPT % FirstYear + 1 CALL READ_LUH2 ( LUC_EXPT ) DO k = 1 , mland POPLUC % ptos ( k ) = LUC_EXPT % INPUT ( ptos )% VAL ( k ) POPLUC % ptog ( k ) = LUC_EXPT % INPUT ( ptog )% VAL ( k ) POPLUC % stop ( k ) = 0.0 POPLUC % stog ( k ) = LUC_EXPT % INPUT ( stog )% VAL ( k ) POPLUC % gtop ( k ) = 0.0 POPLUC % gtos ( k ) = LUC_EXPT % INPUT ( gtos )% VAL ( k ) POPLUC % pharv ( k ) = LUC_EXPT % INPUT ( pharv )% VAL ( k ) POPLUC % smharv ( k ) = LUC_EXPT % INPUT ( smharv )% VAL ( k ) POPLUC % syharv ( k ) = LUC_EXPT % INPUT ( syharv )% VAL ( k ) POPLUC % thisyear = yyyy ENDDO ! zero secondary forest tiles in POP where secondary forest area is zero DO k = 1 , mland IF (( POPLUC % frac_primf ( k ) - POPLUC % frac_forest ( k )) == 0.0 & . AND . (. NOT . LUC_EXPT % prim_only ( k ))) THEN j = landpt ( k )% cstart + 1 DO l = 1 , SIZE ( POP % Iwood ) IF ( POP % Iwood ( l ) == j ) THEN CALL POP_init_single ( POP , veg % disturbance_interval , l ) EXIT ENDIF ENDDO casapool % cplant ( j , leaf ) = 0.01 casapool % nplant ( j , leaf ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), leaf ) * casapool % cplant ( j , leaf ) casapool % pplant ( j , leaf ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), leaf ) * casapool % cplant ( j , leaf ) casapool % cplant ( j , froot ) = 0.01 casapool % nplant ( j , froot ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), froot ) * casapool % cplant ( j , froot ) casapool % pplant ( j , froot ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), froot ) * casapool % cplant ( j , froot ) casapool % cplant ( j , wood ) = 0.01 casapool % nplant ( j , wood ) = casabiome % ratioNCplantmin ( veg % iveg ( j ), wood ) * casapool % cplant ( j , wood ) casapool % pplant ( j , wood ) = casabiome % ratioPCplantmin ( veg % iveg ( j ), wood ) * casapool % cplant ( j , wood ) casaflux % frac_sapwood ( j ) = 1.0 ENDIF ENDDO CALL POPLUCStep ( POPLUC , yyyy ) CALL POPLUC_weights_transfer ( POPLUC , POP , LUC_EXPT ) END SUBROUTINE LUCdriver","tags":"","loc":"sourcefile/cable_driver.f90.html"},{"title":"cable_abort.F90 – CABLE","text":"Contents Modules cable_abort_module Source Code cable_abort.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Error management for CABLE offline ! ! Contact: Bernard.Pak@csiro.au ! ! History: Developed by Gab Abramowitz and Harvey Davies ! ! ! ============================================================================== MODULE cable_abort_module IMPLICIT NONE CONTAINS !============================================================================== ! ! Name: abort ! ! Purpose: Prints an error message and stops the code ! ! CALLed from: get_default_inits !              get_restart_data !              get_default_lai !              open_met_file !              get_met_data !              load_parameters !              open_output_file !              write_output !              read_gridinfo !              countpatch !              get_type_parameters !              readpar_i !              readpar_r !              readpar_rd !              readpar_r2 !              readpar_r2d !              define_output_variable_r1 !              define_output_variable_r2 !              define_output_parameter_r1 !              define_output_parameter_r2 !              write_output_variable_r1 !              write_output_variable_r2 !              write_output_parameter_r1 !              write_output_parameter_r1d !              write_output_parameter_r2 !              write_output_parameter_r2d ! !============================================================================== SUBROUTINE abort ( message ) ! Input arguments CHARACTER ( LEN =* ), INTENT ( IN ) :: message WRITE ( * , * ) message STOP 1 END SUBROUTINE abort !============================================================================== ! ! Name: nc_abort ! ! Purpose: For NETCDF errors. Prints an error message then stops the code ! ! CALLed from: get_restart_data !              extrarestart !              get_default_lai !              open_met_file !              get_met_data !              close_met_file !              load_parameters !              open_output_file !              write_output !              close_output_file !              create_restart !              read_gridinfo !              readpar_i !              readpar_r !              readpar_rd !              readpar_r2 !              readpar_r2d !              define_output_variable_r1 !              define_output_variable_r2 !              define_output_parameter_r1 !              define_output_parameter_r2 !              write_output_variable_r1 !              write_output_variable_r2 !              write_output_parameter_r1 !              write_output_parameter_r1d !              write_output_parameter_r2 !              write_output_parameter_r2d ! ! MODULEs used: netcdf ! !============================================================================== SUBROUTINE nc_abort ( ok , message ) USE netcdf ! Input arguments CHARACTER ( LEN =* ), INTENT ( IN ) :: message INTEGER , INTENT ( IN ) :: ok WRITE ( * , * ) message ! error from subroutine WRITE ( * , * ) NF90_STRERROR ( ok ) ! netcdf error details STOP END SUBROUTINE nc_abort !============================================================================== ! ! Name: range_abort ! ! Purpose: Prints an error message and localisation information then stops the !          code ! ! CALLed from: write_output_variable_r1 !              write_output_variable_r2 ! ! MODULEs used: cable_def_types_mod !               cable_IO_vars_module ! !============================================================================== SUBROUTINE range_abort ( message , ktau , met , value , var_range , & i , xx , yy ) USE cable_def_types_mod , ONLY : met_type USE cable_IO_vars_module , ONLY : latitude , longitude , landpt , lat_all , lon_all ! Input arguments CHARACTER ( LEN =* ), INTENT ( IN ) :: message INTEGER , INTENT ( IN ) :: & ktau , & ! time step i ! landpt number of erroneous grid square INTEGER , INTENT ( IN ), OPTIONAL :: & xx , & ! coordinates of erroneous grid square yy ! coordinates of erroneous grid square TYPE ( met_type ), INTENT ( IN ) :: met ! met data REAL , INTENT ( IN ) :: value ! value deemed to be out of range REAL , DIMENSION ( 2 ), INTENT ( IN ) :: var_range ! appropriate var range WRITE ( * , * ) \"in SUBR range_abort\" WRITE ( * , * ) message ! error from subroutine IF ( PRESENT ( yy ) ) THEN ! i.e. using rectangular land/sea grid WRITE ( * , * ) 'Site lat, lon:' , lat_all ( xx , yy ), lon_all ( xx , yy ) WRITE ( * , * ) 'Output timestep' , ktau , & ', or ' , met % hod ( landpt ( i )% cstart ), ' hod, ' , & INT ( met % doy ( landpt ( i )% cstart ) ), 'doy, ' , & INT ( met % year ( landpt ( i )% cstart ) ) ELSE ! i.e. using compressed land only grid WRITE ( * , * ) 'Site lat, lon:' , latitude ( i ), longitude ( i ) WRITE ( * , * ) 'Output timestep' , ktau , & ', or ' , met % hod ( landpt ( i )% cstart ), ' hod, ' , & INT ( met % doy ( landpt ( i )% cstart ) ), 'doy, ' , & INT ( met % year ( landpt ( i )% cstart ) ) END IF WRITE ( * , * ) 'Specified acceptable range (checks.f90):' , var_range ( 1 ), & 'to' , var_range ( 2 ) WRITE ( * , * ) 'Value:' , value STOP END SUBROUTINE range_abort !============================================================================== END MODULE cable_abort_module","tags":"","loc":"sourcefile/cable_abort.f90.html"},{"title":"cable_plume_mip.F90 – CABLE","text":"Contents Modules CABLE_PLUME_MIP Source Code cable_plume_mip.F90 Source Code MODULE CABLE_PLUME_MIP USE netcdf USE CABLE_COMMON_MODULE , ONLY : IS_LEAPYEAR , LEAP_DAY USE casa_ncdf_module , ONLY : HANDLE_ERR , GET_UNIT USE cable_IO_vars_module , ONLY : logn , land_x , land_y IMPLICIT NONE ! The whole PLUME information TYPE PLUME_MET_TYPE REAL , DIMENSION (:), ALLOCATABLE :: VAL END TYPE PLUME_MET_TYPE TYPE PLUME_MIP_TYPE INTEGER :: mland , NMET , xdimsize , ydimsize , tdimsize INTEGER :: CYEAR , MetStart , MetEnd , CTSTEP , DT , ktau INTEGER , DIMENSION ( 9 ) :: F_ID , V_ID REAL , DIMENSION (:) , ALLOCATABLE :: AVG_LWDN , CO2VALS LOGICAL :: DirectRead , LeapYears LOGICAL , DIMENSION (:,:), ALLOCATABLE :: LandMask CHARACTER ( len = 15 ) :: Run , Forcing , RCP , CO2 , NDEP , RCPdir CHARACTER ( len = 200 ) :: BasePath , MetPath , LandMaskFile CHARACTER ( len = 12 ) , DIMENSION ( 9 ) :: VAR_NAME CHARACTER ( len = 200 ), DIMENSION ( 9 ) :: MetFile TYPE ( PLUME_MET_TYPE ), DIMENSION ( 11 ) :: MET END TYPE PLUME_MIP_TYPE TYPE ( PLUME_MIP_TYPE ) :: PLUME ! Some local parameters INTEGER , PRIVATE , PARAMETER :: & prec = 1 , & snow = 2 , & lwdn = 3 , & swdn = 4 , & pres = 5 , & rhum = 6 , & tmax = 7 , & tmin = 8 , & wind = 9 , & prevTmax = 10 , & nextTmin = 11 INTEGER , PRIVATE :: STATUS REAL , PRIVATE , PARAMETER :: SecDay = 8640 0. CHARACTER ( len = 6 ), DIMENSION ( 9 ), PARAMETER , PRIVATE :: & PREF = ( / \"pr    \" , \"prsn  \" , \"rlds  \" , \"rsds  \" , \"ps    \" , \"hurs  \" , \"tasmax\" , \"tasmin\" , \"wind  \" / ) CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! PLUME routines !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE PLUME_MIP_INIT ( PLUME ) USE cable_IO_vars_module , ONLY : latitude , longitude , nmetpatches , & mask , metGrid , sdoy , smoy , syear , shod , xdimsize , ydimsize , & lat_all , lon_all USE cable_def_types_mod , ONLY : mland IMPLICIT NONE TYPE ( PLUME_MIP_TYPE ) :: PLUME INTEGER :: STATUS , iu INTEGER :: FID , latID , lonID , landID , timID , tdimsize INTEGER :: cnt , x , y LOGICAL :: DirectRead = . FALSE . LOGICAL :: ERR = . FALSE . CHARACTER ( len = 15 ) :: Run , Forcing , RCP , CO2 , NDEP CHARACTER ( len = 200 ) :: BasePath , LandMaskFile , LMFILE REAL :: DT REAL , DIMENSION (:) , ALLOCATABLE :: plume_lats , plume_lons INTEGER , DIMENSION (:,:), ALLOCATABLE :: landmask NAMELIST / PLUMENML / BasePath , LandMaskFile , Run , Forcing , RCP , CO2 , NDEP , DT , DirectRead ! Read PLUME settings CALL GET_UNIT ( iu ) OPEN ( iu , FILE = \"plume.nml\" , STATUS = 'OLD' , ACTION = 'READ' ) READ ( iu , NML = PLUMENML ) CLOSE ( iu ) PLUME % BasePath = BasePath PLUME % LandMaskFile = LandMaskFile PLUME % Run = Run PLUME % Forcing = Forcing PLUME % RCP = RCP PLUME % CO2 = CO2 PLUME % NDEP = NDEP PLUME % DT = INT ( DT * 360 0. ) ! in seconds PLUME % DirectRead = DirectRead ! Print settings WRITE ( * , * ) \"========================================= PLUME ============\" WRITE ( * , * ) \"PLUME-MIP settings chosen:\" WRITE ( * , * ) \" BasePath: \" , TRIM ( PLUME % BasePath ) WRITE ( * , * ) \" LandMask: \" , TRIM ( PLUME % LandMaskFile ) WRITE ( * , * ) \" Run     : \" , PLUME % Run WRITE ( * , * ) \" Forcing : \" , PLUME % Forcing WRITE ( * , * ) \" RCP     : \" , PLUME % RCP WRITE ( * , * ) \" CO2     : \" , PLUME % CO2 WRITE ( * , * ) \" NDEP    : \" , PLUME % NDEP WRITE ( * , * ) \" DT      : \" , PLUME % DT WRITE ( logn , * ) \"========================================= PLUME ============\" WRITE ( logn , * ) \"PLUME-MIP settings chosen:\" WRITE ( logn , * ) \" BasePath: \" , TRIM ( PLUME % BasePath ) WRITE ( logn , * ) \" LandMask: \" , TRIM ( PLUME % LandMaskFile ) WRITE ( logn , * ) \" Run     : \" , PLUME % Run WRITE ( logn , * ) \" Forcing : \" , PLUME % Forcing WRITE ( logn , * ) \" RCP     : \" , PLUME % RCP WRITE ( logn , * ) \" CO2     : \" , PLUME % CO2 WRITE ( logn , * ) \" NDEP    : \" , PLUME % NDEP WRITE ( logn , * ) \" DT      : \" , PLUME % DT PRINT * , \"DOUBLECHECK FOR EACH CASE IN FILE_SWITCH WHETHER ANNUAL OR OTHER!\" ! check for valid Run Identifier SELECT CASE ( TRIM ( PLUME % Run )) CASE ( \"2006_2099\" ) ; CONTINUE CASE ( \"spinup\" ) IF ( TRIM ( PLUME % CO2 ) . NE . \"static1850\" ) THEN WRITE ( * , * ) \"'spinup' chosen: Set CO2 to 'static1850'!!!\" WRITE ( logn , * ) \"'spinup' chosen: Set CO2 to 'static1850'!!!\" ERR = . TRUE . ENDIF CASE ( \"1850_1900\" ) IF ( TRIM ( PLUME % CO2 ) . NE . \"varying\" ) THEN WRITE ( * , * ) \"'1850_1900' chosen: Set CO2 to 'varying'!!!\" WRITE ( logn , * ) \"'1850_1900' chosen: Set CO2 to 'varying'!!!\" ERR = . TRUE . ENDIF CASE ( \"1901_2001\" ) IF ( TRIM ( PLUME % Forcing ) . NE . \"watch\" ) THEN WRITE ( * , * ) \"Run 1901_2001 must use 'watch' forcing!\" WRITE ( logn , * ) \"Run 1901_2001 must use 'watch' forcing!\" ERR = . TRUE . ENDIF CASE ( \"1901_2005\" ) IF ( TRIM ( PLUME % Forcing ) . EQ . \"watch\" ) THEN WRITE ( * , * ) \"Run 1901_2005 cannot use 'watch' forcing!\" WRITE ( logn , * ) \"Run 1901_2005 cannot use 'watch' forcing!\" ERR = . TRUE . ENDIF CASE default WRITE ( * , * ) \"Wrong PLUME%Run: \" , PLUME % Run WRITE ( * , * ) \"Use: spinup, 1850_1900, 1901_2001, 1901_2005 or 2006_2099!\" WRITE ( logn , * ) \"Wrong PLUME%Run: \" , PLUME % Run WRITE ( logn , * ) \"Use: spinup, 1850_1900, 1901_2001, 1901_2005 or 2006_2099!\" ERR = . TRUE . END SELECT ! check for valid Forcing SELECT CASE ( TRIM ( PLUME % Forcing )) CASE ( \"hadgem2-es\" , \"ipsl-cm5a-lr\" , \"miroc-esm-chem\" , & \"gfdl-esm2m\" , \"noresm1-m\" , \"ccsm4\" , \"watch\" ) ; CONTINUE CASE default WRITE ( * , * ) \"Wrong PLUME%Forcing: \" , PLUME % Forcing WRITE ( * , * ) \"Please choose any of\" WRITE ( * , * ) \" hadgem2-es\" WRITE ( * , * ) \" ipsl-cm5a-lr\" WRITE ( * , * ) \" miroc-esm-chem\" WRITE ( * , * ) \" gfdl-esm2m\" WRITE ( * , * ) \" noresm1-m\" WRITE ( * , * ) \" ccsm4\" WRITE ( * , * ) \" watch\" WRITE ( logn , * ) \"Wrong PLUME%Forcing: \" , PLUME % Forcing WRITE ( logn , * ) \"Please choose any of\" WRITE ( logn , * ) \" hadgem2-es\" WRITE ( logn , * ) \" ipsl-cm5a-lr\" WRITE ( logn , * ) \" miroc-esm-chem\" WRITE ( logn , * ) \" gfdl-esm2m\" WRITE ( logn , * ) \" noresm1-m\" WRITE ( logn , * ) \" ccsm4\" WRITE ( logn , * ) \" watch\" ERR = . TRUE . END SELECT ! check for valid RCP SELECT CASE ( TRIM ( PLUME % RCP )) CASE ( \"hist\" , \"2.6\" , \"4.5\" , \"6.0\" , \"8.5\" ) ; CONTINUE CASE default WRITE ( * , * ) \"Wrong PLUME%RCP: \" , PLUME % RCP WRITE ( * , * ) \"Please choose any of\" WRITE ( * , * ) \" hist, 2.6, 4.5, 6.0, 8.5\" WRITE ( logn , * ) \"Wrong PLUME%RCP: \" , PLUME % RCP WRITE ( logn , * ) \"Please choose any of\" WRITE ( logn , * ) \" hist, 2.6, 4.5, 6.0, 8.5\" ERR = . TRUE . END SELECT ! check for valid CO2 SELECT CASE ( TRIM ( PLUME % CO2 )) CASE ( \"static1850\" , \"static1990\" , \"static2085\" , \"varying\" ) ; CONTINUE CASE default WRITE ( * , * ) \"Wrong PLUME%CO2: \" , PLUME % CO2 WRITE ( * , * ) \"Please choose any of\" WRITE ( * , * ) \" static1850, static1990, static2085, varying\" WRITE ( logn , * ) \"Wrong PLUME%CO2: \" , PLUME % CO2 WRITE ( logn , * ) \"Please choose any of\" WRITE ( logn , * ) \" static1850, static1990, static2085, varying\" ERR = . TRUE . END SELECT IF ( ERR ) THEN WRITE ( logn , * ) \"Invalid settings in PLUME_INIT\" STOP \"Invalid settings in PLUME_INIT\" ENDIF ! Determine paths to met-files re settings IF ( TRIM ( PLUME % Forcing ) . EQ . \"watch\" ) THEN PLUME % MetPath = TRIM ( PLUME % BasePath ) // \"/WATCH/\" ELSE PLUME % MetPath = TRIM ( PLUME % BasePath ) // \"/GCM/\" // TRIM ( PLUME % Forcing ) // \"/\" ENDIF IF ( TRIM ( PLUME % Run ) . EQ . \"spinup\" . OR . TRIM ( PLUME % Run ) . EQ . \"1850_1900\" ) THEN PLUME % MetPath = TRIM ( PLUME % MetPath ) // \"spinup_data/\" ELSE SELECT CASE ( TRIM ( PLUME % RCP )) CASE ( \"hist\" ); PLUME % RCPdir = \"hist\" CASE ( \"2.6\" ); PLUME % RCPdir = \"rcp2p6\" CASE ( \"4.5\" ); PLUME % RCPdir = \"rcp4p5\" CASE ( \"6.0\" ); PLUME % RCPdir = \"rcp6p0\" CASE ( \"8.5\" ); PLUME % RCPdir = \"rcp8p5\" END SELECT PLUME % MetPath = TRIM ( PLUME % MetPath ) // TRIM ( PLUME % RCPdir ) // \"/\" ENDIF ! Set Leap-years according to dataset IF ( TRIM ( PLUME % Forcing ) . EQ . \"watch\" ) THEN PLUME % LeapYears = . FALSE . ELSE PLUME % LeapYears = . TRUE . ENDIF ! Set varialbe names in files PLUME % NMET = 9 IF ( TRIM ( PLUME % Forcing ) . EQ . \"watch\" ) THEN PLUME % VAR_NAME ( prec ) = \"Rainf\" PLUME % VAR_NAME ( snow ) = \"Snowf\" PLUME % VAR_NAME ( lwdn ) = \"LWdown\" PLUME % VAR_NAME ( swdn ) = \"SWdown\" PLUME % VAR_NAME ( pres ) = \"PSurf\" PLUME % VAR_NAME ( rhum ) = \"Qmean\" PLUME % VAR_NAME ( tmax ) = \"Tmax\" PLUME % VAR_NAME ( tmin ) = \"Tmin\" PLUME % VAR_NAME ( wind ) = \"Wind\" ELSE PLUME % VAR_NAME ( prec ) = \"prAdjust\" PLUME % VAR_NAME ( snow ) = \"prsnAdjust\" PLUME % VAR_NAME ( lwdn ) = \"rldsAdjust\" PLUME % VAR_NAME ( swdn ) = \"rsdsAdjust\" PLUME % VAR_NAME ( pres ) = \"psAdjust\" PLUME % VAR_NAME ( rhum ) = \"hurs\" PLUME % VAR_NAME ( tmax ) = \"tasmaxAdjust\" PLUME % VAR_NAME ( tmin ) = \"tasminAdjust\" PLUME % VAR_NAME ( wind ) = \"windAdjust\" END IF WRITE ( * , * ) \"========================================= PLUME ============\" WRITE ( logn , * ) \"========================================= PLUME ============\" ! Now read landmask file ! Landmask file into init! Get LAt, LON etc. from there LMFILE = TRIM ( PLUME % LandMaskFile ) WRITE ( * , * ) 'Opening PLUME landmask file: ' , TRIM ( LMFILE ) WRITE ( logn , * ) 'Opening PLUME landmask file: ' , TRIM ( LMFILE ) STATUS = NF90_OPEN ( TRIM ( LMFILE ), NF90_NOWRITE , FID ) CALL HANDLE_ERR ( STATUS , \"Opening PLUME Land-mask file\" // TRIM ( LMFILE )) ! lat dimension STATUS = NF90_INQ_DIMID ( FID , 'latitude' , latID ) STATUS = NF90_INQUIRE_DIMENSION ( FID , latID , len = ydimsize ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'lat'\" // TRIM ( LMFILE )) PLUME % ydimsize = ydimsize ALLOCATE ( plume_lats ( ydimsize ) ) STATUS = NF90_INQ_VARID ( FID , 'latitude' , latID ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'latitudes'\" // TRIM ( LMFILE )) STATUS = NF90_GET_VAR ( FID , latID , plume_lats ) CALL HANDLE_ERR ( STATUS , \"Reading 'latitudes'\" // TRIM ( LMFILE )) ! lon dimension STATUS = NF90_INQ_DIMID ( FID , 'longitude' , lonID ) STATUS = NF90_INQUIRE_DIMENSION ( FID , lonID , len = xdimsize ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'lon'\" // TRIM ( LMFILE )) PLUME % xdimsize = xdimsize ALLOCATE ( plume_lons ( xdimsize ) ) STATUS = NF90_INQ_VARID ( FID , 'longitude' , lonID ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'longitudes'\" // TRIM ( LMFILE )) STATUS = NF90_GET_VAR ( FID , lonID , plume_lons ) CALL HANDLE_ERR ( STATUS , \"Reading 'longitudes'\" // TRIM ( LMFILE )) ! Allocate PLUME arrays ALLOCATE ( PLUME % landmask ( xdimsize , ydimsize ) ) ALLOCATE ( landmask ( xdimsize , ydimsize ) ) ALLOCATE ( mask ( xdimsize , ydimsize ) ) ! get mask STATUS = NF90_INQ_VARID ( FID , 'land' , landID ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'land' \" // TRIM ( LMFILE )) STATUS = NF90_GET_VAR ( FID , landID , landmask ) CALL HANDLE_ERR ( STATUS , \"Reading 'land' \" // TRIM ( LMFILE )) ! Number of land cells WHERE ( landmask . GT . 0 ) PLUME % landmask = . TRUE . mask = 1 ELSEWHERE PLUME % landmask = . FALSE . mask = 0 END WHERE PLUME % mland = COUNT ( PLUME % landmask ) ! Allocate CABLE arrays ALLOCATE ( latitude ( PLUME % mland ), longitude ( PLUME % mland ) ) ALLOCATE ( land_y ( PLUME % mland ), land_x ( PLUME % mland ) ) DO x = 1 , PLUME % NMET ALLOCATE ( PLUME % MET ( x )% VAL ( PLUME % mland ) ) END DO ! Extra fields for Tmin and Tmax for Weathergenerator ALLOCATE ( PLUME % MET ( prevTmax )% VAL ( PLUME % mland ) ) ALLOCATE ( PLUME % MET ( nextTmin )% VAL ( PLUME % mland ) ) ! Map all to Landgrid arrays cnt = 1 DO y = 1 , ydimsize DO x = 1 , xdimsize IF ( . NOT . PLUME % landmask ( x , y ) ) CYCLE WRITE ( 6 , FMT = '(A15,I5,2(1X,F8.2),2(1x,I3))' ) \"i, lo,la, x,y\" , cnt , plume_lons ( x ), plume_lats ( y ), x , y land_x ( cnt ) = x land_y ( cnt ) = y longitude ( cnt ) = plume_lons ( x ) latitude ( cnt ) = plume_lats ( y ) cnt = cnt + 1 END DO END DO ! set global cable variables metGrid = \"mask\" ALLOCATE ( mask ( xdimsize , ydimsize ) ) mask = landmask mland = PLUME % mland nmetpatches = 1 ALLOCATE ( lat_all ( xdimsize , ydimsize ), lon_all ( xdimsize , ydimsize ) ) DO x = 1 , xdimsize lat_all ( x ,:) = plume_lats END DO DO y = 1 , ydimsize lon_all (:, y ) = plume_lons END DO ! CABLE TIME-UNITS needed by load-parameters (only on CABLE_init) shod = 0. sdoy = 1 smoy = 1 syear = PLUME % CYEAR ! and a PLUME var ALLOCATE ( PLUME % AVG_LWDN ( mland ) ) DEALLOCATE ( landmask , plume_lats , plume_lons ) STATUS = NF90_CLOSE ( FID ) CALL HANDLE_ERR ( STATUS , \"Closing mask-file\" // TRIM ( LMFILE )) END SUBROUTINE PLUME_MIP_INIT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE PLUME_GET_FILENAME ( PLUME , cyear , par , FN ) IMPLICIT NONE TYPE ( PLUME_MIP_TYPE ), INTENT ( INOUT ) :: PLUME INTEGER , INTENT ( IN ) :: cyear , par CHARACTER ( LEN = 200 ), INTENT ( OUT ) :: FN INTEGER :: i , idx CHARACTER :: cy * 4 , sfy * 12 , mp * 200 , fc * 15 , rcp * 15 , ccy * 4 INTEGER , DIMENSION ( 21 ), PARAMETER :: & syear = ( / 1901 , 1911 , 1921 , 1931 , 1941 , 1951 , 1961 , 1971 , 1981 , 1991 , 2001 , & 2006 , 2011 , 2021 , 2031 , 2041 , 2051 , 2061 , 2071 , 2081 , 2091 / ) , & eyear = ( / 1910 , 1920 , 1930 , 1940 , 1950 , 1960 , 1970 , 1980 , 1990 , 2000 , 2005 , & 2010 , 2020 , 2030 , 2040 , 2050 , 2060 , 2070 , 2080 , 2090 , 2099 / ) FN = \"                                                                    \" WRITE ( cy , FMT = '(I4)' ) cyear mp = PLUME % MetPath fc = PLUME % Forcing rcp = PLUME % RCP IF ( TRIM ( fc ) . EQ . \"watch\" ) THEN ! WATCH data comes in annual files IF ( TRIM ( PLUME % Run ) . EQ . \"spinup\" ) THEN IF ( PLUME % DirectRead ) THEN FN = TRIM ( mp ) // \"1901_1930/RECHUNKED_FULL/\" ELSE FN = TRIM ( mp ) // \"1901_1930/ORICHUNKED_D0/\" ENDIF SELECT CASE ( par ) CASE ( prec ) ; FN = TRIM ( FN ) // \"Rainf_daily_WFD_GPCC_TYX_format_detrended_\" CASE ( snow ) ; FN = TRIM ( FN ) // \"Snowf_daily_WFD_GPCC_TYX_format_detrended_\" CASE ( lwdn ) ; FN = TRIM ( FN ) // \"LWdown_daily_WFD_TYX_format_detrended_\" CASE ( swdn ) ; FN = TRIM ( FN ) // \"SWdown_daily_WFD_TYX_format_detrended_\" CASE ( pres ) ; FN = TRIM ( FN ) // \"PSurf_daily_WFD_TYX_format_detrended_\" CASE ( rhum ) ; FN = TRIM ( FN ) // \"Qmean_WFD_TYX_format_detrended_\" CASE ( tmax , PrevTmax ) ; FN = TRIM ( FN ) // \"Tmax_WFD_TYX_format_detrended_\" CASE ( tmin , NextTmin ) ; FN = TRIM ( FN ) // \"Tmin_WFD_TYX_format_detrended_\" CASE ( wind ) ; FN = TRIM ( FN ) // \"Wind_daily_WFD_TYX_format_\" END SELECT FN = TRIM ( FN ) // cy // \".nc\" ELSE IF ( TRIM ( PLUME % Run ) . EQ . \"1850_1900\" ) THEN IF ( PLUME % DirectRead ) THEN FN = TRIM ( mp ) // \"1901_1930/RECHUNKED_FULL/\" ELSE FN = TRIM ( mp ) // \"1901_1930/ORICHUNKED_D0/\" ENDIF SELECT CASE ( par ) CASE ( prec ) ; FN = TRIM ( FN ) // \"Rainf_daily_WFD_GPCC_TYX_format_detrended_\" CASE ( snow ) ; FN = TRIM ( FN ) // \"Snowf_daily_WFD_GPCC_TYX_format_detrended_\" CASE ( lwdn ) ; FN = TRIM ( FN ) // \"LWdown_daily_WFD_TYX_format_detrended_\" CASE ( swdn ) ; FN = TRIM ( FN ) // \"SWdown_daily_WFD_TYX_format_detrended_\" CASE ( pres ) ; FN = TRIM ( FN ) // \"PSurf_daily_WFD_TYX_format_detrended_\" CASE ( rhum ) ; FN = TRIM ( FN ) // \"Qmean_WFD_TYX_format_detrended_\" CASE ( tmax , PrevTmax ) ; FN = TRIM ( FN ) // \"Tmax_WFD_TYX_format_detrended_\" CASE ( tmin , NextTmin ) ; FN = TRIM ( FN ) // \"Tmin_WFD_TYX_format_detrended_\" CASE ( wind ) ; FN = TRIM ( FN ) // \"Wind_daily_WFD_TYX_format_\" END SELECT WRITE ( CCY , FMT = \"(I4.4)\" ) MOD ( cyear + 10 , 30 ) + 1901 FN = TRIM ( FN ) // ccy // \".nc\" ELSE IF ( PLUME % DirectRead ) THEN FN = TRIM ( mp ) // \"RECHUNKED_FULL/\" ELSE FN = TRIM ( mp ) // \"ORICHUNKED_D0/\" ENDIF SELECT CASE ( par ) CASE ( prec ) ; FN = TRIM ( FN ) // \"/Rainf_daily_WFD/Rainf_daily_WFD_GPCC_TYX_format_\" CASE ( snow ) ; FN = TRIM ( FN ) // \"/Snowf_daily_WFD/Snowf_daily_WFD_GPCC_TYX_format_\" CASE ( lwdn ) ; FN = TRIM ( FN ) // \"/LWdown_daily_WFD/LWdown_daily_WFD_TYX_format_\" CASE ( swdn ) ; FN = TRIM ( FN ) // \"/SWdown_daily_WFD/SWdown_daily_WFD_TYX_format_\" CASE ( pres ) ; FN = TRIM ( FN ) // \"/PSurf_daily_WFD/PSurf_daily_WFD_TYX_format_\" CASE ( rhum ) ; FN = TRIM ( FN ) // \"/Qmean_WFD/Qmean_WFD_TYX_format_\" CASE ( tmax , PrevTmax ) ; FN = TRIM ( FN ) // \"/Tmax_WFD/Tmax_WFD_TYX_format_\" CASE ( tmin , NextTmin ) ; FN = TRIM ( FN ) // \"/Tmin_WFD/Tmin_WFD_TYX_format_\" CASE ( wind ) ; FN = TRIM ( FN ) // \"/Wind_daily_WFD/Wind_daily_WFD_TYX_format_\" END SELECT FN = TRIM ( FN ) // cy // \".nc\" ENDIF ELSE ! find proper file for current time ! hist spinup only IF ( TRIM ( PLUME % Run ) . EQ . \"spinup\" ) THEN FN = TRIM ( mp ) // \"/\" // TRIM ( PREF ( par )) IF ( par . NE . rhum ) FN = TRIM ( FN ) // \"Adjust\" FN = TRIM ( FN ) // \"_\" // TRIM ( fc ) // \"_\" // TRIM ( rcp ) // \"_\" IF ( par . NE . wind ) FN = TRIM ( FN ) // \"detrended_\" FN = TRIM ( FN ) // cy ELSE IF ( TRIM ( PLUME % Run ) . EQ . \"1850_1900\" ) THEN STOP \"Not yet implemented! PLUME: GET_FILE_NAMES\" ELSE ! real runs IF ( cyear . LT . syear ( 1 ) . OR . cyear . GT . 2099 ) THEN WRITE ( * , * ) \"Wrong year (Must be 1901 <= y <= 2099) \" , CYEAR WRITE ( logn , * ) \"Wrong year (Must be 1901 <= y <= 2099) \" , CYEAR STOP \"Error in PLUME_GET_FILENAME\" ENDIF idx = SIZE ( syear ) DO i = 1 , SIZE ( syear ) IF ( syear ( i ) . GT . cyear ) THEN idx = i - 1 EXIT ENDIF END DO WRITE ( sfy , FMT = '(I4,A1,I4,A3)' ) syear ( idx ), \"-\" , eyear ( idx ), \".nc\" PLUME % MetStart = syear ( idx ) PLUME % MetEnd = eyear ( idx ) FN = TRIM ( mp ) // \"/\" // TRIM ( PREF ( par )) // \"_\" IF ( . NOT . par . EQ . rhum ) FN = TRIM ( FN ) // \"bced_1960_1999_\" FN = TRIM ( FN ) // TRIM ( fc ) // \"_\" // TRIM ( PLUME % RCPdir ) // \"_\" // sfy END IF END IF END SUBROUTINE PLUME_GET_FILENAME !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! FUNCTION FILE_SWITCH ( PLUME , action ) IMPLICIT NONE TYPE ( PLUME_MIP_TYPE ), INTENT ( IN ) :: PLUME CHARACTER ( len = 5 ) , INTENT ( IN ) :: action LOGICAL :: FILE_SWITCH FILE_SWITCH = . FALSE . IF ( TRIM ( PLUME % Forcing ) . EQ . \"watch\" ) THEN FILE_SWITCH = . TRUE . RETURN ENDIF IF ( INDEX ( action , \"OPEN\" ) . GE . 1 ) THEN !Open files IF ( TRIM ( PLUME % Run ) . EQ . \"spinup\" ) THEN IF ( PLUME % CYEAR . EQ . 1900 ) FILE_SWITCH = . TRUE . ELSE IF ( TRIM ( PLUME % Run ) . EQ . \"1850_1900\" ) THEN !WRONG like spinuup IF ( PLUME % CYEAR . EQ . 1850 . OR . PLUME % CYEAR . EQ . 1880 ) FILE_SWITCH = . TRUE . ELSE IF ( TRIM ( PLUME % Run ) . EQ . \"1901_2005\" ) THEN IF ( MOD ( PLUME % CYEAR - 1 , 10 ) . EQ . 0 ) FILE_SWITCH = . TRUE . ELSE IF ( TRIM ( PLUME % Run ) . EQ . \"2006_2099\" ) THEN IF ( MOD ( PLUME % CYEAR - 1 , 10 ) . EQ . 0 . OR . PLUME % CYEAR . EQ . 2006 ) FILE_SWITCH = . TRUE . ENDIF ELSE IF ( INDEX ( action , \"CLOSE\" ) . GE . 1 ) THEN ! Closing files IF ( TRIM ( PLUME % Run ) . EQ . \"spinup\" ) THEN IF ( PLUME % CYEAR . EQ . 1930 ) FILE_SWITCH = . TRUE . ELSE IF ( TRIM ( PLUME % Run ) . EQ . \"1850_1900\" ) THEN IF ( PLUME % CYEAR . EQ . 1879 . OR . PLUME % CYEAR . EQ . 1900 ) FILE_SWITCH = . TRUE . ELSE IF ( TRIM ( PLUME % Run ) . EQ . \"1901_2005\" ) THEN IF ( MOD ( PLUME % CYEAR , 10 ) . EQ . 0 ) FILE_SWITCH = . TRUE . ELSE IF ( TRIM ( PLUME % Run ) . EQ . \"2006_2099\" ) THEN IF ( MOD ( PLUME % CYEAR , 10 ) . EQ . 0 . OR . PLUME % CYEAR . EQ . 2006 ) FILE_SWITCH = . TRUE . ENDIF ELSE STOP \"Wrong action in PLUME FILE_SWITCH! <OPEN|CLOSE> \" ENDIF END FUNCTION FILE_SWITCH !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE GET_PLUME_CO2 ( PLUME , CO2air ) IMPLICIT NONE TYPE ( PLUME_MIP_TYPE ) :: PLUME REAL , INTENT ( OUT ) :: CO2air INTEGER :: i , iu , f , IOS = 0 CHARACTER :: CO2FILE * 200 IF ( TRIM ( PLUME % Run ) . EQ . \"spinup\" . OR . TRIM ( PLUME % CO2 ) . EQ . \"static1850\" ) THEN ! fixed 1850 value CO2air = 28 4.72501 ELSE IF ( TRIM ( PLUME % CO2 ) . EQ . \"static1990\" ) THEN ! fixed 1990 value CO2air = 35 3.85501 ELSE IF ( TRIM ( PLUME % CO2 ) . EQ . \"static2085\" ) THEN ! fixed 2085 value STOP \" static 2085 not yet implemented! cable_plume_mip.F90\" ELSE ! In 2006 new file must be opened -> old array discarded IF ( ALLOCATED ( PLUME % CO2VALS ) . AND . PLUME % CYEAR . EQ . 2006 ) & DEALLOCATE ( PLUME % CO2VALS ) ! Read from file if none availale IF ( . NOT . ALLOCATED ( PLUME % CO2VALS ) ) THEN IF ( PLUME % CYEAR . LE . 2005 ) THEN ALLOCATE ( PLUME % CO2VALS ( 1850 : 2005 ) ) CO2FILE = TRIM ( PLUME % BasePath ) // \"/CO2/co2_1850_2005_hist.dat\" ELSE ALLOCATE ( PLUME % CO2VALS ( 2006 : 2100 ) ) CO2FILE = TRIM ( PLUME % BasePath ) // \"/CO2/co2_2006_2100_\" SELECT CASE ( TRIM ( PLUME % RCP )) CASE ( \"2.6\" ); CO2FILE = TRIM ( CO2FILE ) // \"rcp2p6.dat\" CASE ( \"4.5\" ); CO2FILE = TRIM ( CO2FILE ) // \"rcp4p5.dat\" CASE ( \"6.0\" ); CO2FILE = TRIM ( CO2FILE ) // \"rcp6p0.dat\" CASE ( \"8.5\" ); CO2FILE = TRIM ( CO2FILE ) // \"rcp8p5.dat\" END SELECT ENDIF ! open CO2 file and read CALL GET_UNIT ( iu ) OPEN ( iu , FILE = TRIM ( CO2FILE ), STATUS = \"OLD\" , ACTION = \"READ\" ) DO WHILE ( IOS . EQ . 0 ) READ ( iu , FMT =* , IOSTAT = IOS ) f , PLUME % CO2VALS ( f ) END DO CLOSE ( iu ) ENDIF CO2air = PLUME % CO2VALS ( PLUME % CYEAR ) ENDIF END SUBROUTINE GET_PLUME_CO2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE OPEN_PLUME_MET ( PLUME ) USE cable_IO_vars_module , ONLY : timeunits IMPLICIT NONE TYPE ( PLUME_MIP_TYPE ) :: PLUME INTEGER :: i , iy , yy , tID INTEGER :: CYEAR LOGICAL , SAVE :: CALL1 = . TRUE . ! find time ! ipsl_cm5a_lr/rcp4p5/hurs_ipsl-cm5a-lr_rcp4p5_2006-2010.nc ! ipsl_cm5a_lr/rcp4p5/pr_bced_1960_1999_ipsl-cm5a-lr_rcp4p5_2006-2010.nc ! Wind_daily_WFD_TYX_format_1901.nc DO i = 1 , PLUME % NMET IF ( TRIM ( PLUME % Run ) . EQ . 'spinup' . AND . & TRIM ( PLUME % FORCING ) . EQ . 'watch' ) THEN CYEAR = MODULO ( PLUME % CYEAR - 1901 , 30 ) + 1901 ELSE CYEAR = PLUME % CYEAR ENDIF CALL PLUME_GET_FILENAME ( PLUME , CYEAR , i , PLUME % MetFile ( i ) ) ! OPEN NEW MET FILES and access variables WRITE ( * , * ) 'Opening met data file: ' , PLUME % MetFile ( i ) WRITE ( logn , * ) 'Opening met data file: ' , PLUME % MetFile ( i ) STATUS = NF90_OPEN ( TRIM ( PLUME % MetFile ( i )), NF90_NOWRITE , PLUME % F_ID ( i )) CALL HANDLE_ERR ( STATUS , \"Opening PLUME file \" // PLUME % MetFile ( i ) ) STATUS = NF90_INQ_VARID ( PLUME % F_ID ( i ), TRIM ( PLUME % VAR_NAME ( i )), PLUME % V_ID ( i )) CALL HANDLE_ERR ( STATUS , \"Inquiring PLUME var \" // TRIM ( PLUME % VAR_NAME ( i )) // & \" in \" // PLUME % MetFile ( i ) ) END DO ! Set internal counter PLUME % CTSTEP = 1 ! For first call there might be an offset IF ( TRIM ( PLUME % FORCING ) . NE . 'watch' . AND . TRIM ( PLUME % Run ) . NE . 'spinup' & . AND . TRIM ( PLUME % Run ) . NE . '1850_1900' & . AND . PLUME % CYEAR . GT . PLUME % MetStart ) THEN DO yy = PLUME % MetStart , PLUME % CYEAR - 1 PLUME % CTSTEP = PLUME % CTSTEP + 365 + LEAP_DAY ( yy ) END DO END IF ! Get unit of time IF ( CALL1 ) THEN STATUS = NF90_INQ_VARID ( PLUME % F_ID ( prec ), 'time' , tID ) CALL HANDLE_ERR ( STATUS , \"Inquiring PLUME time  in \" // PLUME % MetFile ( 1 ) ) STATUS = NF90_GET_ATT ( PLUME % F_ID ( prec ), tID , 'units' , timeunits ) CALL HANDLE_ERR ( STATUS , \"Inquiring PLUME timeunit in \" // PLUME % MetFile ( 1 ) ) ENDIF CALL1 = . FALSE . END SUBROUTINE OPEN_PLUME_MET !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE PLUME_GET_DAILY_MET ( PLUME , TminFlag , islast ) IMPLICIT NONE TYPE ( PLUME_MIP_TYPE ) :: PLUME LOGICAL , INTENT ( IN ) :: TminFlag , islast REAL :: tmparr ( 720 , 360 ), tmp , stmp ( 365 ) INTEGER :: t , i , ii , k , x , y , realk INTEGER :: fid , vid , tid INTEGER :: xds , yds , tds , CYEAR , NYEAR LOGICAL , SAVE :: CALL1 = . TRUE . CHARACTER ( LEN = 200 ) :: filename ! Set previous day's Tmax to current (last step's) Tmax IF ( . NOT . CALL1 ) THEN PLUME % MET ( prevTmax )% VAL (:) = PLUME % MET ( Tmax )% VAL (:) PLUME % MET ( Tmin )% VAL (:) = PLUME % MET ( NextTmin )% VAL (:) ENDIF IF ( TRIM ( PLUME % Run ) . EQ . 'spinup' . AND . & TRIM ( PLUME % FORCING ) . EQ . 'watch' ) THEN CYEAR = MODULO ( PLUME % CYEAR - 1901 , 30 ) + 1901 ELSE CYEAR = PLUME % CYEAR ENDIF xds = PLUME % xdimsize yds = PLUME % ydimsize DO i = 1 , PLUME % NMET IF ( i . EQ . Tmin ) THEN ! Tmin needs to be read from NEXT DAY ii = nextTmin t = PLUME % CTSTEP + 1 ! On first occasion read t=1 as well IF ( CALL1 ) THEN IF ( PLUME % DirectRead ) THEN DO k = 1 , PLUME % mland STATUS = NF90_GET_VAR ( PLUME % F_ID ( i ), PLUME % V_ID ( i ), tmp , & start = ( / land_x ( k ), land_y ( k ), t - 1 / ) ) CALL HANDLE_ERR ( STATUS , \"Reading direct from \" // PLUME % MetFile ( i ) ) PLUME % MET ( i )% VAL ( k ) = tmp END DO ELSE STATUS = NF90_GET_VAR ( PLUME % F_ID ( i ), PLUME % V_ID ( i ), tmparr , & start = ( / 1 , 1 , t - 1 / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // PLUME % MetFile ( i ) ) DO k = 1 , PLUME % mland PLUME % MET ( i )% VAL ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF END IF ELSE ii = i t = PLUME % CTSTEP ENDIF IF ( i . EQ . Tmin . AND . TminFlag ) THEN IF ( . NOT . islast ) THEN ! Open next file for Quick access or use same if very last t-step. t = 1 IF ( TRIM ( PLUME % Run ) . EQ . 'spinup' . AND . & TRIM ( PLUME % FORCING ) . EQ . 'watch' ) THEN NYEAR = MODULO ( PLUME % CYEAR + 1 - 1901 , 30 ) + 1901 ELSE NYEAR = PLUME % CYEAR ENDIF CALL PLUME_GET_FILENAME ( PLUME , NYEAR , Tmin , filename ) STATUS = NF90_OPEN ( TRIM ( filename ), NF90_NOWRITE , fid ) CALL HANDLE_ERR ( STATUS , \"Opening PLUME file \" // filename ) STATUS = NF90_INQ_VARID ( fid , TRIM ( PLUME % VAR_NAME ( i )), vid ) CALL HANDLE_ERR ( STATUS , \"Inquiring PLUME var \" // filename ) IF ( PLUME % DirectRead ) THEN DO k = 1 , PLUME % mland STATUS = NF90_GET_VAR ( fid , vid , PLUME % MET ( ii )% VAL ( k ), & start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( STATUS , \"Reading directly from \" // filename ) END DO ELSE STATUS = NF90_GET_VAR ( fid , vid , tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // filename ) DO k = 1 , PLUME % mland PLUME % MET ( ii )% VAL ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF STATUS = NF90_CLOSE ( fid ) CALL HANDLE_ERR ( STATUS , \"Closing PLUME file \" // filename ) ELSE CONTINUE ! The values simply remain the same ENDIF ELSE ! STANDARD READ ! variables from open files IF ( PLUME % DirectRead ) THEN DO k = 1 , PLUME % mland STATUS = NF90_GET_VAR ( PLUME % F_ID ( i ), PLUME % V_ID ( i ), PLUME % MET ( ii )% VAL ( k ), & start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( STATUS , \"Reading directly from \" // PLUME % MetFile ( i ) ) END DO ELSE STATUS = NF90_GET_VAR ( PLUME % F_ID ( i ), PLUME % V_ID ( i ), tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // PLUME % MetFile ( i ) ) DO k = 1 , PLUME % mland PLUME % MET ( ii )% VAL ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF ENDIF IF ( ( i . EQ . Tmax ) . AND . CALL1 ) THEN ii = prevTmax IF ( CYEAR . GT . 1901 ) THEN ! on CALL PLUME_GET_FILENAME ( PLUME , CYEAR - 1 , i , filename ) STATUS = NF90_OPEN ( TRIM ( filename ), NF90_NOWRITE , fid ) CALL HANDLE_ERR ( STATUS , \"Opening PLUME file \" // filename ) STATUS = NF90_INQ_DIMID ( fid , 'time' , tid ) STATUS = NF90_INQUIRE_DIMENSION ( fid , tid , len = tds ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'time'\" // TRIM ( filename )) STATUS = NF90_INQ_VARID ( fid , TRIM ( PLUME % VAR_NAME ( i )), vid ) CALL HANDLE_ERR ( STATUS , \"Inquiring PLUME var \" // filename ) IF ( PLUME % DirectRead ) THEN DO k = 1 , PLUME % mland STATUS = NF90_GET_VAR ( fid , vid , PLUME % MET ( ii )% VAL ( k ), & start = ( / land_x ( k ), land_y ( k ), tds / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // filename ) END DO ELSE STATUS = NF90_GET_VAR ( fid , vid , tmparr , & start = ( / 1 , 1 , tds / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // filename ) DO k = 1 , PLUME % mland PLUME % MET ( ii )% VAL ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF STATUS = NF90_CLOSE ( fid ) CALL HANDLE_ERR ( STATUS , \"Closing PLUME file \" // filename ) ELSE PLUME % MET ( ii )% VAL (:) = PLUME % MET ( i ) % VAL (:) ENDIF END IF END DO ! Convert pressure Pa -> hPa PLUME % MET ( pres )% VAL (:) = PLUME % MET ( pres )% VAL (:) / 10 0. ! update internal counter PLUME % CTSTEP = PLUME % CTSTEP + 1 ! Wrap up IF ( CALL1 ) CALL1 = . FALSE . END SUBROUTINE PLUME_GET_DAILY_MET !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE PLUME_MIP_GET_MET ( PLUME , MET , CurYear , ktau , kend , islast ) !============================================================================== ! ! Name: open_met_file ! ! Purpose: ! ! ! ! ! ! ! ! ! ! CALLed from: cable_<offline>_driver ! ! CALLs: abort !        nc_abort !        date_and_time ! ! Input file: plume_landmask.nc !             [GSWP_Snowf].nc !             [GSWP_LWdown].nc !             [GSWP_SWdown].nc !             [GSWP_PSurf].nc !             [GSWP_Qair].nc !             [GSWP_Tair].nc !             [GSWP_wind].nc !             [GSWP_Rainf].nc ! !============================================================================== USE cable_def_types_mod , ONLY : MET_TYPE USE cable_IO_vars_module , ONLY : LANDPT , latitude USE casa_ncdf_module , ONLY : DOYSOD2YMDHMS USE cable_weathergenerator , ONLY : WEATHER_GENERATOR_TYPE , WGEN_INIT , & WGEN_DAILY_CONSTANTS , WGEN_SUBDIURNAL_MET USE cable_checks_module , ONLY : rh_sh IMPLICIT NONE INTEGER , INTENT ( IN ) :: CurYear , ktau , kend LOGICAL , INTENT ( IN ) :: islast TYPE ( PLUME_MIP_TYPE ) :: PLUME TYPE ( MET_TYPE ) :: MET LOGICAL :: newday INTEGER :: i , dY , dM , dD , is , ie REAL :: dt , CO2air , etime CHARACTER :: LMFILE * 200 TYPE ( WEATHER_GENERATOR_TYPE ), SAVE :: WG LOGICAL , SAVE :: CALL1 = . TRUE . dt = PLUME % DT ! On first step read and check PLUME settings and read land-mask IF ( CALL1 ) CALL WGEN_INIT ( WG , PLUME % mland , latitude , dt ) ! time-step relevant settings PLUME % CYEAR = CurYear PLUME % ktau = ktau !!!!  this only works with CANBERRA cable_driver, as ktau    !!!! !!!!  restarts on Jan 1                                      !!!! met % hod (:) = REAL ( MOD ( ( ktau - 1 ) * NINT ( dt ), INT ( SecDay )) ) / 360 0. met % doy (:) = INT ( REAL ( ktau - 1 ) * dt / SecDay ) + 1 met % year (:) = Curyear CALL DOYSOD2YMDHMS ( CurYear , INT ( met % doy ( 1 )), INT ( met % hod ( 1 )) * 3600 , dY , dM , dD ) met % moy (:) = dM newday = ( met % hod ( landpt ( 1 )% cstart ). EQ . 0 ) ! Beginning-of-year accounting IF ( ktau . EQ . 1 ) THEN ! Update CO2 CALL GET_PLUME_CO2 ( PLUME , CO2air ) met % ca (:) = CO2air / 1.e+6 ! Open/close Met-files if necessary IF ( FILE_SWITCH ( PLUME , 'OPEN ' ) . OR . CALL1 ) CALL OPEN_PLUME_MET ( PLUME ) ENDIF ! Now get the Met data for this day IF ( newday ) THEN !CALL CPU_TIME(etime) !  PRINT *, 'b4 daily ', etime, ' seconds needed ' CALL PLUME_GET_DAILY_MET ( PLUME , ( ktau . EQ . kend - (( SecDay / dt ) - 1 ) . AND . & FILE_SWITCH ( PLUME , 'CLOSE' )), islast ) !CALL CPU_TIME(etime) !   PRINT *, 'after daily ', etime, ' seconds needed ' !STOP ! Air pressure assumed to be constant over day DO i = 1 , PLUME % mland met % pmb ( landpt ( i )% cstart : landpt ( i )% cend ) = PLUME % MET ( pres )% VAL ( i ) !CLN interpolation?? END DO WG % WindDay = PLUME % MET ( wind )% VAL WG % TempMinDay = PLUME % MET ( Tmin )% VAL - 27 3.15 WG % TempMaxDay = PLUME % MET ( Tmax )% VAL - 27 3.15 WG % TempMinDayNext = PLUME % MET ( NextTmin )% VAL - 27 3.15 WG % TempMaxDayPrev = PLUME % MET ( PrevTmax )% VAL - 27 3.15 WG % SolarMJDay = PLUME % MET ( swdn )% VAL * 1.e-6 * SecDay ! ->[MJ/m2/d] WG % PrecipDay = PLUME % MET ( prec )% VAL * SecDay / 100 0. ! ->[m/d] WG % SnowDay = PLUME % MET ( snow )% VAL * SecDay / 100 0. ! ->[m/d] CALL WGEN_DAILY_CONSTANTS ( WG , PLUME % mland , INT ( met % doy ( 1 )) + 1 ) ! To get the diurnal cycle for lwdn get whole day and scale with ! LWDN from file later PLUME % AVG_LWDN (:) = 0. DO i = 1 , NINT ( SecDay / dt ) CALL WGEN_SUBDIURNAL_MET ( WG , PLUME % mland , i - 1 ) PLUME % AVG_LWDN = PLUME % AVG_LWDN + WG % PhiLD END DO PLUME % AVG_LWDN = PLUME % AVG_LWDN / ( SecDay / dt ) END IF ! Decision has been made, that first tstep of the day is at 0:01 am CALL WGEN_SUBDIURNAL_MET ( WG , PLUME % mland , NINT ( met % hod ( 1 ) * 360 0. / dt ) ) ! assign to cable variables ! strangely, met% is not save over Wait all in MPI...! !  met%pmb = PLUME%MET(pres)%VAL !CLN interpolation?? DO i = 1 , PLUME % mland is = landpt ( i )% cstart ie = landpt ( i )% cend met % precip ( is : ie ) = WG % Precip ( i ) + WG % Snow ( i ) met % precip_sn ( is : ie ) = WG % Snow ( i ) met % fld ( is : ie ) = PLUME % MET ( lwdn )% VAL ( i ) * WG % PhiLD ( i ) / PLUME % AVG_LWDN ( i ) met % fsd ( is : ie , 1 ) = WG % PhiSD ( i ) * 0.5 met % fsd ( is : ie , 2 ) = WG % PhiSD ( i ) * 0.5 met % tk ( is : ie ) = WG % Temp ( i ) + 27 3.15 met % ua ( is : ie ) = WG % Wind ( i ) met % coszen ( is : ie ) = WG % coszen ( i ) ! compute qv ! CALL rh_sh ( PLUME%MET(rhum)%VAL(i), met%tk(is), met%pmb(is), met%qv(is) ) ! met%qv        (is:ie)   = met%qv(is) met % qv ( is : ie ) = PLUME % MET ( rhum )% VAL ( i ) END DO ! initialise within canopy air temp met % tvair = met % tk met % tvrad = met % tk !!$write(*,*) \"met\", met%precip(1), & !!$met%precip_sn (is:ie)  , & !!$     met%fld       (is:ie), & !!$     met%fsd       (is:ie,1), & !!$     met%fsd       (is:ie,2), & !!$     met%tk        (is:ie) , & !!$     met%ua        (is:ie)  , & !!$     met%coszen    (is:ie) !CLN  IF ( ktau.EQ.1 ) & !CLN       WRITE(*,*)\"#    qv       Precip   snow   LWDin  PhiLD   rPhiLD   PhiSD Temp     Wind     coszen\" !Test write out !  IF ( ktau .lt. 100 ) THEN !CLN     DO i = 1, PLUME%MLAND !CLN       WRITE(*,FMT='(I4,3(X,F8.5),X,3(F6.1,x),F7.3,2(X,F6.1),3(X,ES12.4))')& !CLN       i, met%qv(i), & !CLN       WG%Precip(i), met%precip_sn(i), PLUME%MET(lwdn)%VAL(i), & !CLN       met%fld(i), WG%PhiLD(i) , WG%PhiSD(i) , met%tk(i) , WG%Wind(i), & !CLN       WG%coszen(i) !CLN    ENDDO ! ENDIF ! Finally closing files when done IF (( ktau . EQ . kend . AND . FILE_SWITCH ( PLUME , 'CLOSE' )) . OR . islast ) THEN DO i = 1 , PLUME % NMET STATUS = NF90_CLOSE ( PLUME % F_ID ( i )) CALL HANDLE_ERR ( STATUS , \"Closing PLUME file\" // PLUME % MetFile ( i )) END DO END IF ! CALL1 is over... CALL1 = . FALSE . END SUBROUTINE PLUME_MIP_GET_MET END MODULE CABLE_PLUME_MIP","tags":"","loc":"sourcefile/cable_plume_mip.f90.html"},{"title":"cable_mpicommon.F90 – CABLE","text":"Contents Modules cable_mpicommon Source Code cable_mpicommon.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: common modules for MPI wrapper for CABLE ! ! Contact: Bernard.Pak@csiro.au ! ! History: MPI wrapper developed by Maciej Golebiewski (2012) ! ! ============================================================================== ! MODULE cable_mpicommon USE cable_def_types_mod IMPLICIT NONE SAVE PUBLIC ! base number of input fields: must correspond to CALLS to ! MPI_address (field ) in *_mpimaster/ *_mpiworker INTEGER , PARAMETER :: nparam = 330 ! MPI: extra params sent only if nsoilparmnew is true INTEGER , PARAMETER :: nsoilnew = 1 ! MPI: number of casa parameters sent to workers as ! start up parameters ! MPI: added casapool fields ratioNCsoilnew, ratioNCsoilmin and ratioNCsoilmax INTEGER , PARAMETER :: ncasaparam = 213 ! YPW to account for 3 aditional woodproduct pools ! MPI: base number of casa_init parameters sent to the workers INTEGER , PARAMETER :: ncinit = 18 ! MPI: number of casa_init parameters sent to the workers only if ! icycle = 2 or 3 INTEGER , PARAMETER :: ncinit2 = 13 ! MPI: number of casa_init parameters sent to the workers only if ! icycle = 3 INTEGER , PARAMETER :: ncinit3 = 18 ! MPI: number of casa_dump parameters sent/rec'd to/from the workers every ! timestep INTEGER , PARAMETER :: ncdumprw = 8 !reduced from 9 - #294 ! MPI: number of casa_LUC parameters sent/rec'd to/from the workers every ! year INTEGER , PARAMETER :: nLUCrw = 12 ! MPI: number of pop parameters sent/rec'd to/from the workers every ! timestep or at start, end. Here, with POP the dimensions are separate! INTEGER , PARAMETER :: npop = 988 ! MPI: number of input fields sent to workers at the start of each ! timestep !INTEGER, PARAMETER :: ninput = 11 ! added 4 time fields in met: year, moy, doy, hod INTEGER , PARAMETER :: ninput = 16 ! MPI: number of 3D array slices / worker (results) INTEGER , PARAMETER :: n3d = 1 ! MPI: number of matrix slices / worker (results) !INTEGER, PARAMETER :: nmat = 29 ! MPI: 2011-07-08 - removed dtmlt from data exchange !INTEGER, PARAMETER :: nmat = 28 ! MPI: gol124: net +1 when Bernard ported to CABLE_r491 !INTEGER, PARAMETER :: nmat = 29 ! MPI: CABLE_r491, after following up with Bernard on the new variables ! vh sli nmat + 4 36 -> 40 INTEGER , PARAMETER :: nmat = 40 ! MPI: number of contig vector parts / worker (results) !INTEGER, PARAMETER :: nvec = 149 ! MPI: 2011-06-28 - removed ebal, ebal_tot, seb, seb_tot from data exchange !INTEGER, PARAMETER :: nvec = 145 ! MPI: 2011-07-08 - removed otss from data exchange ! INTEGER, PARAMETER :: nvec = 144 ! MPI: 2012-02-14 - removed year, moy, doy, hod !INTEGER, PARAMETER :: nvec = 140 ! MPI: gol124: net -3 (removed or changed to 2D) when Bernard ! ported to CABLE_r491 !INTEGER, PARAMETER :: nvec = 137 ! MPI: CABLE_r491, after following up with Bernard on the new variables ! vh sli nvec + 6 162 -> 168 ! INTEGER, PARAMETER :: nvec = 172! 168 ! INH REV_CORR +3  (SSEB +2 will be needed) INTEGER , PARAMETER :: nvec = 175 ! MPI: number of final casa result matrices and vectors to receive ! by the master for casa_poolout and casa_fluxout INTEGER , PARAMETER :: ncasa_mat = 37 ! add three more wood product variables INTEGER , PARAMETER :: ncasa_vec = 58 ! vh changed on 5-feb-2016 for adding sapwood area and frac_sapwood ! MPI: number of fields included in restart_t type for data ! that is returned only for creating a restart file at the end of the run ! MPI: gol124: canopy%rwater removed when Bernard ported to CABLE_r491 INTEGER , PARAMETER :: nrestart = 15 INTEGER , PARAMETER :: nsumcasaflux = 62 INTEGER , PARAMETER :: nsumcasapool = 40 INTEGER , PARAMETER :: nclimate = 30 INTEGER , PARAMETER :: nphen = 9 ! MPI: type to hold landpoint decomposition info TYPE lpdecomp_t INTEGER :: landp0 ! starting land point index INTEGER :: nland ! number of landpoints INTEGER :: patch0 ! starting patch index in global CABLE vars INTEGER :: npatch ! sum of patches for all landpoints of this ! worker INTEGER :: npop_iwood ! number of pop-patches for each worker INTEGER , ALLOCATABLE :: iwood (:) ! number of pop-patches for each worker END TYPE lpdecomp_t ! MPI: worker's local landpoints and patches TYPE ( lpdecomp_t ) :: wpatch ! MPI: Fortran types extents INTEGER :: extr1 , extr2 , extid , extl CONTAINS ! calculates extents of the Fortran types used by CABLE SUBROUTINE find_extents USE mpi USE cable_def_types_mod IMPLICIT NONE INTEGER , DIMENSION ( 2 ) :: itmp REAL , DIMENSION ( 2 ) :: r1tmp REAL ( r_2 ), DIMENSION ( 2 ) :: r2tmp LOGICAL , DIMENSION ( 2 ) :: ltmp INTEGER ( KIND = MPI_ADDRESS_KIND ), DIMENSION ( 2 ) :: a INTEGER :: ierr CALL MPI_Get_address ( itmp ( 1 ), a ( 1 ), ierr ) CALL MPI_Get_address ( itmp ( 2 ), a ( 2 ), ierr ) extid = INT ( a ( 2 ) - a ( 1 )) CALL MPI_Get_address ( r1tmp ( 1 ), a ( 1 ), ierr ) CALL MPI_Get_address ( r1tmp ( 2 ), a ( 2 ), ierr ) extr1 = INT ( a ( 2 ) - a ( 1 )) CALL MPI_Get_address ( r2tmp ( 1 ), a ( 1 ), ierr ) CALL MPI_Get_address ( r2tmp ( 2 ), a ( 2 ), ierr ) extr2 = INT ( a ( 2 ) - a ( 1 )) CALL MPI_Get_address ( ltmp ( 1 ), a ( 1 ), ierr ) CALL MPI_Get_address ( ltmp ( 2 ), a ( 2 ), ierr ) extl = INT ( a ( 2 ) - a ( 1 )) END SUBROUTINE find_extents ! creates MPI derived datatypes for exchanging landpt and patch arrays SUBROUTINE decomp_types ( landpt_t , patch_t ) USE mpi USE cable_IO_vars_module IMPLICIT NONE INTEGER , INTENT ( OUT ) :: landpt_t , patch_t ! dummy vars to calculate field offsets TYPE ( land_type ) :: dlandpt ( 2 ) TYPE ( patch_type ) :: dpatch ( 2 ) INTEGER ( KIND = MPI_ADDRESS_KIND ) :: base_d , el2 , text INTEGER , PARAMETER :: fields = 5 INTEGER , DIMENSION ( fields ) :: blocks , types INTEGER ( KIND = MPI_ADDRESS_KIND ), DIMENSION ( fields ) :: displs ! temp variable for lower bound parameter when setting extent INTEGER ( KIND = MPI_ADDRESS_KIND ) :: lb INTEGER :: tmp_t , ierr lb = 0 blocks = 1 ! create MPI type to exchange landpt records types = MPI_INTEGER CALL MPI_Get_address ( dlandpt ( 1 ), base_d , ierr ) CALL MPI_Get_address ( dlandpt ( 1 )% nap , displs ( 1 ), ierr ) CALL MPI_Get_address ( dlandpt ( 1 )% cstart , displs ( 2 ), ierr ) CALL MPI_Get_address ( dlandpt ( 1 )% cend , displs ( 3 ), ierr ) CALL MPI_Get_address ( dlandpt ( 1 )% ilat , displs ( 4 ), ierr ) CALL MPI_Get_address ( dlandpt ( 1 )% ilon , displs ( 5 ), ierr ) displs = displs - base_d CALL MPI_Type_create_struct ( 5 , blocks , displs , types , tmp_t , ierr ) CALL MPI_Type_commit ( tmp_t , ierr ) ! make sure the type has correct extent for use in arrays CALL MPI_Get_Address ( dlandpt ( 2 ), el2 , ierr ) text = el2 - base_d CALL MPI_Type_create_resized ( tmp_t , lb , text , landpt_t , ierr ) CALL MPI_Type_commit ( landpt_t , ierr ) ! create MPI type to exchange patch records types = MPI_REAL CALL MPI_Get_address ( dpatch ( 1 ), base_d , ierr ) CALL MPI_Get_address ( dpatch ( 1 )% frac , displs ( 1 ), ierr ) CALL MPI_Get_address ( dpatch ( 1 )% latitude , displs ( 2 ), ierr ) CALL MPI_Get_address ( dpatch ( 1 )% longitude , displs ( 3 ), ierr ) displs = displs - base_d CALL MPI_Type_create_struct ( 3 , blocks , displs , types , tmp_t , ierr ) CALL MPI_Type_commit ( tmp_t , ierr ) ! make sure the type has correct extent for use in arrays CALL MPI_Get_Address ( dpatch ( 2 ), el2 , ierr ) text = el2 - base_d CALL MPI_Type_create_resized ( tmp_t , lb , text , patch_t , ierr ) CALL MPI_Type_commit ( patch_t , ierr ) RETURN END SUBROUTINE decomp_types SUBROUTINE bcast_start_time ( comm ) USE mpi USE cable_IO_vars_module IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm INTEGER :: ierr CALL MPI_Bcast ( shod , 1 , MPI_REAL , 0 , comm , ierr ) CALL MPI_Bcast ( sdoy , 1 , MPI_INTEGER , 0 , comm , ierr ) CALL MPI_Bcast ( smoy , 1 , MPI_INTEGER , 0 , comm , ierr ) CALL MPI_Bcast ( syear , 1 , MPI_INTEGER , 0 , comm , ierr ) CALL MPI_Bcast ( time_coord , 3 , MPI_CHARACTER , 0 , comm , ierr ) RETURN END SUBROUTINE bcast_start_time END MODULE cable_mpicommon","tags":"","loc":"sourcefile/cable_mpicommon.f90.html"},{"title":"landuse_inout.F90 – CABLE","text":"Contents Subroutines landuse_data landuse_getxluh2 landuse_getdata create_new_gridinfo rangechk2 rangechk3 sort WRITE_LANDUSE_CASA_RESTART_NC create_landuse_cable_restart Source Code landuse_inout.F90 Source Code subroutine landuse_data ( mlon , mlat , landmask , arealand , luc_atransit , luc_fharvw , luc_xluh2cable ) use netcdf use cable_abort_module , ONLY : nc_abort use cable_common_module , ONLY : filename USE cable_def_types_mod , ONLY : mland , r_2 use landuse_constant , ONLY : mstate , mvmax , mharvw IMPLICIT NONE integer mlon , mlat real ( r_2 ), dimension ( mland , mvmax , mvmax ) :: luc_atransit real ( r_2 ), dimension ( mland , mharvw ) :: luc_fharvw real ( r_2 ), dimension ( mland , mvmax , mstate ) :: luc_xluh2cable integer , dimension ( mlon , mlat ) :: landmask real ( r_2 ), dimension ( mland ) :: arealand ! \"mland\" variables real ( r_2 ), dimension (:,:), allocatable :: areax ! integer ivt , ee , hh , np , p , q , np1 integer ncid , ok , xID , yID , varID , i , j , m , mpx ! get \" mlon mlat landmask\" from \"gridinfo\" ok = NF90_OPEN ( filename % type , 0 , ncid ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error opening grid info file.' ) ok = NF90_INQ_DIMID ( ncid , 'longitude' , xID ) IF ( ok /= NF90_NOERR ) ok = NF90_INQ_DIMID ( ncid , 'x' , xID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring x dimension.' ) ok = NF90_INQUIRE_DIMENSION ( ncid , xID , LEN = mlon ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting x dimension.' ) ok = NF90_INQ_DIMID ( ncid , 'latitude' , yID ) IF ( ok /= NF90_NOERR ) ok = NF90_INQ_DIMID ( ncid , 'y' , yID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring y dimension.' ) ok = NF90_INQUIRE_DIMENSION ( ncid , yID , LEN = mlat ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting y dimension.' ) allocate ( areax ( mlon , mlat )) ok = NF90_INQ_VARID ( ncid , 'area' , varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error finding variable area' ) ok = NF90_GET_VAR ( ncid , varID , areax ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error reading variable longitude.' ) ok = NF90_CLOSE ( ncid ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error closing grid info file.' ) m = 0 ; arealand = 0.0 do i = 1 , mlon do j = 1 , mlat if ( areax ( i , j ) > 0.01 ) then landmask ( i , j ) = 1 m = m + 1 arealand ( m ) = areax ( i , j ) else landmask ( i , j ) = 0 endif enddo enddo if ( m /= mland ) then print * , 'mland not consistent: check gridinof area' stop endif ! get the mapping matrix (landuse type to PFT) call landuse_getxluh2 ( mlat , mlon , landmask , filename % fxluh2cable , luc_xluh2cable ) !\"xluh2cable\" call landuse_getdata ( mlat , mlon , landmask , filename % fxpft , luc_atransit , luc_fharvw ) end subroutine landuse_data SUBROUTINE landuse_getxluh2 ( mlat , mlon , landmask , fxluh2cable , luc_xluh2cable ) ! get data: luc%fprimary; luc%fsecondary USE netcdf USE cable_def_types_mod , ONLY : mland , r_2 use landuse_constant , ONLY : mstate , mvmax IMPLICIT NONE character * 500 fxluh2cable integer mlat , mlon integer , dimension ( mlon , mlat ) :: landmask real ( r_2 ), dimension ( mland , mvmax , mstate ) :: luc_xluh2cable ! local variables real ( r_2 ), dimension (:,:,:,:), allocatable :: xluh2cable integer ok , ncid2 , varxid integer i , j , k , m , v , s allocate ( xluh2cable ( mlon , mlat , 21 , mstate )) ok = nf90_open ( fxluh2cable , nf90_nowrite , ncid2 ) ok = nf90_inq_varid ( ncid2 , \"xluh2cable\" , varxid ) ok = nf90_get_var ( ncid2 , varxid , xluh2cable ) ok = nf90_close ( ncid2 ) ! assig the values of luc%variables luc_xluh2cable (:,:,:) = 0.0 m = 0 do i = 1 , mlon do j = 1 , mlat if ( landmask ( i , j ) == 1 ) then m = m + 1 do k = 1 , 10 luc_xluh2cable ( m , k ,:) = xluh2cable ( i , j , k ,:) enddo luc_xluh2cable ( m , 16 ,:) = xluh2cable ( i , j , 11 ,:) + xluh2cable ( i , j , 16 ,:) luc_xluh2cable ( m , 14 ,:) = xluh2cable ( i , j , 14 ,:) luc_xluh2cable ( m , 15 ,:) = xluh2cable ( i , j , 15 ,:) luc_xluh2cable ( m , 17 ,:) = xluh2cable ( i , j , 17 ,:) luc_xluh2cable ( m , 11 ,:) = xluh2cable ( i , j , 18 ,:) luc_xluh2cable ( m , 12 ,:) = xluh2cable ( i , j , 19 ,:) luc_xluh2cable ( m , 13 ,:) = xluh2cable ( i , j , 21 ,:) do s = 1 , mstate do v = 1 , mvmax luc_xluh2cable ( m , v , s ) = luc_xluh2cable ( m , v , s ) / sum ( luc_xluh2cable ( m , 1 : mvmax , s )) enddo enddo endif enddo enddo deallocate ( xluh2cable ) END SUBROUTINE landuse_getxluh2 SUBROUTINE landuse_getdata ( mlat , mlon , landmask , fxpft , luc_atransit , luc_fharvw ) ! get LUC data USE netcdf USE cable_def_types_mod , ONLY : mland , r_2 use landuse_constant , ONLY : mstate , mvmax , mharvw IMPLICIT NONE character * 500 fxpft integer mlat , mlon integer , dimension ( mlon , mlat ) :: landmask real ( r_2 ), dimension ( mland , mvmax , mvmax ) :: luc_atransit real ( r_2 ), dimension ( mland , mharvw ) :: luc_fharvw ! local variables real ( r_2 ), dimension (:,:,:), allocatable :: fracharvw real ( r_2 ), dimension (:,:,:,:), allocatable :: transitx integer ok , ncid1 , varxid integer i , j , m , k , ivt allocate ( fracharvw ( mlon , mlat , mharvw )) allocate ( transitx ( mlon , mlat , mvmax , mvmax )) ok = nf90_open ( fxpft , nf90_nowrite , ncid1 ) ok = nf90_inq_varid ( ncid1 , \"harvest\" , varxid ) ok = nf90_get_var ( ncid1 , varxid , fracharvw ) ok = nf90_inq_varid ( ncid1 , \"transition\" , varxid ) ok = nf90_get_var ( ncid1 , varxid , transitx ) ok = nf90_close ( ncid1 ) ! assig the values of luc%variables luc_fharvw (:,:) = 0.0 ; luc_atransit (:,:,:) = 0.0 m = 0 do i = 1 , mlon do j = 1 , mlat if ( landmask ( i , j ) == 1 ) then m = m + 1 luc_atransit ( m ,:,:) = transitx ( i , j ,:,:) luc_fharvw ( m ,:) = fracharvw ( i , j ,:) endif enddo enddo deallocate ( fracharvw ) deallocate ( transitx ) END SUBROUTINE landuse_getdata subroutine create_new_gridinfo ( fgridold , fgridnew , mlon , mlat , landmask , patchfrac_new ) use netcdf use cable_abort_module , ONLY : nc_abort use cable_common_module , ONLY : filename USE cable_def_types_mod , ONLY : r_2 , nrb , ms USE cable_IO_vars_module , ONLY : logn use landuse_constant , ONLY : mvmax , thresh_frac implicit none character * 500 fgridold , fgridnew integer mlon , mlat integer , dimension ( mlon , mlat ) :: landmask real ( r_2 ), dimension ( mlon , mlat , mvmax ) :: patchfrac_new ! local variables integer , parameter :: missint = - 99999 real , parameter :: missreal = 1.0e23 integer , parameter :: time12 = 12 integer , dimension ( mlon , mlat ) :: isoil_y , soilorder_y real ( r_2 ), dimension ( mlon , mlat ) :: ndep_y , nfix_y , pdust_y , pwea_y real ( r_2 ), dimension ( mlon , mlat , nrb ) :: albedo_y real ( r_2 ), dimension ( mlon ) :: longitude_y real ( r_2 ), dimension ( mlat ) :: latitude_y real ( r_2 ), dimension ( mlon , mlat , time12 ) :: lai_y , snowdepth_y real ( r_2 ), dimension ( mlon , mlat , ms , time12 ) :: soilmoist_y , soiltemp_y real ( r_2 ), dimension ( mlon , mlat ) :: albedo2_y , area_y real ( r_2 ), dimension ( mlon , mlat ) :: bch_y , clay_y , cnsd_y , css_y , hyds_y , rhosoil_y , & sand_y , sfc_y , silt_y , ssat_y , sucs_y , swilt_y real ( r_2 ), dimension ( mlon , mlat , mvmax ) :: patchfrac_y integer , dimension ( mlon , mlat , mvmax ) :: iveg_y integer , dimension ( mvmax ) :: tmpint real ( r_2 ), dimension ( mvmax ) :: tmpx ! integer dim_radid , dim_mlatid , dim_mlonid , dim_timeid , dim_patchid , dim_soilid integer var_albedoid , var_laiid , var_ndepid , var_nfixid , var_pdustid , var_pweaid integer var_snowdepthid , var_soilmoistid , var_soilorderid , var_soiltempid integer var_albedo2id , var_areaid , var_bchid , var_clayid , var_cnsdid , var_cssid integer var_hydsid , var_isoilid , var_latitudeid , var_longitudeid , var_rhosoilid integer var_sandid , var_sfcid , var_siltid , var_ssatid , var_sucsid , var_swiltid integer var_ivegid , var_patchfracid integer varxid integer ncid0 , ncid11 , ok integer i , j , k ! then set non-land patch vegtype to -1 ! then order patch within each land cell by area fraction from largest to the smallest ! sort patch by area fraction patchfrac_y = 0.0 do j = 1 , mlat do i = 1 , mlon if ( landmask ( i , j ) == 1 ) then do k = 1 , mvmax tmpx ( k ) = patchfrac_new ( i , j , k ) tmpint ( k ) = k enddo call sort ( mvmax , tmpx , tmpint ) do k = 1 , mvmax patchfrac_y ( i , j , k ) = tmpx ( k ) if ( patchfrac_y ( i , j , k ) >= thresh_frac ) then iveg_y ( i , j , k ) = tmpint ( k ) else iveg_y ( i , j , k ) = - 1 endif enddo else iveg_y ( i , j ,:) = - 1 patchfrac_y ( i , j ,:) = 0.0 endif enddo enddo write ( logn , * ) 'landuse on: create new gridinfo' ok = NF90_OPEN ( fgridold , 0 , ncid0 ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'file opening error' ) ok = NF90_INQ_VARID ( ncid0 , 'latitude' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , latitude_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading latitude' ) ok = NF90_INQ_VARID ( ncid0 , 'longitude' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , longitude_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in longitude' ) ok = NF90_INQ_VARID ( ncid0 , 'area' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , area_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in area' ) ok = NF90_INQ_VARID ( ncid0 , 'isoil' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , isoil_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading isoil' ) ok = NF90_INQ_VARID ( ncid0 , 'SoilOrder' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , soilorder_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading SoilOrder' ) ok = NF90_INQ_VARID ( ncid0 , 'SnowDepth' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , snowdepth_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading SnowDepth' ) ok = NF90_INQ_VARID ( ncid0 , 'LAI' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , lai_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading LAI' ) ok = NF90_INQ_VARID ( ncid0 , 'SoilMoist' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , soilmoist_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading SoilMoist' ) ok = NF90_INQ_VARID ( ncid0 , 'SoilTemp' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , soiltemp_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading SoilTemp' ) ok = NF90_INQ_VARID ( ncid0 , 'Albedo' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , albedo_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading Albedo' ) ok = NF90_INQ_VARID ( ncid0 , 'albedo2' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , albedo2_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading albedo2' ) ok = NF90_INQ_VARID ( ncid0 , 'bch' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , bch_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading bch' ) ok = NF90_INQ_VARID ( ncid0 , 'clay' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , clay_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading clay' ) ok = NF90_INQ_VARID ( ncid0 , 'cnsd' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , cnsd_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading cnsd' ) ok = NF90_INQ_VARID ( ncid0 , 'css' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , css_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading css' ) ok = NF90_INQ_VARID ( ncid0 , 'hyds' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , hyds_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading hyds' ) ok = NF90_INQ_VARID ( ncid0 , 'rhosoil' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , rhosoil_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading rhosoil' ) ok = NF90_INQ_VARID ( ncid0 , 'sand' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , sand_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading sand' ) ok = NF90_INQ_VARID ( ncid0 , 'sfc' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , sfc_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading sfc' ) ok = NF90_INQ_VARID ( ncid0 , 'silt' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , silt_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading silt' ) ok = NF90_INQ_VARID ( ncid0 , 'ssat' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , ssat_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading ssat' ) ok = NF90_INQ_VARID ( ncid0 , 'sucs' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , sucs_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading sucs' ) ok = NF90_INQ_VARID ( ncid0 , 'swilt' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , swilt_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading swilt' ) ok = NF90_INQ_VARID ( ncid0 , 'Ndep' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , ndep_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading Ndep' ) ok = NF90_INQ_VARID ( ncid0 , 'Nfix' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , nfix_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading Nfix' ) ok = NF90_INQ_VARID ( ncid0 , 'Pdust' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , pdust_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading Pdust' ) ok = NF90_INQ_VARID ( ncid0 , 'Pwea' , varxid ) ok = NF90_GET_VAR ( ncid0 , varxid , pwea_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in reading Pwea' ) ok = nf90_close ( ncid0 ) ! ! create ACCESS ESM pool size file ok = nf90_create ( fgridnew , nf90_clobber , ncid11 ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in opening fgridnew' ) ! define dimensions ok = nf90_def_dim ( ncid11 , 'rad' , nrb , dim_radid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining rad' ) ok = nf90_def_dim ( ncid11 , 'latitude' , mlat , dim_mlatid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining latitude' ) ok = nf90_def_dim ( ncid11 , 'longitude' , mlon , dim_mlonid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining longitude' ) ok = nf90_def_dim ( ncid11 , 'time' , 12 , dim_timeid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining time' ) ok = nf90_def_dim ( ncid11 , 'soil' , ms , dim_soilid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining soil' ) ok = nf90_def_dim ( ncid11 , 'patch' , mvmax , dim_patchid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patch' ) ! define variables ok = nf90_def_var ( ncid11 , 'Albedo' , nf90_float ,( / dim_mlonid , dim_mlatid , dim_radid / ), var_albedoid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Albedo' ) ok = nf90_put_att ( ncid11 , var_albedoid , 'units' , ' ---' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Albedo' ) ok = nf90_put_att ( ncid11 , var_albedoid , 'long_name' , ' snow-free bareground albedo' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Albedo' ) ok = nf90_put_att ( ncid11 , var_albedoid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patch' ) ok = nf90_put_att ( ncid11 , var_albedoid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patch' ) ok = nf90_def_var ( ncid11 , 'LAI' , nf90_float ,( / dim_mlonid , dim_mlatid , dim_timeid / ), var_laiid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining LAI' ) ok = nf90_put_att ( ncid11 , var_laiid , 'units' , ' ---' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining LAI' ) ok = nf90_put_att ( ncid11 , var_laiid , 'long_name' , ' monthly canopy LAI' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining LAI' ) ok = nf90_put_att ( ncid11 , var_laiid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining LAI' ) ok = nf90_put_att ( ncid11 , var_laiid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining LAI' ) ok = nf90_def_var ( ncid11 , 'Ndep' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_ndepid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Ndep' ) ok = nf90_put_att ( ncid11 , var_ndepid , 'units' , ' gN m-2 yr-1' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Ndep' ) ok = nf90_put_att ( ncid11 , var_ndepid , 'long_name' , ' Annual N deposition' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Ndep' ) ok = nf90_put_att ( ncid11 , var_ndepid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Ndep' ) ok = nf90_put_att ( ncid11 , var_ndepid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Ndep' ) ok = nf90_def_var ( ncid11 , 'Nfix' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_nfixid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Nfix' ) ok = nf90_put_att ( ncid11 , var_nfixid , 'units' , ' gN m-2 yr-1' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Nfix' ) ok = nf90_put_att ( ncid11 , var_nfixid , 'long_name' , ' Annual N fixation' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Nfix' ) ok = nf90_put_att ( ncid11 , var_nfixid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Nfix' ) ok = nf90_put_att ( ncid11 , var_nfixid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Nfix' ) ok = nf90_def_var ( ncid11 , 'Pdust' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_pdustid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patch' ) ok = nf90_put_att ( ncid11 , var_pdustid , 'units' , ' gP m-2 yr-1' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pdust' ) ok = nf90_put_att ( ncid11 , var_pdustid , 'long_name' , ' Annual P deposition' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pdust' ) ok = nf90_put_att ( ncid11 , var_pdustid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pdust' ) ok = nf90_put_att ( ncid11 , var_pdustid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pdust' ) ok = nf90_def_var ( ncid11 , 'Pwea' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_pweaid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pwea' ) ok = nf90_put_att ( ncid11 , var_pweaid , 'units' , ' gP m-2 yr-1' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pwea' ) ok = nf90_put_att ( ncid11 , var_pweaid , 'long_name' , ' P weathering rate' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pwea' ) ok = nf90_put_att ( ncid11 , var_pweaid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pwea' ) ok = nf90_put_att ( ncid11 , var_pweaid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining Pwea' ) ok = nf90_def_var ( ncid11 , 'SnowDepth' , nf90_float ,( / dim_mlonid , dim_mlatid , dim_timeid / ), var_snowdepthid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SnowDepth' ) ok = nf90_put_att ( ncid11 , var_snowdepthid , 'units' , ' m' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SnowDepth' ) ok = nf90_put_att ( ncid11 , var_snowdepthid , 'long_name' , ' snow depth' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SnowDepth' ) ok = nf90_put_att ( ncid11 , var_snowdepthid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SnowDepth' ) ok = nf90_put_att ( ncid11 , var_snowdepthid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SnowDepth' ) ok = nf90_def_var ( ncid11 , 'SoilMoist' , nf90_float ,( / dim_mlonid , dim_mlatid , dim_soilid , dim_timeid / ), var_soilmoistid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilMoist' ) ok = nf90_put_att ( ncid11 , var_soilmoistid , 'units' , ' m3/m3' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilMoist' ) ok = nf90_put_att ( ncid11 , var_soilmoistid , 'long_name' , ' soil moisture profile' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilMoist' ) ok = nf90_put_att ( ncid11 , var_soilmoistid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilMoist' ) ok = nf90_put_att ( ncid11 , var_soilmoistid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilMoist' ) ok = nf90_def_var ( ncid11 , 'SoilOrder' , nf90_int ,( / dim_mlonid , dim_mlatid / ), var_soilorderid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilOrder' ) ok = nf90_put_att ( ncid11 , var_soilorderid , 'units' , ' class ' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilOrder' ) ok = nf90_put_att ( ncid11 , var_soilorderid , 'long_name' , ' soil order class' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilOrder' ) ok = nf90_put_att ( ncid11 , var_soilorderid , '_FillValue' , missint ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilOrder' ) ok = nf90_put_att ( ncid11 , var_soilorderid , 'missing_value' , missint ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilOrder' ) ok = nf90_def_var ( ncid11 , 'SoilTemp' , nf90_float ,( / dim_mlonid , dim_mlatid , dim_soilid , dim_timeid / ), var_soiltempid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilTemp' ) ok = nf90_put_att ( ncid11 , var_soiltempid , 'units' , ' K' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilTemp' ) ok = nf90_put_att ( ncid11 , var_soiltempid , 'long_name' , ' soil temperature profile' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilTemp' ) ok = nf90_put_att ( ncid11 , var_soiltempid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilTemp' ) ok = nf90_put_att ( ncid11 , var_soiltempid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining SoilTemp' ) ok = nf90_def_var ( ncid11 , 'albedo2' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_albedo2id ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining albedo2' ) ok = nf90_put_att ( ncid11 , var_albedo2id , 'units' , ' ---' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining albedo2' ) ok = nf90_put_att ( ncid11 , var_albedo2id , 'long_name' , ' snow-free soil albedo' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining albedo2' ) ok = nf90_put_att ( ncid11 , var_albedo2id , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining albedo2' ) ok = nf90_put_att ( ncid11 , var_albedo2id , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining albedo2' ) ok = nf90_def_var ( ncid11 , 'area' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_areaid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining area' ) ok = nf90_put_att ( ncid11 , var_areaid , 'units' , ' m2' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining area' ) ok = nf90_put_att ( ncid11 , var_areaid , 'long_name' , ' land area' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining area' ) ok = nf90_put_att ( ncid11 , var_areaid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining area' ) ok = nf90_put_att ( ncid11 , var_areaid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patch' ) ok = nf90_def_var ( ncid11 , 'bch' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_bchid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining bch' ) ok = nf90_put_att ( ncid11 , var_bchid , 'units' , ' ---' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining bch' ) ok = nf90_put_att ( ncid11 , var_bchid , 'long_name' , ' Clapp-Hornberger B coefficient' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining bch' ) ok = nf90_put_att ( ncid11 , var_bchid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining bch' ) ok = nf90_put_att ( ncid11 , var_bchid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining bch' ) ok = nf90_def_var ( ncid11 , 'clay' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_clayid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining clay' ) ok = nf90_put_att ( ncid11 , var_clayid , 'units' , ' fraction' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining clay' ) ok = nf90_put_att ( ncid11 , var_clayid , 'long_name' , ' clay fraction' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining clay' ) ok = nf90_put_att ( ncid11 , var_clayid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining clay' ) ok = nf90_put_att ( ncid11 , var_clayid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining clay' ) ok = nf90_def_var ( ncid11 , 'cnsd' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_cnsdid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining cnsd' ) ok = nf90_put_att ( ncid11 , var_cnsdid , 'units' , ' W m-2 K-1' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining cnsd' ) ok = nf90_put_att ( ncid11 , var_cnsdid , 'long_name' , ' thermal conductivity' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining cnsd' ) ok = nf90_put_att ( ncid11 , var_cnsdid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining cnsd' ) ok = nf90_put_att ( ncid11 , var_cnsdid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining cnsd' ) ok = nf90_def_var ( ncid11 , 'css' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_cssid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining css' ) ok = nf90_put_att ( ncid11 , var_cssid , 'units' , ' J/kg/K' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining css' ) ok = nf90_put_att ( ncid11 , var_cssid , 'long_name' , ' soil specific heat capacity' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining css' ) ok = nf90_put_att ( ncid11 , var_cssid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining css' ) ok = nf90_put_att ( ncid11 , var_cssid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining css' ) ok = nf90_def_var ( ncid11 , 'hyds' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_hydsid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining hyds' ) ok = nf90_put_att ( ncid11 , var_hydsid , 'units' , ' m/s' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining hyds' ) ok = nf90_put_att ( ncid11 , var_hydsid , 'long_name' , ' saturated hydraulic conductivity' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining hyds' ) ok = nf90_put_att ( ncid11 , var_hydsid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining hyds' ) ok = nf90_put_att ( ncid11 , var_hydsid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining hyds' ) ok = nf90_def_var ( ncid11 , 'isoil' , nf90_int ,( / dim_mlonid , dim_mlatid / ), var_isoilid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining isoil' ) ok = nf90_put_att ( ncid11 , var_isoilid , 'units' , ' --' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining isoil' ) ok = nf90_put_att ( ncid11 , var_isoilid , 'long_name' , ' Zobler soil texture class' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining isoil' ) ok = nf90_put_att ( ncid11 , var_isoilid , '_FillValue' , missint ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining isoil' ) ok = nf90_put_att ( ncid11 , var_isoilid , 'missing_value' , missint ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining isoil' ) ok = nf90_def_var ( ncid11 , 'latitude' , nf90_float ,( / dim_mlatid / ), var_latitudeid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining latitude' ) ok = nf90_put_att ( ncid11 , var_latitudeid , 'units' , ' degree' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining latitude' ) ok = nf90_put_att ( ncid11 , var_latitudeid , 'long_name' , ' latitude' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining latitude' ) ok = nf90_put_att ( ncid11 , var_latitudeid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining latitude' ) ok = nf90_put_att ( ncid11 , var_latitudeid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining latitude' ) ok = nf90_def_var ( ncid11 , 'longitude' , nf90_float ,( / dim_mlonid / ), var_longitudeid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining longitude' ) ok = nf90_put_att ( ncid11 , var_longitudeid , 'units' , ' degree' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining longitude' ) ok = nf90_put_att ( ncid11 , var_longitudeid , 'long_name' , ' longitude' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining longitude' ) ok = nf90_put_att ( ncid11 , var_longitudeid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining longitude' ) ok = nf90_put_att ( ncid11 , var_longitudeid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining longitude' ) ok = nf90_def_var ( ncid11 , 'rhosoil' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_rhosoilid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining rhosoil' ) ok = nf90_put_att ( ncid11 , var_rhosoilid , 'units' , ' kg m-3' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining rhosoil' ) ok = nf90_put_att ( ncid11 , var_rhosoilid , 'long_name' , ' soil bulk density' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining rhosoil' ) ok = nf90_put_att ( ncid11 , var_rhosoilid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining rhosoil' ) ok = nf90_put_att ( ncid11 , var_rhosoilid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining rhosoil' ) ok = nf90_def_var ( ncid11 , 'sand' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_sandid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sand' ) ok = nf90_put_att ( ncid11 , var_sandid , 'units' , ' ---' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sand' ) ok = nf90_put_att ( ncid11 , var_sandid , 'long_name' , ' sand fraction' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sand' ) ok = nf90_put_att ( ncid11 , var_sandid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sand' ) ok = nf90_put_att ( ncid11 , var_sandid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sand' ) ok = nf90_def_var ( ncid11 , 'sfc' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_sfcid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sfc' ) ok = nf90_put_att ( ncid11 , var_sfcid , 'units' , ' m3/m3' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sfc' ) ok = nf90_put_att ( ncid11 , var_sfcid , 'long_name' , ' soil water at field capacity' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sfc' ) ok = nf90_put_att ( ncid11 , var_sfcid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sfc' ) ok = nf90_put_att ( ncid11 , var_sfcid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sfc' ) ok = nf90_def_var ( ncid11 , 'silt' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_siltid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining silt' ) ok = nf90_put_att ( ncid11 , var_siltid , 'units' , ' fraction' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining silt' ) ok = nf90_put_att ( ncid11 , var_siltid , 'long_name' , ' soil silt fraction' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining silt' ) ok = nf90_put_att ( ncid11 , var_siltid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining silt' ) ok = nf90_put_att ( ncid11 , var_siltid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining silt' ) ok = nf90_def_var ( ncid11 , 'ssat' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_ssatid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining ssat' ) ok = nf90_put_att ( ncid11 , var_ssatid , 'units' , ' m3/m3' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining ssat' ) ok = nf90_put_att ( ncid11 , var_ssatid , 'long_name' , ' soil water at saturation' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining ssat' ) ok = nf90_put_att ( ncid11 , var_ssatid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining ssat' ) ok = nf90_put_att ( ncid11 , var_ssatid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining ssat' ) ok = nf90_def_var ( ncid11 , 'sucs' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_sucsid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sucs' ) ok = nf90_put_att ( ncid11 , var_sucsid , 'units' , ' m' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sucs' ) ok = nf90_put_att ( ncid11 , var_sucsid , 'long_name' , ' soil sunction at saturation' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sucs' ) ok = nf90_put_att ( ncid11 , var_sucsid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sucs' ) ok = nf90_put_att ( ncid11 , var_sucsid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining sucs' ) ok = nf90_def_var ( ncid11 , 'swilt' , nf90_float ,( / dim_mlonid , dim_mlatid / ), var_swiltid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining swilt' ) ok = nf90_put_att ( ncid11 , var_swiltid , 'units' , ' m3/m3' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining swilt' ) ok = nf90_put_att ( ncid11 , var_swiltid , 'long_name' , ' soil water at wilting point' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining swilt' ) ok = nf90_put_att ( ncid11 , var_swiltid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining swilt' ) ok = nf90_put_att ( ncid11 , var_swiltid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining swilt' ) ok = nf90_def_var ( ncid11 , 'iveg' , nf90_int ,( / dim_mlonid , dim_mlatid , dim_patchid / ), var_ivegid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining iveg' ) ok = nf90_put_att ( ncid11 , var_ivegid , 'units' , ' class' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining iveg' ) ok = nf90_put_att ( ncid11 , var_ivegid , 'long_name' , ' CABLE PFT' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining iveg' ) ok = nf90_put_att ( ncid11 , var_ivegid , '_FillValue' , missint ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining iveg' ) ok = nf90_put_att ( ncid11 , var_ivegid , 'missing_value' , missint ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining iveg' ) ok = nf90_def_var ( ncid11 , 'patchfrac' , nf90_float ,( / dim_mlonid , dim_mlatid , dim_patchid / ), var_patchfracid ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patchfrac' ) ok = nf90_put_att ( ncid11 , var_patchfracid , 'units' , ' area fraction' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patchfrac' ) ok = nf90_put_att ( ncid11 , var_patchfracid , 'long_name' , ' CABLE PFT fraction' ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patchfrac' ) ok = nf90_put_att ( ncid11 , var_patchfracid , '_FillValue' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patchfrac' ) ok = nf90_put_att ( ncid11 , var_patchfracid , 'missing_value' , missreal ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in defining patchfrac' ) ok = nf90_enddef ( ncid11 ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in enddef' ) ! assign values call rangechk3 ( mlon , mlat , nrb , landmask , albedo_y , 0.01 , 0.9 ) ok = nf90_put_var ( ncid11 , var_albedoid , albedo_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put albedo' ) call rangechk3 ( mlon , mlat , time12 , landmask , lai_y , 0.0 , 1 0.0 ) ok = nf90_put_var ( ncid11 , var_laiid , lai_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put lai' ) call rangechk2 ( mlon , mlat , landmask , ndep_y , 0.0 , 1 0.0 ) ok = nf90_put_var ( ncid11 , var_ndepid , ndep_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put ndep' ) call rangechk2 ( mlon , mlat , landmask , nfix_y , 0.0 , 1 5.0 ) ok = nf90_put_var ( ncid11 , var_nfixid , nfix_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put nfix' ) call rangechk2 ( mlon , mlat , landmask , pdust_y , 0.0 , 5.0 ) ok = nf90_put_var ( ncid11 , var_pdustid , pdust_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put pdep' ) call rangechk2 ( mlon , mlat , landmask , pwea_y , 0.0 , 5.0 ) ok = nf90_put_var ( ncid11 , var_pweaid , pwea_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put pwea' ) ok = nf90_put_var ( ncid11 , var_snowdepthid , snowdepth_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put snowdepth' ) ok = nf90_put_var ( ncid11 , var_soilmoistid , soilmoist_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put soilmoist' ) ok = nf90_put_var ( ncid11 , var_soilorderid , soilorder_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put soilorder' ) ok = nf90_put_var ( ncid11 , var_soiltempid , soiltemp_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put soiltemp' ) call rangechk2 ( mlon , mlat , landmask , albedo2_y , 0.01 , 0.9 ) ok = nf90_put_var ( ncid11 , var_albedo2id , albedo2_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put albedo2' ) ok = nf90_put_var ( ncid11 , var_areaid , area_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put area' ) call rangechk2 ( mlon , mlat , landmask , bch_y , 2.0 , 1 5.0 ) ok = nf90_put_var ( ncid11 , var_bchid , bch_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put bch' ) call rangechk2 ( mlon , mlat , landmask , clay_y , 0.0 , 1.0 ) ok = nf90_put_var ( ncid11 , var_clayid , clay_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put clay' ) ok = nf90_put_var ( ncid11 , var_cnsdid , cnsd_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put cnsd' ) call rangechk2 ( mlon , mlat , landmask , css_y , 70 0.0 , 220 0.0 ) ok = nf90_put_var ( ncid11 , var_cssid , css_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put css' ) call rangechk2 ( mlon , mlat , landmask , hyds_y , 5.0e-7 , 8.5e-3 ) ok = nf90_put_var ( ncid11 , var_hydsid , hyds_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put hyds' ) ok = nf90_put_var ( ncid11 , var_isoilid , isoil_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put isoil' ) ok = nf90_put_var ( ncid11 , var_latitudeid , latitude_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put latitude' ) ok = nf90_put_var ( ncid11 , var_longitudeid , longitude_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put longitude' ) call rangechk2 ( mlon , mlat , landmask , rhosoil_y , 30 0.0 , 300 0.0 ) ok = nf90_put_var ( ncid11 , var_rhosoilid , rhosoil_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put rhosoil' ) call rangechk2 ( mlon , mlat , landmask , sand_y , 0.0 , 1.0 ) ok = nf90_put_var ( ncid11 , var_sandid , sand_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put sand' ) call rangechk2 ( mlon , mlat , landmask , sfc_y , 0.1 , 0.5 ) ok = nf90_put_var ( ncid11 , var_sfcid , sfc_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put sfc' ) call rangechk2 ( mlon , mlat , landmask , silt_y , 0.0 , 1.0 ) ok = nf90_put_var ( ncid11 , var_siltid , silt_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put silt' ) call rangechk2 ( mlon , mlat , landmask , ssat_y , 0.35 , 0.50 ) ok = nf90_put_var ( ncid11 , var_ssatid , ssat_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put ssat' ) call rangechk2 ( mlon , mlat , landmask , sucs_y , - 0.8 , - 0.03 ) ok = nf90_put_var ( ncid11 , var_sucsid , sucs_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put sucs' ) call rangechk2 ( mlon , mlat , landmask , swilt_y , 0.05 , 0.4 ) ok = nf90_put_var ( ncid11 , var_swiltid , swilt_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put swilt' ) ok = nf90_put_var ( ncid11 , var_ivegid , iveg_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put iveg' ) ok = nf90_put_var ( ncid11 , var_patchfracid , patchfrac_y ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put patchfrac' ) ok = nf90_close ( ncid11 ) if ( ok /= nf90_noerr ) call nc_abort ( ok , 'error in put albedo' ) write ( logn , * ) 'landuse on: new gridinfo created' , fgridnew end subroutine create_new_gridinfo subroutine rangechk2 ( mlon , mlat , landmask , varx2 , xmin , xmax ) USE cable_def_types_mod , ONLY : r_2 implicit none real xmin , xmax integer mlon , mlat integer , dimension ( mlon , mlat ) :: landmask real ( r_2 ), dimension ( mlon , mlat ) :: varx2 integer i , j do i = 1 , mlon do j = 1 , mlat if ( landmask ( i , j ) == 1 ) then varx2 ( i , j ) = max ( xmin , varx2 ( i , j )) varx2 ( i , j ) = min ( xmax , varx2 ( i , j )) endif enddo enddo end subroutine rangechk2 subroutine rangechk3 ( mlon , mlat , nx3 , landmask , varx3 , xmin , xmax ) USE cable_def_types_mod , ONLY : r_2 implicit none real xmin , xmax integer mlon , mlat , nx3 integer , dimension ( mlon , mlat ) :: landmask real ( r_2 ), dimension ( mlon , mlat , nx3 ) :: varx3 integer i , j , k do i = 1 , mlon do j = 1 , mlat if ( landmask ( i , j ) == 1 ) then do k = 1 , nx3 varx3 ( i , j , k ) = max ( xmin , varx3 ( i , j , k )) varx3 ( i , j , k ) = min ( xmax , varx3 ( i , j , k )) enddo endif enddo enddo end subroutine rangechk3 subroutine sort ( mvmax , tmpx , tmpint ) ! based on numerical recipes, straight insertion method  p322 USE cable_def_types_mod , ONLY : r_2 implicit none integer mvmax integer , dimension ( mvmax ) :: tmpint real ( r_2 ), dimension ( mvmax ) :: tmpx integer i , j , na real ( r_2 ) xa do j = 2 , mvmax xa = tmpx ( j ) na = tmpint ( j ) do i = j - 1 , 1 , - 1 if ( tmpx ( i ) >= xa ) go to 10 tmpx ( i + 1 ) = tmpx ( i ) tmpint ( i + 1 ) = tmpint ( i ) enddo i = 0 10 tmpx ( i + 1 ) = xa tmpint ( i + 1 ) = na enddo end subroutine sort SUBROUTINE WRITE_LANDUSE_CASA_RESTART_NC ( mpx , lucmp , CASAONLY ) USE netcdf USE casavariable , ONLY : icycle , mplant , mlitter , msoil , mwood , casafile USE cable_IO_vars_module , ONLY : logn USE cable_common_module USE casa_ncdf_module , ONLY : HANDLE_ERR USE landuse_variable , ONLY : landuse_mp IMPLICIT NONE type ( landuse_mp ) :: lucmp INTEGER , INTENT ( IN ) :: mpx INTEGER * 4 :: mp4 INTEGER * 4 , PARAMETER :: pmp4 = 0 INTEGER , PARAMETER :: fmp4 = KIND ( pmp4 ) INTEGER * 4 :: STATUS INTEGER * 4 :: FILE_ID , land_ID , plnt_ID , litt_ID , soil_ID , wood_ID , i LOGICAL :: CASAONLY CHARACTER :: CYEAR * 4 , FNAME * 99 , dum * 50 ! ! 1 dim arrays (npt ) ! CHARACTER(len=20),DIMENSION(7), PARAMETER :: A1 = (/ 'latitude', 'longitude', 'glai', & !      'clabile', 'psoillab','psoilsorb','psoilocc' /) ! ! 2 dim arrays (npt,mplant) ! CHARACTER(len=20),DIMENSION(3), PARAMETER :: A2 = (/ 'cplant' , 'nplant' , 'pplantc' /) ! ! 2 dim arrays (npt,mlitter) ! CHARACTER(len=20),DIMENSION(3), PARAMETER :: A3 = (/ 'clitter', 'nlitter', 'plitter' /) ! ! 2 dim arrays (npt,msoil) ! CHARACTER(len=20),DIMENSION(3), PARAMETER :: A4 = (/ 'csoil', 'nsoil', 'psoil' /) ! 1 dim arrays (npt ) CHARACTER ( len = 20 ), DIMENSION ( 12 ) :: A1 CHARACTER ( len = 20 ), DIMENSION ( 2 ) :: AI1 ! 2 dim arrays (npt,mplant) CHARACTER ( len = 20 ), DIMENSION ( 3 ) :: A2 ! 2 dim arrays (npt,mlitter) CHARACTER ( len = 20 ), DIMENSION ( 3 ) :: A3 ! 2 dim arrays (npt,msoil) CHARACTER ( len = 20 ), DIMENSION ( 3 ) :: A4 ! 2 dim arrays (npt,msoil) CHARACTER ( len = 20 ), DIMENSION ( 3 ) :: A5 INTEGER * 4 :: VID1 ( SIZE ( A1 )), VIDI1 ( SIZE ( AI1 )), VID2 ( SIZE ( A2 )), & VID3 ( SIZE ( A3 )), VID4 ( SIZE ( A4 )), VID5 ( SIZE ( A5 )) mp4 = INT ( mpx , fmp4 ) write ( logn , * ) ' landuse on: writing casa pool: patch number=' , mpx , fmp4 , mp4 A1 ( 1 ) = 'latitude' A1 ( 2 ) = 'longitude' A1 ( 3 ) = 'glai' A1 ( 4 ) = 'clabile' A1 ( 5 ) = 'psoillab' A1 ( 6 ) = 'psoilsorb' A1 ( 7 ) = 'psoilocc' A1 ( 8 ) = 'frac_sapwood' A1 ( 9 ) = 'sapwood_area' A1 ( 10 ) = 'phen' A1 ( 11 ) = 'aphen' A1 ( 12 ) = 'nsoilmin' AI1 ( 1 ) = 'phase' AI1 ( 2 ) = 'doyphase3' A2 ( 1 ) = 'cplant' A2 ( 2 ) = 'nplant' A2 ( 3 ) = 'pplant' A3 ( 1 ) = 'clitter' A3 ( 2 ) = 'nlitter' A3 ( 3 ) = 'plitter' A4 ( 1 ) = 'csoil' A4 ( 2 ) = 'nsoil' A4 ( 3 ) = 'psoil' A5 ( 1 ) = 'cwoodprod' A5 ( 2 ) = 'nwoodprod' A5 ( 3 ) = 'pwoodprod' ! Get File-Name WRITE ( CYEAR , FMT = '(I4)' ) CurYear + 1 IF ( LEN ( TRIM ( casafile % cnpepool ) ) . GT . 0 ) THEN fname = TRIM ( casafile % cnpepool ) ELSE fname = TRIM ( filename % path ) // '/' // TRIM ( cable_user % RunIden ) // & '_casa_rst.nc' ENDIF ! Create NetCDF file: STATUS = NF90_create ( fname , NF90_CLOBBER , FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) WRITE ( * , * ) 'writing casa restart' , fname ! Put the file in define mode: STATUS = NF90_redef ( FILE_ID ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"Valid restart date\" , \"01/01/\" // CYEAR ) STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"Icycle\" , icycle ) IF ( CASAONLY ) THEN dum = 'CASA-ONLY run' ELSE dum = 'CABLE-CASA coupled run' ENDIF STATUS = NF90_PUT_ATT ( FILE_ID , NF90_GLOBAL , \"Run-Type\" , TRIM ( dum ) ) ! Define dimensions: ! Land (number of points) STATUS = NF90_def_dim ( FILE_ID , 'land' , mp4 , land_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mplant' , mplant , plnt_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mlitter' , mlitter , litt_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'msoil' , msoil , soil_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_def_dim ( FILE_ID , 'mwood' , mwood , wood_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) DO i = 1 , SIZE ( A1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A1 ( i )) , NF90_FLOAT ,( / land_ID / ), VID1 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( AI1 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( AI1 ( i )) , NF90_INT ,( / land_ID / ), VIDI1 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A2 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A2 ( i )) , NF90_FLOAT ,( / land_ID , plnt_ID / ), VID2 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A3 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A3 ( i )) , NF90_FLOAT ,( / land_ID , litt_ID / ), VID3 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A4 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A4 ( i )) , NF90_FLOAT ,( / land_ID , soil_ID / ), VID4 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO DO i = 1 , SIZE ( A5 ) STATUS = NF90_def_var ( FILE_ID , TRIM ( A5 ( i )) , NF90_FLOAT ,( / land_ID , wood_ID / ), VID5 ( i )) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END DO ! End define mode: STATUS = NF90_enddef ( FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! PUT LAT / LON STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 1 ), lucmp % lat ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 2 ), lucmp % lon ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! PUT VARS STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 3 ), lucmp % lai ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 4 ), lucmp % clabile ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 5 ), lucmp % psoillab ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 6 ), lucmp % psoilsorb ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 7 ), lucmp % psoilocc ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 8 ), lucmp % frac_sapwood ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 9 ), lucmp % sapwood_area ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 10 ), lucmp % phen ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 11 ), lucmp % aphen ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID1 ( 12 ), lucmp % Nsoilmin ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDI1 ( 1 ), lucmp % phase ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VIDI1 ( 2 ), lucmp % doyphase3 ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 1 ), lucmp % cplant ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 2 ), lucmp % nplant ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID2 ( 3 ), lucmp % pplant ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID3 ( 1 ), lucmp % clitter ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID3 ( 2 ), lucmp % nlitter ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID3 ( 3 ), lucmp % plitter ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 1 ), lucmp % csoil ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 2 ), lucmp % nsoil ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 3 ), lucmp % psoil ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID5 ( 1 ), lucmp % cwoodprod ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID5 ( 2 ), lucmp % nwoodprod ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) STATUS = NF90_PUT_VAR ( FILE_ID , VID4 ( 3 ), lucmp % pwoodprod ) IF ( STATUS /= NF90_NoErr ) CALL handle_err ( STATUS ) ! Close NetCDF file: STATUS = NF90_close ( FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) write ( logn , * ) 'landuse on: casapool writeen to ' , fname END SUBROUTINE WRITE_LANDUSE_CASA_RESTART_NC SUBROUTINE create_landuse_cable_restart ( logn , dels , ktau , soil , mpx , lucmp , cstart , cend , nap ) ! Creates a restart file for CABLE using a land only grid cell area occupied by a '//  & ! Creates a restart file for CABLE using a land only grid with mland ! land points and max_vegpatches veg/soil patches (some of which may ! not be active). It uses CABLE's internal variable names. use netcdf USE cable_def_types_mod , ONLY : r_2 , mland , mvtype , mstype , nrb , ncs , ncp , ms , msn , soil_parameter_type use cable_abort_module , ONLY : nc_abort USE cable_IO_vars_module , ONLY : latitude , longitude , timeunits , calendar , time_coord , timevar USE cable_checks_module , ONLY : ranges USE cable_write_module USE cable_common_module , ONLY : filename , CurYear , cable_user USE landuse_variable , ONLY : landuse_mp implicit none type ( landuse_mp ) :: lucmp type ( soil_parameter_type ) :: soil INTEGER , INTENT ( IN ) :: logn ! log file number REAL , INTENT ( IN ) :: dels ! time step size INTEGER , INTENT ( IN ) :: ktau ! timestep number in loop which include spinup INTEGER , INTENT ( IN ) :: mpx ! timestep number in loop which include spinup INTEGER , DIMENSION ( mland ), INTENT ( in ) :: cstart , cend , nap !    TYPE (soil_parameter_type),INTENT(IN)  :: soil    ! from \"cable_de_types_mod\" !    TYPE (ranges_type),        INTENT(IN)  :: ranges  ! from \"cable_checks_module\" INTEGER :: ncid_restart ! netcdf restart file ID ! REAL, POINTER,DIMENSION(:,:) :: surffrac ! fraction of each surf type INTEGER :: dummy ! dummy argument in subroutine call INTEGER :: mlandID , mpID , radID , soilID , napID , & soilcarbID , plantcarbID , tID , snowID ! dimension IDs INTEGER :: patchfrac_id , mvtype_id , mstype_id INTEGER :: iveg_id , isoil_id , zse_id , albsoil_id INTEGER :: tvarID , latID , lonID !,surffracID ! time,lat,lon variable ID INTEGER :: tggID , wbID , wbiceID , tssID , ssdnnID , ssdnID , osnowdID , & smassID , sdepthID , snageID , snowdID , rtsoilID , isflagID , & canstoID , albsoilsnID , gammzzID , tggsnID , sghfluxID , & ghfluxID , runoffID , rnof1ID , rnof2ID , gaID , dgdtgID , & fevID , fesID , fhsID , wbtot0ID , osnowd0ID , cplantID , & csoilID , tradID , albedoID , gwID INTEGER :: h0ID , snowliqID , SID , TsurfaceID , scondsID , nsnowID , TsoilID CHARACTER ( LEN = 10 ) :: todaydate , nowtime ! used to timestamp netcdf file CHARACTER :: FRST_OUT * 200 , CYEAR * 4 INTEGER ok dummy = 0 ! initialise WRITE ( logn , '(A24)' ) ' Writing restart file...' IF ( TRIM ( filename % path ) . EQ . '' ) filename % path = './' frst_out = TRIM ( filename % path ) // '/' // TRIM ( filename % restart_out ) ! Look for explicit restart file (netCDF). If not, asssume input is path IF ( INDEX ( TRIM ( frst_out ), '.nc' , BACK = . TRUE .) . NE . LEN_TRIM ( frst_out ) - 2 ) THEN WRITE ( CYEAR , FMT = \"(I4)\" ) CurYear + 1 frst_out = TRIM ( filename % path ) // '/' // TRIM ( cable_user % RunIden ) // & '_' // CYEAR // '_cable_rst.nc' ENDIF ! Create output file: ok = NF90_CREATE ( frst_out , NF90_CLOBBER , ncid_restart ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error creating restart file ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Put the file in define mode: ok = NF90_REDEF ( ncid_restart ) ! Define dimensions: ok = NF90_DEF_DIM ( ncid_restart , 'mland' , mland , mlandID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining mland dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'mp' , mpx , mpID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining mp dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'soil' , ms , soilID ) ! number of soil layers IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining vertical soil dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'snow' , 3 , snowID ) ! number of snow layers IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining vertical snow dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'rad' , nrb , radID ) ! number of rad. bands IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining radiation dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'soil_carbon_pools' , ncs , soilcarbID ) ! number of soil carbon pools IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining soil carbon pool dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'plant_carbon_pools' , ncp , plantcarbID ) ! number of plant carbon pools IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining plant carbon pool dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_DIM ( ncid_restart , 'time' , 1 , tID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time dimension in restart file. ' // & '(SUBROUTINE create_restart)' ) ! Define \"time\" variable and its attributes: ok = NF90_DEF_VAR ( ncid_restart , 'time' , NF90_DOUBLE ,( / tID / ), tvarID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , tvarID , 'units' , timeunits ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , tvarID , 'coordinate' , time_coord ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , tvarID , 'calendar' , calendar ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining time variable attribute calendar in restart file. ' // & '(SUBROUTINE create_restart)' ) ! Define latitude and longitude variable: ok = NF90_DEF_VAR ( ncid_restart , 'latitude' , NF90_FLOAT , ( / mlandID / ), latID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining latitude variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , latID , 'units' , 'degrees_north' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining latitude variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_DEF_VAR ( ncid_restart , 'longitude' , NF90_FLOAT , ( / mlandID / ), lonID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining longitude variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , lonID , 'units' , 'degrees_east' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining longitude variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ! Define number of active patches variable: ok = NF90_DEF_VAR ( ncid_restart , 'nap' , NF90_FLOAT , ( / mlandID / ), napID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining nap variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , napID , 'long_name' , & 'Number of active patches' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining nap variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ! Define patch fraction variable: ok = NF90_DEF_VAR ( ncid_restart , 'patchfrac' , NF90_FLOAT , ( / mpID / ), & patchfrac_id ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining patchfrac variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , patchfrac_id , 'long_name' , & 'Fraction of vegetated grid cell area occupied by a ' // & 'vegetation/soil patch' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining patchfrac variable attributes in restart file. ' // & '(SUBROUTINE create_restart)' ) ! mvtype (Number of vegetation types): ok = NF90_DEF_VAR ( ncid_restart , 'mvtype' , NF90_INT , mvtype_id ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining mvtype variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , mvtype_id , \"long_name\" , & \"Number of vegetation types\" ) ! mstype (Number of soil types): ok = NF90_DEF_VAR ( ncid_restart , 'mstype' , NF90_INT , mstype_id ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining mstype variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , mstype_id , \"long_name\" , & \"Number of soil types\" ) !======begin defining state variables======================================= ! Interface arguments: netcdf file ID, variableID, variable name, variable ! units, variable long name, YES to write patch info (as this is a restart ! file), OPTIONAL extra dimension ID (e.g. for soil dimensioned variables), ! dimension switch to indicate what extra dimension is real or integer for ! single dim variables, xdimID,ydimID, zdimID (all three not used here), ! land dim ID, patch dim ID, YES we're writing a restart file. !------------------define soil states--------------------------------------- CALL define_ovar ( ncid_restart , tggID , 'tgg' , 'K' , & 'Average layer soil temperature' , & . TRUE ., soilID , 'soil' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , wbID , 'wb' , 'vol/vol' , & 'Average layer volumetric soil moisture' , & . TRUE ., soilID , 'r2soil' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , wbiceID , 'wbice' , 'vol/vol' , & 'Average layer volumetric soil ice' , & . TRUE ., soilID , 'r2soil' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , tssID , 'tss' , 'K' , & 'Combined soil/snow temperature' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , albsoilsnID , 'albsoilsn' , '-' , & 'Combined soil/snow albedo' , & . TRUE ., radID , 'radiation' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , rtsoilID , 'rtsoil' , '??' , & 'Turbulent resistance for soil' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , gammzzID , 'gammzz' , 'J/kg/C' , & 'Heat capacity for each soil layer' , & . TRUE ., soilID , 'r2soil' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , runoffID , 'runoff' , 'mm/timestep' , & 'Total runoff' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , rnof1ID , 'rnof1' , 'mm/timestep' , & 'Surface runoff' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , rnof2ID , 'rnof2' , 'mm/timestep' , & 'Subsurface runoff' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !---------------define snow states------------------------------------------ CALL define_ovar ( ncid_restart , tggsnID , 'tggsn' , 'K' , & 'Average layer snow temperature' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , ssdnnID , 'ssdnn' , 'kg/m&#94;3' , & 'Average snow density' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , ssdnID , 'ssdn' , 'kg/m&#94;3' , & 'Average layer snow density' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , snowdID , 'snowd' , 'mm' , & 'Liquid water eqivalent snow depth' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , snageID , 'snage' , '??' , & 'Snow age' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , smassID , 'smass' , 'kg/m&#94;2' , & 'Average layer snow mass' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , sdepthID , 'sdepth' , 'm' , & 'Snow layer depth' , . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , osnowdID , 'osnowd' , 'mm' , & 'Previous time step snow depth in water equivalent' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , isflagID , 'isflag' , '-' , & 'Snow layer scheme flag' , . TRUE ., 'integer' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !----------------define canopy states---------------------------------- CALL define_ovar ( ncid_restart , canstoID , 'cansto' , 'mm' , & 'Canopy surface water storage' , . TRUE ., 'real' , 0 , 0 , 0 , & mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , ghfluxID , 'ghflux' , 'W/m&#94;2?' , & '????' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , sghfluxID , 'sghflux' , 'W/m&#94;2?' , & '????' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , gaID , 'ga' , 'W/m&#94;2' , & 'Ground heat flux' , . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , dgdtgID , 'dgdtg' , 'W/m&#94;2/K' , & 'Derivative of ground heat flux wrt soil temperature' , . TRUE ., & 'r2' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , fevID , 'fev' , 'W/m&#94;2' , & 'Latent heat flux from vegetation' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , fesID , 'fes' , 'W/m&#94;2' , & 'Latent heat flux from soil' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , fhsID , 'fhs' , 'W/m&#94;2' , & 'Sensible heat flux from soil' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !--------------biogeochemical variables------------------------ CALL define_ovar ( ncid_restart , cplantID , 'cplant' , 'gC/m&#94;2' , & 'Plant carbon stores' , & . TRUE ., plantcarbID , 'plantcarbon' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , csoilID , 'csoil' , 'gC/m&#94;2' , & 'Soil carbon stores' , & . TRUE ., soilcarbID , 'soilcarbon' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !-------------------others--------------------------------- CALL define_ovar ( ncid_restart , wbtot0ID , 'wbtot0' , 'mm' , & 'Initial time step soil water total' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , osnowd0ID , 'osnowd0' , 'mm' , & 'Initial time step snow water total' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , albedoID , 'albedo' , '-' , & 'Albedo for shortwave and NIR radiation' , & . TRUE ., radID , 'radiation' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , tradID , 'trad' , 'K' , & 'Surface radiative temperature (soil/snow/veg inclusive)' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) !---------------------MODEL PARAMETERS--------------------------------- WRITE ( logn , '(A43)' ) '   Writing model parameters to restart file' CALL define_ovar ( ncid_restart , iveg_id , 'iveg' , '-' , & 'Vegetation type' , . TRUE ., 'integer' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , isoil_id , 'isoil' , '-' , & 'Soil type' , . TRUE ., 'integer' , 0 , 0 , 0 , mpID , dummy , . TRUE .) ! zse (depth of each soil layer): ok = NF90_DEF_VAR ( ncid_restart , 'zse' , NF90_FLOAT , ( / soilID / ), zse_id ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining zse variable in restart file. ' // & '(SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , zse_id , \"long_name\" , & \"Depth of each soil layer\" ) ok = NF90_PUT_ATT ( ncid_restart , zse_id , \"units\" , \"m\" ) CALL define_ovar ( ncid_restart , albsoil_id , 'albsoil' , '-' , & 'Soil reflectance' , . TRUE ., & radID , 'radiation' , 0 , 0 , 0 , mpID , dummy , . TRUE .) CALL define_ovar ( ncid_restart , gwID , 'GWwb' , 'mm3/mm3' , 'GW water content' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy , . TRUE .) ! Soil-Litter-Iso soil model IF ( cable_user % SOIL_STRUC == 'sli' ) THEN ! Parameters for SLI: CALL define_ovar ( ncid_restart , SID , 'S' , '-' ,& 'Fractional soil moisture content relative to saturated value' , & . TRUE ., soilID , 'soil' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , TsoilID , 'Tsoil' , 'degC' ,& 'Tsoil' , & . TRUE ., soilID , 'soil' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , snowliqID , 'snowliq' , 'mm' ,& 'liquid water content of snowpack' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , scondsID , 'sconds' , 'Wm-1K-1' ,& 'thermal cond of snowpack' , & . TRUE ., snowID , 'snow' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , h0ID , 'h0' , 'm' ,& 'Pond height above soil' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , nsnowID , 'nsnow' , '-' ,& 'number of snow layers' , & . TRUE ., 'integer' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) CALL define_ovar ( ncid_restart , TsurfaceID , 'Tsurface' , 'degC' ,& 'soil or snow surface T' , & . TRUE ., 'real' , 0 , 0 , 0 , mpID , dummy ,. TRUE .) END IF ! SLI soil model ! Write global attributes for file: CALL DATE_AND_TIME ( todaydate , nowtime ) todaydate = todaydate ( 1 : 4 ) // '/' // todaydate ( 5 : 6 ) // '/' // todaydate ( 7 : 8 ) nowtime = nowtime ( 1 : 2 ) // ':' // nowtime ( 3 : 4 ) // ':' // nowtime ( 5 : 6 ) ok = NF90_PUT_ATT ( ncid_restart , NF90_GLOBAL , \"Production\" , & TRIM ( todaydate ) // ' at ' // TRIM ( nowtime )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( frst_out ) // ' (SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , NF90_GLOBAL , \"Source\" , & 'CABLE LSM restart file' ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( frst_out ) // ' (SUBROUTINE create_restart)' ) ok = NF90_PUT_ATT ( ncid_restart , NF90_GLOBAL , \"CABLE_input_file\" , & TRIM ( filename % met )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing global detail to ' & // TRIM ( frst_out ) // ' (SUBROUTINE create_restart)' ) ! End netcdf define mode: ok = NF90_ENDDEF ( ncid_restart ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error creating restart file ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write time variable: ok = NF90_PUT_VAR ( ncid_restart , tvarID , REAL ( REAL ( ktau ) * dels , r_2 )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error time variable to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write latitude and longitude variables: ok = NF90_PUT_VAR ( ncid_restart , latID , latitude ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing latitude variable to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ok = NF90_PUT_VAR ( ncid_restart , lonID , longitude ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing longitude variable to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write number of active patches for each land grid cell: ok = NF90_PUT_VAR ( ncid_restart , napID , nap ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing nap variable to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write vegetated patch fractions ok = NF90_PUT_VAR ( ncid_restart , patchfrac_id , & lucmp % patchfrac , start = ( / 1 / ), count = ( / mpx / )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing patchfrac to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write number of veg and soil types ok = NF90_PUT_VAR ( ncid_restart , mvtype_id , mvtype ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing mvtype parameter to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ok = NF90_PUT_VAR ( ncid_restart , mstype_id , mstype ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , & 'Error writing mstype parameter to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Write parameters: CALL write_ovar ( ncid_restart , iveg_id , 'iveg' , REAL ( lucmp % iveg , 4 ), & ranges % iveg , . TRUE ., 'integer' , . TRUE .) CALL write_ovar ( ncid_restart , isoil_id , 'isoil' , REAL ( lucmp % isoil , 4 ), & ranges % isoil , . TRUE ., 'integer' , . TRUE .) CALL write_ovar ( ncid_restart , tggID , 'tgg' , REAL ( lucmp % tgg , 4 ), & ranges % SoilTemp , . TRUE ., 'soil' , . TRUE .) CALL write_ovar ( ncid_restart , wbID , 'wb' , lucmp % wb , ranges % SoilMoist , & . TRUE ., 'soil' , . TRUE .) CALL write_ovar ( ncid_restart , wbiceID , 'wbice' , lucmp % wbice , & ranges % SoilMoist , . TRUE ., 'soil' , . TRUE .) CALL write_ovar ( ncid_restart , gammzzID , 'gammzz' , lucmp % gammzz , & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'soil' , . TRUE .) ! Snow dimensioned variables/parameters: CALL write_ovar ( ncid_restart , ssdnID , 'ssdn' , REAL ( lucmp % ssdn , 4 ), & ( / 0.0 , 999 9.0 / ), . TRUE ., 'snow' , . TRUE .) CALL write_ovar ( ncid_restart , smassID , 'smass' , REAL ( lucmp % smass , 4 ), & ( / 0.0 , 999 9.0 / ), . TRUE ., 'snow' , . TRUE .) CALL write_ovar ( ncid_restart , sdepthID , 'sdepth' , REAL ( lucmp % sdepth , 4 ), & ( / 0.0 , 999 9.0 / ), . TRUE ., 'snow' , . TRUE .) CALL write_ovar ( ncid_restart , tggsnID , 'tggsn' , REAL ( lucmp % tggsn , 4 ), & ( / 10 0.0 , 30 0.0 / ), . TRUE ., 'snow' , . TRUE .) ! Other dims CALL write_ovar ( ncid_restart , albsoilsnID , 'albsoilsn' , & REAL ( lucmp % albsoilsn , 4 ), ( / 0.0 , 1.0 / ), . TRUE ., 'radiation' , . TRUE .) CALL write_ovar ( ncid_restart , cplantID , 'cplant' , REAL ( lucmp % cplantx , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'plantcarbon' , . TRUE .) CALL write_ovar ( ncid_restart , csoilID , 'csoil' , REAL ( lucmp % csoilx , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'soilcarbon' , . TRUE .) ok = NF90_PUT_VAR ( ncid_restart , zse_id , REAL ( soil % zse , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing zse parameter to ' & // TRIM ( frst_out ) // '(SUBROUTINE create_restart)' ) ! Single dim: CALL write_ovar ( ncid_restart , albsoil_id , 'albsoil' , & REAL ( lucmp % albsoil , 4 ), ranges % albsoil , . TRUE ., & 'radiation' , . TRUE .) CALL write_ovar ( ncid_restart , tssID , 'tss' , REAL ( lucmp % tss , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , ssdnnID , 'ssdnn' , REAL ( lucmp % ssdnn , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , osnowdID , 'osnowd' , REAL ( lucmp % osnowd , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , snageID , 'snage' , REAL ( lucmp % snage , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , snowdID , 'snowd' , REAL ( lucmp % snowd , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , rtsoilID , 'rtsoil' , REAL ( lucmp % rtsoil , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , isflagID , 'isflag' , REAL ( lucmp % isflag , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'integer' , . TRUE .) CALL write_ovar ( ncid_restart , canstoID , 'cansto' , REAL ( lucmp % cansto , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , sghfluxID , 'sghflux' , & REAL ( lucmp % sghflux , 4 ), ( /- 9999 9.0 , 999999 9.0 / ), & . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , ghfluxID , 'ghflux' , REAL ( lucmp % ghflux , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , runoffID , 'runoff' , REAL ( lucmp % runoff , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , rnof1ID , 'rnof1' , REAL ( lucmp % rnof1 , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , rnof2ID , 'rnof2' , REAL ( lucmp % rnof2 , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , gaID , 'ga' , REAL ( lucmp % ga , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , dgdtgID , 'dgdtg' , lucmp % dgdtg , & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'r2' , . TRUE .) CALL write_ovar ( ncid_restart , fevID , 'fev' , REAL ( lucmp % fev , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , fesID , 'fes' , REAL ( lucmp % fes , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , fhsID , 'fhs' , REAL ( lucmp % fhs , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , wbtot0ID , 'wbtot0' , REAL ( lucmp % wbtot0 , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , osnowd0ID , 'osnowd0' , REAL ( lucmp % osnowd0 , 4 ), & ( /- 9999 9.0 , 999999 9.0 / ), . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , albedoID , 'albedo' , REAL ( lucmp % albedo , 4 ), & ranges % Albedo , . TRUE ., 'radiation' , . TRUE .) CALL write_ovar ( ncid_restart , tradID , 'trad' , & REAL ( lucmp % trad , 4 ), ranges % RadT , . TRUE ., 'real' , . TRUE .) CALL write_ovar ( ncid_restart , gwID , 'GWwb' , REAL ( lucmp % GWwb , 4 ), & ranges % GWwb , . TRUE ., 'real' , . TRUE .) ! Close restart file ok = NF90_CLOSE ( ncid_restart ) write ( logn , * ) ' landuse on' WRITE ( logn , '(A36)' ) '   Restart file complete and closed.' END SUBROUTINE create_landuse_cable_restart","tags":"","loc":"sourcefile/landuse_inout.f90.html"},{"title":"cbl_model_driver_offline.F90 – CABLE","text":"Contents Modules cable_cbm_module Source Code cbl_model_driver_offline.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Calls CABLE routines including define_air, surface_albedo, !          define_canopy, soilsnow, carbon !          Note that cbm is called once per timestep in the offline case but !          twice per timestep in the ACCESS case. Not all parts of cbm !          are executed in each of the ACCESS calls. ! ! Called from: cable_driver for offline version !              cable_explicit_driver, cable_implicit_driver for ACCESS ! ! Contact: Yingping.Wang@csiro.au ! ! History: Calling sequence changes for ACCESS compared to v1.4b ! !          REV_CORR package of fixes for the sensitivity/correction terms ! ! ============================================================================== MODULE cable_cbm_module IMPLICIT NONE PRIVATE PUBLIC cbm CONTAINS SUBROUTINE cbm ( ktau , dels , air , bgc , canopy , met , & bal , rad , rough , soil , & ssnow , sum_flux , veg , climate , xk , c1 , rhoch ) USE cable_common_module USE cable_carbon_module USE cbl_soil_snow_main_module , ONLY : soil_snow USE cable_def_types_mod USE cable_roughness_module , ONLY : ruff_resist USE cbl_init_radiation_module , ONLY : init_radiation USE cable_air_module , ONLY : define_air USE casadimension , ONLY : icycle ! used in casa_cnp ! physical constants USE cable_phys_constants_mod , ONLY : CGRAV => GRAV USE cable_phys_constants_mod , ONLY : CCAPP => CAPP USE cable_phys_constants_mod , ONLY : CEMLEAF => EMLEAF USE cable_phys_constants_mod , ONLY : CEMSOIL => EMSOIL USE cable_phys_constants_mod , ONLY : CSBOLTZ => SBOLTZ !mrd561 USE cable_gw_hydro_module , ONLY : sli_hydrology ,& soil_snow_gw USE cable_canopy_module , ONLY : define_canopy USE cbl_albedo_mod , ONLY : albedo USE sli_main_mod , ONLY : sli_main USE snow_aging_mod , ONLY : snow_aging !data !jhan:pass these USE cable_other_constants_mod , ONLY : CLAI_THRESH => lai_thresh USE cable_other_constants_mod , ONLY : Crad_thresh => rad_thresh USE cable_other_constants_mod , ONLY : Ccoszen_tols => coszen_tols USE cable_other_constants_mod , ONLY : CGAUSS_W => gauss_w USE cable_math_constants_mod , ONLY : CPI => pi USE cable_math_constants_mod , ONLY : CPI180 => pi180 use cbl_masks_mod , ONLY : fveg_mask , fsunlit_mask , fsunlit_veg_mask use cbl_masks_mod , ONLY : veg_mask , sunlit_mask , sunlit_veg_mask ! CABLE model variables TYPE ( air_type ), INTENT ( INOUT ) :: air TYPE ( bgc_pool_type ), INTENT ( INOUT ) :: bgc TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy TYPE ( met_type ), INTENT ( INOUT ) :: met TYPE ( balances_type ), INTENT ( INOUT ) :: bal TYPE ( radiation_type ), INTENT ( INOUT ) :: rad TYPE ( roughness_type ), INTENT ( INOUT ) :: rough TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow TYPE ( sum_flux_type ), INTENT ( INOUT ) :: sum_flux TYPE ( climate_type ), INTENT ( IN ) :: climate TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg REAL , INTENT ( IN ) :: dels ! time setp size (s) INTEGER , INTENT ( IN ) :: ktau INTEGER :: k , kk , j character ( len =* ), parameter :: subr_name = \"cbm\" LOGICAL :: cbl_standalone = . true . LOGICAL :: jls_standalone = . false . LOGICAL :: jls_radiation = . false . !co-efficients usoughout init_radiation ` called from _albedo as well REAL :: c1 ( mp , nrb ) REAL :: rhoch ( mp , nrb ) REAL :: xk ( mp , nrb ) !iFor testing cable_user % soil_struc = \"default\" CALL ruff_resist ( veg , rough , ssnow , canopy , veg % vlai , veg % hc , canopy % vlaiw ) !jhan: this call to define air may be redundant CALL define_air ( met , air ) call fveg_mask ( veg_mask , mp , Clai_thresh , canopy % vlaiw ) !call fsunlit_mask( sunlit_mask, mp, Ccoszen_tols, met%coszen ) call fsunlit_mask ( sunlit_mask , mp , CRAD_THRESH ,( met % fsd (:, 1 ) + met % fsd (:, 2 ) ) ) call fsunlit_veg_mask ( sunlit_veg_mask , mp ) CALL init_radiation ( rad % extkb , rad % extkd , & !ExtCoeff_beam, ExtCoeff_dif, rad % extkbm , rad % extkdm , Rad % Fbeam , & !EffExtCoeff_beam, EffExtCoeff_dif, RadFbeam, c1 , rhoch , xk , & mp , nrb , & Clai_thresh , Ccoszen_tols , CGauss_w , Cpi , Cpi180 , & cbl_standalone , jls_standalone , jls_radiation , & subr_name , & veg_mask , sunlit_mask , sunlit_veg_mask , & veg % Xfang , veg % taul , veg % refl , & !VegXfang, VegTaul, VegRefl met % coszen , int ( met % DoY ), met % fsd , & !coszen, metDoY, SW_down, canopy % vlaiw & ) !reducedLAIdue2snow !Ticket 331 refactored albedo code for JAC CALL snow_aging ( ssnow % snage , mp , dels , ssnow % snowd , ssnow % osnowd , ssnow % tggsn (:, 1 ),& ssnow % tgg (:, 1 ), ssnow % isflag , veg % iveg , soil % isoilm ) call Albedo ( ssnow % AlbSoilsn , soil % AlbSoil , & !AlbSnow, AlbSoil, mp , nrb , & jls_radiation , & veg_mask , sunlit_mask , sunlit_veg_mask , & Ccoszen_tols , CGAUSS_W , & veg % iveg , soil % isoilm , veg % refl , veg % taul , & !surface_type, VegRefl, VegTaul, met % coszen , canopy % vlaiw , & !coszen, reducedLAIdue2snow, ssnow % snowd , ssnow % ssdnn , ssnow % tgg (:, 1 ), ssnow % snage , & !SnowDepth, SnowDensity, SoilTemp, SnowAge, xk , c1 , rhoch , & rad % fbeam , rad % albedo , & !RadFbeam, RadAlbedo, rad % extkd , rad % extkb , & !ExtCoeff_dif, ExtCoeff_beam, rad % extkdm , rad % extkbm , & !EffExtCoeff_dif, EffExtCoeff_beam, rad % rhocdf , rad % rhocbm , & !CanopyRefl_dif,CanopyRefl_beam, rad % cexpkdm , rad % cexpkbm , & !CanopyTransmit_dif, CanopyTransmit_beam, rad % reffdf , rad % reffbm & ) !EffSurfRefl_dif, EffSurfRefl_beam ssnow % otss_0 = ssnow % otss ! vh should be before call to canopy? ssnow % otss = ssnow % tss CALL define_canopy ( bal , rad , rough , air , met , dels , ssnow , soil , veg , canopy , climate , sunlit_veg_mask , canopy % vlaiw ) ssnow % owetfac = ssnow % wetfac CALL soil_snow ( dels , soil , ssnow , canopy , met , bal , veg ) ssnow % deltss = ssnow % tss - ssnow % otss ! need to adjust fe after soilsnow canopy % fev = canopy % fevc + canopy % fevw ! Calculate total latent heat flux: canopy % fe = canopy % fev + canopy % fes ! Calculate net radiation absorbed by soil + veg canopy % rnet = canopy % fns + canopy % fnv ! Calculate radiative/skin temperature: rad % trad = ( ( 1. - rad % transd ) * canopy % tv ** 4 + & rad % transd * ssnow % tss ** 4 ) ** 0.25 IF ( icycle == 0 ) THEN !calculate canopy%frp CALL plantcarb ( veg , bgc , met , canopy ) !calculate canopy%frs CALL soilcarb ( soil , ssnow , veg , bgc , met , canopy ) CALL carbon_pl ( dels , soil , ssnow , veg , canopy , bgc ) canopy % fnpp = - 1.0 * canopy % fpn - canopy % frp canopy % fnee = canopy % fpn + canopy % frs + canopy % frp ENDIF END SUBROUTINE cbm END MODULE cable_cbm_module","tags":"","loc":"sourcefile/cbl_model_driver_offline.f90.html"},{"title":"cable_namelist_input.F90 – CABLE","text":"Contents Modules cable_namelist_util Source Code cable_namelist_input.F90 Source Code MODULE cable_namelist_util !module contains a subroutine to get a namelist file names something !besides cable.nml from the first argument passed to CABLE on the !command line.  If the first argument does not end in nml it is assumed !that is specifies the met or cnppool that will be read from GETARG !later IMPLICIT NONE CHARACTER (:), ALLOCATABLE , SAVE :: CABLE_NAMELIST LOGICAL , SAVE :: arg_not_namelist CONTAINS SUBROUTINE get_namelist_file_name () !LOCAL INTEGER :: arg_length INTEGER :: command_line_stat LOGICAL :: no_arguments !get namelist name arg_not_namelist = . FALSE . !assume the best! IF ( COMMAND_ARGUMENT_COUNT () == 0 ) THEN no_arguments = . TRUE . ELSE no_arguments = . FALSE . END IF IF (. NOT . no_arguments ) THEN CALL GET_COMMAND_ARGUMENT ( 1 , LENGTH = arg_length , STATUS = command_line_stat ) IF (( command_line_stat . GT . 0 ) . OR . ( arg_length . EQ . 0 )) THEN WRITE ( * , * ) \"Cannot process command line definition of namelist fie \" WRITE ( * , * ) \"using cable.nml as the namelsit\" IF ( ALLOCATED ( CABLE_NAMELIST )) DEALLOCATE ( CABLE_NAMELIST ) ALLOCATE ( CHARACTER ( 9 ) :: CABLE_NAMELIST ) CABLE_NAMELIST = \"cable.nml\" END IF ALLOCATE ( CHARACTER ( arg_length ) :: CABLE_NAMELIST ) CALL GET_COMMAND_ARGUMENT ( 1 , VALUE = CABLE_NAMELIST , STATUS = command_line_stat ) !check it ends in nml IF (( SCAN ( CABLE_NAMELIST , 'l' , back = . TRUE .) . NE . ( SCAN ( CABLE_NAMELIST , 'm' , back = . TRUE .) + 1 )) . OR . & ( SCAN ( CABLE_NAMELIST , 'l' , back = . TRUE .) . NE . ( SCAN ( CABLE_NAMELIST , 'n' , back = . TRUE .) + 2 )) ) THEN WRITE ( * , * ) 'FIRST ARGUMENT DOES NOT END IN NML' WRITE ( * , * ) 'ASSUMING filename%met and casafile%cnpipool' arg_not_namelist = . TRUE . END IF IF (( command_line_stat . NE . 0 ) . OR . ( arg_not_namelist )) THEN WRITE ( * , * ) \"Using cable.nml as the namelsit\" IF ( ALLOCATED ( CABLE_NAMELIST )) DEALLOCATE ( CABLE_NAMELIST ) ALLOCATE ( CHARACTER ( 9 ) :: CABLE_NAMELIST ) CABLE_NAMELIST = \"cable.nml\" END IF ELSE WRITE ( * , * ) \"Cannot process command line definition of namelist fie \" WRITE ( * , * ) \"using cable.nml as the namelsit\" IF ( ALLOCATED ( CABLE_NAMELIST )) DEALLOCATE ( CABLE_NAMELIST ) ALLOCATE ( CHARACTER ( 9 ) :: CABLE_NAMELIST ) CABLE_NAMELIST = \"cable.nml\" END IF IF ( no_arguments ) arg_not_namelist = . TRUE . END SUBROUTINE get_namelist_file_name END MODULE cable_namelist_util","tags":"","loc":"sourcefile/cable_namelist_input.f90.html"},{"title":"cable_define_types.F90 – CABLE","text":"Contents Modules cable_def_types_mod Source Code cable_define_types.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: defines parameters, variables and derived types, allocation and !          deallocation of these derived types ! ! Contact: Bernard.Pak@csiro.au ! ! History: Brings together define_dimensions and define_types from v1.4b !          rs20 now in veg% instead of soil% !          fes split into fess and fesp (though fes still defined) ! ! Jan 2016: Now includes climate% for use in climate variables required for ! prognostic phenology and potential veg type ! ============================================================================== !#define UM_BUILD yes MODULE cable_def_types_mod ! Contains all variables which are not subroutine-internal IMPLICIT NONE SAVE PUBLIC !---CABLE default KINDs for representing INTEGER/REAL values !---at least 10-digit precision INTEGER :: mp , & ! # total no of patches/tiles mvtype ,& ! total # vegetation types,   from input #ifdef UM_BUILD mstype = 9 ,& ! total # soil types, needs to de defined atCompile TimeForNow #else mstype ,& ! total # soil types,         from input #endif mland ! # land grid cells INTEGER , PARAMETER :: & i_d = KIND ( 9 ), & #ifdef UM_BUILD r_2 = KIND ( 1.0 ),& !SELECTED_REAL_KIND(12, 50), & #else r_2 = KIND ( 1.d0 ),& !SELECTED_REAL_KIND(12, 50), & #endif n_tiles = 17 , & ! # possible no of different ncp = 3 , & ! # vegetation carbon stores ncs = 2 , & ! # soil carbon stores mf = 2 , & ! # leaves (sunlit, shaded) nrb = 3 , & ! # radiation bands msn = 3 , & ! max # snow layers swb = 2 , & ! # shortwave bands niter = 4 , & ! number of iterations for za/L !      ms = 12          ! # soil layers ms = 6 ! # soil layers - standard !       ms = 13          ! for Loetschental experiment INTEGER , PARAMETER :: n_ktherm = 3 !   PRIVATE :: r_2, ms, msn, mf, nrb, ncp, ncs ! ............................................................................. ! Energy and water balance variables: TYPE balances_type REAL , DIMENSION (:), POINTER :: & drybal , & ! energy balance for dry canopy ebal , & ! energy balance per time step (W/m&#94;2) ebal_tot , & ! cumulative energy balance (W/m&#94;2) ebal_cncheck , & ! energy balance consistency check (W/m&#94;2) ebal_tot_cncheck , & ! cumulative energy balance (W/m&#94;2) ebaltr , & ! energy balance per time step (W/m&#94;2) ebal_tottr , & ! cumulative energy balance (W/m&#94;2) evap_tot , & ! cumulative evapotranspiration (mm/dels) osnowd0 , & ! snow depth, first time step precip_tot , & ! cumulative precipitation (mm/dels) rnoff_tot , & ! cumulative runoff (mm/dels) wbal , & ! water balance per time step (mm/dels) wbal_tot , & ! cumulative water balance (mm/dels) wbtot0 , & ! total soil water (mm), first time step wetbal , & ! energy balance for wet canopy cansto0 , & ! canopy water storage (mm) owbtot , & ! total soil water (mm), first time step evapc_tot , & ! cumulative evapotranspiration (mm/dels) evaps_tot , & ! cumulative evapotranspiration (mm/dels) rnof1_tot , & ! cumulative runoff (mm/dels) rnof2_tot , & ! cumulative runoff (mm/dels) snowdc_tot , & ! cumulative runoff (mm/dels) wbal_tot1 , & ! cumulative water balance (mm/dels) delwc_tot , & ! energy balance for wet canopy qasrf_tot , & ! heat advected to the snow by precip. qfsrf_tot , & ! energy of snowpack phase changes qssrf_tot , & ! energy of snowpack phase changes Radbal , & EbalSoil , & Ebalveg , & Radbalsum END TYPE balances_type ! ............................................................................. ! Soil parameters: TYPE soil_parameter_type INTEGER , DIMENSION (:), POINTER :: & isoilm ! integer soil type REAL , DIMENSION (:), POINTER :: & bch , & ! parameter b in Campbell equation c3 , & ! c3 drainage coeff (fraction) clay , & ! fraction of soil which is clay css , & ! soil specific heat capacity [kJ/kg/K] hsbh , & ! difsat * etasat (=hyds*abs(sucs)*bch) hyds , & ! hydraulic conductivity @ saturation [m/s], Ksat i2bp3 , & ! par. one in K vis suction (=nint(bch)+2) ibp2 , & ! par. two in K vis suction (fn of pbch) rhosoil , & ! soil density [kg/m3] sand , & ! fraction of soil which is sand sfc , & ! vol H2O @ field capacity silt , & ! fraction of soil which is silt ssat , & ! vol H2O @ saturation sucs , & ! suction at saturation (m) swilt , & ! vol H2O @ wilting zse , & ! thickness of each soil layer (1=top) in m zshh , & ! distance between consecutive layer midpoints (m) ! vars intro for Ticket #27 soilcol , & ! keep color for all patches/tiles albsoilf ! soil reflectance REAL ( r_2 ), DIMENSION (:,:), POINTER :: & heat_cap_lower_limit REAL ( r_2 ), DIMENSION (:,:), POINTER :: & zse_vec , css_vec , cnsd_vec REAL ( r_2 ), DIMENSION (:), POINTER :: & cnsd , & ! thermal conductivity of dry soil [W/m/K] pwb_min ! working variable (swilt/ssat)**ibp2 REAL , DIMENSION (:,:), POINTER :: & albsoil ! soil reflectance (2nd dim. BP 21Oct2009) !mrd561 !MD parameters for GW module that vary with soil layer REAL ( r_2 ), DIMENSION (:,:), POINTER :: & sucs_vec , & !psi at saturation in [mm] hyds_vec , & !saturated hydraulic conductivity  [mm/s] bch_vec , & !C and H B [none] clay_vec , & !fraction of soil that is clay [frac] sand_vec , & !fraction of soil that is sand [frac] silt_vec , & !fraction of soil that is silt [frac] org_vec , & !fration of soil made of organic soils [frac] rhosoil_vec ,& !soil density  [kg/m3] ssat_vec , & !volumetric water content at saturation [mm3/mm3] watr , & !residual water content of the soil [mm3/mm3] sfc_vec , & !field capcacity (hk = 1 mm/day) swilt_vec ! wilting point (hk = 0.02 mm/day) REAL ( r_2 ), DIMENSION (:), POINTER :: & drain_dens ,& !  drainage density ( mean dist to rivers/streams ) elev , & !elevation above sea level elev_std , & !elevation above sea level slope , & !mean slope of grid cell slope_std !stddev of grid cell slope !MD parameters for GW module for the aquifer REAL ( r_2 ), DIMENSION (:), POINTER :: & GWsucs_vec , & !head in the aquifer [mm] GWhyds_vec , & !saturated hydraulic conductivity of the aquifer [mm/s] GWbch_vec , & !clapp and horn b of the aquifer   [none] GWssat_vec , & !saturated water content of the aquifer [mm3/mm3] GWwatr , & !residual water content of the aquifer [mm3/mm3] GWz , & !node depth of the aquifer    [m] GWdz , & !thickness of the aquifer   [m] GWrhosoil_vec !density of the aquifer substrate [kg/m3] ! Additional SLI parameters INTEGER , DIMENSION (:), POINTER :: nhorizons ! number of soil horizons INTEGER , DIMENSION (:,:), POINTER :: ishorizon ! horizon number 1:nhorizons REAL ( r_2 ), DIMENSION (:), POINTER :: clitt ! litter (tC/ha) REAL ( r_2 ), DIMENSION (:), POINTER :: zeta ! macropore parameter REAL ( r_2 ), DIMENSION (:), POINTER :: fsatmax ! variably saturated area parameter !REAL(r_2), DIMENSION(:,:), POINTER :: swilt_vec ! vol H2O @ wilting !REAL(r_2), DIMENSION(:,:), POINTER :: ssat_vec  ! vol H2O @ sat !REAL(r_2), DIMENSION(:,:), POINTER :: sfc_vec   ! vol H2O @ fc END TYPE soil_parameter_type ! ............................................................................. ! Soil and snow variables: TYPE soil_snow_type INTEGER , DIMENSION (:), POINTER :: isflag ! 0 => no snow 1 => snow REAL , DIMENSION (:), POINTER :: & iantrct , & ! pointer to Antarctic land points pudsto , & ! puddle storage pudsmx , & ! puddle storage cls , & ! factor for latent heat dfn_dtg , & ! d(canopy%fns)/d(ssnow%tgg) dfh_dtg , & ! d(canopy%fhs)/d(ssnow%tgg) dfe_ddq , & ! d(canopy%fes)/d(dq)        - REV_CORR: no longer necessary ddq_dtg , & ! d(dq)/d(ssnow%tgg)         - REV_CORR: no longer necessary dfe_dtg , & ! d(canopy%fes)/d(ssnow%tgg) - REV_CORR: covers above vars evapsn , & ! snow evaporation fwtop , & ! water flux to the soil fwtop1 , & ! water flux to the soil fwtop2 , & ! water flux to the soil fwtop3 , & ! water flux to the soil osnowd , & ! snow depth from previous time step potev , & ! potential evapotranspiration runoff , & ! total runoff (mm/dels) rnof1 , & ! surface runoff (mm/dels) rnof2 , & ! deep drainage (mm/dels) rtsoil , & ! turbulent resistance for soil wbtot1 , & ! total soil water (mm) wbtot2 , & ! total soil water (mm) wb_lake , & totwblake , & !daily integrated wb_lake: used in ACCESS sinfil , & qstss , & wetfac , & ! surface wetness fact. at current time step owetfac , & ! surface wetness fact. at previous time step t_snwlr , & ! top snow layer depth in 3 layer snowpack tggav , & ! mean soil temperature in K otgg , & ! soil temperature in K otss , & ! surface temperature (weighted soil, snow) otss_0 , & ! surface temperature (weighted soil, snow) tprecip , & tevap , & trnoff , & totenbal ,& ! totenbal2 ,& fland , & ! factor for latent heat ifland , & ! integer soil type qasrf , & ! heat advected to the snow by precip. qfsrf , & ! energy of snowpack phase changes qssrf , & ! sublimation snage , & ! snow age snowd , & ! snow depth (liquid water) smelt , & ! snow melt ssdnn , & ! average snow density tss , & ! surface temperature (weighted soil, snow) tss_p , & ! surface temperature (weighted soil, snow) deltss , & ! surface temperature (weighted soil, snow) owb1 ! surface temperature (weighted soil, snow) REAL , DIMENSION (:,:), POINTER :: & sconds , & ! sdepth , & ! snow depth smass , & ! snow mass ssdn , & ! snow densities tgg , & ! soil temperature in K tggsn , & ! snow temperature in K dtmlt , & ! water flux to the soil albsoilsn , & ! soil + snow reflectance evapfbl , & ! tilefrac ! factor for latent heat REAL ( r_2 ), DIMENSION (:), POINTER :: & wbtot ! total soil water (mm) REAL ( r_2 ), DIMENSION (:,:), POINTER :: & gammzz , & ! heat capacity for each soil layer wb , & ! volumetric soil moisture (solid+liq) wbice , & ! soil ice wblf , & ! wbfice ! !mrd561 !MD variables for the revised soil moisture + GW scheme REAL ( r_2 ), DIMENSION (:), POINTER :: & GWwb , & ! water content in aquifer [mm3/mm3] GWhk , & ! aquifer hydraulic conductivity  [mm/s] GWdhkdw , & ! aquifer d(hk) over d(water content) [(mm/s)/(mm3/mm3)] GWdsmpdw ,& ! aquifer d(smp) / dw   [(mm)/(mm3/mm3)] wtd , & ! water table depth   [mm] GWsmp , & ! aquifer soil matric potential [mm] GWwbeq , & ! equilibrium aquifer water content [mm3/mm3] GWzq , & ! equilibrium aquifer smp   [mm] qhz , & ! horizontal hydraulic conductivity in 1D gw model for soil layers  [mm/s] satfrac , & Qrecharge ,& rh_srf , & rtevap_sat ,& rtevap_unsat ,& rt_qh_sublayer REAL ( r_2 ), DIMENSION (:,:), POINTER :: & wbeq , & ! equilibrium water content [mm3/mm3] zq , & ! equilibrium smp       [mm] icefrac , & ! ice fraction  [none]  -> ice mass / total mass fracice , & ! alternate ice fraction  [none] - parameterized hk , & ! hydraulic conductivity for soil layers [mm/s] smp , & ! soil matric potential for soil layers         [mm] dhkdw , & ! d(hydraulic conductivity ) d(water) for soil layers [(mm/s)/(mm3/mm3)] dsmpdw , & ! d(smp)/ d(water) for soil layers   [(mm)/(mm3/mm3)] wbliq , & ! volumetric liquid water content  [mm3/mm3] wmliq , & !water mass [mm] liq wmice , & !water mass [mm] ice wmtot , & !water mass [mm] liq+ice ->total qhlev ! Additional SLI variables: REAL ( r_2 ), DIMENSION (:,:), POINTER :: S ! moisture content relative to sat value    (edit vh 23/01/08) REAL ( r_2 ), DIMENSION (:,:), POINTER :: Tsoil !     Tsoil (deg C) REAL ( r_2 ), DIMENSION (:), POINTER :: SL ! litter moisture content relative to sat value (edit vh 23/01/08) REAL ( r_2 ), DIMENSION (:), POINTER :: TL ! litter temperature in K     (edit vh 23/01/08) REAL ( r_2 ), DIMENSION (:), POINTER :: h0 ! pond height in m            (edit vh 23/01/08) REAL ( r_2 ), DIMENSION (:,:), POINTER :: rex ! root extraction from each layer (mm/dels) REAL ( r_2 ), DIMENSION (:,:), POINTER :: wflux ! water flux at layer boundaries (mm s-1) REAL ( r_2 ), DIMENSION (:), POINTER :: delwcol ! change in water column (mm / dels) REAL ( r_2 ), DIMENSION (:), POINTER :: zdelta ! water table depth           (edit vh 23/06/08) REAL ( r_2 ), DIMENSION (:,:), POINTER :: kth ! thermal conductivity           (edit vh 29/07/08) REAL ( r_2 ), DIMENSION (:), POINTER :: Tsurface !  tepmerature at surface (soil, pond or litter) (edit vh 22/10/08) REAL ( r_2 ), DIMENSION (:), POINTER :: lE ! soil latent heat flux REAL ( r_2 ), DIMENSION (:), POINTER :: evap ! soil evaporation (mm / dels) REAL ( r_2 ), DIMENSION (:,:), POINTER :: ciso ! concentration of minor isotopologue in soil water (kg m-3 water) REAL ( r_2 ), DIMENSION (:), POINTER :: cisoL ! concentration of minor isotopologue in litter water (kg m-3 water) REAL ( r_2 ), DIMENSION (:), POINTER :: rlitt ! resistance to heat/moisture transfer through litter (m-1 s) REAL ( r_2 ), DIMENSION (:,:), POINTER :: thetai ! volumetric ice content (MC) REAL ( r_2 ), DIMENSION (:,:), POINTER :: snowliq ! liquid snow content (mm H2O) REAL ( r_2 ), DIMENSION (:), POINTER :: nsteps ! number of iterations at each timestep REAL ( r_2 ), DIMENSION (:), POINTER :: TsurfaceFR !  tepmerature at surface (soil, pond or litter) (edit vh 22/10/08) REAL ( r_2 ), DIMENSION (:,:), POINTER :: Ta_daily ! air temp averaged over last 24h INTEGER , DIMENSION (:), POINTER :: nsnow ! number of layers in snow-pack (0-nsnow_max) REAL ( r_2 ), DIMENSION (:), POINTER :: Qadv_daily ! advective heat flux into surface , daily average (W m-2) REAL ( r_2 ), DIMENSION (:), POINTER :: G0_daily ! conductive heat flux into surface , daily average (W m-2) REAL ( r_2 ), DIMENSION (:), POINTER :: Qevap_daily ! evaporative flux at surface, daily average (m s-1) REAL ( r_2 ), DIMENSION (:), POINTER :: Qprec_daily ! liquid precip, daily average (m s-1) REAL ( r_2 ), DIMENSION (:), POINTER :: Qprec_snow_daily ! solid precip, daily average (m s-1) END TYPE soil_snow_type ! ............................................................................. ! Vegetation parameters: TYPE veg_parameter_type INTEGER , DIMENSION (:), POINTER :: & iveg , & ! vegetation type iLU ! land use type REAL , DIMENSION (:), POINTER :: & canst1 , & ! max intercepted water by canopy (mm/LAI) dleaf , & ! chararacteristc legnth of leaf (m) ejmax , & ! max pot. electron transp rate top leaf(mol/m2/s) meth , & ! method for calculation of canopy fluxes and temp. frac4 , & ! fraction of c4 plants hc , & ! roughness height of canopy (veg - snow) vlai , & ! leaf area index xalbnir , & rp20 , & ! plant respiration coefficient at 20 C rpcoef , & ! temperature coef nonleaf plant respiration (1/C) rs20 , & ! soil respiration at 20 C [mol m-2 s-1] shelrb , & ! sheltering factor (dimensionless) vegcf , & ! kdcorbin, 08/10 tminvj , & ! min temperature of the start of photosynthesis toptvj , & ! opt temperature of the start of photosynthesis tmaxvj , & ! max temperature of the start of photosynthesis vbeta , & ! vcmax , & ! max RuBP carboxylation rate top leaf (mol/m2/s) xfang , & ! leaf angle PARAMETER extkn , & ! extinction coef for vertical vlaimax , & ! extinction coef for vertical wai , & ! wood area index (stem+branches+twigs) a1gs , & ! a1 parameter in stomatal conductance model d0gs , & ! d0 in stomatal conductance model alpha , & ! initial slope of J-Q response curve convex , & ! convexity of J-Q response curve cfrd , & ! ratio of day respiration to vcmax gswmin , & ! minimal stomatal conductance conkc0 , & ! Michaelis-menton constant for carboxylase conko0 , & ! Michaelis-menton constant for oxygenase ekc , & ! activation energy for caroxylagse eko , & ! acvtivation enegery for oxygenase g0 , & ! Belinda's stomatal model intercept, Ticket #56. g1 ! Belinda's stomatal model slope, Ticket #56. LOGICAL , DIMENSION (:), POINTER :: & deciduous ! flag used for phenology fix REAL , DIMENSION (:,:), POINTER :: & refl , & taul , & froot ! fraction of root in each soil layer ! Additional  veg parameters: REAL ( r_2 ), DIMENSION (:), POINTER :: rootbeta ! parameter for estimating vertical root mass distribution (froot) REAL ( r_2 ), DIMENSION (:), POINTER :: gamma ! parameter in root efficiency function (Lai and Katul 2000) REAL ( r_2 ), DIMENSION (:), POINTER :: ZR ! maximum rooting depth (cm) REAL ( r_2 ), DIMENSION (:), POINTER :: F10 ! fraction of roots in top 10 cm REAL ( r_2 ), DIMENSION (:), POINTER :: clitt ! ! Additional POP veg param INTEGER , DIMENSION (:,:), POINTER :: disturbance_interval REAL ( r_2 ), DIMENSION (:,:), POINTER :: disturbance_intensity END TYPE veg_parameter_type ! ............................................................................. ! Canopy/vegetation variables: TYPE canopy_type REAL , DIMENSION (:), POINTER :: & cansto , & ! canopy water storage (mm) cduv , & ! drag coefficient for momentum delwc , & ! change in canopy water store (mm/dels) dewmm , & ! dewfall (mm) fe , & ! total latent heat (W/m2) fh , & ! total sensible heat (W/m2) fpn , & ! plant photosynthesis (g C m-2 s-1) frp , & ! plant respiration (g C m-2 s-1) frpw , & ! plant respiration (woody component) (g C m-2 s-1) frpr , & ! plant respiration (root component) (g C m-2 s-1) frs , & ! soil respiration (g C m-2 s-1) fnee , & ! net carbon flux (g C m-2 s-1) frday , & ! daytime leaf resp fnv , & ! net rad. avail. to canopy (W/m2) fev , & ! latent hf from canopy (W/m2) epot , & ! total potential evaporation fnpp , & ! npp flux fevw_pot ,& ! potential lat heat from canopy gswx_T , & ! ! stom cond for water cdtq , & ! drag coefficient for momentum wetfac_cs ,& ! fevw , & ! lat heat fl wet canopy (W/m2) fhvw , & ! sens heatfl from wet canopy (W/m2) oldcansto ,& ! canopy water storage (mm) fhv , & ! sens heatfl from canopy (W/m2) fns , & ! net rad avail to soil (W/m2) fhs , & ! sensible heat flux from soil fhs_cor , & ga , & ! ground heat flux (W/m2) ??? ghflux , & ! ground heat flux (W/m2) ??? precis , & ! throughfall to soil, after snow (mm) qscrn , & ! specific humudity at screen height (g/g) rnet , & ! net radiation absorbed by surface (W/m2) rniso , & !isothermal net radiation absorbed by surface (W/m2) segg , & ! latent heatfl from soil mm sghflux , & ! ground heat flux (W/m2) ??? through , & ! canopy throughfall (mm) through_sn , & ! canopy snow throughfall (equal to precip_sn) (mm) spill , & ! can.storage excess after dewfall (mm) tscrn , & ! air temperature at screen height (oC) wcint , & ! canopy rainfall interception (mm) tv , & ! vegetation temp (K) us , & ! friction velocity uscrn , & ! wind speed at screen height (m/s) vlaiw , & ! lai adj for snow depth for calc of resistances rghlai , & ! lai adj for snow depth for calc of resistances fwet ! fraction of canopy wet !INH - new REV_CORR coupling variables REAL , DIMENSION (:), POINTER :: & fns_cor , & ! correction to net rad avail to soil (W/m2) ga_cor ! correction to ground heat flux (W/m2) REAL , DIMENSION (:,:), POINTER :: & evapfbl , & gswx , & ! stom cond for water zetar , & ! stability parameter (ref height) !! vh_js !! zetash ! stability parameter (shear height) REAL ( r_2 ), DIMENSION (:), POINTER :: & fess , & ! latent heatfl from soil (W/m2) fesp , & ! latent heatfl from soil (W/m2) dgdtg , & ! derivative of gflux wrt soil temp fes , & ! latent heatfl from soil (W/m2) fes_cor , & ! latent heatfl from soil (W/m2) fevc , & ! dry canopy transpiration (W/m2) ofes ! latent heatfl from soil (W/m2) !SSEB - new variables limits on correction terms - for future use !REAL(r_2), DIMENSION(:), POINTER ::                                     & !  fescor_upp,& ! upper limit on the correction term fes_cor (W/m2) !  fescor_low   ! lower limit on the correction term fes_cor (W/m2) REAL ( r_2 ), DIMENSION (:), POINTER :: & sublayer_dz ! Additional variables: REAL ( r_2 ), DIMENSION (:,:), POINTER :: gw ! dry canopy conductance (ms-1) edit vh 6/7/09 REAL ( r_2 ), DIMENSION (:,:,:), POINTER :: ancj ! limiting photosynthetic rates (Rubisco,RuBP,sink) vh 6/7/09 REAL ( r_2 ), DIMENSION (:,:), POINTER :: tlfy ! sunlit and shaded leaf temperatures REAL ( r_2 ), DIMENSION (:,:), POINTER :: ecy ! sunlit and shaded leaf transpiration (dry canopy) REAL ( r_2 ), DIMENSION (:,:), POINTER :: ecx ! sunlit and shaded leaf latent heat flux REAL ( r_2 ), DIMENSION (:,:,:), POINTER :: ci ! intra-cellular CO2 vh 6/7/09 REAL ( r_2 ), DIMENSION (:), POINTER :: fwsoil ! !! vh_js !! !litter thermal conductivity (Wm-2K-1) and vapour diffusivity (m2s-1) REAL ( r_2 ), DIMENSION (:), POINTER :: kthLitt , DvLitt END TYPE canopy_type ! ............................................................................. ! Radiation variables: TYPE radiation_type REAL , DIMENSION (:), POINTER :: & transb , & ! fraction SW beam tranmitted through canopy albedo_T ,& ! canopy+soil albedo for VIS+NIR longitude ,& ! longitude workp1 , & ! absorbed short-wave radiation for soil workp2 , & ! absorbed short-wave radiation for soil workp3 , & ! absorbed short-wave radiation for soil extkb , & ! beam radiation extinction coeff extkd2 , & ! diffuse 2D radiation extinction coeff extkd , & ! diffuse radiation extinction coeff (-) flws , & ! soil long-wave radiation latitude ,& ! latitude lwabv , & ! long wave absorbed by vegetation qssabs , & ! absorbed short-wave radiation for soil transd , & ! frac SW diffuse transmitted through canopy trad , & !  radiative temperature (soil and veg) otrad ! radiative temperature on previous timestep (ACCESS) REAL , DIMENSION (:,:), POINTER :: & fvlai , & ! leaf area index of big leaf rhocdf , & ! canopy diffuse reflectance (-) rniso , & ! sum(rad%qcan, 3) total abs by canopy (W/m2) scalex , & ! scaling PARAMETER for big leaf albedo , & ! canopy+soil albedo reffdf , & ! effective conopy diffuse reflectance reffbm , & ! effective conopy beam reflectance extkbm , & ! modified k beam(6.20)(for leaf scattering) extkdm , & ! modified k diffuse(6.20)(for leaf scattering) fbeam , & ! beam fraction cexpkbm , & ! canopy beam transmittance cexpkdm , & ! canopy diffuse transmittance rhocbm , & ! modified canopy beam reflectance(6.21) gradis ! radiative conductance REAL , DIMENSION (:,:,:), POINTER :: & qcan ! absorbed radiation for canopy (W/m&#94;2) END TYPE radiation_type ! ............................................................................. ! Roughness variables: TYPE roughness_type REAL , DIMENSION (:), POINTER :: & disp , & ! zero-plane displacement hruff , & ! canopy height above snow level hruff_grmx ,& ! max ht of canopy from tiles on same grid rt0us , & ! eq. 3.54, SCAM manual (CSIRO tech report 132) rt1usa , & ! resistance from disp to hruf rt1usb , & ! resist fr hruf to zruffs (zref if zref<zruffs) rt1 , & ! 1/aerodynamic conductance za_uv , & ! level of lowest atmospheric model layer za_tq , & ! level of lowest atmospheric model layer z0m , & ! roughness length zref_uv , & ! Reference height for met forcing zref_tq , & ! Reference height for met forcing zruffs , & ! SCALAR Roughness sublayer depth (ground=origin) z0soilsn ,& ! roughness length of bare soil surface z0soil ! roughness length of bare soil surface ! \"coexp\": coefficient in exponential in-canopy wind profile ! U(z) = U(h)*exp(coexp*(z/h-1)), found by gradient-matching ! canopy and roughness-sublayer U(z) at z=h REAL , DIMENSION (:), POINTER :: & coexp ! Extinction coef for wind profile in canopy ! \"usuh\": us/uh (us=friction velocity, uh = mean velocity at z=h) REAL , DIMENSION (:), POINTER :: & usuh ! Friction velocity/windspeed at canopy height REAL , DIMENSION (:), POINTER :: & term2 , term3 , term5 , term6 , term6a ! for aerodyn resist. calc. END TYPE roughness_type ! ............................................................................. ! Air variables: TYPE air_type REAL , DIMENSION (:), POINTER :: & rho , & ! dry air density (kg m-3) volm , & ! molar volume (m3 mol-1) rlam , & ! latent heat for water (j/kg) qsat , & ! saturation specific humidity epsi , & ! d(qsat)/dT ((kg/kg)/K) visc , & ! air kinematic viscosity (m2/s) psyc , & ! psychrometric constant dsatdk , & ! d(es)/dT (mb/K) cmolar ! conv. from m/s to mol/m2/s END TYPE air_type ! ............................................................................. ! Meterological data: TYPE met_type INTEGER , DIMENSION (:), POINTER :: & year , & ! local time year AD moy ! local time month of year REAL , DIMENSION (:), POINTER :: & ca , & ! CO2 concentration (mol/mol) doy , & ! local time day of year = days since 0 hr 1st Jan hod , & ! local hour of day ofsd , & ! downward short-wave radiation (W/m2) fld , & ! downward long-wave radiation (W/m2) precip , & ! rainfall (liquid+solid)(mm/dels) precip_sn ,& ! solid preipitation only (mm/dels) tk , & ! surface air temperature (oK) tvair , & ! within canopy air temperature (oK) tvrad , & ! radiative vegetation temperature (K) pmb , & ! surface air pressure (mbar) ua , & ! surface wind speed (m/s) qv , & ! surface specific humidity (g/g) qvair , & ! within canopy specific humidity (g/g) da , & ! water vap pressure deficit at ref height (Pa) dva , & ! in canopy water vap pressure deficit (Pa) coszen , & ! cos(zenith angle of sun) Ndep , & ! nitrogen deposition (gN m-2 d-1) Pdep ! P deposition (gP m-2 d-1) REAL , DIMENSION (:,:), POINTER :: & fsd ! downward short-wave radiation (W/m2) END TYPE met_type ! ............................................................................. ! Climate data: TYPE climate_type INTEGER :: nyear_average = 20 INTEGER :: nday_average = 31 !      INTEGER, POINTER ::                                                  & INTEGER :: & nyears , & ! number of years in climate record doy ! day of year INTEGER , DIMENSION (:), POINTER :: & chilldays , & ! length of chilling period (period with T<5deg) iveg , & ! potential vegetation type based on climatic constraints biome REAL , DIMENSION (:), POINTER :: & dtemp , & ! daily temperature dmoist , & ! daily moisture availability mtemp , & ! mean temperature over the last 31 days qtemp , & ! mean temperature over the last 91 days mmoist , & ! monthly moisture availability mtemp_min , & ! minimum monthly temperature mtemp_max , & ! maximum monhtly temperature qtemp_max , & ! mean temperature of the warmest quarter (so far this year) qtemp_max_last_year , & ! mean temperature of the warmest quarter (last calendar year) mtemp_min20 , & ! minimum monthly temperature, averaged over 20 y mtemp_max20 , & ! maximum monhtly temperature, averaged over 20 y atemp_mean , & ! annual average temperature AGDD5 , & GDD5 , & ! growing degree day sum relative to 5deg base temperature AGDD0 , & ! GDD0 , & ! growing degree day sum relative to 0deg base temperature alpha_PT , & ! ratio of annual evap to annual PT evap evap_PT , & ! annual PT evap [mm] aevap , & ! annual evap [mm] alpha_PT20 REAL , DIMENSION (:,:), POINTER :: & mtemp_min_20 , & ! mimimum monthly temperatures for the last 20 y mtemp_max_20 , & ! maximum monthly temperatures for the last 20 y dtemp_31 , & ! daily temperature for the last 31 days dmoist_31 , & ! daily moisture availability for the last 31 days alpha_PT_20 , & ! priestley Taylor Coefft for last 20 y dtemp_91 ! daily temperature for the last 91 days END TYPE climate_type ! ............................................................................. ! Cumulative flux variables: TYPE sum_flux_type REAL , DIMENSION (:), POINTER :: & sumpn , & ! sum of canopy photosynthesis (g C m-2) sumrp , & ! sum of plant respiration (g C m-2) sumrpw , & ! sum of plant respiration (g C m-2) sumrpr , & ! sum of plant respiration (g C m-2) sumrs , & ! sum of soil respiration (g C m-2) sumrd , & ! sum of daytime respiration (g C m-2) dsumpn , & ! daily sumpn dsumrp , & ! daily sumrp dsumrs , & ! daily sumrs dsumrd , & ! daily sumrd sumxrp , & ! sum plant resp. modifier sumxrs ! sum soil resp. modifier END TYPE sum_flux_type ! ............................................................................. TYPE bgc_pool_type REAL , DIMENSION (:,:), POINTER :: & cplant , & ! plant carbon (g C/m2)) csoil ! soil carbon (g C/m2) REAL , DIMENSION ( ncp ) :: ratecp ! plant carbon rate constant (1/year) REAL , DIMENSION ( ncs ) :: ratecs ! soil carbon rate constant (1/year) END TYPE bgc_pool_type ! ............................................................................. ! Functions for allocating these types ! All overloaded so code only needs to call alloc_cbm_var ! Alloc routines could all initialise to NaN or zero for debugging? ! Don't need the mp argument here as it's a module variable. PUBLIC :: alloc_cbm_var PRIVATE :: alloc_bgc_pool_type , dealloc_bgc_pool_type INTERFACE alloc_cbm_var MODULE PROCEDURE alloc_balances_type , & alloc_soil_parameter_type , & alloc_soil_snow_type , & alloc_veg_parameter_type , & alloc_canopy_type , & alloc_radiation_type , & alloc_roughness_type , & alloc_air_type , & alloc_met_type , & alloc_sum_flux_type , & alloc_bgc_pool_type , & alloc_climate_type END INTERFACE INTERFACE dealloc_cbm_var MODULE PROCEDURE dealloc_balances_type , & dealloc_soil_parameter_type , & dealloc_soil_snow_type , & dealloc_veg_parameter_type , & dealloc_canopy_type , & dealloc_radiation_type , & dealloc_roughness_type , & dealloc_air_type , & dealloc_met_type , & dealloc_sum_flux_type , & dealloc_bgc_pool_type END INTERFACE CONTAINS SUBROUTINE alloc_balances_type ( var , mp ) TYPE ( balances_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % drybal ( mp ) ) ALLOCATE ( var % ebal ( mp ) ) ALLOCATE ( var % ebal_tot ( mp ) ) ALLOCATE ( var % ebaltr ( mp ) ) ALLOCATE ( var % ebal_tottr ( mp ) ) ALLOCATE ( var % ebal_cncheck ( mp ) ) ALLOCATE ( var % ebal_tot_cncheck ( mp ) ) ALLOCATE ( var % evap_tot ( mp ) ) ALLOCATE ( var % osnowd0 ( mp ) ) ALLOCATE ( var % precip_tot ( mp ) ) ALLOCATE ( var % rnoff_tot ( mp ) ) ALLOCATE ( var % wbal ( mp ) ) ALLOCATE ( var % wbal_tot ( mp ) ) ALLOCATE ( var % wbtot0 ( mp ) ) ALLOCATE ( var % wetbal ( mp ) ) ALLOCATE ( var % cansto0 ( mp ) ) ALLOCATE ( var % evapc_tot ( mp ) ) ALLOCATE ( var % evaps_tot ( mp ) ) ALLOCATE ( var % rnof1_tot ( mp ) ) ALLOCATE ( var % rnof2_tot ( mp ) ) ALLOCATE ( var % snowdc_tot ( mp ) ) ALLOCATE ( var % wbal_tot1 ( mp ) ) ALLOCATE ( var % owbtot ( mp ) ) ALLOCATE ( var % delwc_tot ( mp ) ) ALLOCATE ( var % qasrf_tot ( mp ) ) ALLOCATE ( var % qfsrf_tot ( mp ) ) ALLOCATE ( var % qssrf_tot ( mp ) ) ALLOCATE ( var % Radbal ( mp ) ) ALLOCATE ( var % EbalSoil ( mp ) ) ALLOCATE ( var % Ebalveg ( mp ) ) ALLOCATE ( var % Radbalsum ( mp ) ) END SUBROUTINE alloc_balances_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_soil_parameter_type ( var , mp ) TYPE ( soil_parameter_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % bch ( mp ) ) ALLOCATE ( var % c3 ( mp ) ) ALLOCATE ( var % clay ( mp ) ) ALLOCATE ( var % css ( mp ) ) ALLOCATE ( var % hsbh ( mp ) ) ALLOCATE ( var % hyds ( mp ) ) ALLOCATE ( var % i2bp3 ( mp ) ) ALLOCATE ( var % ibp2 ( mp ) ) ALLOCATE ( var % isoilm ( mp ) ) ALLOCATE ( var % rhosoil ( mp ) ) ALLOCATE ( var % sand ( mp ) ) ALLOCATE ( var % sfc ( mp ) ) ALLOCATE ( var % silt ( mp ) ) ALLOCATE ( var % ssat ( mp ) ) ALLOCATE ( var % sucs ( mp ) ) ALLOCATE ( var % swilt ( mp ) ) ALLOCATE ( var % zse ( ms ) ) ALLOCATE ( var % zshh ( ms + 1 ) ) ALLOCATE ( var % cnsd ( mp ) ) ALLOCATE ( var % albsoil ( mp , nrb ) ) ALLOCATE ( var % pwb_min ( mp ) ) ALLOCATE ( var % albsoilf ( mp ) ) ALLOCATE ( var % soilcol ( mp ) ) !mrd561 !MD !Aquifer properties ALLOCATE ( var % GWhyds_vec ( mp ) ) ALLOCATE ( var % GWsucs_vec ( mp ) ) ALLOCATE ( var % GWbch_vec ( mp ) ) ALLOCATE ( var % GWssat_vec ( mp ) ) ALLOCATE ( var % GWwatr ( mp ) ) var % GWwatr (:) = 0.05 ALLOCATE ( var % GWz ( mp ) ) ALLOCATE ( var % GWdz ( mp ) ) ALLOCATE ( var % GWrhosoil_vec ( mp ) ) !soil properties (vary by layer) ALLOCATE ( var % zse_vec ( mp , ms ) ) ALLOCATE ( var % heat_cap_lower_limit ( mp , ms ) ) ALLOCATE ( var % css_vec ( mp , ms ) ) ALLOCATE ( var % cnsd_vec ( mp , ms ) ) ALLOCATE ( var % hyds_vec ( mp , ms ) ) ALLOCATE ( var % sucs_vec ( mp , ms ) ) ALLOCATE ( var % bch_vec ( mp , ms ) ) ALLOCATE ( var % ssat_vec ( mp , ms ) ) ALLOCATE ( var % watr ( mp , ms ) ) var % watr (:,:) = 0.05 ALLOCATE ( var % sfc_vec ( mp , ms ) ) ALLOCATE ( var % swilt_vec ( mp , ms ) ) ALLOCATE ( var % sand_vec ( mp , ms ) ) ALLOCATE ( var % clay_vec ( mp , ms ) ) ALLOCATE ( var % silt_vec ( mp , ms ) ) ALLOCATE ( var % org_vec ( mp , ms ) ) ALLOCATE ( var % rhosoil_vec ( mp , ms ) ) ALLOCATE ( var % drain_dens ( mp ) ) ALLOCATE ( var % elev ( mp ) ) ALLOCATE ( var % elev_std ( mp ) ) ALLOCATE ( var % slope ( mp ) ) ALLOCATE ( var % slope_std ( mp ) ) ! Allocate variables for SLI soil model: ALLOCATE ( var % nhorizons ( mp ) ) ALLOCATE ( var % ishorizon ( mp , ms ) ) ALLOCATE ( var % clitt ( mp ) ) ALLOCATE ( var % zeta ( mp ) ) ALLOCATE ( var % fsatmax ( mp ) ) !ALLOCATE ( var % swilt_vec(mp,ms) ) !ALLOCATE ( var % ssat_vec(mp,ms) ) !ALLOCATE ( var % sfc_vec(mp,ms) ) IF (. NOT .( ASSOCIATED ( var % swilt_vec ))) ALLOCATE ( var % swilt_vec ( mp , ms ) ) IF (. NOT .( ASSOCIATED ( var % ssat_vec ))) ALLOCATE ( var % ssat_vec ( mp , ms ) ) IF (. NOT .( ASSOCIATED ( var % sfc_vec ))) ALLOCATE ( var % sfc_vec ( mp , ms ) ) END SUBROUTINE alloc_soil_parameter_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_soil_snow_type ( var , mp ) TYPE ( soil_snow_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % iantrct ( mp ) ) ALLOCATE ( var % pudsto ( mp ) ) ALLOCATE ( var % pudsmx ( mp ) ) ALLOCATE ( var % dtmlt ( mp , 3 ) ) ALLOCATE ( var % albsoilsn ( mp , nrb ) ) ALLOCATE ( var % cls ( mp ) ) ALLOCATE ( var % dfn_dtg ( mp ) ) ALLOCATE ( var % dfh_dtg ( mp ) ) ALLOCATE ( var % dfe_ddq ( mp ) ) ALLOCATE ( var % ddq_dtg ( mp ) ) ALLOCATE ( var % dfe_dtg ( mp ) ) !REV_CORR variable ALLOCATE ( var % evapsn ( mp ) ) ALLOCATE ( var % fwtop ( mp ) ) ALLOCATE ( var % fwtop1 ( mp ) ) ALLOCATE ( var % fwtop2 ( mp ) ) ALLOCATE ( var % fwtop3 ( mp ) ) ALLOCATE ( var % gammzz ( mp , ms ) ) ALLOCATE ( var % isflag ( mp ) ) ALLOCATE ( var % osnowd ( mp ) ) ALLOCATE ( var % potev ( mp ) ) ALLOCATE ( var % runoff ( mp ) ) ALLOCATE ( var % rnof1 ( mp ) ) ALLOCATE ( var % rnof2 ( mp ) ) ALLOCATE ( var % rtsoil ( mp ) ) ALLOCATE ( var % sconds ( mp , msn ) ) ALLOCATE ( var % sdepth ( mp , msn ) ) ALLOCATE ( var % smass ( mp , msn ) ) ALLOCATE ( var % snage ( mp ) ) ALLOCATE ( var % snowd ( mp ) ) ALLOCATE ( var % smelt ( mp ) ) ALLOCATE ( var % ssdn ( mp , msn ) ) ALLOCATE ( var % ssdnn ( mp ) ) ALLOCATE ( var % tgg ( mp , ms ) ) ALLOCATE ( var % tggsn ( mp , msn ) ) ALLOCATE ( var % tss ( mp ) ) ALLOCATE ( var % tss_p ( mp ) ) ALLOCATE ( var % deltss ( mp ) ) ALLOCATE ( var % owb1 ( mp ) ) ALLOCATE ( var % wb ( mp , ms ) ) ALLOCATE ( var % wbice ( mp , ms ) ) ALLOCATE ( var % wblf ( mp , ms ) ) ALLOCATE ( var % wbtot ( mp ) ) ALLOCATE ( var % wbtot1 ( mp ) ) ALLOCATE ( var % wbtot2 ( mp ) ) ALLOCATE ( var % wb_lake ( mp ) ) ALLOCATE ( var % totwblake ( mp ) ) ALLOCATE ( var % sinfil ( mp ) ) ALLOCATE ( var % evapfbl ( mp , ms ) ) ALLOCATE ( var % qstss ( mp ) ) ALLOCATE ( var % wetfac ( mp ) ) ALLOCATE ( var % owetfac ( mp ) ) ALLOCATE ( var % t_snwlr ( mp ) ) ALLOCATE ( var % wbfice ( mp , ms ) ) ALLOCATE ( var % tggav ( mp ) ) ALLOCATE ( var % otgg ( mp ) ) ALLOCATE ( var % otss ( mp ) ) ALLOCATE ( var % otss_0 ( mp ) ) ALLOCATE ( var % tprecip ( mp ) ) ALLOCATE ( var % tevap ( mp ) ) ALLOCATE ( var % trnoff ( mp ) ) ALLOCATE ( var % totenbal ( mp ) ) ALLOCATE ( var % totenbal2 ( mp ) ) ALLOCATE ( var % fland ( mp ) ) ALLOCATE ( var % ifland ( mp ) ) ALLOCATE ( var % tilefrac ( mp , n_tiles ) ) ALLOCATE ( var % qasrf ( mp ) ) ALLOCATE ( var % qfsrf ( mp ) ) ALLOCATE ( var % qssrf ( mp ) ) !mrd561 !MD !Aquifer variables ALLOCATE ( var % GWwb ( mp ) ) ALLOCATE ( var % GWhk ( mp ) ) ALLOCATE ( var % GWdhkdw ( mp ) ) ALLOCATE ( var % GWdsmpdw ( mp ) ) ALLOCATE ( var % wtd ( mp ) ) ALLOCATE ( var % GWsmp ( mp ) ) ALLOCATE ( var % GWwbeq ( mp ) ) ALLOCATE ( var % GWzq ( mp ) ) ALLOCATE ( var % qhz ( mp ) ) ALLOCATE ( var % qhlev ( mp , ms + 1 ) ) ALLOCATE ( var % satfrac ( mp ) ) ALLOCATE ( var % Qrecharge ( mp ) ) ALLOCATE ( var % rh_srf ( mp ) ) ALLOCATE ( var % rtevap_unsat ( mp ) ) ALLOCATE ( var % rtevap_sat ( mp ) ) ALLOCATE ( var % rt_qh_sublayer ( mp ) ) !soil moisture variables ALLOCATE ( var % wbeq ( mp , ms ) ) ALLOCATE ( var % zq ( mp , ms ) ) ALLOCATE ( var % icefrac ( mp , ms ) ) ALLOCATE ( var % fracice ( mp , ms ) ) ALLOCATE ( var % hk ( mp , ms ) ) ALLOCATE ( var % smp ( mp , ms ) ) ALLOCATE ( var % dhkdw ( mp , ms ) ) ALLOCATE ( var % dsmpdw ( mp , ms ) ) ALLOCATE ( var % wbliq ( mp , ms ) ) ALLOCATE ( var % wmliq ( mp , ms ) ) ALLOCATE ( var % wmice ( mp , ms ) ) ALLOCATE ( var % wmtot ( mp , ms ) ) ! Allocate variables for SLI soil model: !IF(cable_user%SOIL_STRUC=='sli') THEN ALLOCATE ( var % S ( mp , ms ) ) ALLOCATE ( var % Tsoil ( mp , ms ) ) ALLOCATE ( var % SL ( mp ) ) ALLOCATE ( var % TL ( mp ) ) ALLOCATE ( var % h0 ( mp ) ) ALLOCATE ( var % rex ( mp , ms ) ) ALLOCATE ( var % wflux ( mp , 0 : ms ) ) ALLOCATE ( var % delwcol ( mp ) ) ALLOCATE ( var % zdelta ( mp ) ) ALLOCATE ( var % kth ( mp , ms ) ) ALLOCATE ( var % Tsurface ( mp ) ) ALLOCATE ( var % lE ( mp ) ) ALLOCATE ( var % evap ( mp ) ) ALLOCATE ( var % ciso ( mp , ms + 1 ) ) ALLOCATE ( var % cisoL ( mp ) ) ALLOCATE ( var % rlitt ( mp ) ) ALLOCATE ( var % thetai ( mp , ms ) ) ALLOCATE ( var % snowliq ( mp , 3 ) ) ALLOCATE ( var % nsteps ( mp ) ) ALLOCATE ( var % nsnow ( mp ) ) ALLOCATE ( var % TsurfaceFR ( mp ) ) ALLOCATE ( var % Ta_daily ( mp , 100 )) ALLOCATE ( var % Qadv_daily ( mp ) ) ALLOCATE ( var % G0_daily ( mp ) ) ALLOCATE ( var % Qevap_daily ( mp ) ) ALLOCATE ( var % Qprec_daily ( mp ) ) ALLOCATE ( var % Qprec_snow_daily ( mp ) ) !END IF END SUBROUTINE alloc_soil_snow_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_veg_parameter_type ( var , mp ) TYPE ( veg_parameter_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % canst1 ( mp ) ) ALLOCATE ( var % dleaf ( mp ) ) ALLOCATE ( var % ejmax ( mp ) ) ALLOCATE ( var % iveg ( mp ) ) ALLOCATE ( var % iLU ( mp ) ) ALLOCATE ( var % meth ( mp ) ) ALLOCATE ( var % frac4 ( mp ) ) ALLOCATE ( var % hc ( mp ) ) ALLOCATE ( var % vlai ( mp ) ) ALLOCATE ( var % xalbnir ( mp ) ) ALLOCATE ( var % rp20 ( mp ) ) ALLOCATE ( var % rpcoef ( mp ) ) ALLOCATE ( var % rs20 ( mp ) ) ALLOCATE ( var % shelrb ( mp ) ) ALLOCATE ( var % vegcf ( mp ) ) ALLOCATE ( var % tminvj ( mp ) ) ALLOCATE ( var % toptvj ( mp ) ) ALLOCATE ( var % tmaxvj ( mp ) ) ALLOCATE ( var % vbeta ( mp ) ) ALLOCATE ( var % vcmax ( mp ) ) ALLOCATE ( var % xfang ( mp ) ) ALLOCATE ( var % extkn ( mp ) ) ALLOCATE ( var % wai ( mp ) ) ALLOCATE ( var % deciduous ( mp ) ) ALLOCATE ( var % froot ( mp , ms ) ) !was nrb(=3), but never uses (:,3) in model #ifdef UM_BUILD ALLOCATE ( var % refl ( mp , nrb ) ) !jhan:swb? ALLOCATE ( var % taul ( mp , nrb ) ) #else ALLOCATE ( var % refl ( mp , 2 ) ) !jhan:swb? ALLOCATE ( var % taul ( mp , 2 ) ) #endif ALLOCATE ( var % vlaimax ( mp ) ) ALLOCATE ( var % a1gs ( mp ) ) ALLOCATE ( var % d0gs ( mp ) ) ALLOCATE ( var % alpha ( mp ) ) ALLOCATE ( var % convex ( mp ) ) ALLOCATE ( var % cfrd ( mp ) ) ALLOCATE ( var % gswmin ( mp ) ) ALLOCATE ( var % conkc0 ( mp ) ) ALLOCATE ( var % conko0 ( mp ) ) ALLOCATE ( var % ekc ( mp ) ) ALLOCATE ( var % eko ( mp ) ) ALLOCATE ( var % g0 ( mp ) ) ! Ticket #56. ALLOCATE ( var % g1 ( mp ) ) ! Ticket #56. ALLOCATE ( var % rootbeta ( mp ) ) ALLOCATE ( var % gamma ( mp ) ) ALLOCATE ( var % F10 ( mp ) ) ALLOCATE ( var % ZR ( mp ) ) ALLOCATE ( var % clitt ( mp ) ) ALLOCATE ( var % disturbance_interval ( mp , 2 ) ) ALLOCATE ( var % disturbance_intensity ( mp , 2 ) ) END SUBROUTINE alloc_veg_parameter_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_canopy_type ( var , mp ) TYPE ( canopy_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % fess ( mp ) ) ALLOCATE ( var % fesp ( mp ) ) ALLOCATE ( var % cansto ( mp ) ) ALLOCATE ( var % cduv ( mp ) ) ALLOCATE ( var % delwc ( mp ) ) ALLOCATE ( var % dewmm ( mp ) ) ALLOCATE ( var % dgdtg ( mp ) ) ALLOCATE ( var % fe ( mp ) ) ALLOCATE ( var % fh ( mp ) ) ALLOCATE ( var % fpn ( mp ) ) ALLOCATE ( var % frp ( mp ) ) ALLOCATE ( var % frpw ( mp ) ) ALLOCATE ( var % frpr ( mp ) ) ALLOCATE ( var % frs ( mp ) ) ALLOCATE ( var % fnee ( mp ) ) ALLOCATE ( var % frday ( mp ) ) ALLOCATE ( var % fnv ( mp ) ) ALLOCATE ( var % fev ( mp ) ) ALLOCATE ( var % fevc ( mp ) ) ALLOCATE ( var % fhv ( mp ) ) ALLOCATE ( var % fns ( mp ) ) ALLOCATE ( var % fhs ( mp ) ) ALLOCATE ( var % fhs_cor ( mp ) ) ALLOCATE ( var % ga ( mp ) ) ALLOCATE ( var % ghflux ( mp ) ) ALLOCATE ( var % precis ( mp ) ) ALLOCATE ( var % qscrn ( mp ) ) ALLOCATE ( var % rnet ( mp ) ) ALLOCATE ( var % rniso ( mp ) ) ALLOCATE ( var % segg ( mp ) ) ALLOCATE ( var % sghflux ( mp ) ) ALLOCATE ( var % through ( mp ) ) ALLOCATE ( var % through_sn ( mp ) ) ALLOCATE ( var % spill ( mp ) ) ALLOCATE ( var % tscrn ( mp ) ) ALLOCATE ( var % wcint ( mp ) ) ALLOCATE ( var % tv ( mp ) ) ALLOCATE ( var % us ( mp ) ) ALLOCATE ( var % uscrn ( mp ) ) ALLOCATE ( var % rghlai ( mp ) ) ALLOCATE ( var % vlaiw ( mp ) ) ALLOCATE ( var % fwet ( mp ) ) ALLOCATE ( var % fns_cor ( mp ) ) !REV_CORR variable ALLOCATE ( var % ga_cor ( mp ) ) !REV_CORR variable ALLOCATE ( var % evapfbl ( mp , ms ) ) ALLOCATE ( var % epot ( mp ) ) ALLOCATE ( var % fnpp ( mp ) ) ALLOCATE ( var % fevw_pot ( mp ) ) ALLOCATE ( var % gswx_T ( mp ) ) ALLOCATE ( var % cdtq ( mp ) ) ALLOCATE ( var % wetfac_cs ( mp ) ) ALLOCATE ( var % fevw ( mp ) ) ALLOCATE ( var % fhvw ( mp ) ) ALLOCATE ( var % fes ( mp ) ) ALLOCATE ( var % fes_cor ( mp ) ) !ALLOCATE( var% fescor_upp(mp) )  !SSEB variable !ALLOCATE( var% fescor_low(mp) )  !SSEB variable ALLOCATE ( var % gswx ( mp , mf ) ) ALLOCATE ( var % oldcansto ( mp ) ) ALLOCATE ( var % zetar ( mp , NITER ) ) ALLOCATE ( var % zetash ( mp , NITER ) ) ALLOCATE ( var % fwsoil ( mp ) ) ALLOCATE ( var % ofes ( mp ) ) ALLOCATE ( var % sublayer_dz ( mp ) ) ALLOCATE ( var % gw ( mp , mf ) ) ! dry canopy conductance (ms-1) edit vh 6/7/09 ALLOCATE ( var % ancj ( mp , mf , 3 ) ) ! limiting photosynthetic rates (Rubisco,RuBP,sink) vh 6/7/09 ALLOCATE ( var % tlfy ( mp , mf ) ) ! sunlit and shaded leaf temperatures ALLOCATE ( var % ecy ( mp , mf ) ) ! sunlit and shaded leaf transpiration (dry canopy) ALLOCATE ( var % ecx ( mp , mf ) ) ! sunlit and shaded leaf latent heat flux ALLOCATE ( var % ci ( mp , mf , 3 ) ) ! intra-cellular CO2 vh 6/7/09 ALLOCATE ( var % fwsoil ( mp ) ) !! vh_js !! liiter resistances to heat and vapour transfer ALLOCATE ( var % kthLitt ( mp )) ALLOCATE ( var % DvLitt ( mp )) END SUBROUTINE alloc_canopy_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_radiation_type ( var , mp ) TYPE ( radiation_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % albedo ( mp , nrb ) ) ALLOCATE ( var % extkb ( mp ) ) ALLOCATE ( var % extkd2 ( mp ) ) ALLOCATE ( var % extkd ( mp ) ) ALLOCATE ( var % flws ( mp ) ) ALLOCATE ( var % fvlai ( mp , mf ) ) ALLOCATE ( var % latitude ( mp ) ) ALLOCATE ( var % lwabv ( mp ) ) ALLOCATE ( var % qcan ( mp , mf , nrb ) ) ALLOCATE ( var % qssabs ( mp ) ) ALLOCATE ( var % rhocdf ( mp , nrb ) ) ALLOCATE ( var % rniso ( mp , mf ) ) ALLOCATE ( var % scalex ( mp , mf ) ) ALLOCATE ( var % transd ( mp ) ) ALLOCATE ( var % trad ( mp ) ) ALLOCATE ( var % otrad ( mp ) ) ALLOCATE ( var % reffdf ( mp , nrb ) ) ALLOCATE ( var % reffbm ( mp , nrb ) ) ALLOCATE ( var % extkbm ( mp , nrb ) ) ALLOCATE ( var % extkdm ( mp , nrb ) ) ALLOCATE ( var % cexpkbm ( mp , swb ) ) ALLOCATE ( var % cexpkdm ( mp , swb ) ) ALLOCATE ( var % fbeam ( mp , nrb ) ) ALLOCATE ( var % rhocbm ( mp , nrb ) ) ALLOCATE ( var % transb ( mp ) ) ALLOCATE ( var % albedo_T ( mp ) ) ALLOCATE ( var % gradis ( mp , mf ) ) ALLOCATE ( var % longitude ( mp ) ) ALLOCATE ( var % workp1 ( mp ) ) ALLOCATE ( var % workp2 ( mp ) ) ALLOCATE ( var % workp3 ( mp ) ) END SUBROUTINE alloc_radiation_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_roughness_type ( var , mp ) TYPE ( roughness_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % coexp ( mp ) ) ALLOCATE ( var % disp ( mp ) ) ALLOCATE ( var % hruff ( mp ) ) ALLOCATE ( var % hruff_grmx ( mp ) ) ALLOCATE ( var % rt0us ( mp ) ) ALLOCATE ( var % rt1usa ( mp ) ) ALLOCATE ( var % rt1usb ( mp ) ) ALLOCATE ( var % rt1 ( mp ) ) ALLOCATE ( var % term2 ( mp ) ) ALLOCATE ( var % term3 ( mp ) ) ALLOCATE ( var % term5 ( mp ) ) ALLOCATE ( var % term6 ( mp ) ) ALLOCATE ( var % term6a ( mp ) ) ALLOCATE ( var % usuh ( mp ) ) ALLOCATE ( var % za_uv ( mp ) ) ALLOCATE ( var % za_tq ( mp ) ) ALLOCATE ( var % z0m ( mp ) ) ALLOCATE ( var % zref_uv ( mp ) ) ALLOCATE ( var % zref_tq ( mp ) ) ALLOCATE ( var % zruffs ( mp ) ) ALLOCATE ( var % z0soilsn ( mp ) ) ALLOCATE ( var % z0soil ( mp ) ) END SUBROUTINE alloc_roughness_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_air_type ( var , mp ) TYPE ( air_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % rho ( mp ) ) ALLOCATE ( var % volm ( mp ) ) ALLOCATE ( var % rlam ( mp ) ) ALLOCATE ( var % qsat ( mp ) ) ALLOCATE ( var % epsi ( mp ) ) ALLOCATE ( var % visc ( mp ) ) ALLOCATE ( var % psyc ( mp ) ) ALLOCATE ( var % dsatdk ( mp ) ) ALLOCATE ( var % cmolar ( mp ) ) END SUBROUTINE alloc_air_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_met_type ( var , mp ) TYPE ( met_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % ca ( mp ) ) ALLOCATE ( var % year ( mp ) ) ALLOCATE ( var % moy ( mp ) ) ALLOCATE ( var % doy ( mp ) ) ALLOCATE ( var % hod ( mp ) ) ALLOCATE ( var % fsd ( mp , swb ) ) ALLOCATE ( var % ofsd ( mp ) ) ALLOCATE ( var % fld ( mp ) ) ALLOCATE ( var % precip ( mp ) ) ALLOCATE ( var % precip_sn ( mp ) ) ALLOCATE ( var % tk ( mp ) ) ALLOCATE ( var % tvair ( mp ) ) ALLOCATE ( var % tvrad ( mp ) ) ALLOCATE ( var % pmb ( mp ) ) ALLOCATE ( var % ua ( mp ) ) ALLOCATE ( var % qv ( mp ) ) ALLOCATE ( var % qvair ( mp ) ) ALLOCATE ( var % da ( mp ) ) ALLOCATE ( var % dva ( mp ) ) ALLOCATE ( var % coszen ( mp ) ) ALLOCATE ( var % Ndep ( mp ) ) ALLOCATE ( var % Pdep ( mp ) ) END SUBROUTINE alloc_met_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_climate_type ( var , mp ) IMPLICIT NONE TYPE ( climate_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp INTEGER :: ny , nd ny = var % nyear_average nd = var % nday_average PRINT * , 'ny' , ny PRINT * , 'nd' , nd !   ALLOCATE ( var %  nyears ) !   ALLOCATE ( var %  doy ) ALLOCATE ( var % dtemp ( mp ) ) ALLOCATE ( var % dmoist ( mp ) ) ALLOCATE ( var % mtemp ( mp ) ) ALLOCATE ( var % qtemp ( mp ) ) ALLOCATE ( var % mmoist ( mp ) ) ALLOCATE ( var % mtemp_min ( mp ) ) ALLOCATE ( var % mtemp_max20 ( mp ) ) ALLOCATE ( var % mtemp_min20 ( mp ) ) ALLOCATE ( var % mtemp_max ( mp ) ) ALLOCATE ( var % qtemp_max ( mp ) ) ALLOCATE ( var % qtemp_max_last_year ( mp ) ) ALLOCATE ( var % atemp_mean ( mp ) ) ALLOCATE ( var % AGDD5 ( mp ) ) ALLOCATE ( var % GDD5 ( mp ) ) ALLOCATE ( var % AGDD0 ( mp ) ) ALLOCATE ( var % GDD0 ( mp ) ) ALLOCATE ( var % chilldays ( mp ) ) ALLOCATE ( var % iveg ( mp ) ) ALLOCATE ( var % biome ( mp ) ) ALLOCATE ( var % alpha_PT ( mp ) ) ALLOCATE ( var % alpha_PT20 ( mp ) ) ALLOCATE ( var % evap_PT ( mp ) ) ALLOCATE ( var % aevap ( mp ) ) ALLOCATE ( var % mtemp_min_20 ( mp , ny ) ) ALLOCATE ( var % mtemp_max_20 ( mp , ny ) ) ALLOCATE ( var % dtemp_31 ( mp , nd ) ) ALLOCATE ( var % dmoist_31 ( mp , nd ) ) ALLOCATE ( var % dtemp_91 ( mp , 91 ) ) ALLOCATE ( var % alpha_PT_20 ( mp , ny ) ) END SUBROUTINE alloc_climate_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_sum_flux_type ( var , mp ) TYPE ( sum_flux_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % sumpn ( mp ) ) ALLOCATE ( var % sumrp ( mp ) ) ALLOCATE ( var % sumrpw ( mp ) ) ALLOCATE ( var % sumrpr ( mp ) ) ALLOCATE ( var % sumrs ( mp ) ) ALLOCATE ( var % sumrd ( mp ) ) ALLOCATE ( var % dsumpn ( mp ) ) ALLOCATE ( var % dsumrp ( mp ) ) ALLOCATE ( var % dsumrs ( mp ) ) ALLOCATE ( var % dsumrd ( mp ) ) ALLOCATE ( var % sumxrp ( mp ) ) ALLOCATE ( var % sumxrs ( mp ) ) END SUBROUTINE alloc_sum_flux_type ! ------------------------------------------------------------------------------ SUBROUTINE alloc_bgc_pool_type ( var , mp ) TYPE ( bgc_pool_type ), INTENT ( inout ) :: var INTEGER , INTENT ( in ) :: mp ALLOCATE ( var % cplant ( mp , ncp ) ) ALLOCATE ( var % csoil ( mp , ncs ) ) END SUBROUTINE alloc_bgc_pool_type ! ------------------------------------------------------------------------------ ! Begin deallocation routines: SUBROUTINE dealloc_balances_type ( var ) TYPE ( balances_type ), INTENT ( inout ) :: var DEALLOCATE ( var % drybal ) DEALLOCATE ( var % ebal ) DEALLOCATE ( var % ebal_tot ) DEALLOCATE ( var % ebaltr ) DEALLOCATE ( var % ebal_tottr ) DEALLOCATE ( var % ebal_cncheck ) DEALLOCATE ( var % ebal_tot_cncheck ) DEALLOCATE ( var % evap_tot ) DEALLOCATE ( var % osnowd0 ) DEALLOCATE ( var % precip_tot ) DEALLOCATE ( var % rnoff_tot ) DEALLOCATE ( var % wbal ) DEALLOCATE ( var % wbal_tot ) DEALLOCATE ( var % wbtot0 ) DEALLOCATE ( var % wetbal ) DEALLOCATE ( var % cansto0 ) DEALLOCATE ( var % evapc_tot ) DEALLOCATE ( var % evaps_tot ) DEALLOCATE ( var % rnof1_tot ) DEALLOCATE ( var % rnof2_tot ) DEALLOCATE ( var % snowdc_tot ) DEALLOCATE ( var % wbal_tot1 ) DEALLOCATE ( var % owbtot ) DEALLOCATE ( var % delwc_tot ) DEALLOCATE ( var % qasrf_tot ) DEALLOCATE ( var % qfsrf_tot ) DEALLOCATE ( var % qssrf_tot ) DEALLOCATE ( var % Radbal ) DEALLOCATE ( var % Ebalsoil ) DEALLOCATE ( var % Ebalveg ) DEALLOCATE ( var % Radbalsum ) END SUBROUTINE dealloc_balances_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_soil_parameter_type ( var ) TYPE ( soil_parameter_type ), INTENT ( inout ) :: var DEALLOCATE ( var % bch ) DEALLOCATE ( var % c3 ) DEALLOCATE ( var % clay ) DEALLOCATE ( var % css ) DEALLOCATE ( var % hsbh ) DEALLOCATE ( var % hyds ) DEALLOCATE ( var % i2bp3 ) DEALLOCATE ( var % ibp2 ) DEALLOCATE ( var % isoilm ) DEALLOCATE ( var % rhosoil ) DEALLOCATE ( var % sand ) DEALLOCATE ( var % sfc ) DEALLOCATE ( var % silt ) DEALLOCATE ( var % ssat ) DEALLOCATE ( var % sucs ) DEALLOCATE ( var % swilt ) DEALLOCATE ( var % zse ) DEALLOCATE ( var % zshh ) DEALLOCATE ( var % cnsd ) DEALLOCATE ( var % albsoil ) DEALLOCATE ( var % cnsd ) DEALLOCATE ( var % pwb_min ) DEALLOCATE ( var % albsoilf ) DEALLOCATE ( var % soilcol ) !mrd561 !MD !Aquifer properties DEALLOCATE ( var % GWhyds_vec ) DEALLOCATE ( var % GWsucs_vec ) DEALLOCATE ( var % GWbch_vec ) DEALLOCATE ( var % GWssat_vec ) DEALLOCATE ( var % GWwatr ) DEALLOCATE ( var % GWz ) DEALLOCATE ( var % GWdz ) DEALLOCATE ( var % GWrhosoil_vec ) !soil properties (vary by layer) DEALLOCATE ( var % zse_vec ) DEALLOCATE ( var % heat_cap_lower_limit ) DEALLOCATE ( var % css_vec ) DEALLOCATE ( var % cnsd_vec ) DEALLOCATE ( var % hyds_vec ) DEALLOCATE ( var % sucs_vec ) DEALLOCATE ( var % bch_vec ) DEALLOCATE ( var % ssat_vec ) DEALLOCATE ( var % watr ) DEALLOCATE ( var % sfc_vec ) DEALLOCATE ( var % swilt_vec ) DEALLOCATE ( var % sand_vec ) DEALLOCATE ( var % clay_vec ) DEALLOCATE ( var % silt_vec ) DEALLOCATE ( var % org_vec ) DEALLOCATE ( var % rhosoil_vec ) DEALLOCATE ( var % drain_dens ) DEALLOCATE ( var % elev ) DEALLOCATE ( var % elev_std ) DEALLOCATE ( var % slope ) DEALLOCATE ( var % slope_std ) ! Deallocate variables for SLI soil model: !IF(cable_user%SOIL_STRUC=='sli') THEN DEALLOCATE ( var % nhorizons ) DEALLOCATE ( var % ishorizon ) DEALLOCATE ( var % clitt ) DEALLOCATE ( var % zeta ) DEALLOCATE ( var % fsatmax ) !DEALLOCATE ( var % swilt_vec ) !DEALLOCATE ( var % ssat_vec ) !DEALLOCATE ( var % sfc_vec ) IF ( ASSOCIATED ( var % swilt_vec )) DEALLOCATE ( var % swilt_vec ) IF ( ASSOCIATED ( var % ssat_vec )) DEALLOCATE ( var % ssat_vec ) IF ( ASSOCIATED ( var % sfc_vec )) DEALLOCATE ( var % sfc_vec ) !END IF END SUBROUTINE dealloc_soil_parameter_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_soil_snow_type ( var ) TYPE ( soil_snow_type ), INTENT ( inout ) :: var DEALLOCATE ( var % iantrct ) DEALLOCATE ( var % pudsto ) DEALLOCATE ( var % pudsmx ) DEALLOCATE ( var % dtmlt ) DEALLOCATE ( var % albsoilsn ) DEALLOCATE ( var % cls ) DEALLOCATE ( var % dfn_dtg ) DEALLOCATE ( var % dfh_dtg ) DEALLOCATE ( var % dfe_ddq ) DEALLOCATE ( var % ddq_dtg ) DEALLOCATE ( var % dfe_dtg ) !REV_CORR variable DEALLOCATE ( var % evapsn ) DEALLOCATE ( var % fwtop ) DEALLOCATE ( var % fwtop1 ) DEALLOCATE ( var % fwtop2 ) DEALLOCATE ( var % fwtop3 ) DEALLOCATE ( var % gammzz ) DEALLOCATE ( var % isflag ) DEALLOCATE ( var % osnowd ) DEALLOCATE ( var % potev ) DEALLOCATE ( var % runoff ) DEALLOCATE ( var % rnof1 ) DEALLOCATE ( var % rnof2 ) DEALLOCATE ( var % rtsoil ) DEALLOCATE ( var % sconds ) DEALLOCATE ( var % sdepth ) DEALLOCATE ( var % smass ) DEALLOCATE ( var % snage ) DEALLOCATE ( var % snowd ) DEALLOCATE ( var % smelt ) DEALLOCATE ( var % ssdn ) DEALLOCATE ( var % ssdnn ) DEALLOCATE ( var % tgg ) DEALLOCATE ( var % tggsn ) DEALLOCATE ( var % tss ) DEALLOCATE ( var % tss_p ) DEALLOCATE ( var % deltss ) DEALLOCATE ( var % owb1 ) DEALLOCATE ( var % wb ) DEALLOCATE ( var % wbice ) DEALLOCATE ( var % wblf ) DEALLOCATE ( var % wbtot ) DEALLOCATE ( var % wbtot1 ) DEALLOCATE ( var % wbtot2 ) DEALLOCATE ( var % wb_lake ) DEALLOCATE ( var % totwblake ) DEALLOCATE ( var % sinfil ) DEALLOCATE ( var % evapfbl ) DEALLOCATE ( var % qstss ) DEALLOCATE ( var % wetfac ) DEALLOCATE ( var % owetfac ) DEALLOCATE ( var % t_snwlr ) DEALLOCATE ( var % wbfice ) DEALLOCATE ( var % tggav ) DEALLOCATE ( var % otgg ) DEALLOCATE ( var % otss ) DEALLOCATE ( var % otss_0 ) DEALLOCATE ( var % tprecip ) DEALLOCATE ( var % tevap ) DEALLOCATE ( var % trnoff ) DEALLOCATE ( var % totenbal ) DEALLOCATE ( var % totenbal2 ) DEALLOCATE ( var % fland ) DEALLOCATE ( var % ifland ) DEALLOCATE ( var % tilefrac ) DEALLOCATE ( var % qasrf ) DEALLOCATE ( var % qfsrf ) DEALLOCATE ( var % qssrf ) !MD !Aquifer variables DEALLOCATE ( var % GWwb ) DEALLOCATE ( var % GWhk ) DEALLOCATE ( var % GWdhkdw ) DEALLOCATE ( var % GWdsmpdw ) DEALLOCATE ( var % wtd ) DEALLOCATE ( var % GWsmp ) DEALLOCATE ( var % GWwbeq ) DEALLOCATE ( var % GWzq ) DEALLOCATE ( var % qhz ) DEALLOCATE ( var % qhlev ) DEALLOCATE ( var % satfrac ) DEALLOCATE ( var % Qrecharge ) DEALLOCATE ( var % rh_srf ) DEALLOCATE ( var % rtevap_unsat ) DEALLOCATE ( var % rtevap_sat ) DEALLOCATE ( var % rt_qh_sublayer ) !soil moisture variables DEALLOCATE ( var % wbeq ) DEALLOCATE ( var % zq ) DEALLOCATE ( var % icefrac ) DEALLOCATE ( var % fracice ) DEALLOCATE ( var % hk ) DEALLOCATE ( var % smp ) DEALLOCATE ( var % dhkdw ) DEALLOCATE ( var % dsmpdw ) DEALLOCATE ( var % wbliq ) DEALLOCATE ( var % wmliq ) DEALLOCATE ( var % wmice ) DEALLOCATE ( var % wmtot ) !IF(cable_user%SOIL_STRUC=='sli') THEN DEALLOCATE ( var % S ) DEALLOCATE ( var % Tsoil ) DEALLOCATE ( var % SL ) DEALLOCATE ( var % TL ) DEALLOCATE ( var % h0 ) DEALLOCATE ( var % rex ) DEALLOCATE ( var % wflux ) DEALLOCATE ( var % delwcol ) DEALLOCATE ( var % zdelta ) DEALLOCATE ( var % kth ) DEALLOCATE ( var % Tsurface ) DEALLOCATE ( var % lE ) DEALLOCATE ( var % evap ) DEALLOCATE ( var % ciso ) DEALLOCATE ( var % cisoL ) DEALLOCATE ( var % rlitt ) DEALLOCATE ( var % thetai ) DEALLOCATE ( var % snowliq ) DEALLOCATE ( var % nsteps ) DEALLOCATE ( var % nsnow ) DEALLOCATE ( var % TsurfaceFR ) DEALLOCATE ( var % Ta_daily ) DEALLOCATE ( var % G0_daily ) DEALLOCATE ( var % Qadv_daily ) DEALLOCATE ( var % Qevap_daily ) DEALLOCATE ( var % Qprec_daily ) DEALLOCATE ( var % Qprec_snow_daily ) ! END IF END SUBROUTINE dealloc_soil_snow_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_veg_parameter_type ( var ) TYPE ( veg_parameter_type ), INTENT ( inout ) :: var DEALLOCATE ( var % canst1 ) DEALLOCATE ( var % dleaf ) DEALLOCATE ( var % ejmax ) DEALLOCATE ( var % iveg ) DEALLOCATE ( var % iLU ) DEALLOCATE ( var % meth ) DEALLOCATE ( var % frac4 ) DEALLOCATE ( var % hc ) DEALLOCATE ( var % vlai ) DEALLOCATE ( var % xalbnir ) DEALLOCATE ( var % rp20 ) DEALLOCATE ( var % rpcoef ) DEALLOCATE ( var % rs20 ) DEALLOCATE ( var % shelrb ) DEALLOCATE ( var % vegcf ) DEALLOCATE ( var % tminvj ) DEALLOCATE ( var % toptvj ) DEALLOCATE ( var % tmaxvj ) DEALLOCATE ( var % vbeta ) DEALLOCATE ( var % vcmax ) DEALLOCATE ( var % xfang ) DEALLOCATE ( var % extkn ) DEALLOCATE ( var % wai ) DEALLOCATE ( var % deciduous ) DEALLOCATE ( var % froot ) DEALLOCATE ( var % refl ) DEALLOCATE ( var % taul ) DEALLOCATE ( var % a1gs ) DEALLOCATE ( var % d0gs ) DEALLOCATE ( var % alpha ) DEALLOCATE ( var % convex ) DEALLOCATE ( var % cfrd ) DEALLOCATE ( var % gswmin ) DEALLOCATE ( var % conkc0 ) DEALLOCATE ( var % conko0 ) DEALLOCATE ( var % ekc ) DEALLOCATE ( var % eko ) DEALLOCATE ( var % g0 ) ! Ticket #56. DEALLOCATE ( var % g1 ) ! Ticket #56. ! Deallocate variables for SLI soil model: !IF(cable_user%SOIL_STRUC=='sli') THEN DEALLOCATE ( var % rootbeta ) DEALLOCATE ( var % gamma ) ! vh 20/07/09 DEALLOCATE ( var % F10 ) DEALLOCATE ( var % ZR ) DEALLOCATE ( var % CLitt ) DEALLOCATE ( var % disturbance_interval ) DEALLOCATE ( var % disturbance_intensity ) IF ( ASSOCIATED ( var % gamma )) DEALLOCATE ( var % gamma ) ! END IF END SUBROUTINE dealloc_veg_parameter_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_canopy_type ( var ) TYPE ( canopy_type ), INTENT ( inout ) :: var DEALLOCATE ( var % fess ) DEALLOCATE ( var % fesp ) DEALLOCATE ( var % cansto ) DEALLOCATE ( var % cduv ) DEALLOCATE ( var % delwc ) DEALLOCATE ( var % dewmm ) DEALLOCATE ( var % dgdtg ) DEALLOCATE ( var % fe ) DEALLOCATE ( var % fh ) DEALLOCATE ( var % fpn ) DEALLOCATE ( var % frp ) DEALLOCATE ( var % frpw ) DEALLOCATE ( var % frpr ) DEALLOCATE ( var % frs ) DEALLOCATE ( var % fnee ) DEALLOCATE ( var % frday ) DEALLOCATE ( var % fnv ) DEALLOCATE ( var % fev ) DEALLOCATE ( var % fevc ) DEALLOCATE ( var % fhv ) DEALLOCATE ( var % fns ) DEALLOCATE ( var % fhs ) DEALLOCATE ( var % fhs_cor ) DEALLOCATE ( var % ga ) DEALLOCATE ( var % ghflux ) DEALLOCATE ( var % precis ) DEALLOCATE ( var % qscrn ) DEALLOCATE ( var % rnet ) DEALLOCATE ( var % rniso ) DEALLOCATE ( var % segg ) DEALLOCATE ( var % sghflux ) DEALLOCATE ( var % through ) DEALLOCATE ( var % through_sn ) DEALLOCATE ( var % spill ) DEALLOCATE ( var % tscrn ) DEALLOCATE ( var % wcint ) DEALLOCATE ( var % tv ) DEALLOCATE ( var % us ) DEALLOCATE ( var % uscrn ) DEALLOCATE ( var % rghlai ) DEALLOCATE ( var % vlaiw ) DEALLOCATE ( var % fwet ) DEALLOCATE ( var % fns_cor ) !REV_CORR variable DEALLOCATE ( var % ga_cor ) !REV_CORR variable DEALLOCATE ( var % evapfbl ) DEALLOCATE ( var % epot ) DEALLOCATE ( var % fnpp ) DEALLOCATE ( var % fevw_pot ) DEALLOCATE ( var % gswx_T ) DEALLOCATE ( var % cdtq ) DEALLOCATE ( var % wetfac_cs ) DEALLOCATE ( var % fevw ) DEALLOCATE ( var % fhvw ) DEALLOCATE ( var % fes ) DEALLOCATE ( var % fes_cor ) !DEALLOCATE( var% fescor_upp ) !SSEB variable !DEALLOCATE( var% fescor_low ) !SSEB variable DEALLOCATE ( var % gswx ) DEALLOCATE ( var % oldcansto ) DEALLOCATE ( var % zetar ) DEALLOCATE ( var % zetash ) DEALLOCATE ( var % fwsoil ) DEALLOCATE ( var % ofes ) DEALLOCATE ( var % sublayer_dz ) !! vh_js !! liiter resistances to heat and vapour transfer DEALLOCATE ( var % kthLitt ) DEALLOCATE ( var % DvLitt ) END SUBROUTINE dealloc_canopy_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_radiation_type ( var ) TYPE ( radiation_type ), INTENT ( inout ) :: var DEALLOCATE ( var % albedo ) DEALLOCATE ( var % extkb ) DEALLOCATE ( var % extkd2 ) DEALLOCATE ( var % extkd ) DEALLOCATE ( var % flws ) DEALLOCATE ( var % fvlai ) DEALLOCATE ( var % latitude ) DEALLOCATE ( var % lwabv ) DEALLOCATE ( var % qcan ) DEALLOCATE ( var % qssabs ) DEALLOCATE ( var % rhocdf ) DEALLOCATE ( var % rniso ) DEALLOCATE ( var % scalex ) DEALLOCATE ( var % transd ) DEALLOCATE ( var % trad ) DEALLOCATE ( var % otrad ) DEALLOCATE ( var % reffdf ) DEALLOCATE ( var % reffbm ) DEALLOCATE ( var % extkbm ) DEALLOCATE ( var % extkdm ) DEALLOCATE ( var % fbeam ) DEALLOCATE ( var % cexpkbm ) DEALLOCATE ( var % cexpkdm ) DEALLOCATE ( var % rhocbm ) DEALLOCATE ( var % transb ) DEALLOCATE ( var % albedo_T ) DEALLOCATE ( var % gradis ) DEALLOCATE ( var % longitude ) DEALLOCATE ( var % workp1 ) DEALLOCATE ( var % workp2 ) DEALLOCATE ( var % workp3 ) END SUBROUTINE dealloc_radiation_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_roughness_type ( var ) TYPE ( roughness_type ), INTENT ( inout ) :: var DEALLOCATE ( var % coexp ) DEALLOCATE ( var % disp ) DEALLOCATE ( var % hruff ) DEALLOCATE ( var % hruff_grmx ) DEALLOCATE ( var % rt0us ) DEALLOCATE ( var % rt1usa ) DEALLOCATE ( var % rt1usb ) DEALLOCATE ( var % rt1 ) DEALLOCATE ( var % term2 ) DEALLOCATE ( var % term3 ) DEALLOCATE ( var % term5 ) DEALLOCATE ( var % term6 ) DEALLOCATE ( var % term6a ) DEALLOCATE ( var % usuh ) DEALLOCATE ( var % za_uv ) DEALLOCATE ( var % za_tq ) DEALLOCATE ( var % z0m ) DEALLOCATE ( var % zref_uv ) DEALLOCATE ( var % zref_tq ) DEALLOCATE ( var % zruffs ) DEALLOCATE ( var % z0soilsn ) DEALLOCATE ( var % z0soil ) END SUBROUTINE dealloc_roughness_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_air_type ( var ) TYPE ( air_type ), INTENT ( inout ) :: var DEALLOCATE ( var % rho ) DEALLOCATE ( var % volm ) DEALLOCATE ( var % rlam ) DEALLOCATE ( var % qsat ) DEALLOCATE ( var % epsi ) DEALLOCATE ( var % visc ) DEALLOCATE ( var % psyc ) DEALLOCATE ( var % dsatdk ) DEALLOCATE ( var % cmolar ) END SUBROUTINE dealloc_air_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_met_type ( var ) TYPE ( met_type ), INTENT ( inout ) :: var DEALLOCATE ( var % ca ) DEALLOCATE ( var % year ) DEALLOCATE ( var % moy ) DEALLOCATE ( var % doy ) DEALLOCATE ( var % hod ) DEALLOCATE ( var % fsd ) DEALLOCATE ( var % ofsd ) DEALLOCATE ( var % fld ) DEALLOCATE ( var % precip ) DEALLOCATE ( var % precip_sn ) DEALLOCATE ( var % tk ) DEALLOCATE ( var % tvair ) DEALLOCATE ( var % tvrad ) DEALLOCATE ( var % pmb ) DEALLOCATE ( var % ua ) DEALLOCATE ( var % qv ) DEALLOCATE ( var % qvair ) DEALLOCATE ( var % da ) DEALLOCATE ( var % dva ) DEALLOCATE ( var % coszen ) DEALLOCATE ( var % Ndep ) DEALLOCATE ( var % Pdep ) END SUBROUTINE dealloc_met_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_sum_flux_type ( var ) TYPE ( sum_flux_type ), INTENT ( inout ) :: var DEALLOCATE ( var % sumpn ) DEALLOCATE ( var % sumrp ) DEALLOCATE ( var % sumrpw ) DEALLOCATE ( var % sumrpr ) DEALLOCATE ( var % sumrs ) DEALLOCATE ( var % sumrd ) DEALLOCATE ( var % dsumpn ) DEALLOCATE ( var % dsumrp ) DEALLOCATE ( var % dsumrs ) DEALLOCATE ( var % dsumrd ) DEALLOCATE ( var % sumxrp ) DEALLOCATE ( var % sumxrs ) END SUBROUTINE dealloc_sum_flux_type ! ------------------------------------------------------------------------------ SUBROUTINE dealloc_bgc_pool_type ( var ) TYPE ( bgc_pool_type ), INTENT ( inout ) :: var DEALLOCATE ( var % cplant ) DEALLOCATE ( var % csoil ) END SUBROUTINE dealloc_bgc_pool_type END MODULE cable_def_types_mod","tags":"","loc":"sourcefile/cable_define_types.f90.html"},{"title":"cable_input.F90 – CABLE","text":"Contents Modules cable_input_module Source Code cable_input.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Input module for CABLE offline version ! ! Contact: Bernard.Pak@csiro.au ! ! History: Developed by Gab Abramowitz !          Rewritten for v2.0 for new input files (1x1 deg instead of CCAM ~2x2 deg) !          LAI and casa-cnp nutrient inputs included in 1x1 deg file ! ! ============================================================================== ! ! MODULEs used: cable_abort_module !               cable_def_types_mod !               cable_IO_vars_module !               cable_read_module !               netcdf !               casadimension !               casavariable !               phenvariable !               cable_param_module !               cable_checks_module !               cable_radiation_module !               cable_init_module ! !============================================================================== MODULE cable_input_module ! Note that any precision changes from r_1 to REAL(4) enable running with -r8 ! USE cable_abort_module , ONLY : abort , nc_abort USE cable_def_types_mod USE casadimension , ONLY : icycle USE casavariable USE casaparm , ONLY : forest , shrub USE phenvariable !! vh_js !! USE POP_Types , ONLY : POP_TYPE USE POPLUC_Types , ONLY : POPLUC_TYPE USE cable_param_module USE cable_checks_module , ONLY : ranges , rh_sh USE cbl_sinbet_mod , ONLY : sinbet USE cable_IO_vars_module USE cable_read_module , ONLY : readpar USE cable_init_module USE netcdf ! link must be made in cd to netcdf-x.x.x/src/f90/netcdf.mod USE cable_common_module , ONLY : filename , cable_user , CurYear , is_leapyear USE casa_ncdf_module , ONLY : HANDLE_ERR USE casa_inout_module , ONLY : casa_readbiome , casa_readphen , casa_init IMPLICIT NONE PRIVATE PUBLIC get_default_lai , open_met_file , close_met_file , load_parameters , & allocate_cable_vars , get_met_data , & ncid_met , & ncid_rain , & ncid_snow , & ncid_lw , & ncid_sw , & ncid_ps , & ncid_qa , & ncid_ta , & ncid_wd , & ncid_mask INTEGER :: & ncid_met , & ! met data netcdf file ID ncid_rain , & ! following are netcdf file IDs for gswp run ncid_snow , & ncid_lw , & ncid_sw , & ncid_ps , & ncid_qa , & ncid_ta , & ncid_wd , & ncid_mask , & ok ! netcdf error status ! - see ALMA compress by gathering INTEGER , POINTER , DIMENSION (:) :: landGrid ! for ALMA compressed variables REAL , POINTER , DIMENSION (:) :: & elevation , & ! site/grid cell elevation avPrecip ! site/grid cell average precip TYPE met_varID_type INTEGER :: & SWdown , & LWdown , & Wind , & Wind_E , & PSurf , & Tair , & Qair , & Rainf , & Snowf , & CO2air , & Elev , & LAI , & avPrecip , & iveg , & isoil , & patchfrac END TYPE met_varID_type TYPE ( met_varID_type ) :: id ! netcdf variable IDs for input met variables TYPE met_units_type CHARACTER ( LEN = 20 ) :: & SWdown , & LWdown , & Wind , & Wind_E , & PSurf , & Tair , & Qair , & Rainf , & Snowf , & CO2air , & Elev , & avPrecip END TYPE met_units_type TYPE ( met_units_type ) :: metunits ! units for meteorological variables TYPE convert_units_type REAL :: & PSurf , & Tair , & Qair , & Rainf , & CO2air , & Elev END TYPE convert_units_type TYPE ( convert_units_type ) :: convert ! units change factors for met variables !$OMP THREADPRIVATE(ok,exists) CONTAINS !============================================================================== ! ! Name: get_default_lai ! ! Purpose: Reads all monthly LAI from default gridded netcdf file ! ! CALLed from: load_parameters ! ! CALLs: nc_abort !        abort ! ! Input file: [LAI].nc ! !============================================================================== SUBROUTINE get_default_lai ! Input variables: !   filename%LAI      - via cable_IO_vars_module !   landpt            - via cable_IO_vars_module (%nap,cstart,cend,ilon,ilat) !   exists%laiPatch   - via cable_IO_vars_module ! Output variables: !   defaultLAI(mp,12) - via cable_IO_vars_module ! Local variables INTEGER :: & ncid , & xID , & yID , & pID , & tID , & laiID , & nlon , & nlat , & nLaiPatches , & ntime , & e , tt , i ! do loop counter REAL , DIMENSION (:,:,:), ALLOCATABLE :: inLai3D REAL , DIMENSION (:,:,:,:), ALLOCATABLE :: inLai4D ! Allocate default LAI variable: changed mland to mp (BP apr2010) ALLOCATE ( defaultLAI ( mp , 12 )) ! mp = mp_global WRITE ( logn , * ) ' Loading LAI from default file ' , TRIM ( filename % LAI ) ! Open netcdf file ok = NF90_OPEN ( filename % LAI , 0 , ncid ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error opening default LAI file.' ) ok = NF90_INQ_DIMID ( ncid , 'x' , xID ) IF ( ok /= NF90_NOERR ) THEN ! added to read some input files (BP mar2011) ok = NF90_INQ_DIMID ( ncid , 'longitude' , xID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring x dimension.' ) END IF ok = NF90_INQUIRE_DIMENSION ( ncid , xID , LEN = nlon ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting x dimension.' ) ok = NF90_INQ_DIMID ( ncid , 'y' , yID ) IF ( ok /= NF90_NOERR ) THEN ! added to read some input files (BP mar2011) ok = NF90_INQ_DIMID ( ncid , 'latitude' , yID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring y dimension.' ) END IF ok = NF90_INQUIRE_DIMENSION ( ncid , yID , LEN = nlat ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting y dimension.' ) ok = NF90_INQ_DIMID ( ncid , 'patch' , pID ) IF ( ok /= NF90_NOERR ) THEN ! if failed exists % laiPatch = . FALSE . WRITE ( logn , * ) ' **ALL patches will be given the same LAI**' ELSE exists % laiPatch = . TRUE . ok = NF90_INQUIRE_DIMENSION ( ncid , pID , len = nLaiPatches ) IF ( ANY ( landpt (:)% nap > nLaiPatches )) THEN WRITE ( logn , * ) ' **Some patches will be given the same LAI**' END IF IF ( nLaiPatches > max_vegpatches ) THEN ! input file can have more info WRITE ( * , * ) ' Note that LAI input file has ' , nLaiPatches , ' patches.' WRITE ( * , * ) ' while the model has max at ' , max_vegpatches , ' patches.' END IF END IF ok = NF90_INQ_DIMID ( ncid , 'time' , tID ) IF ( ok /= NF90_NOERR ) THEN ! added to read some input files (BP mar2011) ok = NF90_INQ_DIMID ( ncid , 'month' , tID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error inquiring t dimension.' ) END IF ok = NF90_INQUIRE_DIMENSION ( ncid , tID , LEN = ntime ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error getting time dimension.' ) IF ( ntime /= 12 ) CALL abort ( 'Time dimension not 12 months.' ) ok = NF90_INQ_VARID ( ncid , 'LAI' , laiID ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error finding LAI variable.' ) ! Read LAI values: IF ( exists % laiPatch ) THEN ALLOCATE ( inLai4D ( nlon , nlat , nLaiPatches , ntime )) ok = NF90_GET_VAR ( ncid , laiID , inLai4D ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading 4D LAI variable.' ) DO e = 1 , mland ! over all land grid points DO tt = 1 , ntime defaultLAI ( landpt ( e )% cstart : landpt ( e )% cend , tt ) = & inLai4D ( landpt ( e )% ilon , landpt ( e )% ilat , 1 : landpt ( e )% nap , tt ) END DO END DO ELSE ALLOCATE ( inLai3D ( nlon , nlat , ntime )) ok = NF90_GET_VAR ( ncid , laiID , inLai3D ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error reading 3D LAI variable.' ) DO e = 1 , mland DO tt = 1 , ntime defaultLAI ( landpt ( e )% cstart : landpt ( e )% cend , tt ) = & inLai3D ( landpt ( e )% ilon , landpt ( e )% ilat , tt ) END DO END DO END IF ! Close netcdf file ok = NF90_CLOSE ( ncid ) END SUBROUTINE get_default_lai !============================================================================== ! ! Name: open_met_file ! ! Purpose: Opens netcdf file containing meteorological (LSM input) data !          and determines: !   1. Spatial details - number of sites/grid cells, latitudes, longitudes !   2. Timing details - time step size, number of timesteps, starting date, !      and whether time coordinate is local or GMT !   3. Checks availability, including units issues, of all required !      meteorological input variables. Also checks whether or not LAI is !      present, and fetches prescribed veg and soil type if present. ! ! ! CALLed from: cable_offline_driver ! ! CALLs: abort !        nc_abort !        date_and_time ! ! Input file: [SiteName].nc !             [GSWP_Snowf].nc !             [GSWP_LWdown].nc !             [GSWP_SWdown].nc !             [GSWP_PSurf].nc !             [GSWP_Qair].nc !             [GSWP_Tair].nc !             [GSWP_wind].nc !             [GSWP_Rainf].nc ! !============================================================================== SUBROUTINE open_met_file ( dels , koffset , kend , spinup , TFRZ ) USE CABLE_COMMON_MODULE , ONLY : IS_LEAPYEAR USE casa_ncdf_module , ONLY : HANDLE_ERR , YMDHMS2DOYSOD , DOYSOD2YMDHMS USE CABLE_METUTILS_MODULE , ONLY : possible_varnames , find_metvarid IMPLICIT NONE ! Input arguments REAL , INTENT ( OUT ) :: dels ! time step size REAL , INTENT ( IN ) :: TFRZ INTEGER , INTENT ( INOUT ) :: koffset ! offset between met file and desired period INTEGER , INTENT ( OUT ) :: kend ! number of time steps in simulation LOGICAL , INTENT ( IN ) :: spinup ! will a model spinup be performed? ! Local variables INTEGER :: & timevarID , & ! time variable ID number xdimID , & ! x dimension ID numbers ydimID , & ! y dimension ID numbers patchdimID , & ! patch dimension ID monthlydimID , & ! month dimension ID for LAI info maskID , & ! mask variable ID landID , & ! land variable ID landdimID , & ! land dimension ID latitudeID , & ! lat variable IDs longitudeID , & ! lon variable IDs edoy , & ! end time day-of-year eyear , & ! end time year jump_days , & ! days made by first \"time\" entry sdoytmp , & ! used to determine start time hour-of-day mland_ctr , & ! counter for number of land points read from file mland_fromfile , & ! number of land points in file lai_dims , & ! number of dims of LAI var if in met file iveg_dims , & ! number of dims of iveg var if in met file isoil_dims , & ! number of dims of isoil var if in met file tsmin , tsdoy , tsyear , & ! temporary variables x , y , i , j , & ! do loop counters tempmonth , & ssod , & nsod , & LOY , & iday ,& imin ,& isec ,& ishod , & dnsec = 0 ,& ntstp INTEGER , DIMENSION ( 1 ) :: & timedimID , & ! time dimension ID number data1i ! temp variable for netcdf reading INTEGER , DIMENSION ( 4 ) :: laidimids ! for checking lai variable INTEGER , DIMENSION ( 1 , 1 ) :: data2i ! temp variable for netcdf reading INTEGER , POINTER , DIMENSION (:) :: land_xtmp , land_ytmp ! temp indicies REAL , POINTER , DIMENSION (:) :: lat_temp , lon_temp ! lat and lon REAL :: & tshod , & ! temporary variable ehod , & ! end time hour-of-day precipTot , & ! used for spinup adj avPrecipInMet ! used for spinup adj CHARACTER ( LEN = 10 ) :: todaydate , nowtime ! used to timestamp log file REAL ( 4 ), DIMENSION ( 1 ) :: data1 ! temp variable for netcdf reading REAL ( 4 ), DIMENSION ( 1 , 1 ) :: data2 ! temp variable for netcdf reading REAL ( 4 ), DIMENSION (:), ALLOCATABLE :: temparray1 ! temp read in variable REAL ( 4 ), DIMENSION (:,:), ALLOCATABLE :: & tempPrecip2 , & ! used for spinup adj temparray2 ! temp read in variable REAL ( 4 ), DIMENSION (:,:,:), ALLOCATABLE :: tempPrecip3 ! used for spinup adj LOGICAL :: & all_met , LAT1D , LON1D ! ALL required met in met file (no synthesis)? ! Initialise parameter loading switch - will be set to TRUE when ! parameters are loaded: exists % parameters = . FALSE . ! initialise ! Initialise initialisation loading switch - will be set to TRUE when ! initialisation data are loaded: exists % initial = . FALSE . ! initialise LAT1D = . FALSE . LON1D = . FALSE . ! Write filename to log file: WRITE ( logn , * ) '============================================================' WRITE ( logn , * ) 'Log file for offline CABLE run:' CALL DATE_AND_TIME ( todaydate , nowtime ) todaydate = todaydate ( 1 : 4 ) // '/' // todaydate ( 5 : 6 ) // '/' // todaydate ( 7 : 8 ) nowtime = nowtime ( 1 : 2 ) // ':' // nowtime ( 3 : 4 ) // ':' // nowtime ( 5 : 6 ) WRITE ( logn , * ) TRIM ( nowtime ), ' ' , TRIM ( todaydate ) WRITE ( logn , * ) '============================================================' ! Open netcdf file: IF ( ncciy > 0 ) THEN IF ( globalMetfile % l_gpcc ) THEN WRITE ( logn , * ) 'Opening met data file: ' , TRIM ( globalMetfile % rainf ), ' and 7 more' ELSE WRITE ( logn , * ) 'Opening met data file: ' , TRIM ( gswpfile % rainf ), ' and 7 more' ENDIF IF ( globalMetfile % l_gpcc ) THEN ok = NF90_OPEN ( globalMetfile % rainf , 0 , ncid_rain ) ELSE ok = NF90_OPEN ( gswpfile % rainf , 0 , ncid_rain ) ENDIF IF ( ok /= NF90_NOERR ) THEN PRINT * , 'rainf' CALL handle_err ( ok ) ENDIF IF (. NOT . globalMetfile % l_gpcc ) THEN ok = NF90_OPEN ( gswpfile % snowf , 0 , ncid_snow ) IF ( ok /= NF90_NOERR ) THEN PRINT * , 'snow' CALL handle_err ( ok ) ENDIF ENDIF IF ( globalMetfile % l_gpcc ) THEN ok = NF90_OPEN ( globalMetfile % LWdown , 0 , ncid_lw ) ELSE ok = NF90_OPEN ( gswpfile % LWdown , 0 , ncid_lw ) ENDIF IF ( ok /= NF90_NOERR ) THEN PRINT * , 'lw' CALL handle_err ( ok ) ENDIF IF ( globalMetfile % l_gpcc ) THEN ok = NF90_OPEN ( globalMetfile % SWdown , 0 , ncid_sw ) ELSE ok = NF90_OPEN ( gswpfile % SWdown , 0 , ncid_sw ) ENDIF IF ( ok /= NF90_NOERR ) THEN PRINT * , 'sw' CALL handle_err ( ok ) ENDIF IF ( globalMetfile % l_gpcc ) THEN ok = NF90_OPEN ( globalMetfile % PSurf , 0 , ncid_ps ) ELSE ok = NF90_OPEN ( gswpfile % PSurf , 0 , ncid_ps ) ENDIF IF ( ok /= NF90_NOERR ) THEN PRINT * , 'ps' CALL handle_err ( ok ) ENDIF IF ( globalMetfile % l_gpcc ) THEN ok = NF90_OPEN ( globalMetfile % Qair , 0 , ncid_qa ) ELSE ok = NF90_OPEN ( gswpfile % Qair , 0 , ncid_qa ) ENDIF IF ( ok /= NF90_NOERR ) THEN PRINT * , 'qa' CALL handle_err ( ok ) ENDIF IF ( globalMetfile % l_gpcc ) THEN ok = NF90_OPEN ( globalMetfile % Tair , 0 , ncid_ta ) ELSE ok = NF90_OPEN ( gswpfile % Tair , 0 , ncid_ta ) ENDIF IF ( ok /= NF90_NOERR ) THEN PRINT * , 'ta' CALL handle_err ( ok ) ENDIF IF ( globalMetfile % l_gpcc ) THEN ok = NF90_OPEN ( globalMetfile % wind , 0 , ncid_wd ) ELSE ok = NF90_OPEN ( gswpfile % wind , 0 , ncid_wd ) ENDIF IF ( ok /= NF90_NOERR ) THEN PRINT * , 'wind' , ncid_wd CALL handle_err ( ok ) ENDIF IF ( cable_user % GSWP3 ) THEN ok = NF90_OPEN ( gswpfile % mask , 0 , ncid_mask ) IF ( ok . NE . NF90_NOERR ) THEN CALL nc_abort ( ok , \"Error opening GSWP3 mask file\" ) END IF LAT1D = . TRUE . !GSWP3 forcing has 1d lat/lon variables LON1D = . TRUE . ELSE ncid_mask = ncid_rain END IF ncid_met = ncid_rain ELSE WRITE ( logn , * ) 'Opening met data file: ' , TRIM ( filename % met ) ok = NF90_OPEN ( filename % met , 0 , ncid_met ) ! open met data file IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error opening netcdf met forcing file ' // TRIM ( filename % met ) // & ' (SUBROUTINE open_met_file)' ) ENDIF !!=====================VV Determine spatial details VV================= ! Determine number of sites/gridcells. ! Find size of 'x' or 'lon' dimension: ok = NF90_INQ_DIMID ( ncid_met , 'x' , xdimID ) IF ( ok /= NF90_NOERR ) THEN ! if failed ! Try 'lon' instead of x ok = NF90_INQ_DIMID ( ncid_met , 'lon' , xdimID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding x dimension in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END IF ok = NF90_INQUIRE_DIMENSION ( ncid_met , xdimID , len = xdimsize ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error determining size of x dimension in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Find size of 'y' dimension: ok = NF90_INQ_DIMID ( ncid_met , 'y' , ydimID ) IF ( ok /= NF90_NOERR ) THEN ! if failed ! Try 'lat' instead of y ok = NF90_INQ_DIMID ( ncid_met , 'lat' , ydimID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding y dimension in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END IF ok = NF90_INQUIRE_DIMENSION ( ncid_met , ydimID , len = ydimsize ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error determining size of y dimension in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Determine number of gridcells in netcdf file: ngridcells = xdimsize * ydimsize WRITE ( logn , '(A28,I7)' ) 'Total number of gridcells: ' , ngridcells ! Get all latitude and longitude values. ! Find latitude variable (try 'latitude' and 'nav_lat'(ALMA)): CALL find_metvarid ( ncid_met , possible_varnames % LatNames , latitudeID , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding latitude variable in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Allocate space for lat_all variable and its temp counterpart: ALLOCATE ( lat_all ( xdimsize , ydimsize )) ALLOCATE ( temparray2 ( xdimsize , ydimsize )) !MDeck allow for 1d lat called 'lat' ! Get latitude values for entire region: IF (. NOT . LAT1D ) THEN ok = NF90_GET_VAR ( ncid_met , latitudeID , temparray2 ) ELSE IF ( ALLOCATED ( temparray1 )) DEALLOCATE ( temparray1 ) ALLOCATE ( temparray1 ( ydimsize )) ok = NF90_GET_VAR ( ncid_met , latitudeID , temparray1 ) temparray2 = SPREAD ( temparray1 , 1 , xdimsize ) DEALLOCATE ( temparray1 ) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading latitude variable in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Needed since r_1 will be double precision with -r8: lat_all = REAL ( temparray2 ) ! Find longitude variable (try 'longitude' and 'nav_lon'(ALMA)): CALL find_metvarid ( ncid_met , possible_varnames % LonNames , longitudeID , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding longitude variable in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Allocate space for lon_all variable: ALLOCATE ( lon_all ( xdimsize , ydimsize )) ! Get longitude values for entire region: !MDeck allow for 1d lon IF (. NOT . LON1D ) THEN ok = NF90_GET_VAR ( ncid_met , longitudeID , temparray2 ) ELSE ALLOCATE ( temparray1 ( xdimsize )) ok = NF90_GET_VAR ( ncid_met , longitudeID , temparray1 ) temparray2 = SPREAD ( temparray1 , 2 , ydimsize ) DEALLOCATE ( temparray1 ) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading longitude variable in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Needed since r_1 will be double precision with -r8: lon_all = REAL ( temparray2 ) DEALLOCATE ( temparray2 ) ! Check for \"mask\" variable or \"land\" variable to tell grid type ! (and allow neither if only one gridpoint). \"mask\" is a 2D variable ! with dims x,y and \"land\" is a 1D variable. CALL find_metvarid ( ncid_mask , possible_varnames % MaskNames , maskID , ok ) IF ( ok /= NF90_NOERR ) THEN ! if error, i.e. no \"mask\" variable: ! Check for \"land\" variable: ok = NF90_INQ_VARID ( ncid_met , 'land' , landID ) IF ( ok /= NF90_NOERR ) THEN ! ie no \"land\" or \"mask\" IF ( ngridcells == 1 ) THEN ! Allow no explicit grid system if only one gridpoint ALLOCATE ( mask ( xdimsize , ydimsize )) ! Allocate \"mask\" variable metGrid = 'mask' ! Use mask system, one gridpoint. mask = 1 ALLOCATE ( latitude ( 1 ), longitude ( 1 )) latitude = lat_all ( 1 , 1 ) longitude = lon_all ( 1 , 1 ) mland_fromfile = 1 ALLOCATE ( land_x ( mland_fromfile ), land_y ( mland_fromfile )) land_x = 1 land_y = 1 ELSE ! Call abort if more than one gridcell and no ! recognised grid system: CALL nc_abort & ( ok , 'Error finding grid system (\"mask\" or \"land\") variable in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END IF ELSE ! i.e. \"land\" variable exists metGrid = 'land' ! Check size of \"land\" dimension: ok = NF90_INQ_DIMID ( ncid_met , 'land' , landdimID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding land dimension in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ok = NF90_INQUIRE_DIMENSION ( ncid_met , landdimID , len = mland_fromfile ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error determining size of land dimension in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Allocate landGrid variable and its temporary counterpart: ALLOCATE ( landGrid ( mland_fromfile )) ALLOCATE ( temparray1 ( mland_fromfile )) ! Get values of \"land\" variable from file: ok = NF90_GET_VAR ( ncid_met , landID , temparray1 ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading \"land\" variable in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Needed since r_1 will be double precision with -r8: landGrid = REAL ( temparray1 ) DEALLOCATE ( temparray1 ) ! Allocate latitude and longitude variables: ALLOCATE ( latitude ( mland_fromfile ), longitude ( mland_fromfile )) ! Write to indicies of points in all-grid which are land ALLOCATE ( land_x ( mland_fromfile ), land_y ( mland_fromfile )) ! Allocate \"mask\" variable: ALLOCATE ( mask ( xdimsize , ydimsize )) ! Initialise all gridpoints as sea: mask = 0 DO j = 1 , mland_fromfile ! over all land points ! Find x and y coords of current land point y = INT (( landGrid ( j ) - 1 ) / xdimsize ) x = landGrid ( j ) - y * xdimsize y = y + 1 ! Write lat and lon to land-only lat/lon vars: latitude ( j ) = lat_all ( x , y ) longitude ( j ) = lon_all ( x , y ) ! Write to mask variable: mask ( x , y ) = 1 ! Save indicies: land_x ( j ) = x land_y ( j ) = y END DO END IF ! does \"land\" variable exist ELSE ! i.e. \"mask\" variable exists ! Allocate \"mask\" variable: ALLOCATE ( mask ( xdimsize , ydimsize )) metGrid = 'mask' ! Use mask system ! Get mask values from file: ok = NF90_GET_VAR ( ncid_mask , maskID , mask ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading \"mask\" variable in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) !gswp3 uses 1 for sea and 0 for land, make is opposite IF ( cable_user % gswp3 ) mask = 1 - mask ! Allocate space for extracting land lat/lon values: ALLOCATE ( lat_temp ( ngridcells ), lon_temp ( ngridcells )) ! Allocate space for extracting index of mask which is land ALLOCATE ( land_xtmp ( ngridcells ), land_ytmp ( ngridcells )) ! Cycle through all gridsquares: mland_ctr = 0 ! initialise DO y = 1 , ydimsize DO x = 1 , xdimsize IF ( mask ( x , y ) == 1 ) THEN ! If land mland_ctr = mland_ctr + 1 ! Store lat and lon for land points lat_temp ( mland_ctr ) = lat_all ( x , y ) lon_temp ( mland_ctr ) = lon_all ( x , y ) ! Store indicies of points in mask which are land land_xtmp ( mland_ctr ) = x land_ytmp ( mland_ctr ) = y END IF END DO END DO ! Record number of land points mland_fromfile = mland_ctr ! Allocate latitude and longitude variables: ALLOCATE ( latitude ( mland_fromfile ), longitude ( mland_fromfile )) ! Write to latitude and longitude variables: latitude = lat_temp ( 1 : mland_fromfile ) longitude = lon_temp ( 1 : mland_fromfile ) ! Write to indicies of points in mask which are land ALLOCATE ( land_x ( mland_fromfile ), land_y ( mland_fromfile )) land_x = land_xtmp ( 1 : mland_fromfile ) land_y = land_ytmp ( 1 : mland_fromfile ) ! Clear lon_temp, lat_temp,land_xtmp,land_ytmp DEALLOCATE ( lat_temp , lon_temp , land_xtmp , land_ytmp ) END IF ! \"mask\" variable or no \"mask\" variable ! Set global mland value (number of land points), used to allocate ! all of CABLE's arrays: mland = mland_fromfile ! Write number of land points to log file: WRITE ( logn , '(24X,I7,A29)' ) mland_fromfile , ' of which are land grid cells' ! Check if veg/soil patch dimension exists (could have ! parameters with patch dimension) ok = NF90_INQ_DIMID ( ncid_met , 'patch' , patchdimID ) IF ( ok /= NF90_NOERR ) THEN ! if failed exists % patch = . FALSE . nmetpatches = 1 ! initialised so that old met files without patch ! data can still be run correctly (BP apr08) ELSE ! met file does have patch dimension exists % patch = . TRUE . ok = NF90_INQUIRE_DIMENSION ( ncid_met , patchdimID , len = nmetpatches ) END IF ! Check if monthly dimension exists for LAI info ok = NF90_INQ_DIMID ( ncid_met , 'monthly' , monthlydimID ) IF ( ok == NF90_NOERR ) THEN ! if found ok = NF90_INQUIRE_DIMENSION ( ncid_met , monthlydimID , len = tempmonth ) IF ( tempmonth /= 12 ) CALL abort ( 'Number of months in met file /= 12.' ) END IF ! Set longitudes to be [-180,180]: WHERE ( longitude > 18 0.0 ) longitude = longitude - 36 0.0 END WHERE ! Check ranges for latitude and longitude: IF ( ANY ( longitude > 18 0.0 ). OR . ANY ( longitude <- 18 0.0 )) & CALL abort ( 'Longitudes read from ' // TRIM ( filename % met ) // & ' are not [-180,180] or [0,360]! Please set.' ) IF ( ANY ( latitude > 9 0.0 ). OR . ANY ( latitude <- 9 0.0 )) & CALL abort ( 'Latitudes read from ' // TRIM ( filename % met ) // & ' are not [-90,90]! Please set.' ) !!=================&#94;&#94; End spatial details &#94;&#94;======================== !!=========VV Determine simulation timing details VV================ ! Inquire 'time' variable's ID: CALL find_metvarid ( ncid_met , possible_varnames % TimeNames , timevarID , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding time variable in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Get ID for dimension upon which time depends: ok = NF90_INQUIRE_VARIABLE ( ncid_met , timevarID , dimids = timedimID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error determining \"time\" dimension dimension in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Determine number of time steps: ok = NF90_INQUIRE_DIMENSION ( ncid_met , timedimID ( 1 ), len = kend ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error determining number of timesteps in ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Allocate time variable: ALLOCATE ( timevar ( kend )) ! Fetch 'time' variable: ok = NF90_GET_VAR ( ncid_met , timevarID , timevar ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading time variable in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( cable_user % gswp3 ) THEN !Hack the GSWP3 time units to make from start of year timevar (:) = ( timevar (:) - timevar ( 1 )) * 360 0.0 + 1.5 * 360 0.0 !convert hours to seconds END IF ! Set time step size: dels = REAL ( timevar ( 2 ) - timevar ( 1 )) WRITE ( logn , '(1X,A29,I8,A3,F10.3,A5)' ) 'Number of time steps in run: ' ,& kend , ' = ' , REAL ( kend ) / ( 3600 / dels * 24 ), ' days' ! CLN READJUST kend referring to Set START & END ! if kend > # days in selected episode !********* gswp input file has bug in timevar ************** IF ( ncciy > 0 ) THEN PRINT * , 'original timevar(kend) = ' , timevar ( kend ) DO i = 1 , kend - 1 timevar ( i + 1 ) = timevar ( i ) + dels ENDDO PRINT * , 'New      timevar(kend) = ' , timevar ( kend ) !! hacking (BP feb2011) !      kend = 16   ! 2 days for 1986 !!      kend = 480  ! 2 months for 1986 !      PRINT *, 'Hacked   timevar(kend) = ', timevar(kend) !      PRINT *, 'Hacked kend = ', kend !! end hacking END IF !********* done bug fixing for timevar in gswp input file ** ! Write time step size to log file: WRITE ( logn , '(1X,A17,F8.1,1X,A7)' ) 'Time step size:  ' , dels , 'seconds' ! Get units for 'time' variable: ok = NF90_GET_ATT ( ncid_met , timevarID , 'units' , timeunits ) IF (. NOT . cable_user % GSWP3 ) THEN ok = NF90_GET_ATT ( ncid_met , timevarID , 'units' , timeunits ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding time variable units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ELSE !Hack the GSWP3 time units to make from start of year WRITE ( * , * ) 'writing timeunits' WRITE ( timeunits , \"('seconds since ',I4.4,'-01-01 00:00:00')\" ) ncciy WRITE ( * , * ) 'wrote time units' END IF !MDeck !write(*,*) timeunits IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding time variable units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) !****** PALS met file has timevar(1)=0 while timeunits from 00:30:00 ****** !!CLN CRITICAL! From my point of view, the information in the file is correct... !!CLN WHY DO the input files all have bugs??? IF ( timevar ( 1 ) == 0.0 ) THEN READ ( timeunits ( 29 : 30 ), * ) tsmin IF ( tsmin * 6 0.0 >= dels ) THEN tsmin = tsmin - INT ( dels / 60 ) timevar = timevar + dels WRITE ( timeunits ( 29 : 30 ), '(i2.2)' ) tsmin ENDIF ENDIF !****** done bug fixing for timevar in PALS met file ********************** !********* gswp input file has bug in timeunits ************ IF ( ncciy > 0 ) WRITE ( timeunits ( 26 : 27 ), '(i2.2)' ) 0 !********* done bug fixing for timeunits in gwsp file ****** WRITE ( logn , * ) 'Time variable units: ' , timeunits ! Get coordinate field: ok = NF90_GET_ATT ( ncid_met , timevarID , 'coordinate' , time_coord ) ! If error getting coordinate field (i.e. it doesn't exist): IF ( ok /= NF90_NOERR ) THEN ! Assume default time coordinate: IF ( mland_fromfile == 1. AND .( TRIM ( cable_user % MetType ) . NE . 'gswp' )) THEN ! If single site, this is local time time_coord = 'LOC' ! 12am is 12am local time, at site/gridcell ELSE ! If multiple/global/regional, use GMT time_coord = 'GMT' ! 12am is GMT time, local time set by longitude END IF ELSE IF (( ok == NF90_NOERR . AND . time_coord == 'LOC' . AND . mland_fromfile > 1 )) THEN ! Else if local time is selected for regional simulation, abort: CALL abort ( '\"time\" variable must be GMT for multiple site simulation!' & // ' Check \"coordinate\" field in time variable.' & // ' (SUBROUTINE open_met_file)' ) ELSE IF ( time_coord /= 'LOC' . AND . time_coord /= 'GMT' ) THEN CALL abort ( 'Meaningless time coordinate in met data file!' & // ' (SUBROUTINE open_met_file)' ) END IF ! Use internal files to convert \"time\" variable units (giving the run's ! start time) from character to integer; calculate starting hour-of-day, ! day-of-year, year: IF (. NOT . cable_user % GSWP3 ) THEN READ ( timeunits ( 15 : 18 ), * ) syear READ ( timeunits ( 20 : 21 ), * ) smoy ! integer month READ ( timeunits ( 23 : 24 ), * ) sdoytmp ! integer day of that month READ ( timeunits ( 26 : 27 ), * ) shod ! starting hour of day ELSE syear = ncciy smoy = 1 sdoytmp = 1 shod = 0 END IF ! if site data, shift start time to middle of timestep ! only do this if not already at middle of timestep !! vh_js !! IF (( TRIM ( cable_user % MetType ). EQ . '' . OR . & TRIM ( cable_user % MetType ). EQ . 'site' ). AND . MOD ( shod * 3600 , dels ) == 0 . AND . & ( shod . GT . dels / 360 0. / 2. ) ) THEN shod = shod - dels / 360 0. / 2. ELSEIF ( TRIM ( cable_user % MetType ). EQ . '' . OR . & ( TRIM ( cable_user % MetType ). EQ . 'site' ) . AND . MOD ( shod * 3600 , dels ) == 0 . AND . & ( shod . LT . dels / 360 0. / 2. ) ) THEN shod = shod + dels / 360 0. / 2. ENDIF ! Decide day-of-year for non-leap year: CALL YMDHMS2DOYSOD ( syear , smoy , sdoytmp , INT ( shod ), 0 , 0 , sdoy , ssod ) ! Number of days between start position and 1st timestep: sdoy = sdoy + INT (( timevar ( 1 ) / 360 0.0 + shod ) / 2 4.0 ) nsod = MOD ( INT (( timevar ( 1 ) + shod * 3600 )), 86400 ) DO LOY = 365 IF ( IS_LEAPYEAR ( syear ) ) LOY = 366 IF ( sdoy . GT . LOY ) THEN sdoy = sdoy - LOY syear = syear + 1 ELSE EXIT END IF END DO CALL DOYSOD2YMDHMS ( syear , sdoy , nsod , smoy , iday , ishod , imin , isec ) shod = REAL ( ishod ) + REAL ( imin ) / 6 0. + REAL ( isec ) / 360 0. ! Cycle through days to find leap year inclusive starting date: ! Now all start time variables established, report to log file: WRITE ( logn , '(1X,A12,F5.2,A14,I3,A14,I4,2X,A3,1X,A4)' ) & 'Run begins: ' , shod , ' hour-of-day, ' , sdoy , ' day-of-year, ' ,& syear , time_coord , 'time' ! Determine ending time of run... IF ( leaps ) THEN ! If we're using leap year timing... eyear = syear edoy = sdoy + INT ((( timevar ( kend ) - timevar ( 1 )) / 360 0.0 + shod ) / 2 4.0 ) ehod = MOD ((( timevar ( kend ) - timevar ( 1 ) / 360 0. ) + shod ), 2 4._r_2 ) DO LOY = 365 IF ( IS_LEAPYEAR ( eyear ) ) LOY = 366 IF ( edoy . GT . LOY ) THEN edoy = edoy - LOY eyear = eyear + 1 ELSE EXIT END IF END DO ELSE ! if not using leap year timing ! Update shod, sdoy, syear for first \"time\" value: ehod = MOD ( REAL (( timevar ( kend ) - timevar ( 1 )) / 360 0.0 + shod ), 2 4.0 ) edoy = MOD ( INT ((( timevar ( kend ) - timevar ( 1 )) / 360 0.0 + shod ) / 2 4.0 ) & + sdoy , 365 ) eyear = INT ( REAL ( INT ((( timevar ( kend ) - timevar ( 1 )) & / 360 0.0 + shod ) / 2 4.0 ) + sdoy ) / 36 5.0 ) + syear !       ehod = MOD(REAL((timevar(kend)-timevar(1)+dels)/3600.0 + shod),24.0) !       edoy = MOD(INT(((timevar(kend)-timevar(1)+dels)/3600.0 + shod)/24.0) & !            + sdoy, 365) !       eyear = INT(REAL(INT(((timevar(kend)-timevar(1)+dels) & !            /3600.0+shod)/24.0)+sdoy)/365.0)+syear END IF ! IF A CERTAIN PERIOD IS DESIRED AND WE ARE NOT RUNNING ON GSWP DATA or special site ! RECALCULATE STARTING AND ENDING INDICES IF ( CABLE_USER % YEARSTART . GT . 0 . AND . . NOT . ncciy . GT . 0 . AND . & TRIM ( cable_user % MetType ) . NE . \"site\" ) THEN IF ( syear . GT . CABLE_USER % YEARSTART . OR . eyear . LE . CABLE_USER % YEAREND . OR . & ( syear . EQ . CABLE_USER % YEARSTART . AND . sdoy . GT . 1 ) ) THEN WRITE ( * , * ) \"Chosen period doesn't match dataset period!\" WRITE ( * , * ) \"Chosen period: \" , CABLE_USER % YEARSTART , 1 , CABLE_USER % YEAREND , 365 WRITE ( * , * ) \"Data   period: \" , syear , sdoy , eyear , edoy WRITE ( * , * ) \"For using the metfile's time set CABLE_USER%YEARSTART = 0 !\" STOP ENDIF ! Find real kstart! dnsec = 0 DO y = syear , CABLE_USER % YEARSTART - 1 LOY = 365 IF ( IS_LEAPYEAR ( y ) ) LOY = 366 IF ( y . EQ . syear ) THEN dnsec = ( LOY - sdoy ) * 86400 + ( 24 - shod ) * 3600 ELSE dnsec = dnsec + LOY * 86400 ENDIF END DO koffset = INT ( REAL ( dnsec ) / REAL ( dels )) - 1 ! Find real kend kend = 0 DO y = CABLE_USER % YEARSTART , CABLE_USER % YEAREND LOY = 365 IF ( IS_LEAPYEAR ( y ) ) LOY = 366 kend = kend + INT ( REAL ( LOY ) * 8640 0. / REAL ( dels ) ) END DO ENDIF ! Report finishing time to log file: WRITE ( logn , '(1X,A12,F5.2,A14,I3,A14,I4,2X,A3,1X,A4)' ) 'Run ends:   ' ,& ehod , ' hour-of-day, ' , edoy , & ' day-of-year, ' , eyear , time_coord , 'time' !!===================&#94;&#94; End timing details &#94;&#94;========================== !!===================VV Look for met variables VV====================== all_met = . TRUE . ! initialise ! Look for SWdown (essential):- - - - - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_sw ! option was added by Chris Lu to allow for different variable names between GPCC and GSWP forcings ! added by ypwang 30/oct/2012 CALL find_metvarid ( ncid_met , possible_varnames % SWdownNames , id % SWdown , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding SWdown in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Get SWdown units and check okay: ok = NF90_GET_ATT ( ncid_met , id % SWdown , 'units' , metunits % SWdown ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding SWdown units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) !! vh_js !! fixed bug in logic IF (. NOT .( metunits % SWdown ( 1 : 4 ) /= 'W/m2' . OR . metunits % SWdown ( 1 : 5 ) & /= 'W/m&#94;2' . OR . metunits % SWdown ( 1 : 5 ) /= 'Wm&#94;-2' & . OR . metunits % SWdown ( 1 : 4 ) /= 'Wm-2' . OR . metunits % SWdown ( 1 : 5 ) /= 'W m-2' )) THEN WRITE ( * , * ) metunits % SWdown CALL abort ( 'Unknown units for SWdown' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ! Look for Tair (essential):- - - - - - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_ta CALL find_metvarid ( ncid_met , possible_varnames % TairNames , id % Tair , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Tair in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Get Tair units and check okay: ok = NF90_GET_ATT ( ncid_met , id % Tair , 'units' , metunits % Tair ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Tair units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( metunits % Tair ( 1 : 1 ) == 'C' . OR . metunits % Tair ( 1 : 1 ) == 'c' ) THEN ! Change from celsius to kelvin: convert % Tair = tfrz WRITE ( logn , * ) 'Temperature will be converted from C to K' ELSE IF ( metunits % Tair ( 1 : 1 ) == 'K' . OR . metunits % Tair ( 1 : 1 ) == 'k' ) THEN ! Units are correct convert % Tair = 0.0 ELSE WRITE ( * , * ) metunits % Tair CALL abort ( 'Unknown units for Tair' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ! Look for Qair (essential):- - - - - - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_qa Call find_metvarid ( ncid_met , possible_varnames % QairNames , id % Qair , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Qair in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Get Qair units: ok = NF90_GET_ATT ( ncid_met , id % Qair , 'units' , metunits % Qair ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Qair units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( metunits % Qair ( 1 : 1 ) == '%' . OR . metunits % Qair ( 1 : 1 ) == '-' ) THEN ! Change from relative humidity to specific humidity: convert % Qair = - 99 9.0 WRITE ( logn , * ) 'Humidity will be converted from relative to specific' ELSE IF ( metunits % Qair ( 1 : 3 ) == 'g/g' . OR . metunits % Qair ( 1 : 5 ) == 'kg/kg' & . OR . metunits % Qair ( 1 : 3 ) == 'G/G' . OR . metunits % Qair ( 1 : 5 ) == 'KG/KG' . OR . metunits % Qair ( 1 : 7 ) == 'kg kg-1' ) THEN ! Units are correct convert % Qair = 1.0 ELSE WRITE ( * , * ) metunits % Qair CALL abort ( 'Unknown units for Qair' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ! Look for Rainf (essential):- - - - - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_rain CALL find_metvarid ( ncid_met , possible_varnames % RainNames , id % Rainf , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Rainf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Get Rainf units: ok = NF90_GET_ATT ( ncid_met , id % Rainf , 'units' , metunits % Rainf ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Rainf units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( metunits % Rainf ( 1 : 8 ) == 'kg/m&#94;2/s' . OR . metunits % Rainf ( 1 : 6 ) == 'kg/m2s' . OR . metunits % Rainf ( 1 : 10 ) == & 'kgm&#94;-2s&#94;-1' . OR . metunits % Rainf ( 1 : 4 ) == 'mm/s' . OR . & metunits % Rainf ( 1 : 6 ) == 'mms&#94;-1' . OR . & metunits % Rainf ( 1 : 7 ) == 'kg/m&#94;2s' . OR . metunits % Rainf ( 1 : 10 ) == 'kg m-2 s-1' . OR . metunits % Wind ( 1 : 5 ) /= 'm s-1' ) THEN ! Change from mm/s to mm/time step: convert % Rainf = dels ELSE IF ( metunits % Rainf ( 1 : 4 ) == 'mm/h' . OR . metunits % Rainf ( 1 : 6 ) == & 'mmh&#94;-1' ) THEN ! Change from mm/h to mm/time step: convert % Rainf = dels / 360 0.0 ELSE WRITE ( * , * ) metunits % Rainf CALL abort ( 'Unknown units for Rainf' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ! Multiply acceptable Rainf ranges by time step size: !ranges%Rainf = ranges%Rainf*dels ! range therefore depends on dels ! vh ! why has this been commented out? ranges % Rainf = ranges % Rainf * dels ! range therefore depends on dels ! Look for Wind (essential):- - - - - - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_wd CALL find_metvarid ( ncid_met , possible_varnames % WindNames , id % Wind , ok ) IF ( ok /= NF90_NOERR ) THEN ! Look for vector wind: ok = NF90_INQ_VARID ( ncid_met , 'Wind_N' , id % Wind ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Wind_N in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ok = NF90_INQ_VARID ( ncid_met , 'Wind_E' , id % Wind_E ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Wind_E in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) exists % Wind = . FALSE . ! Use vector wind when reading met ELSE exists % Wind = . TRUE . ! 'Wind' variable exists END IF ! The following does not work with vector winds. Do we want to keep ! vector winds? ! Get Wind units: ok = NF90_GET_ATT ( ncid_met , id % Wind , 'units' , metunits % Wind ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Wind units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( metunits % Wind ( 1 : 3 ) /= 'm/s' . AND . metunits % Wind ( 1 : 2 ) /= 'ms' . AND . metunits % Wind ( 1 : 5 ) /= 'm s-1' ) THEN WRITE ( * , * ) metunits % Wind CALL abort ( 'Unknown units for Wind' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ! Now \"optional\" variables: ! Look for LWdown (can be synthesised):- - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_lw CALL find_metvarid ( ncid_met , possible_varnames % LWdownNames , id % LWdown , ok ) IF ( ok == NF90_NOERR ) THEN ! If inquiry is okay exists % LWdown = . TRUE . ! LWdown is present in met file ! Get LWdown units and check okay: ok = NF90_GET_ATT ( ncid_met , id % LWdown , 'units' , metunits % LWdown ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding LWdown units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) !! vh_js !! fixed bug in logic !!$       IF(metunits%LWdown(1:4)/='W/m2'.AND.metunits%LWdown(1:5) & !!$            /='W/m&#94;2'.AND.metunits%LWdown(1:5)/='Wm&#94;-2' & !!$            .AND.metunits%LWdown(1:4)/='Wm-2') THEN IF (. NOT .( metunits % LWdown ( 1 : 4 ) /= 'W/m2' . OR . metunits % LWdown ( 1 : 5 ) & /= 'W/m&#94;2' . OR . metunits % LWdown ( 1 : 5 ) /= 'Wm&#94;-2' & . OR . metunits % LWdown ( 1 : 4 ) /= 'Wm-2' . OR . metunits % SWdown ( 1 : 5 ) /= 'W m-2' )) THEN WRITE ( * , * ) metunits % LWdown CALL abort ( 'Unknown units for LWdown' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ELSE exists % LWdown = . FALSE . ! LWdown is not present in met file all_met = . FALSE . ! not all met variables are present in file ! Note this in log file: WRITE ( logn , * ) 'LWdown not present in met file; ' , & 'values will be synthesised based on air temperature.' END IF ! Look for PSurf (can be synthesised):- - - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_ps CALL find_metvarid ( ncid_met , possible_varnames % PSurfNames , id % PSurf , ok ) IF ( ok == NF90_NOERR ) THEN ! If inquiry is okay exists % PSurf = . TRUE . ! PSurf is present in met file ! Get PSurf units and check: ok = NF90_GET_ATT ( ncid_met , id % PSurf , 'units' , metunits % PSurf ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding PSurf units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( metunits % PSurf ( 1 : 2 ) == 'Pa' . OR . metunits % PSurf ( 1 : 2 ) == 'pa' . OR . & metunits % PSurf ( 1 : 2 ) == 'PA' ) THEN ! Change from pa to mbar (cable uses mbar): convert % PSurf = 0.01 WRITE ( logn , * ) 'Pressure will be converted from Pa to mb' ELSE IF ( metunits % PSurf ( 1 : 2 ) == 'KP' . OR . metunits % PSurf ( 1 : 2 ) == 'kP' & . OR . metunits % PSurf ( 1 : 2 ) == 'Kp' . OR . metunits % PSurf ( 1 : 2 ) == 'kp' ) THEN ! convert from kPa to mb convert % PSurf = 1 0.0 WRITE ( logn , * ) 'Pressure will be converted from kPa to mb' ELSE IF ( metunits % PSurf ( 1 : 2 ) == 'MB' . OR . metunits % PSurf ( 1 : 2 ) == 'mB' & . OR . metunits % PSurf ( 1 : 2 ) == 'Mb' . OR . metunits % PSurf ( 1 : 2 ) == 'mb' ) THEN ! Units are correct convert % PSurf = 1.0 ELSE WRITE ( * , * ) metunits % PSurf CALL abort ( 'Unknown units for PSurf' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ELSE ! If PSurf not present exists % PSurf = . FALSE . ! PSurf is not present in met file all_met = . FALSE . ! not all met variables are present in file ! Look for \"elevation\" variable to approximate pressure based ! on elevation and temperature: CALL find_metvarid ( ncid_met , possible_varnames % ElevNames , id % Elev , ok ) IF ( ok == NF90_NOERR ) THEN ! elevation present ! Get elevation units: ok = NF90_GET_ATT ( ncid_met , id % Elev , 'units' , metunits % Elev ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding elevation units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Units should be metres or feet: IF ( metunits % Elev ( 1 : 1 ) == 'm' . OR . metunits % Elev ( 1 : 1 ) == 'M' ) THEN ! This is the expected unit - metres convert % Elev = 1.0 ELSE IF ( metunits % Elev ( 1 : 1 ) == 'f' . OR . metunits % Elev ( 1 : 1 ) == 'F' ) THEN ! Convert from feet to metres: convert % Elev = 0.3048 ELSE CALL abort ( 'Unknown units for Elevation' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ! Allocate space for elevation variable: ALLOCATE ( elevation ( mland )) ! Get site elevations: IF ( metGrid == 'mask' ) THEN DO i = 1 , mland ok = NF90_GET_VAR ( ncid_met , id % Elev , data2 , & start = ( / land_x ( i ), land_y ( i ) / ), count = ( / 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading elevation in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) elevation ( i ) = REAL ( data2 ( 1 , 1 )) * convert % Elev END DO ELSE IF ( metGrid == 'land' ) THEN ! Collect data from land only grid in netcdf file: ok = NF90_GET_VAR ( ncid_met , id % Elev , data1 ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading elevation in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) elevation = REAL ( data1 ) * convert % Elev END IF ELSE ! If both PSurf and elevation aren't present, abort: CALL abort & ( 'Error finding PSurf or Elevation in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END IF ! Note static pressure based on elevation in log file: WRITE ( logn , * ) 'PSurf not present in met file; values will be ' , & 'synthesised based on elevation and temperature.' END IF ! Look for CO2air (can be assumed to be static):- - - - - - - - - - - CALL find_metvarid ( ncid_met , possible_varnames % CO2Names , id % CO2air , ok ) IF ( ok == NF90_NOERR ) THEN ! If inquiry is okay exists % CO2air = . TRUE . ! CO2air is present in met file ! Get CO2air units: ok = NF90_GET_ATT ( ncid_met , id % CO2air , 'units' , metunits % CO2air ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding CO2air units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( metunits % CO2air ( 1 : 3 ) /= 'ppm' ) THEN WRITE ( * , * ) metunits % CO2air CALL abort ( 'Unknown units for CO2air' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) END IF ELSE ! CO2 not present exists % CO2air = . FALSE . ! CO2air is not present in met file all_met = . FALSE . ! not all met variables are present in file ! Note this in log file: WRITE ( logn , '(A33,A24,I4,A5)' ) ' CO2air not present in met file; ' , & 'values will be fixed at ' , INT ( fixedCO2 ), ' ppmv' END IF ! Look for Snowf (could be part of Rainf variable):- - - - - - - - - - !IF (ncciy > 0 .AND. (globalMetfile%l_gpcc .OR. globalMetfile%l_gswp .OR. globalMetfile%l_ncar))Then IF ( ncciy > 0 . AND . ( globalMetfile % l_gswp . OR . globalMetfile % l_ncar )) Then ncid_met = ncid_snow END IF CALL find_metvarid ( ncid_met , possible_varnames % SnowNames , id % Snowf , ok ) IF ( ok == NF90_NOERR ) THEN ! If inquiry is okay exists % Snowf = . TRUE . ! Snowf is present in met file ! Get Snowf units: ok = NF90_GET_ATT ( ncid_met , id % Snowf , 'units' , metunits % Snowf ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding Snowf units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Make sure Snowf units are the same as Rainf units: IF ( metunits % Rainf /= metunits % Snowf ) CALL abort & ( 'Please ensure Rainf and Snowf units are the same' // & ' in ' // TRIM ( filename % met ) // ' (SUBROUTINE open_met_data)' ) ELSE exists % Snowf = . FALSE . ! Snowf is not present in met file !  all_met=.FALSE. not required; Snowf assumed to be in Rainf ! Note this in log file: WRITE ( logn , * ) 'Snowf not present in met file; ' , & 'Assumed to be contained in Rainf variable' END IF ! Look for LAI - - - - - - - - - - - - - - - - - - - - - - - - - CALL find_metvarid ( ncid_met , possible_varnames % LAINames , id % LAI , ok ) IF ( ok == NF90_NOERR ) THEN ! If inquiry is okay exists % LAI = . TRUE . ! LAI is present in met file ! LAI will be read in which ever land grid is used ! Check dimension of LAI variable: ok = NF90_INQUIRE_VARIABLE ( ncid_met , id % LAI , & ndims = lai_dims , dimids = laidimids ) ! If any of LAI's dimensions are the time dimension IF ( ANY ( laidimids == timedimID ( 1 ))) THEN exists % LAI_T = . TRUE . ! i.e. time varying LAI WRITE ( logn , * ) 'LAI found in met file - time dependent;' ELSE exists % LAI_T = . FALSE . ! i.e. not time varying LAI END IF IF ( ANY ( laidimids == monthlydimID )) THEN exists % LAI_M = . TRUE . ! i.e. time varying LAI, but monthly only WRITE ( logn , * ) 'LAI found in met file - monthly values;' ELSE exists % LAI_M = . FALSE . END IF IF ( ANY ( laidimids == patchdimID )) THEN exists % LAI_P = . TRUE . ! i.e. patch varying LAI WRITE ( logn , * ) 'LAI found in met file - patch-specific values' ELSE exists % LAI_P = . FALSE . ! i.e. not patch varying LAI END IF ELSE exists % LAI = . FALSE . ! LAI is not present in met file ! Report to log file WRITE ( logn , * ) 'LAI not present in met file; ' , & 'Will use MODIS coarse grid monthly LAI' END IF ! If a spinup is to be performed: IF ( spinup ) THEN ! Look for avPrecip variable (time invariant - used for spinup): CALL find_metvarid ( ncid_met , possible_varnames % APrecipNames , id % avPrecip , ok ) IF ( ok == NF90_NOERR ) THEN ! If inquiry is okay and avPrecip exists ! Report to log file than modified spinup will be used: WRITE ( logn , * ) 'Spinup will use modified precip - avPrecip variable found' WRITE ( logn , * ) '  precip will be rescaled to match these values during spinup:' WRITE ( * , * ) 'Spinup will use modified precip - avPrecip variable found' WRITE ( * , * ) '  precip will be rescaled to match these values during spinup' ! Spinup will modify precip values: exists % avPrecip = . TRUE . ! Get avPrecip units: ok = NF90_GET_ATT ( ncid_met , id % avPrecip , 'units' , metunits % avPrecip ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding avPrecip units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( metunits % avPrecip ( 1 : 2 ) /= 'mm' ) CALL abort ( & 'Unknown avPrecip units in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Allocate space for avPrecip variable: ALLOCATE ( avPrecip ( mland )) ! Get avPrecip from met file: IF ( metGrid == 'mask' ) THEN DO i = 1 , mland ok = NF90_GET_VAR ( ncid_met , id % avPrecip , data2 , & start = ( / land_x ( i ), land_y ( i ) / ), count = ( / 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading avPrecip in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) avPrecip ( i ) = REAL ( data2 ( 1 , 1 )) END DO ELSE IF ( metGrid == 'land' ) THEN ! Allocate single preciaion temporary variable: ALLOCATE ( temparray1 ( mland )) ! Collect data from land only grid in netcdf file: ok = NF90_GET_VAR ( ncid_met , id % avPrecip , temparray1 ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading avPrecip in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Needed since r_1 will be double precision with -r8: avPrecip = REAL ( temparray1 ) DEALLOCATE ( temparray1 ) END IF ! Now find average precip from met data, and create rescaling ! factor for spinup: ALLOCATE ( PrecipScale ( mland )) DO i = 1 , mland IF ( metGrid == 'mask' ) THEN ! Allocate space for temporary precip variable: ALLOCATE ( tempPrecip3 ( 1 , 1 , kend )) ! Get all data for this grid cell: ok = NF90_GET_VAR ( ncid_met , id % Rainf , tempPrecip3 , & start = ( / land_x ( i ), land_y ( i ), 1 + koffset / ), count = ( / 1 , 1 , kend / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Rainf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Store total Rainf for this grid cell: PrecipTot = REAL ( SUM ( SUM ( SUM ( tempPrecip3 , 3 ), 2 ))) & * convert % Rainf ! Get snowfall data for this grid cell: IF ( exists % Snowf ) THEN ok = NF90_GET_VAR ( ncid_met , id % Snowf , tempPrecip3 , & start = ( / land_x ( i ), land_y ( i ), 1 + koffset / ), count = ( / 1 , 1 , kend / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Snowf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Add total Snowf to this grid cell total: PrecipTot = PrecipTot + & ( REAL ( SUM ( SUM ( SUM ( tempPrecip3 , 3 ), 2 ))) & * convert % Rainf ) END IF DEALLOCATE ( tempPrecip3 ) ELSE IF ( metGrid == 'land' ) THEN ! Allocate space for temporary precip variable: ALLOCATE ( tempPrecip2 ( 1 , kend )) ! Get rainfall data for this land grid cell: ok = NF90_GET_VAR ( ncid_met , id % Rainf , tempPrecip2 , & start = ( / i , 1 + koffset / ), count = ( / 1 , kend / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Rainf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Store total Rainf for this land grid cell: PrecipTot = REAL ( SUM ( SUM ( tempPrecip2 , 2 ))) * convert % Rainf IF ( exists % Snowf ) THEN ok = NF90_GET_VAR ( ncid_met , id % Snowf , tempPrecip2 , & start = ( / i , 1 + koffset / ), count = ( / 1 , kend / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Snowf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Add total Snowf to this land grid cell total: PrecipTot = PrecipTot + ( REAL ( SUM ( SUM ( tempPrecip2 , 2 ))) & * convert % Rainf ) END IF DEALLOCATE ( tempPrecip2 ) END IF ! Create rescaling factor for this grid cell to ensure spinup ! rainfall/snowfall is closer to average rainfall: ! First calculate annual average precip in met data: avPrecipInMet = PrecipTot / REAL ( kend ) * 360 0.0 / dels * 365 * 24 PrecipScale ( i ) = avPrecipInMet / avPrecip ( i ) WRITE ( logn , * ) '  Site number:' , i WRITE ( logn , * ) '  average precip quoted in avPrecip variable:' , & avPrecip ( i ) WRITE ( logn , * ) '  average precip in met data:' , avPrecipInMet END DO ! over each land grid cell DEALLOCATE ( avPrecip ) ELSE ! avPrecip doesn't exist in met file ! Spinup will not modify precip values: exists % avPrecip = . FALSE . WRITE ( logn , * ) 'Spinup will repeat entire data set until states converge' WRITE ( logn , * ) '  (see below for convergence criteria);' WRITE ( * , * ) 'Spinup will repeat entire data set until states converge:' END IF END IF ! if a spinup is to be performed ! Look for veg type - - - - - - - - - - - - - - - - -: CALL find_metvarid ( ncid_met , possible_varnames % IVegNames , id % iveg , ok ) IF ( ok == NF90_NOERR ) THEN ! If 'iveg' exists in the met file ! Note existence of at least one model parameter in the met file: exists % parameters = . TRUE . ! Allocate space for user-defined veg type variable: ALLOCATE ( vegtype_metfile ( mland , nmetpatches )) IF ( exists % patch ) ALLOCATE ( vegpatch_metfile ( mland , nmetpatches )) ! Check dimension of veg type: ok = NF90_INQUIRE_VARIABLE ( ncid_met , id % iveg , ndims = iveg_dims ) IF ( metGrid == 'mask' ) THEN ! i.e. at least two spatial dimensions IF ( iveg_dims == 2 ) THEN ! no patch specific iveg information, just x,y DO i = 1 , mland ok = NF90_GET_VAR ( ncid_met , id % iveg , data2i , & ! get iveg data start = ( / land_x ( i ), land_y ( i ) / ), count = ( / 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading iveg in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Set all veg patches in grid cell to be this single type vegtype_metfile ( i ,:) = data2i ( 1 , 1 ) END DO ELSE IF ( iveg_dims == 3 ) THEN ! i.e. patch specific iveg information ! Patch-specific iveg variable MUST be accompanied by ! patchfrac variable with the same dimensions. So, ! Make sure that the patchfrac variable exists: CALL find_metvarid ( ncid_met , possible_varnames % PFracNames , id % patchfrac , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ! check read ok ( ok , 'Patch-specific vegetation type (iveg) must be accompanied ' // & 'by a patchfrac variable - this was not found in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) DO i = 1 , mland ! Then, get the patch specific iveg data: ok = NF90_GET_VAR ( ncid_met , id % iveg , vegtype_metfile ( i ,:), & start = ( / land_x ( i ), land_y ( i ), 1 / ), count = ( / 1 , 1 , nmetpatches / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ! check read ok ( ok , 'Error reading iveg in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( exists % patch ) then !Anna: also read patch fractions ok = NF90_GET_VAR ( ncid_met , id % patchfrac , vegpatch_metfile ( i ,:), & start = ( / land_x ( i ), land_y ( i ), 1 / ), count = ( / 1 , 1 , nmetpatches / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ! check read ok ( ok , 'Error reading patchfrac in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END IF END DO END IF ELSE IF ( metGrid == 'land' ) THEN ! Collect data from land only grid in netcdf file: IF ( iveg_dims == 1 ) THEN ! i.e. no patch specific iveg information DO i = 1 , mland ok = NF90_GET_VAR ( ncid_met , id % iveg , data1i , & start = ( / i / ), count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading iveg in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Set all veg patches in grid cell to be this single type vegtype_metfile ( i ,:) = data1i ( 1 ) END DO ELSE IF ( iveg_dims == 2 ) THEN ! i.e. patch specific iveg information ! Patch-specific iveg variable MUST be accompanied by ! patchfrac variable with same dimensions. So, ! Make sure that the patchfrac variable exists: CALL find_metvarid ( ncid_met , possible_varnames % PFracNames , id % patchfrac , ok ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ! check read ok ( ok , 'Patch-specific vegetation type (iveg) must be accompanied' // & 'by a patchfrac variable - this was not found in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) IF ( exists % patch ) then !Anna: also read patch fractions ok = NF90_GET_VAR ( ncid_met , id % patchfrac , vegpatch_metfile ( i ,:), & start = ( / land_x ( i ), land_y ( i ), 1 / ), count = ( / 1 , 1 , nmetpatches / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ! check read ok ( ok , 'Error reading patchfrac in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END IF DO i = 1 , mland ! Then, get the patch specific iveg data: ok = NF90_GET_VAR ( ncid_met , id % iveg , & vegtype_metfile ( i ,:),& start = ( / i , 1 / ), count = ( / 1 , nmetpatches / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading iveg in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END DO END IF END IF ELSE NULLIFY ( vegtype_metfile ) IF ( exists % patch ) NULLIFY ( vegpatch_metfile ) END IF ! Look for soil type: CALL find_metvarid ( ncid_met , possible_varnames % ISoilNames , id % isoil , ok ) IF ( ok == NF90_NOERR ) THEN ! If inquiry is okay ! Note existence of at least one model parameter in the met file: exists % parameters = . TRUE . ! Check dimension of soil type: ok = NF90_INQUIRE_VARIABLE ( ncid_met , id % isoil , ndims = isoil_dims ) ! Allocate space for user-defined soil type variable: ALLOCATE ( soiltype_metfile ( mland , nmetpatches )) ! Get soil type from met file: IF ( metGrid == 'mask' ) THEN IF ( isoil_dims == 2 ) THEN ! i.e. no patch specific isoil information DO i = 1 , mland ok = NF90_GET_VAR ( ncid_met , id % isoil , data2i , & start = ( / land_x ( i ), land_y ( i ) / ), count = ( / 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading isoil in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Set all soil patches in grid cell to be this single type soiltype_metfile ( i ,:) = data2i ( 1 , 1 ) END DO ELSE IF ( isoil_dims == 3 ) THEN ! i.e. patch specific isoil information DO i = 1 , mland ok = NF90_GET_VAR ( ncid_met , id % isoil , & soiltype_metfile ( i ,:), & start = ( / land_x ( i ), land_y ( i ), 1 / ), count = ( / 1 , 1 , nmetpatches / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading isoil in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END DO END IF ELSE IF ( metGrid == 'land' ) THEN IF ( isoil_dims == 1 ) THEN ! i.e. no patch specific isoil information ! Collect data from land only grid in netcdf file: DO i = 1 , mland ok = NF90_GET_VAR ( ncid_met , id % isoil , data1i , & start = ( / i / ), count = ( / 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading isoil in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) ! Set all veg patches in grid cell to be this single type soiltype_metfile ( i ,:) = data1i ( 1 ) END DO ELSE IF ( isoil_dims == 2 ) THEN ! i.e. patch specific isoil information DO i = 1 , mland ok = NF90_GET_VAR ( ncid_met , id % isoil , & soiltype_metfile ( i ,:), & start = ( / i , 1 / ), count = ( / 1 , nmetpatches / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading isoil in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE open_met_file)' ) END DO END IF END IF ELSE NULLIFY ( soiltype_metfile ) END IF ! Report finding met variables to log file: IF ( all_met ) THEN WRITE ( logn , * ) 'Found all met variables in met file.' ELSE WRITE ( logn , * ) 'Found all ESSENTIAL met variables in met file,' , & ' some synthesised (as above).' END IF !!=================&#94;&#94; End met variables search&#94;&#94;======================= END SUBROUTINE open_met_file !============================================================================== ! ! Name: get_met_data ! ! Purpose: Fetches meteorological forcing data from the netcdf met forcing file !          for a single time step, including LAI if it exists. !          Note that currently met forcing is duplicated for every vegetated !          patch in a single gridcell. ! ! CALLed from: cable_offline_driver ! ! MODULEs used: cable_common_module ! ! CALLs: abort !        nc_abort !        rh_sh !        sinbet ! ! Input file: [SiteName].nc ! !============================================================================== SUBROUTINE get_met_data ( spinup , spinConv , met , soil , rad , & veg , kend , dels , TFRZ , ktau , kstart ) ! Precision changes from REAL(4) to r_1 enable running with -r8 ! Input arguments LOGICAL , INTENT ( IN ) :: & spinup , & ! are we performing a spinup? spinConv ! has model spinup converged? TYPE ( met_type ), INTENT ( INOUT ) :: met ! meteorological data TYPE ( soil_parameter_type ), INTENT ( IN ) :: soil TYPE ( radiation_type ), INTENT ( IN ) :: rad TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! LAI retrieved from file INTEGER , INTENT ( IN ) :: ktau , & ! timestep in loop including spinup kend , & ! total number of timesteps in run kstart ! starting timestep REAL , INTENT ( IN ) :: dels ! time step size REAL , INTENT ( IN ) :: TFRZ ! Local variables REAL ( KIND = 4 ), DIMENSION ( 1 , 1 , 1 ) :: data3 ! temp variable for netcdf reading REAL ( KIND = 4 ), DIMENSION ( 1 , 1 , 1 , 1 ) :: data4 !  \" \" \" REAL ( KIND = 4 ), DIMENSION ( 1 , 1 ) :: data2 ! \" \" REAL ( KIND = 4 ), DIMENSION ( 1 ) :: data1 ! \" \" INTEGER :: i , j ! do loop counter INTEGER :: ndims ! tempvar for number of dims in variable REAL ( KIND = 4 ), ALLOCATABLE , DIMENSION (:) :: tmpDat1 REAL ( KIND = 4 ), ALLOCATABLE , DIMENSION (:,:) :: tmpDat2 , tmpDat2x REAL ( KIND = 4 ), ALLOCATABLE , DIMENSION (:,:,:) :: tmpDat3 , tmpDat3x REAL ( KIND = 4 ), ALLOCATABLE , DIMENSION (:,:,:,:) :: tmpDat4 , tmpDat4x DO i = 1 , mland ! over all land points/grid cells ! First set timing variables: ! All timing details below are initially written to the first patch ! of each gridcell, then dumped to all patches for the gridcell. IF ( ktau == kstart ) THEN ! initialise... SELECT CASE ( time_coord ) CASE ( 'LOC' ) ! i.e. use local time by default ! hour-of-day = starting hod met % hod ( landpt ( i )% cstart ) = shod met % doy ( landpt ( i )% cstart ) = sdoy met % moy ( landpt ( i )% cstart ) = smoy met % year ( landpt ( i )% cstart ) = syear CASE ( 'GMT' ) ! use GMT ! hour-of-day = starting hod + offset from GMT time: met % hod ( landpt ( i )% cstart ) = shod + ( longitude ( i ) / 18 0.0 ) * 1 2.0 ! Note above that all met%* vars have dim mp, ! while longitude and latitude have dimension mland. met % doy ( landpt ( i )% cstart ) = sdoy met % moy ( landpt ( i )% cstart ) = smoy met % year ( landpt ( i )% cstart ) = syear CASE DEFAULT CALL abort ( 'Unknown time coordinate! ' & // ' (SUBROUTINE get_met_data)' ) END SELECT ELSE ! increment hour-of-day by time step size: met % hod ( landpt ( i )% cstart ) = met % hod ( landpt ( i )% cstart ) + dels / 360 0.0 END IF ! IF ( met % hod ( landpt ( i )% cstart ) < 0.0 ) THEN ! may be -ve since longitude ! has range [-180,180] ! Reduce day-of-year by one and ammend hour-of-day: met % doy ( landpt ( i )% cstart ) = met % doy ( landpt ( i )% cstart ) - 1 met % hod ( landpt ( i )% cstart ) = met % hod ( landpt ( i )% cstart ) + 2 4.0 ! If a leap year AND we're using leap year timing: IF ( is_leapyear ( met % year ( landpt ( i )% cstart ))) THEN SELECT CASE ( INT ( met % doy ( landpt ( i )% cstart ))) CASE ( 0 ) ! ie Dec previous year met % moy ( landpt ( i )% cstart ) = 12 met % year ( landpt ( i )% cstart ) = met % year ( landpt ( i )% cstart ) - 1 met % doy ( landpt ( i )% cstart ) = 365 ! prev year not leap year as this is CASE ( 31 ) ! Jan met % moy ( landpt ( i )% cstart ) = 1 CASE ( 60 ) ! Feb met % moy ( landpt ( i )% cstart ) = 2 CASE ( 91 ) ! Mar met % moy ( landpt ( i )% cstart ) = 3 CASE ( 121 ) met % moy ( landpt ( i )% cstart ) = 4 CASE ( 152 ) met % moy ( landpt ( i )% cstart ) = 5 CASE ( 182 ) met % moy ( landpt ( i )% cstart ) = 6 CASE ( 213 ) met % moy ( landpt ( i )% cstart ) = 7 CASE ( 244 ) met % moy ( landpt ( i )% cstart ) = 8 CASE ( 274 ) met % moy ( landpt ( i )% cstart ) = 9 CASE ( 305 ) met % moy ( landpt ( i )% cstart ) = 10 CASE ( 335 ) met % moy ( landpt ( i )% cstart ) = 11 END SELECT ELSE ! not a leap year or not using leap year timing SELECT CASE ( INT ( met % doy ( landpt ( i )% cstart ))) CASE ( 0 ) ! ie Dec previous year met % moy ( landpt ( i )% cstart ) = 12 met % year ( landpt ( i )% cstart ) = met % year ( landpt ( i )% cstart ) - 1 ! If previous year is a leap year IF ( is_leapyear ( met % year ( landpt ( i )% cstart ))) THEN met % doy ( landpt ( i )% cstart ) = 366 ELSE met % doy ( landpt ( i )% cstart ) = 365 END IF CASE ( 31 ) ! Jan met % moy ( landpt ( i )% cstart ) = 1 CASE ( 59 ) ! Feb met % moy ( landpt ( i )% cstart ) = 2 CASE ( 90 ) met % moy ( landpt ( i )% cstart ) = 3 CASE ( 120 ) met % moy ( landpt ( i )% cstart ) = 4 CASE ( 151 ) met % moy ( landpt ( i )% cstart ) = 5 CASE ( 181 ) met % moy ( landpt ( i )% cstart ) = 6 CASE ( 212 ) met % moy ( landpt ( i )% cstart ) = 7 CASE ( 243 ) met % moy ( landpt ( i )% cstart ) = 8 CASE ( 273 ) met % moy ( landpt ( i )% cstart ) = 9 CASE ( 304 ) met % moy ( landpt ( i )% cstart ) = 10 CASE ( 334 ) met % moy ( landpt ( i )% cstart ) = 11 END SELECT END IF ! if leap year or not ELSE IF ( met % hod ( landpt ( i )% cstart ) >= 2 4.0 ) THEN ! increment or GMT adj has shifted day ! Adjust day-of-year and hour-of-day: met % doy ( landpt ( i )% cstart ) = met % doy ( landpt ( i )% cstart ) + 1 met % hod ( landpt ( i )% cstart ) = met % hod ( landpt ( i )% cstart ) - 2 4.0 ! If a leap year AND we're using leap year timing: !! vh_js !! use is_leapyear function here instead of multiple conditions IF ( is_leapyear ( met % year ( landpt ( i )% cstart ))) THEN SELECT CASE ( INT ( met % doy ( landpt ( i )% cstart ))) CASE ( 32 ) ! Feb met % moy ( landpt ( i )% cstart ) = 2 CASE ( 61 ) ! Mar met % moy ( landpt ( i )% cstart ) = 3 CASE ( 92 ) met % moy ( landpt ( i )% cstart ) = 4 CASE ( 122 ) met % moy ( landpt ( i )% cstart ) = 5 CASE ( 153 ) met % moy ( landpt ( i )% cstart ) = 6 CASE ( 183 ) met % moy ( landpt ( i )% cstart ) = 7 CASE ( 214 ) met % moy ( landpt ( i )% cstart ) = 8 CASE ( 245 ) met % moy ( landpt ( i )% cstart ) = 9 CASE ( 275 ) met % moy ( landpt ( i )% cstart ) = 10 CASE ( 306 ) met % moy ( landpt ( i )% cstart ) = 11 CASE ( 336 ) met % moy ( landpt ( i )% cstart ) = 12 CASE ( 367 ) ! end of year; increment met % year ( landpt ( i )% cstart ) = met % year ( landpt ( i )% cstart ) + 1 met % moy ( landpt ( i )% cstart ) = 1 met % doy ( landpt ( i )% cstart ) = 1 END SELECT ! ELSE IF not leap year and Dec 31st, increment year ELSE SELECT CASE ( INT ( met % doy ( landpt ( i )% cstart ))) CASE ( 32 ) ! Feb met % moy ( landpt ( i )% cstart ) = 2 CASE ( 60 ) ! Mar met % moy ( landpt ( i )% cstart ) = 3 CASE ( 91 ) met % moy ( landpt ( i )% cstart ) = 4 CASE ( 121 ) met % moy ( landpt ( i )% cstart ) = 5 CASE ( 152 ) met % moy ( landpt ( i )% cstart ) = 6 CASE ( 182 ) met % moy ( landpt ( i )% cstart ) = 7 CASE ( 213 ) met % moy ( landpt ( i )% cstart ) = 8 CASE ( 244 ) met % moy ( landpt ( i )% cstart ) = 9 CASE ( 274 ) met % moy ( landpt ( i )% cstart ) = 10 CASE ( 305 ) met % moy ( landpt ( i )% cstart ) = 11 CASE ( 335 ) met % moy ( landpt ( i )% cstart ) = 12 CASE ( 366 ) ! end of year; increment met % year ( landpt ( i )% cstart ) = met % year ( landpt ( i )% cstart ) + 1 met % moy ( landpt ( i )% cstart ) = 1 met % doy ( landpt ( i )% cstart ) = 1 END SELECT END IF ! if leap year or not END IF ! if increment has pushed hod to a different day ! Now copy these values to all veg/soil patches in the current grid cell: met % hod ( landpt ( i )% cstart : landpt ( i )% cend ) = met % hod ( landpt ( i )% cstart ) met % doy ( landpt ( i )% cstart : landpt ( i )% cend ) = met % doy ( landpt ( i )% cstart ) met % moy ( landpt ( i )% cstart : landpt ( i )% cend ) = met % moy ( landpt ( i )% cstart ) met % year ( landpt ( i )% cstart : landpt ( i )% cend ) = met % year ( landpt ( i )% cstart ) ENDDO IF ( metGrid == 'mask' ) THEN ! N.B. not for GSWP runs, therefore only one met file here. ! Also, xdimsize and ydimsize are passed from io_variables. ALLOCATE ( tmpDat2 ( xdimsize , ydimsize )) ALLOCATE ( tmpDat3 ( xdimsize , ydimsize , 1 )) ALLOCATE ( tmpDat4 ( xdimsize , ydimsize , 1 , 1 )) ALLOCATE ( tmpDat3x ( xdimsize , ydimsize , nmetpatches )) ALLOCATE ( tmpDat4x ( xdimsize , ydimsize , nmetpatches , 1 )) ! Get SWdown data for mask grid: IF ( cable_user % GSWP3 ) ncid_met = ncid_sw ! since GSWP3 multiple met files ok = NF90_GET_VAR ( ncid_met , id % SWdown , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading SWdown in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Assign value to met data variable (no units change required): !jhan:quick fix, use (1/2) dimension 1 here arbitrarily DO i = 1 , mland ! over all land points/grid cells met % fsd ( landpt ( i )% cstart : landpt ( i )% cend , 1 ) = & 0.5 * REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) met % fsd ( landpt ( i )% cstart : landpt ( i )% cend , 2 ) = & 0.5 * REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ENDDO ! Get Tair data for mask grid:- - - - - - - - - - - - - - - - - - IF ( cable_user % GSWP3 ) ncid_met = ncid_ta ! since GSWP3 multiple met files ! Find number of dimensions of Tair: ok = NF90_INQUIRE_VARIABLE ( ncid_met , id % Tair , ndims = ndims ) IF ( ndims == 3 ) THEN ! 3D var, either on grid or new ALMA format single site ok = NF90_GET_VAR ( ncid_met , id % Tair , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ! check for error ( ok , 'Error reading Tair in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Assign value to met data variable with units change: DO i = 1 , mland ! over all land points/grid cells met % tk ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) + convert % Tair ENDDO ELSE ! i.e. ndims==4, the older ALMA format for Tair ok = NF90_GET_VAR ( ncid_met , id % Tair , tmpDat4 , & start = ( / 1 , 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Tair in met data file HERE' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Assign value to met data variable with units change: DO i = 1 , mland ! over all land points/grid cells met % tk ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat4 ( land_x ( i ), land_y ( i ), 1 , 1 )) + convert % Tair ENDDO END IF ! Get PSurf data for mask grid:- - - - - - - - - - - - - - - - - - IF ( cable_user % GSWP3 ) ncid_met = ncid_ps ! since GSWP3 multiple met files IF ( exists % PSurf ) THEN ! IF PSurf is in met file: ! Find number of dimensions of PSurf: ok = NF90_INQUIRE_VARIABLE ( ncid_met , id % PSurf , ndims = ndims ) IF ( ndims == 3 ) THEN ! 3D var, either grid or new ALMA format single site ok = NF90_GET_VAR ( ncid_met , id % PSurf , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading PSurf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % pmb ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) * convert % PSurf ENDDO ELSE ! i.e. ndims==4, the older ALMA format for PSurf ok = NF90_GET_VAR ( ncid_met , id % PSurf , tmpDat4 , & start = ( / 1 , 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading PSurf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % pmb ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat4 ( land_x ( i ), land_y ( i ), 1 , 1 )) * convert % PSurf ENDDO END IF ELSE ! PSurf must be fixed as a function of site elevation and T: DO i = 1 , mland ! over all land points/grid cells met % pmb ( landpt ( i )% cstart : landpt ( i )% cend ) = 101 3.25 * & ( met % tk ( landpt ( i )% cstart ) / ( met % tk ( landpt ( i )% cstart ) + 0.0065 * & elevation ( i ))) ** ( 9.80665 / 28 7.04 / 0.0065 ) ENDDO END IF ! Get Qair data for mask grid: - - - - - - - - - - - - - - - - - - IF ( cable_user % GSWP3 ) ncid_met = ncid_qa ! since GSWP3 multiple met files ! Find number of dimensions of Qair: ok = NF90_INQUIRE_VARIABLE ( ncid_met , id % Qair , ndims = ndims ) IF ( ndims == 3 ) THEN ! 3D var, either grid or new ALMA format single site ok = NF90_GET_VAR ( ncid_met , id % Qair , tmpDat3 , & ! read 3D Qair var start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ! check for error ( ok , 'Error reading Qair in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) IF ( convert % Qair ==- 99 9.0 ) THEN ! Convert relative value using only first veg/soil patch values ! (identical) DO i = 1 , mland ! over all land points/grid cells CALL rh_sh ( REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )), & met % tk ( landpt ( i )% cstart ), & met % pmb ( landpt ( i )% cstart ), met % qv ( landpt ( i )% cstart )) met % qv ( landpt ( i )% cstart : landpt ( i )% cend ) = met % qv ( landpt ( i )% cstart ) ENDDO ELSE DO i = 1 , mland ! over all land points/grid cells met % qv ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ENDDO END IF ELSE ! i.e. ndims==4, the older ALMA format for Qair ok = NF90_GET_VAR ( ncid_met , id % Qair , tmpDat4 , & start = ( / 1 , 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Qair in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) IF ( convert % Qair ==- 99 9.0 ) THEN ! Convert relative value using only first veg/soil patch values ! (identical) DO i = 1 , mland ! over all land points/grid cells CALL rh_sh ( REAL ( tmpDat4 ( land_x ( i ), land_y ( i ), 1 , 1 )), & met % tk ( landpt ( i )% cstart ), & met % pmb ( landpt ( i )% cstart ), met % qv ( landpt ( i )% cstart )) met % qv ( landpt ( i )% cstart : landpt ( i )% cend ) = met % qv ( landpt ( i )% cstart ) ENDDO ELSE DO i = 1 , mland ! over all land points/grid cells met % qv ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat4 ( land_x ( i ), land_y ( i ), 1 , 1 )) ENDDO END IF END IF ! Get Wind data for mask grid: - - - - - - - - - - - - - - - - - - IF ( cable_user % GSWP3 ) ncid_met = ncid_wd ! since GSWP3 multiple met files IF ( exists % Wind ) THEN ! Scalar Wind ! Find number of dimensions of Wind: ok = NF90_INQUIRE_VARIABLE ( ncid_met , id % Wind , ndims = ndims ) IF ( ndims == 3 ) THEN ! 3D var, either grid or new ALMA format single site ok = NF90_GET_VAR ( ncid_met , id % Wind , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Assign value to met data variable (no units change required): DO i = 1 , mland ! over all land points/grid cells met % ua ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ENDDO ELSE ! i.e. ndims==4, the older ALMA format for Wind ok = NF90_GET_VAR ( ncid_met , id % Wind , tmpDat4 , & start = ( / 1 , 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Assign value to met data variable (no units change required): DO i = 1 , mland ! over all land points/grid cells met % ua ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat4 ( land_x ( i ), land_y ( i ), 1 , 1 )) ENDDO END IF ! 3 or 4D for 'Wind' variable ELSE ! Vector wind ! Find number of dimensions of Wind_N: ok = NF90_INQUIRE_VARIABLE ( ncid_met , id % Wind , ndims = ndims ) IF ( ndims == 3 ) THEN ! 3D var, either grid or new ALMA format single site ok = NF90_GET_VAR ( ncid_met , id % Wind , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind_N in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Write part of wind variable to met%ua: DO i = 1 , mland ! over all land points/grid cells met % ua ( landpt ( i )% cstart ) = REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ENDDO ! Then fetch 3D Wind_E, and combine: ok = NF90_GET_VAR ( ncid_met , id % Wind_E , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind_E in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Write final scalar Wind value: DO i = 1 , mland ! over all land points/grid cells met % ua ( landpt ( i )% cstart : landpt ( i )% cend ) = & SQRT ( met % ua ( landpt ( i )% cstart ) ** 2 + & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ** 2 ) ENDDO ELSE ! i.e. ndims==4, the older ALMA format for Wind_N and _E ! Get 4D Wind_N: ok = NF90_GET_VAR ( ncid_met , id % Wind , tmpDat4 , & start = ( / 1 , 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind_N in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Write part of wind variable to met%ua: DO i = 1 , mland ! over all land points/grid cells met % ua ( landpt ( i )% cstart ) = REAL ( tmpDat4 ( land_x ( i ), land_y ( i ), 1 , 1 )) ENDDO ! Then fetch 4D Wind_E, and combine: ok = NF90_GET_VAR ( ncid_met , id % Wind_E , tmpDat4 , & start = ( / 1 , 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind_E in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Write final scalar Wind value: DO i = 1 , mland ! over all land points/grid cells met % ua ( landpt ( i )% cstart : landpt ( i )% cend ) = & SQRT ( met % ua ( landpt ( i )% cstart ) ** 2 + & REAL ( tmpDat4 ( land_x ( i ), land_y ( i ), 1 , 1 )) ** 2 ) ENDDO END IF ! 3 or 4D for 'Wind_N' and 'Wind_E' variables END IF ! scalar or vector wind - 'Wind' or 'Wind_N'/'Wind_E' ! Get Rainf and Snowf data for mask grid:- - - - - - - - - - - - - IF ( cable_user % GSWP3 ) ncid_met = ncid_rain ok = NF90_GET_VAR ( ncid_met , id % Rainf , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Rainf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % precip ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ! store Rainf ENDDO IF ( exists % Snowf ) THEN IF ( cable_user % GSWP3 ) ncid_met = ncid_snow ok = NF90_GET_VAR ( ncid_met , id % Snowf , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Snowf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! store Snowf value (EK nov2007) DO i = 1 , mland ! over all land points/grid cells met % precip_sn ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ENDDO ELSE met % precip_sn (:) = 0.0 END IF ! combine Rainf and Snowf data met % precip (:) = met % precip (:) + met % precip_sn (:) ! Convert units: met % precip (:) = met % precip (:) * convert % Rainf met % precip_sn (:) = met % precip_sn (:) * convert % Rainf ! If we're performing a spinup, the spinup hasn't converged, ! and an avPrecip variable has been found, modify precip to ! ensure reasonable equilibration: IF ( spinup . AND .(. NOT . spinConv ). AND . exists % avPrecip ) THEN ! Rescale precip to average rainfall for this site: DO i = 1 , mland ! over all land points/grid cells met % precip ( landpt ( i )% cstart : landpt ( i )% cend ) = & met % precip ( landpt ( i )% cstart ) / PrecipScale ( i ) ! Added for snow (EK nov2007) met % precip_sn ( landpt ( i )% cstart : landpt ( i )% cend ) = & met % precip_sn ( landpt ( i )% cstart ) / PrecipScale ( i ) ENDDO END IF ! Get LWdown data for mask grid: - - - - - - - - - - - - - - - - - IF ( cable_user % GSWP3 ) ncid_met = ncid_lw IF ( exists % LWdown ) THEN ! If LWdown exists in met file ok = NF90_GET_VAR ( ncid_met , id % LWdown , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LWdown in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % fld ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ENDDO ELSE ! Synthesise LWdown based on temperature ! Use Swinbank formula: met % fld (:) = 0.0000094 * 0.0000000567 * ( met % tk (:) ** 6.0 ) END IF ! Get CO2air data for mask grid:- - - - - - - - - - - - - - - - - - IF ( exists % CO2air ) THEN ! If CO2air exists in met file ok = NF90_GET_VAR ( ncid_met , id % CO2air , tmpDat4 , & start = ( / 1 , 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading CO2air in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % ca ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat4 ( land_x ( i ), land_y ( i ), 1 , 1 )) / 100000 0.0 ENDDO ELSE ! Fix CO2 air concentration: met % ca (:) = fixedCO2 / 100000 0.0 END IF ! Get LAI, if it's present, for mask grid:- - - - - - - - - - - - - IF ( exists % LAI ) THEN ! If LAI exists in met file IF ( exists % LAI_T ) THEN ! i.e. time dependent LAI IF ( exists % LAI_P ) THEN ! i.e. patch dependent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat4x , & start = ( / 1 , 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , nmetpatches , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met1 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells DO j = 1 , nmetpatches veg % vlai ( landpt ( i )% cstart + j - 1 ) = & REAL ( tmpDat4x ( land_x ( i ), land_y ( i ), j , 1 )) ENDDO ENDDO ELSE ! i.e. patch independent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met2 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells veg % vlai ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ENDDO END IF ELSEIF ( exists % LAI_M ) THEN ! i.e. monthly LAI (BP apr08) IF ( exists % LAI_P ) THEN ! i.e. patch dependent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat4x , & start = ( / 1 , 1 , 1 , met % moy / ), count = ( / xdimsize , ydimsize , nmetpatches , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met3 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells DO j = 1 , nmetpatches veg % vlai ( landpt ( i )% cstart + j - 1 ) = & REAL ( tmpDat4x ( land_x ( i ), land_y ( i ), j , 1 )) ENDDO ENDDO ELSE ! i.e. patch independent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat3 , & start = ( / 1 , 1 , met % moy / ), count = ( / xdimsize , ydimsize , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met4 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells veg % vlai ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat3 ( land_x ( i ), land_y ( i ), 1 )) ENDDO END IF ELSE ! i.e. time independent LAI IF ( exists % LAI_P ) THEN ! i.e. patch dependent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat3x , & start = ( / 1 , 1 , 1 / ), count = ( / xdimsize , ydimsize , nmetpatches / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met5 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells DO j = 1 , nmetpatches veg % vlai ( landpt ( i )% cstart + j - 1 ) = & REAL ( tmpDat3x ( land_x ( i ), land_y ( i ), j )) ENDDO ENDDO ELSE ! i.e. patch independent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat2 , & start = ( / 1 , 1 / ), count = ( / xdimsize , ydimsize / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met6 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells veg % vlai ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat2 ( land_x ( i ), land_y ( i ))) ENDDO END IF END IF ELSE ! If not in met file, use default LAI value: DO i = 1 , mland ! over all land points/grid cells veg % vlai ( landpt ( i )% cstart : landpt ( i )% cend ) = & defaultLAI ( landpt ( i )% cstart : landpt ( i )% cend , met % moy ( landpt ( i )% cstart )) ENDDO END IF DEALLOCATE ( tmpDat2 , tmpDat3 , tmpDat4 , tmpDat3x , tmpDat4x ) ELSE IF ( metGrid == 'land' ) THEN ! Collect data from land only grid in netcdf file: ALLOCATE ( tmpDat1 ( mland )) ALLOCATE ( tmpDat2 ( mland , 1 )) ALLOCATE ( tmpDat2x ( mland , nmetpatches )) ALLOCATE ( tmpDat3 ( mland , nmetpatches , 1 )) ! Get SWdown data for land-only grid: - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_sw ok = NF90_GET_VAR ( ncid_met , id % SWdown , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading SWdown in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Assign value to met data variable (no units change required): DO i = 1 , mland ! over all land points/grid cells met % fsd ( landpt ( i )% cstart : landpt ( i )% cend , 1 ) = 0.5 * REAL ( tmpDat2 ( i , 1 )) met % fsd ( landpt ( i )% cstart : landpt ( i )% cend , 2 ) = 0.5 * REAL ( tmpDat2 ( i , 1 )) ENDDO ! Get Tair data for land-only grid:- - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_ta ok = NF90_GET_VAR ( ncid_met , id % Tair , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Tair in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Assign value to met data variable with units change: DO i = 1 , mland ! over all land points/grid cells met % tk ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat2 ( i , 1 )) + convert % Tair ENDDO ! Get PSurf data for land-only grid:- -- - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_ps IF ( exists % PSurf ) THEN ! IF PSurf is in met file: IF (( ncciy == 1986 ) . AND . ( ktau == 2184 )) THEN !hzz to fix the problem of ps data on time step 2184 ok = NF90_GET_VAR ( ncid_met , id % PSurf , tmpDat2 , & start = ( / 1 , 2176 / ), count = ( / mland , 1 / )) ! fixing bug in GSWP ps data ELSE ok = NF90_GET_VAR ( ncid_met , id % PSurf , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) ENDIF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading PSurf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % pmb ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat2 ( i , 1 )) * convert % PSurf ENDDO ELSE ! PSurf must be fixed as a function of site elevation and T: DO i = 1 , mland ! over all land points/grid cells met % pmb ( landpt ( i )% cstart : landpt ( i )% cend ) = 101 3.25 & * ( met % tk ( landpt ( i )% cstart ) / ( met % tk ( landpt ( i )% cstart ) & + 0.0065 * elevation ( i ))) ** ( 9.80665 / 28 7.04 / 0.0065 ) ENDDO END IF ! Get Qair data for land-only grid:- - - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_qa ok = NF90_GET_VAR ( ncid_met , id % Qair , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Qair in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) IF ( convert % Qair ==- 99 9.0 ) THEN DO i = 1 , mland ! over all land points/grid cells CALL rh_sh ( REAL ( tmpDat2 ( i , 1 )), met % tk ( landpt ( i )% cstart ), & met % pmb ( landpt ( i )% cstart ), met % qv ( landpt ( i )% cstart )) met % qv ( landpt ( i )% cstart : landpt ( i )% cend ) = met % qv ( landpt ( i )% cstart ) ENDDO ELSE DO i = 1 , mland ! over all land points/grid cells met % qv ( landpt ( i )% cstart : landpt ( i )% cend ) = REAL ( tmpDat2 ( i , 1 )) ENDDO END IF ! Get Wind data for land-only grid: - - - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_wd IF ( exists % Wind ) THEN ! Scalar Wind ok = NF90_GET_VAR ( ncid_met , id % Wind , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Assign value to met data variable (no units change required): DO i = 1 , mland ! over all land points/grid cells met % ua ( landpt ( i )% cstart : landpt ( i )% cend ) = REAL ( tmpDat2 ( i , 1 )) ENDDO ELSE ! Vector wind ! Get Wind_N: ok = NF90_GET_VAR ( ncid_met , id % Wind , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind_N in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! write part of the wind variable met % ua ( landpt (:)% cstart ) = REAL ( tmpDat2 (:, 1 )) ok = NF90_GET_VAR ( ncid_met , id % Wind_E , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Wind_E in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) ! Write final scalar Wind value: DO i = 1 , mland ! over all land points/grid cells met % ua ( landpt ( i )% cstart : landpt ( i )% cend ) = & SQRT ( met % ua ( landpt ( i )% cstart ) ** 2 + REAL ( tmpDat2 ( i , 1 )) ** 2 ) ENDDO END IF ! Get Rainf and Snowf data for land-only grid: - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_rain ok = NF90_GET_VAR ( ncid_met , id % Rainf , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Rainf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % precip ( landpt ( i )% cstart : landpt ( i )% cend ) = REAL ( tmpDat2 ( i , 1 )) ENDDO IF ( ncciy > 0 ) ncid_met = ncid_snow IF ( exists % Snowf ) THEN ok = NF90_GET_VAR ( ncid_met , id % Snowf , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading Snowf in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % precip_sn ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat2 ( i , 1 )) ENDDO ELSE met % precip_sn (:) = 0.0 END IF ! combine Rainf and Snowf data met % precip (:) = met % precip (:) + met % precip_sn (:) ! Convert units: met % precip (:) = met % precip (:) * convert % Rainf met % precip_sn (:) = met % precip_sn (:) * convert % Rainf ! If we're performing a spinup, the spinup hasn't converged, ! and an avPrecip variable has been found, modify precip to ! ensure reasonable equilibration: IF ( spinup . AND .(. NOT . spinConv ). AND . exists % avPrecip ) THEN ! Rescale precip to average rainfall for this site: DO i = 1 , mland ! over all land points/grid cells met % precip ( landpt ( i )% cstart : landpt ( i )% cend ) = & met % precip ( landpt ( i )% cstart ) / PrecipScale ( i ) met % precip_sn ( landpt ( i )% cstart : landpt ( i )% cend ) = & met % precip_sn ( landpt ( i )% cstart ) / PrecipScale ( i ) ENDDO END IF ! Get LWdown data for land-only grid: - - - - - - - - - - - - - - IF ( ncciy > 0 ) ncid_met = ncid_lw IF ( exists % LWdown ) THEN ! If LWdown exists in met file ok = NF90_GET_VAR ( ncid_met , id % LWdown , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LWdown in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % fld ( landpt ( i )% cstart : landpt ( i )% cend ) = REAL ( tmpDat2 ( i , 1 )) ENDDO ELSE ! Synthesise LWdown based on temperature ! Use Swinbank formula: met % fld (:) = 0.0000094 * 0.0000000567 * ( met % tk (:) ** 6.0 ) END IF ! Get CO2air data for land-only grid:- - - - - - - - - - - - - - IF ( exists % CO2air ) THEN ! If CO2air exists in met file ok = NF90_GET_VAR ( ncid_met , id % CO2air , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading CO2air in met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells met % ca ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat2 ( i , 1 )) / 100000 0.0 ENDDO ELSE met % ca (:) = fixedCO2 / 100000 0.0 END IF ! Get LAI data, if it exists, for land-only grid:- - - - - - - - - IF ( exists % LAI ) THEN ! If LAI exists in met file IF ( exists % LAI_T ) THEN ! i.e. time dependent LAI IF ( exists % LAI_P ) THEN ! i.e. patch dependent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat3 , & start = ( / 1 , 1 , ktau / ), count = ( / mland , nmetpatches , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met7 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells IF ( ( landpt ( i )% cend - landpt ( i )% cstart + 1 ) < nmetpatches ) THEN PRINT * , 'not enough patches at land point ' , i STOP END IF DO j = 1 , nmetpatches veg % vlai ( landpt ( i )% cstart + j - 1 ) = REAL ( tmpDat3 ( i , j , 1 )) ENDDO ENDDO ELSE ! i.e. patch independent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat2 , & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met8 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells veg % vlai ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat2 ( i , 1 )) ENDDO END IF ELSEIF ( exists % LAI_M ) THEN ! i.e. monthly LAI (BP apr08) IF ( exists % LAI_P ) THEN ! i.e. patch dependent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat3 , & start = ( / 1 , 1 , met % moy / ), count = ( / mland , nmetpatches , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met9 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells DO j = 1 , nmetpatches veg % vlai ( landpt ( i )% cstart + j - 1 ) = REAL ( tmpDat3 ( i , j , 1 )) ENDDO ENDDO ELSE ! i.e. patch independent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat2 , & start = ( / 1 , met % moy / ), count = ( / mland , 1 / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met10 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells veg % vlai ( landpt ( i )% cstart : landpt ( i )% cend ) = & REAL ( tmpDat2 ( i , 1 )) ENDDO END IF ELSE ! LAI time independent IF ( exists % LAI_P ) THEN ! i.e. patch dependent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat2x , & start = ( / 1 , 1 / ), count = ( / mland , nmetpatches / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met11 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells DO j = 1 , nmetpatches veg % vlai ( landpt ( i )% cstart + j - 1 ) = REAL ( tmpDat2x ( i , j )) ENDDO ENDDO ELSE ! i.e. patch independent LAI ok = NF90_GET_VAR ( ncid_met , id % LAI , tmpDat1 , & start = ( / 1 / ), count = ( / mland / )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error reading LAI in met12 data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE get_met_data)' ) DO i = 1 , mland ! over all land points/grid cells veg % vlai ( landpt ( i )% cstart : landpt ( i )% cend ) = REAL ( tmpDat1 ( i )) ENDDO END IF END IF ELSE ! If not in met file, use default LAI value: DO i = 1 , mland ! over all land points/grid cells !! vh_js !! corrected indices of defaultLAI veg % vlai ( landpt ( i )% cstart : landpt ( i )% cend ) = & defaultLAI ( landpt ( i )% cstart : landpt ( i )% cend , met % moy ( landpt ( i )% cstart )) ENDDO END IF DEALLOCATE ( tmpDat1 , tmpDat2 , tmpDat3 , tmpDat2x ) ELSE CALL abort ( 'Unrecognised grid type' ) END IF ! grid type IF ((. NOT . exists % Snowf ) . OR . ALL ( met % precip_sn == 0.0 )) THEN ! honour snowf input DO i = 1 , mland ! over all land points/grid cells ! Set solid precip based on temp met % precip_sn ( landpt ( i )% cstart : landpt ( i )% cend ) = 0.0 ! (EK nov2007) IF ( met % tk ( landpt ( i )% cstart ) <= tfrz ) & met % precip_sn ( landpt ( i )% cstart : landpt ( i )% cend ) & = met % precip ( landpt ( i )% cstart ) ! (EK nov2007) END DO ! 1, mland over all land grid points ENDIF ! Set cosine of zenith angle (provided by GCM when online): met % coszen = sinbet ( met % doy , rad % latitude , met % hod ) ! initialise within canopy air temp met % tvair = met % tk met % tvrad = met % tk IF ( check % ranges ) THEN ! Check ranges are okay: !jhan:quick fix, use dimension 1 here arbitrarily IF ( ANY ( met % fsd (:, 1 ) < ranges % SWdown ( 1 )). OR . ANY ( met % fsd (:, 1 ) > ranges % SWdown ( 2 ))) & CALL abort ( 'SWdown out of specified ranges!' ) IF ( ANY ( met % fsd (:, 2 ) < ranges % SWdown ( 1 )). OR . ANY ( met % fsd (:, 2 ) > ranges % SWdown ( 2 ))) & CALL abort ( 'SWdown out of specified ranges!' ) IF ( ANY ( met % fld < ranges % LWdown ( 1 )). OR . ANY ( met % fld > ranges % LWdown ( 2 ))) & CALL abort ( 'LWdown out of specified ranges!' ) IF ( ANY ( met % qv < ranges % Qair ( 1 )). OR . ANY ( met % qv > ranges % Qair ( 2 ))) & CALL abort ( 'Qair out of specified ranges!' ) IF ( ANY ( met % precip < ranges % Rainf ( 1 )). OR . ANY ( met % precip > ranges % Rainf ( 2 ))) THEN CALL abort ( 'Rainf out of specified ranges!' ) ENDIF IF ( ANY ( met % ua < ranges % Wind ( 1 )). OR . ANY ( met % ua > ranges % Wind ( 2 ))) & CALL abort ( 'Wind out of specified ranges!' ) IF ( ANY ( met % tk < ranges % Tair ( 1 )). OR . ANY ( met % tk > ranges % Tair ( 2 ))) & CALL abort ( 'Tair out of specified ranges!' ) IF ( ANY ( met % pmb < ranges % PSurf ( 1 )). OR . ANY ( met % pmb > ranges % PSurf ( 2 ))) THEN WRITE ( * , * ) \"min, max Psurf\" , MINVAL ( met % pmb ), MAXVAL ( met % pmb ), ranges % Psurf ( 1 ), ranges % Psurf ( 2 ) CALL abort ( 'PSurf out of specified ranges!' ) ENDIF END IF END SUBROUTINE get_met_data !============================================================================== ! ! Name: close_met_file ! ! Purpose: Close the file with the meteorological data ! ! CALLed from: cable_offline_driver ! ! CALLs: nc_abort ! ! Input file: [SiteName].nc ! !============================================================================== SUBROUTINE close_met_file ok = NF90_CLOSE ( ncid_met ) IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error closing met data file ' & // TRIM ( filename % met ) // ' (SUBROUTINE close_met_file)' ) ! Clear lat_all and lon_all variables END SUBROUTINE close_met_file !============================================================================== ! ! Name: load_parameters ! ! Purpose: Checks where parameters and initialisations should be loaded from. !          If they can be found in either the met file or restart file, they !          will load from there, with the met file taking precedence. Otherwise, !          they'll be chosen from a coarse global grid of veg and soil types, !          based on the lat/lon coordinates. ! ! CALLed from: cable_offline_driver ! ! CALLs: get_default_params !        allocate_cable_vars !        alloc_casavariable !        alloc_phenvariable !        write_default_params !        write_cnp_params !        casa_readbiome !        casa_readphen !        casa_init !        abort !        get_restart_data !        get_parameters_met !        derived_parameters !        check_parameter_values !        report_parameters ! ! Input file: [restart].nc ! !============================================================================== SUBROUTINE load_parameters ( met , air , ssnow , veg , climate , bgc , soil , canopy , rough , rad , & sum_flux , bal , logn , vegparmnew , casabiome , casapool , & casaflux , sum_casapool , sum_casaflux , casamet , casabal , phen , POP , spinup , EMSOIL , & TFRZ , LUC_EXPT , POPLUC ) ! Input variables not listed: !   filename%type  - via cable_IO_vars_module !   exists%type    - via cable_IO_vars_module !   smoy           - via cable_IO_vars_module ! Output variables not listed: !   (determined here or from sub get_default_params <- countPatch) !   landpt%type    - via cable_IO_vars_module (nap,cstart,cend,ilon,ilat) !   max_vegpatches - via cable_IO_vars_module !! vh_js !! USE POPmodule , ONLY : POP_INIT USE POPLUC_module , ONLY : POPLUC_INIT USE CABLE_LUC_EXPT , ONLY : LUC_EXPT_TYPE IMPLICIT NONE ! Input arguments TYPE ( met_type ), INTENT ( INOUT ) :: met TYPE ( air_type ), INTENT ( INOUT ) :: air TYPE ( soil_snow_type ), INTENT ( OUT ) :: ssnow TYPE ( veg_parameter_type ), INTENT ( OUT ) :: veg TYPE ( climate_type ), INTENT ( INOUT ) :: climate TYPE ( bgc_pool_type ), INTENT ( OUT ) :: bgc TYPE ( soil_parameter_type ), INTENT ( OUT ) :: soil TYPE ( canopy_type ), INTENT ( OUT ) :: canopy TYPE ( roughness_type ), INTENT ( OUT ) :: rough TYPE ( radiation_type ), INTENT ( OUT ) :: rad TYPE ( sum_flux_type ), INTENT ( OUT ) :: sum_flux TYPE ( balances_type ), INTENT ( OUT ) :: bal TYPE ( casa_biome ) , INTENT ( OUT ) :: casabiome TYPE ( casa_pool ) , INTENT ( OUT ) :: casapool TYPE ( casa_flux ) , INTENT ( OUT ) :: casaflux TYPE ( casa_pool ) , INTENT ( OUT ) :: sum_casapool TYPE ( casa_flux ) , INTENT ( OUT ) :: sum_casaflux TYPE ( casa_met ) , INTENT ( OUT ) :: casamet TYPE ( casa_balance ), INTENT ( OUT ) :: casabal TYPE ( phen_variable ), INTENT ( OUT ) :: phen TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( POPLUC_TYPE ), INTENT ( INOUT ) :: POPLUC TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT INTEGER , INTENT ( IN ) :: logn ! log file unit number LOGICAL , INTENT ( IN ) :: & vegparmnew , & ! are we using the new format? !! vh_js !! spinup ! for POP (initialize pop) REAL , INTENT ( IN ) :: TFRZ , EMSOIL ! Local variables REAL , POINTER , DIMENSION (:) :: pfractmp ! temp store of patch fraction LOGICAL :: completeSet ! was a complete parameter set found? LOGICAL :: EXRST = . FALSE . ! does a RunIden restart file exist? INTEGER :: & mp_restart , & ! total number of patches in restart file mpID , & napID , & i , j ! do loop variables !! vh_js !! ! CHARACTER :: frst_in*100, CYEAR*4 CHARACTER :: frst_in * 200 , CYEAR * 4 INTEGER :: IOS CHARACTER :: TACC * 20 INTEGER , DIMENSION (:), ALLOCATABLE :: ALLVEG !! vh_js !! INTEGER :: mp_POP INTEGER , DIMENSION (:), ALLOCATABLE :: Iwood ! Allocate spatial heterogeneity variables: ALLOCATE ( landpt ( mland )) WRITE ( logn , * ) '-------------------------------------------------------' WRITE ( logn , * ) 'Looking for parameters and initial states....' WRITE ( logn , * ) ' Loading initialisations from default grid.' ! Parameter values and some grid info are read in. ! They will be overwritten by values from the restart file, if present. ! Those variables found in the met file will again overwrite existing ones. CALL get_default_params ( logn , vegparmnew , LUC_EXPT ) CALL allocate_cable_vars ( air , bgc , canopy , met , bal , rad , rough , soil , ssnow , & sum_flux , veg , mp ) WRITE ( logn , * ) ' CABLE variables allocated with ' , mp , ' patch(es).' IF ( icycle > 0 . OR . CABLE_USER % CASA_DUMP_WRITE ) & CALL alloc_casavariable ( casabiome , casapool , casaflux , & casamet , casabal , mp ) !mpdiff CALL alloc_sum_casavariable ( sum_casapool , sum_casaflux , mp ) IF ( icycle > 0 ) THEN CALL alloc_phenvariable ( phen , mp ) ENDIF ! Write parameter values to CABLE's parameter variables: CALL write_default_params ( met , air , ssnow , veg , bgc , soil , canopy , rough , & rad , logn , vegparmnew , smoy , TFRZ , LUC_EXPT ) ! Zero out lai where there is no vegetation acc. to veg. index WHERE ( veg % iveg (:) . GE . 14 ) veg % vlai = 0. IF ( icycle > 0 ) THEN CALL write_cnp_params ( veg , casaflux , casamet ) CALL casa_readbiome ( veg , soil , casabiome , casapool , casaflux , & casamet , phen ) IF ( cable_user % PHENOLOGY_SWITCH . EQ . 'MODIS' ) CALL casa_readphen ( veg , casamet , phen ) CALL casa_init ( casabiome , casamet , casaflux , casapool , casabal , veg , phen ) !! vh_js !! IF ( CABLE_USER % CALL_POP ) THEN ! evaluate mp_POP and POP_array mp_POP = COUNT ( casamet % iveg2 == forest ) + COUNT ( casamet % iveg2 == shrub ) ALLOCATE ( Iwood ( mp_POP )) j = 1 DO i = 1 , mp IF ( casamet % iveg2 ( i ) == forest . OR . casamet % iveg2 ( i ) == shrub ) THEN Iwood ( j ) = i j = j + 1 ENDIF ENDDO CALL POP_init ( POP , veg % disturbance_interval ( Iwood ,:), mp_POP , Iwood ) IF ( . NOT . ( spinup . OR . CABLE_USER % POP_fromZero )) & CALL POP_IO ( POP , casamet , cable_user % YearStart , \"READ_rst \" , . TRUE .) ENDIF IF ( CABLE_USER % POPLUC ) THEN ! initialise POPLUC structure and params !zero biomass in secondary forest tiles ! read POP_LUC restart file here ! set POP%LU here for secondary tiles if cable_user%POPLUC_RunType is not 'static' CALL POPLUC_init ( POPLUC , LUC_EXPT , casapool , casaflux , casabiome , veg , POP , mland ) ENDIF ENDIF ! removed get_default_inits and get_default_lai as they are already done ! in write_default_params !    ! Load default initialisations from Mk3L climatology: !    CALL get_default_inits(met,soil,ssnow,canopy,logn) ! !    ! load default LAI values from global data: !    CALL get_default_lai ! Look for explicit restart file (which will have parameters): IF ( TRIM ( filename % restart_in ) . EQ . '' ) filename % restart_in = './' frst_in = filename % restart_in ok = NF90_OPEN ( TRIM ( frst_in ), NF90_NOWRITE , ncid_rin ) IF ( ok == NF90_NOERR ) EXRST = . TRUE . ! If not an explicit rstfile, search for RunIden_YEAR...nc ! use (filename%restart_in) as path IF ( . NOT . EXRST . AND . CABLE_USER % YEARSTART . GT . 0 ) THEN WRITE ( CYEAR , FMT = \"(I4)\" ) CurYear frst_in = TRIM ( filename % restart_in ) // '/' // TRIM ( cable_user % RunIden ) // & '_' // CYEAR // '_cable_rst.nc' INQUIRE ( FILE = TRIM ( frst_in ), EXIST = EXRST ) ENDIF IF ( EXRST ) THEN ok = NF90_OPEN ( TRIM ( frst_in ), NF90_NOWRITE , ncid_rin ) ! open restart file IF ( ok /= NF90_NOERR ) CALL HANDLE_ERR ( ok ) ! Any restart file exists, parameters and init will be loaded from it. WRITE ( logn , * ) ' Overwriting initialisations with values in ' , & 'restart file: ' , TRIM ( frst_in ) WRITE ( * , * ) ' Overwriting initialisations with values in ' , & 'restart file: ' , TRIM ( frst_in ) ! Check total number of patches in restart file: ok = NF90_INQ_DIMID ( ncid_rin , 'mp' , mpID ) IF ( ok /= NF90_NOERR ) THEN ok = NF90_INQ_DIMID ( ncid_rin , 'mp_patch' , mpID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding mp or mp_patch dimension in restart file ' & // TRIM ( frst_in ) // ' (SUBROUTINE load_parameters) ' & // 'Recommend running without restart file.' ) END IF ok = NF90_INQUIRE_DIMENSION ( ncid_rin , mpID , len = mp_restart ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error finding total number of patches in restart file ' & // TRIM ( frst_in ) // ' (SUBROUTINE load_parameters) ' & // 'Recommend running without restart file.' ) ! Check that mp_restart = mp from default/met values IF ( mp_restart /= mp ) CALL abort ( 'Number of patches in ' // & 'restart file ' // TRIM ( frst_in ) // ' does not equal ' // & 'to number in default/met file settings. (SUB load_parameters) ' & // 'Recommend running without restart file.' ) ! Load initialisations and parameters from restart file: CALL get_restart_data ( logn , ssnow , canopy , rough , bgc , bal , veg , & soil , rad , vegparmnew , EMSOIL ) ELSE ! With no restart file, use default parameters already loaded WRITE ( logn , * ) ' Could neither find restart file ' , TRIM ( filename % restart_in ) WRITE ( logn , * ) ' nor ' , TRIM ( frst_in ) WRITE ( logn , * ) ' Pre-loaded default initialisations are used.' WRITE ( * , * ) ' Could neither find restart file ' , TRIM ( filename % restart_in ) WRITE ( * , * ) ' nor ' , TRIM ( frst_in ) WRITE ( * , * ) ' Pre-loaded default initialisations are used.' END IF ! if restart file exists ! Overwrite default values by those available in met file: CALL get_parameters_met ( soil , veg , bgc , rough , completeSet ) ! Results of looking for parameters in the met file: WRITE ( logn , * ) IF ( exists % parameters . AND . completeSet ) THEN ! All pars were found in met file: WRITE ( logn , * ) ' Loaded all parameters from met input file: ' , & TRIM ( filename % met ) ELSE IF ( exists % parameters . AND .. NOT . completeSet ) THEN ! Only some pars were found in met file: WRITE ( logn , * ) ' Loaded some parameters from met input file: ' , & TRIM ( filename % met ), & ! write to log file ' the rest are default values' WRITE ( * , * ) ' Loaded some parameters from met input file: ' , & TRIM ( filename % met ), & ! write to screen ' the rest are default values - check log file' ELSE ! No parameters were found in met file: WRITE ( logn , * ) ' Met file has no params; all parameters remain as default.' END IF WRITE ( logn , * ) ! Construct derived parameters and zero initialisations, regardless ! of where parameters and other initialisations have loaded from: CALL derived_parameters ( soil , sum_flux , bal , ssnow , veg , rough ) ! Check for basic inconsistencies in parameter values: CALL check_parameter_values ( soil , veg , ssnow ) ! Write per-site parameter values to log file if requested: CALL report_parameters ( logn , soil , veg , bgc , rough , ssnow , canopy , & casamet , casapool , casaflux , phen , vegparmnew , verbose ) END SUBROUTINE load_parameters !============================================================================== ! ! Name: get_parameters_met ! ! Purpose: This subroutine looks for parameters in the met file, and loads !          those that are found. ! ! CALLed from: load_parameters !              old_load_parameters ! ! CALLs: readpar ! ! Input file: [SiteName].nc ! !============================================================================== SUBROUTINE get_parameters_met ( soil , veg , bgc , rough , completeSet ) TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg TYPE ( bgc_pool_type ), INTENT ( INOUT ) :: bgc TYPE ( roughness_type ), INTENT ( INOUT ) :: rough LOGICAL , INTENT ( OUT ) :: completeSet ! were all pars found? ! Local variables INTEGER :: parID ! parameter's netcdf ID ! removed the following section because already in IGBP types (BP apr08) !    ! First, if user defined surface type ratios are present in the !    ! met file then use them: !    IF(ASSOCIATED(vegfrac_user)) THEN !       DO i=1,mland !          ! Overwrite landpt(i)%*%frac, which will be set either by restart !          ! or default values: !          landpt(i)%veg%frac = vegfrac_user(i) !          landpt(i)%urban%frac = urbanfrac_user(i) !          landpt(i)%lake%frac = lakefrac_user(i) !          landpt(i)%ice%frac = icefrac_user(i) !       END DO !    END IF completeSet = . TRUE . ! initialise (assume all param will load from met file) ! Get parameter values: ! Arguments: netcdf file ID; parameter name; complete set check; !   parameter value; filename for error messages; number of veg/soil patches !   in met file; switch to indicate size of dimensions of the parameter. ! ! Use 'defd' for single dim double precision. ! veg and soil types already obtained in sub open_met_file !    CALL readpar(ncid_met,'iveg',completeSet,veg%iveg,filename%met, & !         nmetpatches,'def') CALL readpar ( ncid_met , 'patchfrac' , completeSet , patch (:)% frac , filename % met , & nmetpatches , 'def' ) !    CALL readpar(ncid_met,'isoil',completeSet,soil%isoilm,filename%met, & !         nmetpatches,'def') CALL readpar ( ncid_met , 'clay' , completeSet , soil % clay , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'sand' , completeSet , soil % sand , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'silt' , completeSet , soil % silt , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'ssat' , completeSet , soil % ssat , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'sfc' , completeSet , soil % sfc , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'swilt' , completeSet , soil % swilt , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'bch' , completeSet , soil % bch , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'hyds' , completeSet , soil % hyds , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'sucs' , completeSet , soil % sucs , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'css' , completeSet , soil % css , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'rhosoil' , completeSet , soil % rhosoil , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'rs20' , completeSet , veg % rs20 , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'albsoil' , completeSet , soil % albsoil , filename % met , & nmetpatches , 'nrb' ) CALL readpar ( ncid_met , 'froot' , completeSet , veg % froot , filename % met , & nmetpatches , 'ms' ) CALL readpar ( ncid_met , 'hc' , completeSet , veg % hc , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'canst1' , completeSet , veg % canst1 , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'dleaf' , completeSet , veg % dleaf , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'frac4' , completeSet , veg % frac4 , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'ejmax' , completeSet , veg % ejmax , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'vcmax' , completeSet , veg % vcmax , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'rp20' , completeSet , veg % rp20 , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'rpcoef' , completeSet , veg % rpcoef , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'shelrb' , completeSet , veg % shelrb , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'xfang' , completeSet , veg % xfang , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'wai' , completeSet , veg % wai , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'vegcf' , completeSet , veg % vegcf , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'extkn' , completeSet , veg % extkn , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'tminvj' , completeSet , veg % tminvj , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'tmaxvj' , completeSet , veg % tmaxvj , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'vbeta' , completeSet , veg % vbeta , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'xalbnir' , completeSet , veg % xalbnir , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'meth' , completeSet , veg % meth , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'g0' , completeSet , veg % g0 , filename % met , & nmetpatches , 'def' ) ! Ticket #56 CALL readpar ( ncid_met , 'g1' , completeSet , veg % g1 , filename % met , & nmetpatches , 'def' ) ! Ticket #56 ok = NF90_INQ_VARID ( ncid_met , 'za' , parID ) IF ( ok == NF90_NOERR ) THEN ! if it does exist CALL readpar ( ncid_met , 'za' , completeSet , rough % za_uv , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'za' , completeSet , rough % za_tq , filename % met , & nmetpatches , 'def' ) ELSE CALL readpar ( ncid_met , 'za_uv' , completeSet , rough % za_uv , filename % met , & nmetpatches , 'def' ) CALL readpar ( ncid_met , 'za_tq' , completeSet , rough % za_tq , filename % met , & nmetpatches , 'def' ) ENDIF CALL readpar ( ncid_met , 'zse' , completeSet , soil % zse , filename % met , & nmetpatches , 'ms' ) CALL readpar ( ncid_met , 'ratecp' , completeSet , bgc % ratecp , filename % met , & nmetpatches , 'ncp' ) CALL readpar ( ncid_met , 'ratecs' , completeSet , bgc % ratecs , filename % met , & nmetpatches , 'ncs' ) END SUBROUTINE get_parameters_met !============================================================================== ! ! Name: allocate_cable_vars ! ! Purpose: Allocate CABLE's main variables. ! ! CALLed from: load_parameters !              old_load_parameters ! ! CALLs: alloc_cbm_var ! !============================================================================== SUBROUTINE allocate_cable_vars ( air , bgc , canopy , met , bal , & rad , rough , soil , ssnow , sum_flux , & veg , arraysize ) TYPE ( met_type ), INTENT ( INOUT ) :: met TYPE ( air_type ), INTENT ( INOUT ) :: air TYPE ( soil_snow_type ), INTENT ( INOUT ) :: ssnow TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg TYPE ( bgc_pool_type ), INTENT ( INOUT ) :: bgc TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil TYPE ( canopy_type ), INTENT ( INOUT ) :: canopy TYPE ( roughness_type ), INTENT ( INOUT ) :: rough TYPE ( radiation_type ), INTENT ( INOUT ) :: rad TYPE ( sum_flux_type ), INTENT ( INOUT ) :: sum_flux TYPE ( balances_type ), INTENT ( INOUT ) :: bal INTEGER , INTENT ( IN ) :: arraysize CALL alloc_cbm_var ( air , arraysize ) CALL alloc_cbm_var ( bgc , arraysize ) CALL alloc_cbm_var ( canopy , arraysize ) CALL alloc_cbm_var ( met , arraysize ) CALL alloc_cbm_var ( bal , arraysize ) CALL alloc_cbm_var ( rad , arraysize ) CALL alloc_cbm_var ( rough , arraysize ) CALL alloc_cbm_var ( soil , arraysize ) CALL alloc_cbm_var ( ssnow , arraysize ) CALL alloc_cbm_var ( sum_flux , arraysize ) CALL alloc_cbm_var ( veg , arraysize ) ! Allocate patch fraction variable: ALLOCATE ( patch ( arraysize )) END SUBROUTINE allocate_cable_vars END MODULE cable_input_module !==============================================================================","tags":"","loc":"sourcefile/cable_input.f90.html"},{"title":"cable_mpiworker.F90 – CABLE","text":"Contents Modules cable_mpiworker Source Code cable_mpiworker.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Offline driver for mpi worker in CABLE global run ! ! Contact: Bernard.Pak@csiro.au ! ! History: Since 1.4b, capability to run global offline (ncciy = YEAR), !          inclusion of call to CASA-CNP (icycle>0) !          soil_snow_type now ssnow (instead of ssoil) ! !          MPI wrapper developed by Maciej Golebiewski (2012) !          Modified from cable_driver.F90 in CABLE-2.0_beta r171 by B Pak ! ! ============================================================================== ! Uses:           mpi !                 cable_mpicommon !                 cable_def_types_mod !                 cable_IO_vars_module !                 cable_common_module !                 cable_data_module !                 cable_input_module !                 cable_output_module !                 cable_cbm_module !                 casadimension !                 casavariable !                 phenvariable !                 casa_cable !                 casa_inout_module ! ! CALLs: !              casa_feedback !              cbm !              bgcdriver !              sumcflux !              find_extents !              worker_decomp !              worker_cable_params !              worker_casa_params !              worker_intype !              worker_outtype !              worker_casa_type !              worker_restart_type !              worker_end ! ! input  file: [SiteName].nc !              poolcnpIn[SiteName].csv -- for CASA-CNP only !              gridinfo_CSIRO_1x1.nc !              def_veg_params.txt !              def_soil_params.txt -- nearly redundant, can be switched on !              restart_in.nc -- not strictly required ! ! output file: log_cable.txt !              out_cable.nc !              restart_out.nc !              poolcnpOut.csv -- from CASA-CNP !============================================================================== MODULE cable_mpiworker USE cable_mpicommon USE cable_common_module , ONLY : cable_user USE casa_inout_module USE casa_cable IMPLICIT NONE SAVE PRIVATE ! MPI: MPI derived datatype for receiving parameters from the master INTEGER :: param_t ! MPI: MPI derived datatype for receiving casa parameters from the master INTEGER :: casaparam_t ! MPI: MPI derived datatype for receiving input from the master INTEGER :: inp_t ! MPI: MPI derived datatype for sending results back to the master INTEGER :: send_t ! worker's struct for sending final casa results to the master INTEGER :: casa_t ! worker's struct for rec'ing/sending final casa results to/from the master INTEGER :: casa_dump_t ! worker's struct for rec'ing/sending casa pools to/from the master (for LUC calcs) INTEGER :: casa_LUC_t ! worker's struct for rec'ing/sending final casa results to/from the master INTEGER :: climate_t ! worker's struct for rec'ing/sending pop io to/from the master INTEGER :: pop_t ! worker's struct for restart data to the master INTEGER :: restart_t ! worker's logfile unit !INTEGER :: wlogn !debug moved to iovars -- easy to pass around PUBLIC :: mpidrv_worker REAL , allocatable :: heat_cap_lower_limit (:,:) CONTAINS SUBROUTINE mpidrv_worker ( comm ) USE mpi USE cable_def_types_mod USE cable_IO_vars_module , ONLY : logn , gswpfile , ncciy , leaps , globalMetfile , & verbose , fixedCO2 , output , check , patchout , & patch_type , soilparmnew ,& defaultLAI , wlogn USE cable_common_module , ONLY : ktau_gl , kend_gl , knode_gl , cable_user , & cable_runtime , filename , myhome , & redistrb , wiltParam , satuParam , CurYear , & IS_LEAPYEAR , calcsoilalbedo , & kwidth_gl , gw_params USE casa_ncdf_module , ONLY : is_casa_time USE cable_input_module , ONLY : open_met_file , load_parameters , & get_met_data , close_met_file USE cable_output_module , ONLY : create_restart , open_output_file , & write_output , close_output_file USE cable_cbm_module USE cable_climate_mod ! modules related to CASA-CNP USE casadimension , ONLY : icycle USE casavariable , ONLY : casafile , casa_biome , casa_pool , casa_flux , & casa_met , casa_balance USE phenvariable , ONLY : phen_variable !CLN added ! modules related to POP USE POPmodule , ONLY : POP_INIT USE POP_Types , ONLY : POP_TYPE USE POP_Constants , ONLY : HEIGHT_BINS , NCOHORT_MAX ! PLUME-MIP only USE CABLE_PLUME_MIP , ONLY : PLUME_MIP_TYPE USE cable_namelist_util , ONLY : get_namelist_file_name ,& CABLE_NAMELIST , arg_not_namelist USE cbl_soil_snow_init_special_module IMPLICIT NONE ! MPI: INTEGER :: comm ! MPI communicator for comms with the workers ! CABLE namelist: model configuration, runtime/user switches !CHARACTER(LEN=200), PARAMETER :: CABLE_NAMELIST='cable.nml' ! timing variables INTEGER , PARAMETER :: kstart = 1 ! start of simulation INTEGER , PARAMETER :: mloop = 30 ! CASA-CNP PreSpinup loops INTEGER :: & ktau , & ! increment equates to timestep, resets if spinning up ktau_tot , & ! NO reset when spinning up, total timesteps by model kend , & ! no. of time steps in run !CLN      kstart = 1, &  ! timestep to start at koffset = 0 , & ! timestep to start at ktauday , & ! day counter for CASA-CNP idoy , & ! day of year (1:365) counter for CASA-CNP nyear , & ! year counter for CASA-CNP casa_it , & ! number of calls to CASA-CNP ctime , & ! day count for casacnp YYYY , & ! LOY , & ! Length of Year count_sum_casa , & ! number of time steps over which casa pools & !and fluxes are aggregated (for output) rank , & ! Rank of this worker maxdiff ( 2 ) ! location of maximum in convergence test REAL :: dels ! time step size in seconds CHARACTER :: cRank * 4 ! for worker-logfiles ! CABLE variables TYPE ( met_type ) :: met ! met input variables TYPE ( air_type ) :: air ! air property variables TYPE ( canopy_type ) :: canopy ! vegetation variables TYPE ( radiation_type ) :: rad ! radiation variables TYPE ( roughness_type ) :: rough ! roughness varibles TYPE ( balances_type ) :: bal ! energy and water balance variables TYPE ( soil_snow_type ) :: ssnow ! soil and snow variables TYPE ( climate_type ) :: climate ! climate variables ! CABLE parameters TYPE ( soil_parameter_type ) :: soil ! soil parameters TYPE ( veg_parameter_type ) :: veg ! vegetation parameters TYPE ( sum_flux_type ) :: sum_flux ! cumulative flux variables TYPE ( bgc_pool_type ) :: bgc ! carbon pool variables ! CASA-CNP variables TYPE ( casa_biome ) :: casabiome TYPE ( casa_pool ) :: casapool TYPE ( casa_flux ) :: casaflux TYPE ( casa_met ) :: casamet TYPE ( casa_balance ) :: casabal TYPE ( phen_variable ) :: phen TYPE ( POP_TYPE ) :: POP TYPE ( PLUME_MIP_TYPE ) :: PLUME CHARACTER :: cyear * 4 CHARACTER :: ncfile * 99 ! declare vars for switches (default .FALSE.) etc declared thru namelist LOGICAL , SAVE :: & vegparmnew = . FALSE ., & ! using new format input file (BP dec 2007) spinup = . FALSE ., & ! model spinup to soil state equilibrium? spinConv = . FALSE ., & ! has spinup converged? spincasa = . FALSE ., & ! TRUE: CASA-CNP Will spin mloop times, l_casacnp = . FALSE ., & ! using CASA-CNP with CABLE l_landuse = . FALSE ., & ! using LANDUSE l_laiFeedbk = . FALSE ., & ! using prognostic LAI l_vcmaxFeedbk = . FALSE ., & ! using prognostic Vcmax CASAONLY = . FALSE ., & ! ONLY Run CASA-CNP CALL1 = . TRUE . REAL :: & delsoilM , & ! allowed variation in soil moisture for spin up delsoilT ! allowed variation in soil temperature for spin up ! temporary storage for soil moisture/temp. in spin up mode REAL , ALLOCATABLE , DIMENSION (:,:) :: & soilMtemp , & soilTtemp ! MPI: LOGICAL :: loop_exit ! MPI: exit flag for bcast to workers INTEGER :: stat ( MPI_STATUS_SIZE ) INTEGER :: icomm ! separate dupes of MPI communicator for send and recv INTEGER :: ocomm ! separate dupes of MPI communicator for send and recv INTEGER :: ierr CHARACTER ( len = 200 ) :: Run ! switches etc defined thru namelist (by default cable.nml) NAMELIST / CABLE / & filename , & ! TYPE, containing input filenames vegparmnew , & ! use new soil param. method soilparmnew , & ! use new soil param. method calcsoilalbedo , & ! switch: soil colour albedo - Ticket #27 spinup , & ! spinup model (soil) to steady state delsoilM , delsoilT ,& ! output , & patchout , & check , & verbose , & leaps , & logn , & fixedCO2 , & spincasa , & l_casacnp , & l_landuse , & l_laiFeedbk , & l_vcmaxFeedbk , & icycle , & casafile , & ncciy , & gswpfile , & globalMetfile , & redistrb , & wiltParam , & satuParam , & cable_user , & ! additional USER switches gw_params INTEGER :: i , x , kk INTEGER :: LALLOC , iu !For consistency w JAC REAL , ALLOCATABLE , SAVE :: c1 (:,:) REAL , ALLOCATABLE , SAVE :: rhoch (:,:) REAL , ALLOCATABLE , SAVE :: xk (:,:) ! END header ! Maciej: make sure the variable does not go out of scope mp = 0 ! Open, read and close the namelist file. OPEN ( 10 , FILE = CABLE_NAMELIST ) READ ( 10 , NML = CABLE ) !where NML=CABLE defined above CLOSE ( 10 ) IF ( IARGC () > 0 ) THEN CALL GETARG ( 1 , filename % met ) CALL GETARG ( 2 , casafile % cnpipool ) ENDIF IF ( CABLE_USER % POPLUC . AND . TRIM ( CABLE_USER % POPLUC_RunType ) . EQ . 'static' ) & CABLE_USER % POPLUC = . FALSE . ! Get worker's rank and determine logfile-unit ! MPI: TODO: find a way to preserve workers log messages somewhere ! (either separate files or collated by the master to a single file ! or perhaps use MPI-IO - but probably not gonna work with random length ! text strings) ! LN: Done! IF ( CABLE_USER % LogWorker ) THEN CALL MPI_Comm_rank ( comm , rank , ierr ) WRITE ( cRank , FMT = '(I4.4)' ) rank wlogn = 1000 + rank OPEN ( wlogn , FILE = \"cable_log_\" // cRank , STATUS = \"REPLACE\" ) ELSE wlogn = 1000 OPEN ( wlogn , FILE = \"/dev/null\" ) ENDIF ! INITIALISATION depending on nml settings CurYear = CABLE_USER % YearStart IF ( icycle . GE . 11 ) THEN icycle = icycle - 10 CASAONLY = . TRUE . CABLE_USER % CASA_DUMP_READ = . TRUE . CABLE_USER % CASA_DUMP_WRITE = . FALSE . ELSEIF ( icycle . EQ . 0 ) THEN CABLE_USER % CASA_DUMP_READ = . FALSE . spincasa = . FALSE . CABLE_USER % CALL_POP = . FALSE . ENDIF !! vh_js !! IF ( icycle . GT . 0 ) THEN l_casacnp = . TRUE . ELSE l_casacnp = . FALSE . ENDIF !! vh_js !! suggest LALLOC should ulitmately be a switch in the .nml file IF ( CABLE_USER % CALL_POP ) THEN LALLOC = 3 ! for use with POP: makes use of pipe model to partition between stem and leaf ELSE LALLOC = 0 ! default ENDIF IF ( TRIM ( cable_user % MetType ) . EQ . 'gpgs' ) THEN leaps = . TRUE . cable_user % MetType = 'gswp' ENDIF cable_runtime % offline = . TRUE . IF ( l_casacnp . AND . ( icycle == 0 . OR . icycle > 3 ) ) & STOP 'icycle must be 1 to 3 when using casaCNP' IF ( ( l_laiFeedbk . OR . l_vcmaxFeedbk ) . AND . ( . NOT . l_casacnp ) ) & STOP 'casaCNP required to get prognostic LAI or Vcmax' IF ( l_vcmaxFeedbk . AND . icycle < 2 ) & STOP 'icycle must be 2 to 3 to get prognostic Vcmax' IF ( icycle > 0 . AND . ( . NOT . soilparmnew ) ) & STOP 'casaCNP must use new soil parameters' ! Open log file: ! MPI: worker logs go to the black hole ! by opening the file we don't need to touch any of the code that writes ! to it and may be called somewhere by a worker ! OPEN(logn,FILE=filename%log) !! Check for gswp run ! MPI: done by the master only; if check fails then master MPI_Aborts ! everyone !IF (ncciy /= 0) THEN ! !   PRINT *, 'Looking for global offline run info.' ! !   IF (ncciy < 1986 .OR. ncciy > 1995) THEN !      PRINT *, 'Year ', ncciy, ' outside range of dataset!' !      STOP 'Please check input in namelist file.' !   ELSE ! !      CALL prepareFiles(ncciy) ! !   ENDIF ! !ENDIF ! Open met data and get site information from netcdf file. ! This retrieves time step size, number of timesteps, starting date, ! latitudes, longitudes, number of sites. ! MPI: master only; necessary info will be received by MPI below !CALL open_met_file( dels, kend, spinup, C%TFRZ ) ! Checks where parameters and initialisations should be loaded from. ! If they can be found in either the met file or restart file, they will ! load from there, with the met file taking precedence. Otherwise, they'll ! be chosen from a coarse global grid of veg and soil types, based on ! the lat/lon coordinates. Allocation of CABLE's main variables also here. ! MPI: master only; necessary info will be received by MPI below !CALL load_parameters( met, air, ssnow, veg, bgc,                            & !                      soil, canopy, rough, rad, sum_flux,                   & !                      bal, logn, vegparmnew, casabiome, casapool,           & !                      casaflux, casamet, casabal, phen, C%EMSOIL,        & !                      C%TFRZ ) ! Check for leap-year settings CALL MPI_Bcast ( leaps , 1 , MPI_LOGICAL , 0 , comm , ierr ) ktau_tot = 0 SPINLOOP : DO YEAR : DO YYYY = CABLE_USER % YearStart , CABLE_USER % YearEnd CurYear = YYYY IF ( leaps . AND . IS_LEAPYEAR ( YYYY ) ) THEN LOY = 366 ELSE LOY = 365 ENDIF IF ( CALL1 ) THEN IF (. NOT . spinup ) spinConv = . TRUE . ! MPI: bcast to workers so that they don't need to open the met ! file themselves CALL MPI_Bcast ( dels , 1 , MPI_REAL , 0 , comm , ierr ) ENDIF ! MPI: receive from master ending time fields CALL MPI_Bcast ( kend , 1 , MPI_INTEGER , 0 , comm , ierr ) IF ( CALL1 ) THEN ! MPI: need to know extents before creating datatypes CALL find_extents ! MPI: receive decomposition info from the master CALL worker_decomp ( comm ) ! MPI: in overlap version sends and receives occur on separate comms CALL MPI_Comm_dup ( comm , icomm , ierr ) CALL MPI_Comm_dup ( comm , ocomm , ierr ) ! MPI: data set in load_parameter is now received from ! the master CALL worker_cable_params ( comm , met , air , ssnow , veg , bgc , soil , canopy ,& & rough , rad , sum_flux , bal ) !mrd561 debug WRITE ( wlogn , * ) ' ssat_vec min' , MINVAL ( soil % ssat_vec ), MINLOC ( soil % ssat_vec ) WRITE ( wlogn , * ) ' sfc_vec min' , MINVAL ( soil % sfc_vec ), MINLOC ( soil % sfc_vec ) WRITE ( wlogn , * ) ' wb min' , MINVAL ( ssnow % wb ), MINLOC ( ssnow % wb ) CALL flush ( wlogn ) IF ( cable_user % call_climate ) THEN CALL worker_climate_types ( comm , climate , ktauday ) ENDIF ! MPI: mvtype and mstype send out here instead of inside worker_casa_params !      so that old CABLE carbon module can use them. (BP May 2013) CALL MPI_Bcast ( mvtype , 1 , MPI_INTEGER , 0 , comm , ierr ) CALL MPI_Bcast ( mstype , 1 , MPI_INTEGER , 0 , comm , ierr ) ! MPI: casa parameters received only if cnp module is active IF ( icycle > 0 ) THEN CALL worker_casa_params ( comm , casabiome , casapool , casaflux , casamet ,& & casabal , phen ) ! MPI: POP restart received only if pop module AND casa are active IF ( CABLE_USER % CALL_POP ) CALL worker_pop_types ( comm , veg , casamet , pop ) END IF ! MPI: create inp_t type to receive input data from the master ! at the start of every timestep CALL worker_intype ( comm , met , veg ) ! MPI: casa parameters received only if cnp module is active ! MPI: create send_t type to send the results to the master ! at the end of every timestep CALL worker_outtype ( comm , met , canopy , ssnow , rad , bal , air , soil , veg ) ! MPI: casa parameters received only if cnp module is active ! MPI: create type to send casa results back to the master ! only if cnp module is active IF ( icycle > 0 ) THEN CALL worker_casa_type ( comm , casapool , casaflux , & casamet , casabal , phen ) IF ( CABLE_USER % CASA_DUMP_READ . OR . CABLE_USER % CASA_DUMP_WRITE ) & CALL worker_casa_dump_types ( comm , casamet , casaflux , phen , climate ) WRITE ( wlogn , * ) 'cable_mpiworker, POPLUC: ' , CABLE_USER % POPLUC WRITE ( * , * ) 'cable_mpiworker, POPLUC: ' , CABLE_USER % POPLUC CALL flush ( wlogn ) IF ( CABLE_USER % POPLUC ) & CALL worker_casa_LUC_types ( comm , casapool , casabal ) ! MPI: casa parameters received only if cnp module is active END IF ! MPI: create type to send restart data back to the master ! only if restart file is to be created IF ( output % restart ) THEN CALL worker_restart_type ( comm , canopy , air ) END IF ! Open output file: ! MPI: only the master writes to the files !CALL open_output_file( dels, soil, veg, bgc, rough ) ssnow % otss_0 = ssnow % tgg (:, 1 ) ssnow % otss = ssnow % tgg (:, 1 ) canopy % fes_cor = 0. canopy % fhs_cor = 0. met % ofsd = 0.1 ! CALL worker_sumcasa_types(comm, sum_casapool, sum_casaflux) !count_sum_casa = 0 IF ( icycle > 0 . AND . spincasa ) THEN WRITE ( wlogn , * ) 'EXT spincasacnp enabled with mloop= ' , mloop CALL worker_spincasacnp ( dels , kstart , kend , mloop , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , icomm , ocomm ) SPINconv = . FALSE . CASAONLY = . TRUE . ktau_gl = 0 ktau = 0 ELSEIF ( casaonly . AND . (. NOT . spincasa ) . AND . cable_user % popluc ) THEN CALL worker_CASAONLY_LUC ( dels , kstart , kend , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , & icomm , ocomm ) SPINconv = . FALSE . ktau_gl = 0 ktau = 0 ENDIF ELSE IF ( icycle . GT . 0 ) THEN ! re-initalise annual flux sums casabal % FCgppyear = 0.0 casabal % FCrpyear = 0.0 casabal % FCnppyear = 0.0 casabal % FCrsyear = 0.0 casabal % FCneeyear = 0.0 ENDIF ENDIF !CALL1 ! globally (WRT code) accessible kend through USE cable_common_module ktau_gl = 0 kwidth_gl = INT ( dels ) kend_gl = kend knode_gl = 0 IF ( spincasa . OR . casaonly ) THEN EXIT ENDIF if ( . NOT . allocated ( heat_cap_lower_limit ) ) then allocate ( heat_cap_lower_limit ( mp , ms ) ) heat_cap_lower_limit = 0.01 end if call spec_init_soil_snow ( dels , soil , ssnow , canopy , met , bal , veg , heat_cap_lower_limit ) ! IF (.NOT.spincasa) THEN ! time step loop over ktau KTAULOOP : DO ktau = kstart , kend ! increment total timstep counter ktau_tot = ktau_tot + 1 WRITE ( wlogn , * ) 'ktau -' , ktau_tot CALL flush ( wlogn ) ! globally (WRT code) accessible kend through USE cable_common_module ktau_gl = ktau_gl + 1 ! somethings (e.g. CASA-CNP) only need to be done once per day ktauday = INT ( 2 4.0 * 360 0.0 / dels ) !!$             idoy = mod(ktau/ktauday,365) !!$             IF(idoy==0) idoy=365 !!$ !!$             ! needed for CASA-CNP !!$             nyear =INT((kend-kstart+1)/(365*ktauday)) ! some things (e.g. CASA-CNP) only need to be done once per day idoy = INT ( MOD (( REAL ( ktau + koffset ) / REAL ( ktauday )), REAL ( LOY ))) IF ( idoy . EQ . 0 ) idoy = LOY ! needed for CASA-CNP nyear = INT (( kend - kstart + 1 ) / ( LOY * ktauday )) canopy % oldcansto = canopy % cansto ! Get met data and LAI, set time variables. ! Rainfall input may be augmented for spinup purposes: met % ofsd = met % fsd (:, 1 ) + met % fsd (:, 2 ) ! MPI: input file read on the master only !CALL get_met_data( spinup, spinConv, met, soil,                    & !                   rad, veg, kend, dels, C%TFRZ, ktau ) ! MPI: receive input data for this step from the master IF ( . NOT . CASAONLY ) THEN CALL MPI_Recv ( MPI_BOTTOM , 1 , inp_t , 0 , ktau_gl , icomm , stat , ierr ) ! MPI: receive casa_dump_data for this step from the master ELSEIF ( IS_CASA_TIME ( \"dread\" , yyyy , ktau , kstart , koffset , & kend , ktauday , wlogn ) ) THEN CALL MPI_Recv ( MPI_BOTTOM , 1 , casa_dump_t , 0 , ktau_gl , icomm , stat , ierr ) END IF ! MPI: some fields need explicit init, because we don't transfer ! them for better performance ! in the serial version this is done in get_met_data ! after input has been read from the file met % tvair = met % tk met % tvrad = met % tk ! Feedback prognostic vcmax and daily LAI from casaCNP to CABLE IF ( l_vcmaxFeedbk ) CALL casa_feedback ( ktau , veg , casabiome , & casapool , casamet ) IF ( l_laiFeedbk ) veg % vlai (:) = REAL ( casamet % glai (:)) IF ( cable_user % CALL_climate ) & CALL cable_climate ( ktau_tot , kstart , kend , ktauday , idoy , LOY , met , & climate , canopy , air , rad , dels , mp ) IF (. NOT . allocated ( c1 )) ALLOCATE ( c1 ( mp , nrb ), rhoch ( mp , nrb ), xk ( mp , nrb ) ) ! CALL land surface scheme for this timestep, all grid points: CALL cbm ( ktau , dels , air , bgc , canopy , met , bal , & rad , rough , soil , ssnow , sum_flux , veg , climate , xk , c1 , rhoch ) ssnow % smelt = ssnow % smelt * dels ssnow % rnof1 = ssnow % rnof1 * dels ssnow % rnof2 = ssnow % rnof2 * dels ssnow % runoff = ssnow % runoff * dels !jhan this is insufficient testing. condition for !spinup=.false. & we want CASA_dump.nc (spinConv=.true.) IF ( icycle > 0 ) THEN CALL bgcdriver ( ktau , kstart , kend , dels , met , & ssnow , canopy , veg , soil , climate , casabiome , & casapool , casaflux , casamet , casabal , & phen , pop , spinConv , spinup , ktauday , idoy , loy , & . FALSE ., . FALSE ., LALLOC ) ! IF(MOD((ktau-kstart+1),ktauday)==0) THEN CALL MPI_Send ( MPI_BOTTOM , 1 , casa_t , 0 , ktau_gl , ocomm , ierr ) !  ENDIF IF ( IS_CASA_TIME ( \"write\" , yyyy , ktau , kstart , & koffset , kend , ktauday , wlogn ) ) THEN ! write(wlogn,*), 'IN IS_CASA', casapool%cplant(:,1) !      CALL MPI_Send (MPI_BOTTOM,1, casa_t,0,ktau_gl,ocomm,ierr) ENDIF ! MPI: send the results back to the master IF ( ((. NOT . spinup ). OR .( spinup . AND . spinConv )) . AND . & IS_CASA_TIME ( \"dwrit\" , yyyy , ktau , kstart , & koffset , kend , ktauday , logn )) & CALL MPI_Send ( MPI_BOTTOM , 1 , casa_dump_t , 0 , ktau_gl , ocomm , ierr ) ENDIF ! sumcflux is pulled out of subroutine cbm ! so that casaCNP can be called before adding the fluxes (Feb 2008, YP) CALL sumcflux ( ktau , kstart , kend , dels , bgc , & canopy , soil , ssnow , sum_flux , veg , & met , casaflux , l_vcmaxFeedbk ) ! MPI: send the results back to the master CALL MPI_Send ( MPI_BOTTOM , 1 , send_t , 0 , ktau_gl , ocomm , ierr ) ! Write time step's output to file if either: we're not spinning up ! or we're spinning up and the spinup has converged: ! MPI: writing done only by the master !IF((.NOT.spinup).OR.(spinup.AND.spinConv))                         & !   CALL write_output( dels, ktau, met, canopy, ssnow,                    & !                      rad, bal, air, soil, veg, C%SBOLTZ, & !                      C%EMLEAF, C%EMSOIL ) CALL1 = . FALSE . END DO KTAULOOP ! END Do loop over timestep ktau ! ELSE CALL1 = . FALSE . ! ENDIF CALL flush ( wlogn ) IF ( icycle > 0 . AND . cable_user % CALL_POP ) THEN IF ( CABLE_USER % POPLUC ) THEN WRITE ( wlogn , * ), 'before MPI_Send casa_LUC' ! worker sends casa updates required for LUC calculations here CALL MPI_Send ( MPI_BOTTOM , 1 , casa_LUC_t , 0 , 0 , ocomm , ierr ) WRITE ( wlogn , * ), 'after MPI_Send casa_LUC' ! master calls LUCDriver here ! worker receives casa and POP updates CALL MPI_Recv ( POP % pop_grid ( 1 ), POP % np , pop_t , 0 , 0 , icomm , stat , ierr ) ENDIF ! one annual time-step of POP CALL POPdriver ( casaflux , casabal , veg , POP ) CALL worker_send_pop ( POP , ocomm ) IF ( CABLE_USER % POPLUC ) & CALL MPI_Recv ( MPI_BOTTOM , 1 , casa_LUC_t , 0 , nyear , icomm , stat , ierr ) ENDIF IF ( ((. NOT . spinup ). OR .( spinup . AND . spinConv )). AND . & CABLE_USER % CALL_POP ) THEN !CALL worker_send_pop (POP, ocomm) ENDIF END DO YEAR IF ( spincasa . OR . casaonly ) THEN EXIT ENDIF !!jhan this is insufficient testing. condition for !!spinup=.false. & we want CASA_dump.nc (spinConv=.true.) !! see if spinup (if conducting one) has converged: !IF(spinup.AND..NOT.spinConv) THEN ! !   ! Write to screen and log file: !   WRITE(*,'(A18,I3,A24)') ' Spinning up: run ',INT(ktau_tot/kend),      & !         ' of data set complete...' !   WRITE(wlogn,'(A18,I3,A24)') ' Spinning up: run ',INT(ktau_tot/kend),   & !         ' of data set complete...' ! !   ! IF not 1st run through whole dataset: !   IF( INT( ktau_tot/kend ) > 1 ) THEN ! !      ! evaluate spinup !      IF( ANY( ABS(ssnow%wb-soilMtemp)>delsoilM).OR.                     & !          ANY(ABS(ssnow%tgg-soilTtemp)>delsoilT) ) THEN ! !         ! No complete convergence yet !         PRINT *, 'ssnow%wb : ', ssnow%wb !         PRINT *, 'soilMtemp: ', soilMtemp !         PRINT *, 'ssnow%tgg: ', ssnow%tgg !         PRINT *, 'soilTtemp: ', soilTtemp ! !      ELSE ! spinup has converged ! !         spinConv = .TRUE. !         ! Write to screen and log file: !         WRITE(*,'(A33)') ' Spinup has converged - final run' !         WRITE(logn,'(A52)')                                             & !                    ' Spinup has converged - final run - writing all data' !         WRITE(logn,'(A37,F8.5,A28)')                                    & !                    ' Criteria: Change in soil moisture < ',             & !                    delsoilM, ' in any layer over whole run' !         WRITE(logn,'(A40,F8.5,A28)' )                                   & !                    '           Change in soil temperature < ',          & !                    delsoilT, ' in any layer over whole run' !      END IF !   ELSE ! allocate variables for storage ! !     ALLOCATE( soilMtemp(mp,ms), soilTtemp(mp,ms) ) ! !   END IF ! !   ! store soil moisture and temperature !   soilTtemp = ssnow%tgg !   soilMtemp = REAL(ssnow%wb) !ELSE !   ! if not spinning up, or spin up has converged, exit: !   EXIT ! !END IF ! MPI: learn from the master whether it's time to quit CALL MPI_Bcast ( loop_exit , 1 , MPI_LOGICAL , 0 , comm , ierr ) IF ( loop_exit ) THEN EXIT END IF END DO SPINLOOP IF ( icycle > 0 . AND . (. NOT . spincasa ). AND . (. NOT . casaonly )) THEN ! MPI: send casa results back to the master CALL MPI_Send ( MPI_BOTTOM , 1 , casa_t , 0 , ktau_gl , ocomm , ierr ) ! MPI: output file written by master only !CALL casa_poolout( ktau, veg, soil, casabiome,                           & !                   casapool, casaflux, casamet, casabal, phen ) ! MPI: output file written by master only !CALL casa_fluxout( nyear, veg, soil, casabal, casamet) END IF ! Write restart file if requested: IF ( output % restart . AND . (. NOT . CASAONLY )) THEN ! MPI: send variables that are required by create_restart CALL MPI_Send ( MPI_BOTTOM , 1 , restart_t , 0 , ktau_gl , comm , ierr ) ! MPI: output file written by master only IF ( cable_user % CALL_climate ) & CALL MPI_Send ( MPI_BOTTOM , 1 , climate_t , 0 , ktau_gl , comm , ierr ) END IF ! MPI: cleanup CALL worker_end ( icycle , output % restart ) ! MPI: open and close by master only ! Close met data input file: !CALL close_met_file ! MPI: open and close by master only ! Close output file and deallocate main variables: !CALL close_output_file( bal, air, bgc, canopy, met,                         & !                        rad, rough, soil, ssnow,                            & !                        sum_flux, veg ) !WRITE(logn,*) bal%wbal_tot, bal%ebal_tot, bal%ebal_tot_cncheck ! Close log file ! MPI: closes handle to /dev/null in workers CLOSE ( wlogn ) RETURN END SUBROUTINE mpidrv_worker ! ============== PRIVATE SUBROUTINES USED ONLY BY THE MPI WORKERS =============== ! MPI: receives grid decomposition info from the master SUBROUTINE worker_decomp ( comm ) USE mpi USE cable_def_types_mod , ONLY : mland , mp IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm ! MPI communicator to talk to the workers INTEGER :: stat ( MPI_STATUS_SIZE ), ierr ! receive number of landpoints assigned to this worker CALL MPI_Recv ( mland , 1 , MPI_INTEGER , 0 , 0 , comm , stat , ierr ) ! receive number of land patches assigned to this worker CALL MPI_Recv ( mp , 1 , MPI_INTEGER , 0 , 0 , comm , stat , ierr ) RETURN END SUBROUTINE worker_decomp ! MPI: creates param_t type for the worker to receive the default parameters ! from the master process ! then receives the parameters ! and finally frees the MPI type SUBROUTINE worker_cable_params ( comm , met , air , ssnow , veg , bgc , soil , canopy ,& rough , rad , sum_flux , bal ) USE mpi USE cable_def_types_mod USE cable_IO_vars_module USE cable_input_module , ONLY : allocate_cable_vars USE cable_common_module , ONLY : calcsoilalbedo IMPLICIT NONE ! subroutine arguments INTEGER , INTENT ( IN ) :: comm ! MPI communicator TYPE ( met_type ), INTENT ( OUT ) :: met TYPE ( air_type ), INTENT ( OUT ) :: air TYPE ( soil_snow_type ), INTENT ( OUT ) :: ssnow TYPE ( veg_parameter_type ), INTENT ( OUT ) :: veg TYPE ( bgc_pool_type ), INTENT ( OUT ) :: bgc TYPE ( soil_parameter_type ), INTENT ( OUT ) :: soil TYPE ( canopy_type ), INTENT ( OUT ) :: canopy TYPE ( roughness_type ), INTENT ( OUT ) :: rough TYPE ( radiation_type ), INTENT ( OUT ) :: rad TYPE ( sum_flux_type ), INTENT ( OUT ) :: sum_flux TYPE ( balances_type ), INTENT ( OUT ) :: bal ! local vars ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blen INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize INTEGER :: stat ( MPI_STATUS_SIZE ), ierr INTEGER :: landp_t , patch_t , param_t INTEGER :: r1len , r2len , i1len , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank , off , ierr2 , rcount , pos CHARACTER , DIMENSION (:), ALLOCATABLE :: rbuf CALL MPI_Comm_rank ( comm , rank , ierr ) ! mp and mland should have been received previously by ! worker_decomp ! creates types to receive slices of landpt and patch arrays from the master CALL decomp_types ( landp_t , patch_t ) ! Allocate spatial heterogeneity variables: ALLOCATE ( landpt ( mland )) ! and receive own slice from the master CALL MPI_Recv ( landpt , mland , landp_t , 0 , 0 , comm , stat , ierr ) CALL allocate_cable_vars ( air , bgc , canopy , met , bal , rad , rough , soil , ssnow , & sum_flux , veg , mp ) ! receive slice of patch array that was allocated above inside ! allocate_cable_vars CALL MPI_Recv ( patch , mp , patch_t , 0 , 0 , comm , stat , ierr ) ! MPI: TODO: probably not a bad idea to free landp_t and patch_t types ntyp = nparam ! ntyp increases if include ... Ticket #27 IF ( calcsoilalbedo ) THEN ntyp = nparam + 1 END IF ALLOCATE ( blen ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! default type is byte, to be overriden for multi-D types types = MPI_BYTE r1len = mp * extr1 r2len = mp * extr2 i1len = mp * extid llen = mp * extl bidx = 0 ! the order of variables follows argument list ! the order of fields within follows alloc_*_type subroutines ! ----------- met -------------- bidx = bidx + 1 CALL MPI_Get_address ( met % ca , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % year , displs ( bidx ), ierr ) blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( met % moy , displs ( bidx ), ierr ) blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( met % doy , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % hod , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % fsd , displs ( bidx ), ierr ) blen ( bidx ) = swb * r1len bidx = bidx + 1 CALL MPI_Get_address ( met % fld , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % precip , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % precip_sn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % tk , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % tvair , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % tvrad , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % pmb , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % ua , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % qv , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % qvair , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % da , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % dva , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % coszen , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ----------- air -------------- bidx = bidx + 1 CALL MPI_Get_address ( air % rho , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % volm , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % rlam , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % qsat , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % epsi , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % visc , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % psyc , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % dsatdk , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % cmolar , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ----------- ssnow -------------- bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dtmlt , displs ( bidx ), ierr ) blen ( bidx ) = 3 * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % pudsto , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % pudsmx , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % albsoilsn , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % cls , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfn_dtg , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfh_dtg , displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfe_dtg , displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR - no longer needed bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfe_ddq , displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR - no longer needed bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ddq_dtg , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % evapsn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop1 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop2 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop3 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % gammzz , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % isflag , displs ( bidx ), ierr ) blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % osnowd , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % potev , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % pwb_min , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % runoff , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rnof1 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rnof2 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rtsoil , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sconds , displs ( bidx ), ierr ) blen ( bidx ) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sdepth , displs ( bidx ), ierr ) blen ( bidx ) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % smass , displs ( bidx ), ierr ) blen ( bidx ) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snage , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snowd , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % smelt , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ssdn , displs ( bidx ), ierr ) blen ( bidx ) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ssdnn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tgg , displs ( bidx ), ierr ) blen ( bidx ) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tggsn , displs ( bidx ), ierr ) blen ( bidx ) = msn * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tss , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wb , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbfice , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbice , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wblf , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len ! additional  for sli bidx = bidx + 1 CALL MPI_Get_address ( ssnow % S , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % Tsoil , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len !!$ bidx = bidx + 1 CALL MPI_Get_address ( ssnow % thetai , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snowliq , displs ( bidx ), ierr ) blen ( bidx ) = 3 * r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % Tsurface , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % h0 , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % nsnow , displs ( bidx ), ierr ) blen ( bidx ) = I1len ! end additional for sli bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbtot , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wb_lake , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sinfil , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % evapfbl , displs ( bidx ), ierr ) blen ( bidx ) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qstss , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wetfac , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % owetfac , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % t_snwlr , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tggav , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % otss , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % otss_0 , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ----------- veg -------------- bidx = bidx + 1 CALL MPI_Get_address ( veg % canst1 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % dleaf , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % ejmax , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % frac4 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % froot , displs ( bidx ), ierr ) blen ( bidx ) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % hc , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % iveg , displs ( bidx ), ierr ) blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( veg % meth , displs ( bidx ), ierr ) ! Maciej: veg%meth is REAL !    blen(bidx) = i1len blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % rp20 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % rpcoef , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % shelrb , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % wai , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % vegcf , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % tminvj , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % tmaxvj , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % vbeta , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % xalbnir , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % vcmax , displs ( bidx ), ierr ) blen ( bidx ) = r1len !  bidx = bidx + 1 !  CALL MPI_Get_address (veg%vlai, displs(bidx), ierr) !  blen(bidx) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % xfang , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % extkn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % deciduous , displs ( bidx ), ierr ) ! Maciej: deciduous is logical !    blen(bidx) = r1len blen ( bidx ) = llen bidx = bidx + 1 CALL MPI_Get_address ( veg % a1gs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % d0gs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % alpha , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % convex , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % cfrd , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % gswmin , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % conkc0 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % conko0 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % ekc , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % eko , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % clitt , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( veg % zr , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( veg % gamma , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( veg % refl , displs ( bidx ), ierr ) blen ( bidx ) = 2 * r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % taul , displs ( bidx ), ierr ) blen ( bidx ) = 2 * r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % disturbance_interval , displs ( bidx ), ierr ) blen ( bidx ) = 2 * i1len bidx = bidx + 1 CALL MPI_Get_address ( veg % disturbance_intensity , displs ( bidx ), ierr ) ! Maciej: disturbance_intensity is REAL(r_2) !    blen(bidx) = 2 * r1len blen ( bidx ) = 2 * r2len ! Ticket #56, adding new veg parms bidx = bidx + 1 CALL MPI_Get_address ( veg % g0 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % g1 , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! Ticket #56, finish adding new veg parms ! ----------- bgc -------------- bidx = bidx + 1 CALL MPI_Get_address ( bgc % cplant , displs ( bidx ), ierr ) blen ( bidx ) = ncp * r1len bidx = bidx + 1 CALL MPI_Get_address ( bgc % csoil , displs ( bidx ), ierr ) blen ( bidx ) = ncs * r1len bidx = bidx + 1 CALL MPI_Get_address ( bgc % ratecp , displs ( bidx ), ierr ) blen ( bidx ) = ncp * extr1 bidx = bidx + 1 CALL MPI_Get_address ( bgc % ratecs , displs ( bidx ), ierr ) blen ( bidx ) = ncs * extr1 ! ----------- soil -------------- bidx = bidx + 1 CALL MPI_Get_address ( soil % albsoil , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % bch , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % c3 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % clay , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % cnsd , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % css , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % hsbh , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % hyds , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % i2bp3 , displs ( bidx ), ierr ) ! Maciej: i2bp3 is REAL !    blen(bidx) = i1len blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % ibp2 , displs ( bidx ), ierr ) ! Maciej: ibp2 is REAL !    blen(bidx) = i1len blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % isoilm , displs ( bidx ), ierr ) ! Maciej isoilm is INTEGER !    blen(bidx) = r1len blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( soil % rhosoil , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % rs20 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % sand , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % sfc , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % silt , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % ssat , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % sucs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( soil % swilt , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! extra for sli bidx = bidx + 1 CALL MPI_Get_address ( soil % zeta , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % fsatmax , displs ( bidx ), ierr ) blen ( bidx ) = r2len ! end extra for sil bidx = bidx + 1 CALL MPI_Get_address ( soil % zse , displs ( bidx ), ierr ) blen ( bidx ) = ms * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % zshh , displs ( bidx ), ierr ) blen ( bidx ) = ( ms + 1 ) * extr1 ! pass soilcolour albedo as well if including Ticket #27 IF ( calcsoilalbedo ) THEN bidx = bidx + 1 CALL MPI_Get_address ( soil % soilcol , displs ( bidx ), ierr ) blen ( bidx ) = r1len END IF ! ----------- canopy -------------- bidx = bidx + 1 CALL MPI_Get_address ( canopy % fess , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fesp , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % cansto , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % oldcansto , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % cduv , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % delwc , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % dewmm , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % dgdtg , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fe , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fh , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fpn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frp , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpw , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpr , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnee , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frday , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnv , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fev , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevc , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevw , displs ( bidx ), ierr ) blen ( bidx ) = r1len !  bidx = bidx + 1 !  CALL MPI_Get_address (canopy%potev_c, displs(bidx), ierr) !  blen(bidx) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhv , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhvw , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fns , displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR - temporary? bidx = bidx + 1 CALL MPI_Get_address ( canopy % fns_cor , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fes , displs ( bidx ), ierr ) blen ( bidx ) = r2len !INH - REV_CORR - temporary? bidx = bidx + 1 CALL MPI_Get_address ( canopy % fes_cor , displs ( bidx ), ierr ) blen ( bidx ) = r2len !INH - SSEB - temporary? !bidx = bidx + 1 !CALL MPI_Get_address (canopy%fescor_upp, displs(bidx), ierr) !blen(bidx) = r2len !INH - SSEB - temporary? !bidx = bidx + 1 !CALL MPI_Get_address (canopy%fescor_low, displs(bidx), ierr) !blen(bidx) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhs , displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR - temporary? bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhs_cor , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fwet , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % ga , displs ( bidx ), ierr ) blen ( bidx ) = r1len !INH - REV_CORR - temporary? bidx = bidx + 1 CALL MPI_Get_address ( canopy % ga_cor , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % ghflux , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % precis , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % qscrn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % rnet , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % segg , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % sghflux , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % spill , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % through , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % tscrn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % tv , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % us , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % uscrn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % vlaiw , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % rghlai , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % wcint , displs ( bidx ), ierr ) blen ( bidx ) = r1len !  bidx = bidx + 1 !  CALL MPI_Get_address (canopy%rwater, displs(bidx), ierr) !  blen(bidx) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % evapfbl , displs ( bidx ), ierr ) ! MPI: gol124: changed to r1 when Bernard ported to CABLE_r491 blen ( bidx ) = ms * r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % epot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnpp , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevw_pot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % gswx_T , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % cdtq , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % wetfac_cs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fwsoil , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % gswx , displs ( bidx ), ierr ) blen ( bidx ) = mf * r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % zetar , displs ( bidx ), ierr ) blen ( bidx ) = niter * r1len ! ------- rough ------- bidx = bidx + 1 CALL MPI_Get_address ( rough % coexp , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % disp , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % hruff , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % hruff_grmx , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % rt0us , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % rt1usa , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % rt1usb , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % rt1 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % term2 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % term3 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % term5 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % term6 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % usuh , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % za_uv , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % za_tq , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % z0m , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % zref_uv , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % zref_tq , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % zruffs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % z0soilsn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rough % z0soil , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! --------rad -------- bidx = bidx + 1 CALL MPI_Get_address ( rad % albedo , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkb , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkd2 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkd , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % flws , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % fvlai , displs ( bidx ), ierr ) blen ( bidx ) = mf * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % gradis , displs ( bidx ), ierr ) blen ( bidx ) = mf * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % latitude , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % lwabv , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % qcan , displs ( bidx ), ierr ) blen ( bidx ) = mf * nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % qssabs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % rhocdf , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % rniso , displs ( bidx ), ierr ) blen ( bidx ) = mf * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % scalex , displs ( bidx ), ierr ) blen ( bidx ) = mf * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % transd , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % trad , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % reffdf , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % reffbm , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkbm , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % extkdm , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % fbeam , displs ( bidx ), ierr ) blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % cexpkbm , displs ( bidx ), ierr ) ! Maciej: cexpkbm is mp*swb !    blen(bidx) = nrb * r1len blen ( bidx ) = swb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % cexpkdm , displs ( bidx ), ierr ) ! Maciej: cexpkdm is mp*swb !    blen(bidx) = nrb * r1len blen ( bidx ) = swb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % rhocbm , displs ( bidx ), ierr ) ! Maciej: rhocbm is mp*nrb !    blen(bidx) = swb * r1len blen ( bidx ) = nrb * r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % transb , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ------- sum_flux ----- bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumpn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrp , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrpw , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrpr , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumrd , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % dsumpn , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % dsumrp , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % dsumrs , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % dsumrd , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumxrp , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( sum_flux % sumxrs , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! ------- bal ---- bidx = bidx + 1 CALL MPI_Get_address ( bal % drybal , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal_cncheck , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal_tot_cncheck , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % evap_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % osnowd0 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % precip_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % rnoff_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wbal , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wbal_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wbtot0 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wetbal , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % owbtot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % evapc_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % evaps_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % rnof1_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % rnof2_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % snowdc_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % wbal_tot1 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % delwc_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % qasrf_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % qfsrf_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % qssrf_tot , displs ( bidx ), ierr ) blen ( bidx ) = r1len ! additional field missing from previous versions; ! added when trying to fix a bug in the new mpi code ! the order of these new fields follows the order of their ! declaration in cable_define_types.F90 bidx = bidx + 1 CALL MPI_Get_address ( bal % ebaltr , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % ebal_tottr , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( bal % cansto0 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % iantrct , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tss_p , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % deltss , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % owb1 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbtot1 , displs ( bidx ), ierr ) blen ( bidx ) = r1len !    Maciej: duplicate! !    bidx = bidx + 1 !    CALL MPI_Get_address (ssnow%wbtot1, displs(bidx), ierr) !    blen(bidx) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tprecip , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tevap , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % trnoff , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % totenbal , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % totenbal2 , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fland , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ifland , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tilefrac , displs ( bidx ), ierr ) blen ( bidx ) = n_tiles * r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qasrf , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qfsrf , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qssrf , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( veg % vlaimax , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % albedo_T , displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % longitude , displs ( bidx ), ierr ) blen ( bidx ) = r1len !mrd add new GW parameters here !2D bidx = bidx + 1 CALL MPI_Get_address ( soil % ssat_vec , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % sucs_vec , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % hyds_vec , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % bch_vec , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % watr , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % swilt_vec , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % sfc_vec , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len !1d bidx = bidx + 1 CALL MPI_Get_address ( soil % GWssat_vec , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWsucs_vec , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWhyds_vec , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWbch_vec , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWwatr , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWz , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % GWdz , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % slope , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( soil % slope_std , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % GWwb , displs ( bidx ), ierr ) blen ( bidx ) = r2len ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'worker ' , rank , ' invalid number of param_t fields' , bidx , ', fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blen , displs , types , param_t , ierr ) CALL MPI_Type_commit ( param_t , ierr ) CALL MPI_Type_size ( param_t , tsize , ierr ) CALL MPI_Type_get_extent ( param_t , tmplb , text , ierr ) WRITE ( * , * ) 'worker param_t blocks, size, extent and lb: ' , rank , bidx , tsize , text , tmplb ! MPI: check whether total size of received data equals total ! data sent by all the workers CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blen ) ! if anything went wrong the master will mpi_abort ! which mpi_recv below is going to catch... ! so, now receive all the parameters !    CALL MPI_Recv (MPI_BOTTOM, 1, param_t, 0, 0, comm, stat, ierr) !   Maciej: buffered recv + unpac version ALLOCATE ( rbuf ( tsize )) CALL MPI_Recv ( rbuf , tsize , MPI_BYTE , 0 , 0 , comm , stat , ierr ) CALL MPI_Get_count ( stat , param_t , rcount , ierr2 ) IF ( ierr == MPI_SUCCESS . AND . ierr2 == MPI_SUCCESS . AND . rcount == 1 ) THEN pos = 0 CALL MPI_Unpack ( rbuf , tsize , pos , MPI_BOTTOM , rcount , param_t , & comm , ierr ) IF ( ierr /= MPI_SUCCESS ) WRITE ( * , * ), 'cable param unpack error, rank: ' , rank , ierr ELSE WRITE ( * , * ), 'cable param recv rank err err2 rcount: ' , rank , ierr , ierr2 , rcount END IF DEALLOCATE ( rbuf ) ! finally free the MPI type CALL MPI_Type_Free ( param_t , ierr ) ! all CABLE parameters have been received from the master by now RETURN END SUBROUTINE worker_cable_params ! MPI: creates param_t type for the worker to receive the default casa ! parameters from the master process ! then receives them ! and finally frees the MPI type SUBROUTINE worker_casa_params ( comm , casabiome , casapool , casaflux , casamet ,& casabal , phen ) USE mpi USE cable_def_types_mod USE casavariable USE phenvariable IMPLICIT NONE ! sub arguments INTEGER , INTENT ( IN ) :: comm ! MPI communicator ! TODO: have these variables been already allocated? TYPE ( casa_biome ) , INTENT ( OUT ) :: casabiome TYPE ( casa_pool ) , INTENT ( OUT ) :: casapool TYPE ( casa_flux ) , INTENT ( OUT ) :: casaflux TYPE ( casa_met ) , INTENT ( OUT ) :: casamet TYPE ( casa_balance ), INTENT ( OUT ) :: casabal TYPE ( phen_variable ), INTENT ( OUT ) :: phen ! local vars ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blen INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize INTEGER :: stat ( MPI_STATUS_SIZE ), ierr ! INTEGER :: landp_t, patch_t, param_t INTEGER :: casa_t INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank , off , ierr2 , rcount , pos CHARACTER , DIMENSION (:), ALLOCATABLE :: rbuf off = 1 CALL MPI_Comm_rank ( comm , rank , ierr ) IF (. NOT . ASSOCIATED ( casabiome % ivt2 )) THEN WRITE ( * , * ) 'worker alloc casa and phen var with m patches: ' , rank , mp CALL alloc_casavariable ( casabiome , casapool , & & casaflux , casamet , casabal , mp ) CALL alloc_phenvariable ( phen , mp ) END IF ntyp = ncasaparam ALLOCATE ( blen ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! default type is byte, to be overriden for multi-D types types = MPI_BYTE r1len = mp * extr1 r2len = mp * extr2 I1LEN = mp * extid llen = mp * extl bidx = 0 ! ------- casabiome ----- bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ivt2 , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extid bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkleafcoldmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkleafcoldexp , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkleafdrymax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkleafdryexp , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % glaimax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % glaimin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % sla , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratiofrootleaf , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % kroot , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % krootlen , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % rootdepth , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % kuptake , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % kminN , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % KuplabP , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % kclabrate , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 !=================================================================== bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xnpmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % q10soil , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkoptlitter , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkoptsoil , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % maxfinelitter , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % maxcwd , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % prodptase , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % costnpup , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkplab , displs ( bidx ), ierr ) blen ( bidx ) = mso * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkpsorb , displs ( bidx ), ierr ) blen ( bidx ) = mso * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % xkpocc , displs ( bidx ), ierr ) blen ( bidx ) = mso * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % nintercept , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % nslope , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 !=================================================================== bidx = bidx + 1 CALL MPI_Get_address ( casabiome % plantrate , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % rmplant , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % fracnpptoP , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % fraclignin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % fraclabile , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioNCplantmin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioNCplantmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioPCplantmin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioPCplantmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % fracLigninplant , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ftransNPtoL , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ftransPPtoL , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % litterrate , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mlitter * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % soilrate , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * msoil * extr2 ! added by ln bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioNPplantmin , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 bidx = bidx + 1 CALL MPI_Get_address ( casabiome % ratioNPplantmax , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * mplant * extr2 ! ------ casapool ---- bidx = bidx + 1 CALL MPI_Get_address ( casapool % Clabile , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dClabiledt , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Cplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Pplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dCplantdt , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dNplantdt , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPplantdt , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPCplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nsoilmin , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Psoillab , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Psoilsorb , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Psoilocc , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dNsoilmindt , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPsoillabdt , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPsoilsorbdt , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPsoiloccdt , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Clitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nlitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Plitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dClitterdt , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dNlitterdt , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPlitterdt , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNClitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPClitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Csoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nsoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Psoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dCsoildt , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dNsoildt , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % dPsoildt , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPCsoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoilnew , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoilmin , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoilmax , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len ! added by LN bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNPplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNPlitter , displs ( bidx ), ierr ) !    blen(bidx) = mplant * r2len ! Maciej blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNPsoil , displs ( bidx ), ierr ) !    blen(bidx) = mplant * r2len ! Maciej blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % cwoodprod , displs ( bidx ), ierr ) blen ( bidx ) = mwood * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % nwoodprod , displs ( bidx ), ierr ) blen ( bidx ) = mwood * r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % pwoodprod , displs ( bidx ), ierr ) blen ( bidx ) = mwood * r2len ! ------- casaflux ---- bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cgpp , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cnpp , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crp , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crgplant , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminfix , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminuptake , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Plabuptake , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Clabloss , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracClabile , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracCalloc , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracNalloc , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracPalloc , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crmplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromPtoL , displs ( bidx ), ierr ) blen ( bidx ) = mplant * mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cnep , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crsoil , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nmindep , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminloss , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminleach , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nupland , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nlittermin , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsmin , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsimm , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsnet , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fNminloss , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fNminleach , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Pdep , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Pwea , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Pleach , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Ploss , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Pupland , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Plittermin , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Psmin , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Psimm , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Psnet , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fPleach , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kplab , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kpsorb , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kpocc , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kmlabP , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Psorbmax , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % frac_sapwood , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % sapwood_area , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % klitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % ksoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromLtoS , displs ( bidx ), ierr ) blen ( bidx ) = msoil * mlitter * r2len ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromStoS , displs ( bidx ), ierr ) blen ( bidx ) = msoil * msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromLtoCO2 , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromStoCO2 , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtolitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxNtolitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxPtolitter , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtosoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxNtosoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxPtosoil , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtoCO2 , displs ( bidx ), ierr ) blen ( bidx ) = r2len ! ------- casamet ---- bidx = bidx + 1 CALL MPI_Get_address ( casamet % glai , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % Tairk , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % precip , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % tsoilavg , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % moistavg , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % btran , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % lnonwood , displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( casamet % Tsoil , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % moist , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % iveg2 , displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( casamet % ijgcm , displs ( bidx ), ierr ) ! Maciej: ijgcm is INTEGER blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( casamet % isorder , displs ( bidx ), ierr ) ! Maciej: isorder is INTEGER blen ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( casamet % lat , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % lon , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % areacell , displs ( bidx ), ierr ) blen ( bidx ) = r2len ! ------- casabal ---- bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCgppyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCnppyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmleafyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmwoodyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmrootyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrgrowyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrpyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrsyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCneeyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNdepyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNfixyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNsnetyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNupyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNleachyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNlossyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPweayear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPdustyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPsnetyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPupyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPleachyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPlossyear , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % glaimon , displs ( bidx ), ierr ) blen ( bidx ) = 12 * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % glaimonx , displs ( bidx ), ierr ) blen ( bidx ) = 12 * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % cplantlast , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nplantlast , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % pplantlast , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % clitterlast , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nlitterlast , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % plitterlast , displs ( bidx ), ierr ) blen ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % csoillast , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nsoillast , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % psoillast , displs ( bidx ), ierr ) blen ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nsoilminlast , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % psoillablast , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % psoilsorblast , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % psoilocclast , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % cbalance , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % nbalance , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % pbalance , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumcbal , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumnbal , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumpbal , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % clabilelast , displs ( bidx ), ierr ) blen ( bidx ) = r2len ! ------- phen ------- bidx = bidx + 1 CALL MPI_Get_address ( phen % phase , displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % TKshed , displs ( bidx ), ierr ) blen ( bidx ) = mvtype * extr2 bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphase , displs ( bidx ), ierr ) blen ( bidx ) = mphase * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % phen ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( phen % aphen ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( phen % phasespin ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_1 ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_2 ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_3 ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_4 ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = mdyear * I1LEN ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'worker ' , rank , ' invalid number of casa_t param fields ' , bidx , ', fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blen , displs , types , casa_t , ierr ) CALL MPI_Type_commit ( casa_t , ierr ) CALL MPI_Type_size ( casa_t , tsize , ierr ) CALL MPI_Type_get_extent ( casa_t , tmplb , text , ierr ) WRITE ( * , * ) 'worker casa_t param blocks, size, extent and lb: ' , rank , bidx , tsize , text , tmplb ! MPI: check whether total size of received data equals total ! data sent by all the workers CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blen ) ! if anything went wrong the master will mpi_abort ! which mpi_recv below is going to catch... CALL MPI_Barrier ( comm , ierr ) ! so, now receive all the parameters !    CALL MPI_Recv (MPI_BOTTOM, 1, casa_t, 0, 0, comm, stat, ierr) !   Maciej: buffered recv + unpac version ALLOCATE ( rbuf ( tsize )) CALL MPI_Recv ( rbuf , tsize , MPI_BYTE , 0 , 0 , comm , stat , ierr ) CALL MPI_Get_count ( stat , casa_t , rcount , ierr2 ) IF ( ierr == MPI_SUCCESS . AND . ierr2 == MPI_SUCCESS . AND . rcount == 1 ) THEN pos = 0 CALL MPI_Unpack ( rbuf , tsize , pos , MPI_BOTTOM , rcount , casa_t , & comm , ierr ) IF ( ierr /= MPI_SUCCESS ) WRITE ( * , * ), 'casa params unpack error, rank: ' , rank , ierr ELSE WRITE ( * , * ), 'casa params recv rank err err2 rcount: ' , rank , ierr , ierr2 , rcount END IF DEALLOCATE ( rbuf ) ! finally free the MPI type CALL MPI_Type_Free ( casa_t , ierr ) ! all casa parameters have been received from the master by now RETURN END SUBROUTINE worker_casa_params ! MPI: creates inp_t type to receive input data from the master SUBROUTINE worker_intype ( comm , met , veg ) USE mpi USE cable_def_types_mod IMPLICIT NONE ! Arguments INTEGER , INTENT ( IN ) :: comm TYPE ( met_type ), INTENT ( IN ) :: met ! meteorological data TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! LAI retrieved from file ! Local variables ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: ierr INTEGER :: rank CALL MPI_Comm_rank ( comm , rank , ierr ) r1len = mp * extr1 r2len = mp * extr2 I1LEN = mp * extid llen = mp * extl ! max total number of fields to receive: met + veg fields ! ntyp = 10 + 1 ntyp = ninput ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! met fields ! TODO: don't add optional field when not required ! (exists% flags) bidx = 0 bidx = bidx + 1 CALL MPI_Get_address ( met % fsd , displs ( bidx ), ierr ) blocks ( bidx ) = swb * r1len bidx = bidx + 1 CALL MPI_Get_address ( met % tk , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % pmb , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % qv , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % ua , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % precip , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % precip_sn , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % fld , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % ca , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % coszen , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % Ndep , displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! veg fields bidx = bidx + 1 CALL MPI_Get_address ( veg % vlai , displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! additional field missing from previous versions; ! added when trying to fix a bug in the new mpi code ! the order of these new fields follows the order of their ! declaration in cable_define_types.F90 bidx = bidx + 1 CALL MPI_Get_address ( met % year , displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( met % moy , displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( met % doy , displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( met % hod , displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'worker ' , rank , ': invalid intype nmat, nvec or n3d constant, fix it!' WRITE ( * , * ) 'bidx: ' , bidx WRITE ( * , * ) 'nvec: ' , nvec WRITE ( * , * ) 'n3d:' , n3d WRITE ( * , * ) 'ntyp' , ntyp CALL MPI_Abort ( comm , 1 , ierr ) END IF ! marshall all fields into a single MPI derived datatype ! all variables are contiguous blocks of memory so just send them ! as blocks of bytes types = MPI_BYTE CALL MPI_Type_create_struct ( bidx , blocks , displs , types , inp_t , ierr ) CALL MPI_Type_commit ( inp_t , ierr ) CALL MPI_Type_size ( inp_t , tsize , ierr ) CALL MPI_Type_get_extent ( inp_t , tmplb , text , ierr ) WRITE ( * , * ) 'worker ' , rank , ': intype struct blocks, size, extent and lb: ' , & bidx , tsize , text , tmplb ! MPI: check whether total size of received data equals total ! data sent by all the workers CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE worker_intype ! MPI: creates send_t type to send the results to the master ! ! list of fields that master needs to receive for use in write_output: ! ! air%          rlam ! ! canopy%       delwc, fe, fev, fh, fhs, fhv, fevw, fevc, fes, fnee, fpn, frday, !               frp, frs, ga, through, spill, tv, cansto, ! ! met%          precip, precip_sn, fld, fsd, tk, pmb, qv, ua, ca, ! ! rad%          albedo, qcan, qssabs, transd, flws ! ! soil%         zse, ! ! ssnow%        wb, snowd, osnowd, runoff, cls, rnof1, rnof2, tgg, tggsn, sdepth, isflag ! ! veg%          vlai ! ! Total: 47 SUBROUTINE worker_outtype ( comm , met , canopy , ssnow , rad , bal , air , soil , veg ) USE mpi USE cable_def_types_mod IMPLICIT NONE INTEGER :: comm ! MPI communicator to talk to the workers TYPE ( met_type ), INTENT ( IN ) :: met TYPE ( canopy_type ), INTENT ( IN ) :: canopy TYPE ( soil_snow_type ), INTENT ( IN ) :: ssnow TYPE ( radiation_type ), INTENT ( IN ) :: rad TYPE ( balances_type ), INTENT ( INOUT ) :: bal TYPE ( air_type ), INTENT ( IN ) :: air TYPE ( soil_parameter_type ), INTENT ( IN ) :: soil ! soil parameters TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg ! vegetation parameters ! MPI: temp arrays for marshalling all types into a struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types INTEGER :: ntyp ! number of worker's types ! MPI: block lengths and strides for hvector representing matrices INTEGER :: r1len , r2len , I1LEN , llen INTEGER :: rank , off , cnt INTEGER :: bidx , midx , vidx , ierr INTEGER :: tsize INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb ! base index to make types indexing easier INTEGER :: istart INTEGER :: i CALL MPI_Comm_rank ( comm , rank , ierr ) ! MPI: calculate the sizes/extents of Fortran types used by ! CABLE CALL find_extents ! MPI: allocate temp vectors used for marshalling ntyp = n3d + nmat + nvec ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! MPI: should work because worker versions of CABLE variables ! are allocated with starting index set to patch0 !off = wpatch%patch0 !cnt = wpatch%npatch ! MPI: new version, all arrays indices run 1:mp off = 1 cnt = mp r1len = cnt * extr1 r2len = cnt * extr2 I1LEN = cnt * extid llen = cnt * extl ! ------------- 3D arrays ------------- ! rad 3D ! TODO: REAL(r_1) : rad%qcan(landunits,mf,nrb) ! CALL MPI_Type_create_hvector (mf*nrb, r1len, r1stride, MPI_BYTE, & !  &            m3d_t(1, rank), ierr) bidx = 1 CALL MPI_Get_address ( rad % qcan ( off , 1 , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * mf * nrb ! ------------- 2D arrays ------------- ! MPI: an hvector type for each vector, maddr contains displacements ! for bundling these hvectors into the struct later ! block length is number of patches/worker * type extent ! stride is global number of patches * type extent ! repeat/no of blocks is the 2nd rank ! met 2D bidx = bidx + 1 CALL MPI_Get_address ( met % fsd ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * swb ! canopy 2D !midx = 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%rwater(off,1), maddr(midx), ierr) ! 1 !CALL MPI_Type_create_hvector (ms, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) ! TODO: skip, used for restart but not output !  bidx = bidx + 1 !  CALL MPI_Get_address (canopy%rwater(off,1), displs(bidx), ierr) !  blocks(bidx) = r1len * ms ! midx = midx + 1 ! REAL(r_2) ! CALL MPI_Get_address (canopy%evapfbl(off,1), maddr(midx), ierr) ! 2 !CALL MPI_Type_create_hvector (ms, r2len, r2stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( canopy % evapfbl ( off , 1 ), displs ( bidx ), ierr ) ! MPI: gol124: changed to r1 when Bernard ported to CABLE_r491 blocks ( bidx ) = r1len * ms bidx = bidx + 1 CALL MPI_Get_address ( canopy % gswx ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * mf bidx = bidx + 1 CALL MPI_Get_address ( canopy % zetar ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * niter ! ssnow 2D bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dtmlt ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * 3 !midx = midx + 1 ! REAL(r_1) ! CALL MPI_Get_address (ssnow%albsoilsn(off,1), maddr(midx), ierr) ! 3 ! CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) !midx = midx + 1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % albsoilsn ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb ! REAL(r_2) !CALL MPI_Get_address (ssnow%gammzz(off,1), maddr(midx), ierr) ! 4 !CALL MPI_Type_create_hvector (ms, r2len, r2stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % gammzz ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * ms !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%sconds(off,1), maddr(midx), ierr) ! 5 !CALL MPI_Type_create_hvector (msn, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sconds ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * msn !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%sdepth(off,1), maddr(midx), ierr) ! 6 !CALL MPI_Type_create_hvector (msn, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sdepth ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * msn !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%smass(off,1), maddr(midx), ierr) ! 7 !CALL MPI_Type_create_hvector (msn, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % smass ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * msn !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%dtmlt(off,1), maddr(midx), ierr) ! 8 !CALL MPI_Type_create_hvector (msn, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) ! MPI: r1134 does not know about this field, comment out !bidx = bidx + 1 !CALL MPI_Get_address (ssnow%dtmlt(off,1), displs(bidx), ierr) !blocks(bidx) = r1len * msn !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%ssdn(off,1), maddr(midx), ierr) ! 9 !CALL MPI_Type_create_hvector (msn, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ssdn ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * msn !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%tgg(off,1), maddr(midx), ierr) ! 10 !CALL MPI_Type_create_hvector (ms, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tgg ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * ms !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%tggsn(off,1), maddr(midx), ierr) ! 11 !CALL MPI_Type_create_hvector (msn, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tggsn ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * msn !midx = midx + 1 ! REAL(r_2) !CALL MPI_Get_address (ssnow%wb(off,1), maddr(midx), ierr) ! 12 !CALL MPI_Type_create_hvector (ms, r2len, r2stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wb ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * ms bidx = bidx + 1 CALL MPI_Get_address ( ssnow % evapfbl ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * ms !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%wbfice(off,1), maddr(midx), ierr) ! 13 !CALL MPI_Type_create_hvector (ms, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbfice ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * ms !midx = midx + 1 ! REAL(r_2) !CALL MPI_Get_address (ssnow%wbice(off,1), maddr(midx), ierr) ! 14 !CALL MPI_Type_create_hvector (ms, r2len, r2stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbice ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * ms !midx = midx + 1 ! REAL(r_2) !CALL MPI_Get_address (ssnow%wblf(off,1), maddr(midx), ierr) ! 15 !CALL MPI_Type_create_hvector (ms, r2len, r2stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wblf ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * ms ! additional  for sli bidx = bidx + 1 CALL MPI_Get_address ( ssnow % S ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * ms bidx = bidx + 1 CALL MPI_Get_address ( ssnow % Tsoil ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * ms bidx = bidx + 1 CALL MPI_Get_address ( ssnow % thetai ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * ms bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snowliq ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * 3 ! end additional for sli ! rad 2D bidx = bidx + 1 CALL MPI_Get_address ( rad % fbeam ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%albedo(off,1), maddr(midx), ierr) ! 16 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % albedo ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%fvlai(off,1), maddr(midx), ierr) ! 17 !CALL MPI_Type_create_hvector (mf, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % fvlai ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * mf !midx = midx + 1 ! REAL(r_2) !CALL MPI_Get_address (rad%gradis(off,1), maddr(midx), ierr) ! 18 !CALL MPI_Type_create_hvector (mf, r2len, r2stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % gradis ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * mf !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%rhocdf(off,1), maddr(midx), ierr) ! 19 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % rhocdf ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%rniso(off,1), maddr(midx), ierr) ! 20 !CALL MPI_Type_create_hvector (mf, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % rniso ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * mf !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%scalex(off,1), maddr(midx), ierr) ! 21 !CALL MPI_Type_create_hvector (mf, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % scalex ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * mf !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%reffdf(off,1), maddr(midx), ierr) ! 22 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % reffdf ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%reffbm(off,1), maddr(midx), ierr) ! 23 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % reffbm ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%extkbm(off,1), maddr(midx), ierr) ! 24 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % extkbm ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%extkdm(off,1), maddr(midx), ierr) ! 25 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % extkdm ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%cexpkbm(off,1), maddr(midx), ierr) ! 26 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % cexpkbm ( off , 1 ), displs ( bidx ), ierr ) ! Maciej: cexpkbm is mp*swb !    blocks(bidx) = r1len * nrb blocks ( bidx ) = r1len * swb !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%cexpkdm(off,1), maddr(midx), ierr) ! 27 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( rad % cexpkdm ( off , 1 ), displs ( bidx ), ierr ) ! Maciej: cexpkdm is mp*swb !    blocks(bidx) = r1len * nrb blocks ( bidx ) = r1len * swb bidx = bidx + 1 CALL MPI_Get_address ( rad % rhocbm ( off , 1 ), displs ( bidx ), ierr ) ! Maciej: rhocbm is mp*nrb !    blocks(bidx) = r1len * swb blocks ( bidx ) = r1len * nrb ! air 2D - all fields 1D - skipped ! soil 2D !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%albsoil(off,1), maddr(midx), ierr) ! 28 !CALL MPI_Type_create_hvector (nrb, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( soil % albsoil ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * nrb ! veg 2D bidx = bidx + 1 CALL MPI_Get_address ( veg % refl ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * 2 bidx = bidx + 1 CALL MPI_Get_address ( veg % taul ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * 2 !midx = midx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%froot(off,1), maddr(midx), ierr) ! 29 !CALL MPI_Type_create_hvector (ms, r1len, r1stride, MPI_BYTE, & !  &            mat_t(midx, rank), ierr) bidx = bidx + 1 CALL MPI_Get_address ( veg % froot ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len * ms ! ------------- 1D arrays ------------- ! met !vidx = 1 ! REAL(r_1) !CALL MPI_Get_address (met%ca(off), vaddr(vidx), ierr) ! 1 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % ca ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (met%year(off), vaddr(vidx), ierr) ! 2 !blen(vidx) = cnt * extid ! gol124: not output, removed !bidx = bidx + 1 !CALL MPI_Get_address (met%year(off), displs(bidx), ierr) !blocks(bidx) = I1LEN !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (met%moy(off), vaddr(vidx), ierr) ! 3 !blen(vidx) = cnt * extid ! gol124: not output, removed !bidx = bidx + 1 !CALL MPI_Get_address (met%moy(off), displs(bidx), ierr) !blocks(bidx) = I1LEN !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%doy(off), vaddr(vidx), ierr) ! 4 !blen(vidx) = cnt * extr1 ! gol124: not output, removed !bidx = bidx + 1 !CALL MPI_Get_address (met%doy(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%hod(off), vaddr(vidx), ierr) ! 5 !blen(vidx) = cnt * extr1 ! gol124: not output, removed !bidx = bidx + 1 !CALL MPI_Get_address (met%hod(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%fsd(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 ! MPI: gol124: changed to 2D and move up when Bernard ! ported to CABLE_r491 !bidx = bidx + 1 !CALL MPI_Get_address (met%fsd(off,1), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%fld(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % fld ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%precip(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % precip ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%precip_sn(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % precip_sn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%tk(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % tk ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%tvair(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % tvair ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%tvrad(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % tvrad ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%pmb(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % pmb ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%ua(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % ua ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%qv(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % qv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%qvair(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % qvair ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%da(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % da ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%dva(off), vaddr(vidx), ierr) !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % dva ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (met%coszen(off), vaddr(vidx), ierr) ! 19 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( met % coszen ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! canopy bidx = bidx + 1 CALL MPI_Get_address ( canopy % fess ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fesp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%cansto(off), vaddr(vidx), ierr) ! 20 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % cansto ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%cduv(off), vaddr(vidx), ierr) ! 21 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( canopy % cduv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%delwc(off), vaddr(vidx), ierr) ! 22 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % delwc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%dewmm(off), vaddr(vidx), ierr) ! 23 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( canopy % dewmm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_2) !CALL MPI_Get_address (canopy%dgdtg(off), vaddr(vidx), ierr) ! 24 !blen(vidx) = cnt * extr2 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( canopy % dgdtg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fe(off), vaddr(vidx), ierr) ! 25 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fe ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fh(off), vaddr(vidx), ierr) ! 26 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fh ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fpn(off), vaddr(vidx), ierr) ! 27 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fpn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%frp(off), vaddr(vidx), ierr) ! 28 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % frp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%frpw(off), vaddr(vidx), ierr) ! 29 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpw ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%frpr(off), vaddr(vidx), ierr) ! 30 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpr ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%frs(off), vaddr(vidx), ierr) ! 31 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % frs ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fnee(off), vaddr(vidx), ierr) ! 32 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnee ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%frday(off), vaddr(vidx), ierr) ! 33 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % frday ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fnv(off), vaddr(vidx), ierr) ! 34 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! gol124: MPI: DONE until here!!! !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fev(off), vaddr(vidx), ierr) ! 35 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fev ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_2) !CALL MPI_Get_address (canopy%fevc(off), vaddr(vidx), ierr) ! 36 !blen(vidx) = cnt * extr2 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !vidx = vidx + 1 ! REAL(r_2) !CALL MPI_Get_address (canopy%fevw(off), vaddr(vidx), ierr) ! 37 !blen(vidx) = cnt * extr2 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevw ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_2) !CALL MPI_Get_address (canopy%potev_c(off), vaddr(vidx), ierr) ! 38 !blen(vidx) = cnt * extr2 !  bidx = bidx + 1 !  CALL MPI_Get_address (canopy%potev_c(off), displs(bidx), ierr) !  blocks(bidx) = r2len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fhv(off), vaddr(vidx), ierr) ! 39 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_2) !CALL MPI_Get_address (canopy%fhvw(off), vaddr(vidx), ierr) ! 40 !blen(vidx) = cnt * extr2 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhvw ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fns(off), vaddr(vidx), ierr) ! 41 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fns ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fns_cor ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fes(off), vaddr(vidx), ierr) ! 42 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fes ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fes_cor ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fhs(off), vaddr(vidx), ierr) ! 43 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhs ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fhs_cor ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%fwet(off), vaddr(vidx), ierr) ! 44 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % fwet ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % epot ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnpp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fevw_pot ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % gswx_T ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % cdtq ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % wetfac_cs ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%ga(off), vaddr(vidx), ierr) ! 45 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % ga ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % ga_cor ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%ghflux(off), vaddr(vidx), ierr) ! 46 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % ghflux ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%precis(off), vaddr(vidx), ierr) ! 47 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % precis ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%qscrn(off), vaddr(vidx), ierr) ! 48 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % qscrn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%rnet(off), vaddr(vidx), ierr) ! 49 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % rnet ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%segg(off), vaddr(vidx), ierr) ! 50 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % segg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%sghflux(off), vaddr(vidx), ierr) ! 51 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % sghflux ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%spill(off), vaddr(vidx), ierr) ! 52 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % spill ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%through(off), vaddr(vidx), ierr) ! 53 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % through ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%tscrn(off), vaddr(vidx), ierr) ! 54 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % tscrn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%tv(off), vaddr(vidx), ierr) ! 55 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % tv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%us(off), vaddr(vidx), ierr) ! 56 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % us ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%uscrn(off), vaddr(vidx), ierr) ! 57 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % uscrn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%vlaiw(off), vaddr(vidx), ierr) ! 58 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % vlaiw ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % rghlai ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (canopy%wcint(off), vaddr(vidx), ierr) ! 59 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( canopy % wcint ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fwsoil ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len ! MPI: 2D vars moved above ! rwater ! evapfbl ! ssnow ! MPI: 2D vars moved above ! albsoilsn bidx = bidx + 1 CALL MPI_Get_address ( ssnow % pudsto ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % pudsmx ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%cls(off), vaddr(vidx), ierr) ! 60 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % cls ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%dfn_dtg(off), vaddr(vidx), ierr) ! 61 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfn_dtg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%dfh_dtg(off), vaddr(vidx), ierr) ! 62 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfh_dtg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfe_ddq ( off ), displs ( bidx ), ierr ) ! +1 blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % dfe_dtg ( off ), displs ( bidx ), ierr ) ! +1 blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%ddq_dtg(off), vaddr(vidx), ierr) ! 63 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ddq_dtg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%evapsn(off), vaddr(vidx), ierr) ! 64 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % evapsn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%fwtop(off), vaddr(vidx), ierr) ! 65 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop1 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop2 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % fwtop3 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 2D vars moved above ! gammzz !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (ssnow%isflag(off), vaddr(vidx), ierr) ! 66 !blen(vidx) = cnt * extid bidx = bidx + 1 CALL MPI_Get_address ( ssnow % isflag ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%osnowd(off), vaddr(vidx), ierr) ! 67 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % osnowd ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%potev(off), vaddr(vidx), ierr) ! 68 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % potev ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_2) !CALL MPI_Get_address (soil%pwb_min(off), vaddr(vidx), ierr) ! 69 !blen(vidx) = cnt * extr2 bidx = bidx + 1 CALL MPI_Get_address ( soil % pwb_min ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%runoff(off), vaddr(vidx), ierr) ! 70 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % runoff ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%rnof1(off), vaddr(vidx), ierr) ! 71 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rnof1 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%rnof2(off), vaddr(vidx), ierr) ! 72 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rnof2 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%rtsoil(off), vaddr(vidx), ierr) ! 73 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % rtsoil ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 2D vars moved above ! sconds ! sdepth ! smass !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%snage(off), vaddr(vidx), ierr) ! 74 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snage ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%snowd(off), vaddr(vidx), ierr) ! 75 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % snowd ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%smelt(off), vaddr(vidx), ierr) ! 76 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % smelt ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 2D vars moved above ! dtmlt ! ssdn !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%ssdnn(off), vaddr(vidx), ierr) ! 77 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % ssdnn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 2D vars moved above ! tgg ! tggsn !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%tss(off), vaddr(vidx), ierr) ! 78 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tss ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%otss(off), vaddr(vidx), ierr) ! 79 !blen(vidx) = cnt * extr1 ! MPI: r1134 does not know about this field, comment out !bidx = bidx + 1 !CALL MPI_Get_address (ssnow%otss(off), displs(bidx), ierr) !blocks(bidx) = r1len ! MPI: 2D vars moved above ! wb ! wbfice ! wbice ! wblf !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%wbtot(off), vaddr(vidx), ierr) ! 90 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wbtot ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wb_lake ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % sinfil ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % qstss ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (ssnow%wetfac(off), vaddr(vidx), ierr) ! 91 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wetfac ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) ! MPI: TODO: maybe not needed for transfer to master? !CALL MPI_Get_address (ssnow%owetfac(off), vaddr(vidx), ierr) ! 92 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( ssnow % owetfac ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % t_snwlr ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % tggav ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % otss ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % otss_0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! rad ! MPI: 2D vars moved above ! albedo !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%extkb(off), vaddr(vidx), ierr) ! 93 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % extkb ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%extkd2(off), vaddr(vidx), ierr) ! 94 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % extkd2 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%extkd(off), vaddr(vidx), ierr) ! 95 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % extkd ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%flws(off), vaddr(vidx), ierr) ! 96 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % flws ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 2D vars moved above ! fvlai ! gradis !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%latitude(off), vaddr(vidx), ierr) ! 97 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % latitude ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%lwabv(off), vaddr(vidx), ierr) !98 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % lwabv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 3D vars moved above ! qcan !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%qssabs(off), vaddr(vidx), ierr) !99 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % qssabs ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 2D vars moved above ! rhocdf ! rniso ! scalex !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%transd(off), vaddr(vidx), ierr) ! 100 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % transd ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%trad(off), vaddr(vidx), ierr) ! 101 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( rad % trad ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( rad % transb ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 2D vars moved above ! reffdf ! reffbm ! extkbm ! extkdm !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (rad%fbeam(off), vaddr(vidx), ierr) ! 102 !blen(vidx) = cnt * extr1 ! MPI: gol124: changed to 2D and moved up when Bernard ! ported to CABLE_r491 !bidx = bidx + 1 !CALL MPI_Get_address (rad%fbeam(off,1), displs(bidx), ierr) !blocks(bidx) = r1len ! MPI: 2D vars moved above ! cexpkbm ! cexpkdm ! bal !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%drybal(off), vaddr(vidx), ierr) ! 103 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( bal % drybal ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%ebal(off), vaddr(vidx), ierr) ! 104 !blen(vidx) = cnt * extr1 ! MPI: remove ebal from exchanged data, calculate temp val on the master !bidx = bidx + 1 !CALL MPI_Get_address (bal%ebal(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%ebal_tot(off), vaddr(vidx), ierr) ! 105 !blen(vidx) = cnt * extr1 ! MPI: remove ebal_tot from exchanged data, calculate val on the master !bidx = bidx + 1 !CALL MPI_Get_address (bal%ebal_tot(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%seb(off), vaddr(vidx), ierr) ! 106 !blen(vidx) = cnt * extr1 ! MPI: remove seb from exchanged data, calculate temp val on the master !bidx = bidx + 1 !CALL MPI_Get_address (bal%seb(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%seb_tot(off), vaddr(vidx), ierr) ! 107 !blen(vidx) = cnt * extr1 ! MPI: remove seb_tot from exchanged data, calculate val on the master !bidx = bidx + 1 !CALL MPI_Get_address (bal%seb_tot(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%evap_tot(off), vaddr(vidx), ierr) ! 108 !blen(vidx) = cnt * extr1 ! MPI: remove evap_tot from exchanged data !bidx = bidx + 1 !CALL MPI_Get_address (bal%evap_tot(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%osnowd0(off), vaddr(vidx), ierr) ! 109 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( bal % osnowd0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%precip_tot(off), vaddr(vidx), ierr) ! 110 !blen(vidx) = cnt * extr1 ! MPI: remove wbal from exchanged data !bidx = bidx + 1 !CALL MPI_Get_address (bal%precip_tot(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%rnoff_tot(off), vaddr(vidx), ierr) ! 111 !blen(vidx) = cnt * extr1 ! MPI: remove wbal from exchanged data !bidx = bidx + 1 !CALL MPI_Get_address (bal%rnoff_tot(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%wbal(off), vaddr(vidx), ierr) ! 112 !blen(vidx) = cnt * extr1 ! MPI: remove wbal from exchanged data ! bidx = bidx + 1 ! CALL MPI_Get_address (bal%wbal(off), displs(bidx), ierr) ! blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%wbal_tot(off), vaddr(vidx), ierr) ! 113 !blen(vidx) = cnt * extr1 ! MPI: remove wbal_tot from exchanged data !bidx = bidx + 1 !CALL MPI_Get_address (bal%wbal_tot(off), displs(bidx), ierr) !blocks(bidx) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%wbtot0(off), vaddr(vidx), ierr) ! 114 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( bal % wbtot0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (bal%wetbal(off), vaddr(vidx), ierr) ! 115 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( bal % wetbal ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! air !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%rho(off), vaddr(vidx), ierr) ! 116 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( air % rho ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%volm(off), vaddr(vidx), ierr) ! 117 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( air % volm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%rlam(off), vaddr(vidx), ierr) ! 118 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( air % rlam ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%qsat(off), vaddr(vidx), ierr) ! 119 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( air % qsat ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%epsi(off), vaddr(vidx), ierr) ! 120 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( air % epsi ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%visc(off), vaddr(vidx), ierr) ! 121 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( air % visc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%psyc(off), vaddr(vidx), ierr) ! 122 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( air % psyc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%dsatdk(off), vaddr(vidx), ierr) ! 123 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( air % dsatdk ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (air%cmolar(off), vaddr(vidx), ierr) ! 124 !blen(vidx) = cnt * extr1 ! TODO: skip, used for restart but not output bidx = bidx + 1 CALL MPI_Get_address ( air % cmolar ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! soil ! MPI: 2D vars moved above ! albsoil !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%bch(off), vaddr(vidx), ierr) ! 125 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % bch ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%c3(off), vaddr(vidx), ierr) ! 126 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % c3 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%clay(off), vaddr(vidx), ierr) ! 127 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % clay ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%cnsd(off), vaddr(vidx), ierr) ! 128 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % cnsd ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%css(off), vaddr(vidx), ierr) ! 129 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % css ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%hsbh(off), vaddr(vidx), ierr) ! 130 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % hsbh ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%hyds(off), vaddr(vidx), ierr) ! 131 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % hyds ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (soil%i2bp3(off), vaddr(vidx), ierr) ! 132 !blen(vidx) = cnt * extid bidx = bidx + 1 CALL MPI_Get_address ( soil % i2bp3 ( off ), displs ( bidx ), ierr ) ! Maciej: i2bp3 is REAL !    blocks(bidx) = I1LEN blocks ( bidx ) = R1LEN !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (soil%ibp2(off), vaddr(vidx), ierr) ! 133 !blen(vidx) = cnt * extid bidx = bidx + 1 CALL MPI_Get_address ( soil % ibp2 ( off ), displs ( bidx ), ierr ) ! Maciej: ibp2 is REAL !    blocks(bidx) = I1LEN blocks ( bidx ) = R1LEN !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (soil%isoilm(off), vaddr(vidx), ierr) ! 134 !blen(vidx) = cnt * extid bidx = bidx + 1 CALL MPI_Get_address ( soil % isoilm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%rhosoil(off), vaddr(vidx), ierr) ! 135 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % rhosoil ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%rs20(off), vaddr(vidx), ierr) ! 136 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % rs20 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%sand(off), vaddr(vidx), ierr) ! 137 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % sand ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%sfc(off), vaddr(vidx), ierr) ! 138 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % sfc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%silt(off), vaddr(vidx), ierr) ! 139 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % silt ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%ssat(off), vaddr(vidx), ierr) ! 140 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % ssat ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%sucs(off), vaddr(vidx), ierr) ! 141 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % sucs ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (soil%swilt(off), vaddr(vidx), ierr) ! 142 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( soil % swilt ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! veg !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (veg%iveg(off), vaddr(vidx), ierr) ! 143 !blen(vidx) = cnt * extid bidx = bidx + 1 CALL MPI_Get_address ( veg % iveg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN !vidx = vidx + 1 ! INTEGER(i_d) !CALL MPI_Get_address (veg%meth(off), vaddr(vidx), ierr) ! 144 !blen(vidx) = cnt * extid bidx = bidx + 1 CALL MPI_Get_address ( veg % meth ( off ), displs ( bidx ), ierr ) ! Maciej: veg%meth is REAL !    blocks(bidx) = I1LEN blocks ( bidx ) = R1LEN !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%vlai(off), vaddr(vidx), ierr) ! 145 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % vlai ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: 2D vars moved above ! froot !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%canst1(off), vaddr(vidx), ierr) ! 146 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % canst1 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%ejmax(off), vaddr(vidx), ierr) ! 147 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % ejmax ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%frac4(off), vaddr(vidx), ierr) ! 148 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % frac4 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%wai(off), vaddr(vidx), ierr) ! 149 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % wai ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%vegcf(off), vaddr(vidx), ierr) ! 150 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % vegcf ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%tminvj(off), vaddr(vidx), ierr) ! 151 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % tminvj ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%tmaxvj(off), vaddr(vidx), ierr) ! 152 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % tmaxvj ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%vbeta(off), vaddr(vidx), ierr) ! 153 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % vbeta ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%xalbnir(off), vaddr(vidx), ierr) ! 154 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % xalbnir ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%hc(off), vaddr(vidx), ierr) ! 155 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % hc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%shelrb(off), vaddr(vidx), ierr) ! 156 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % shelrb ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%vcmax(off), vaddr(vidx), ierr) ! 157 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % vcmax ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%xfang(off), vaddr(vidx), ierr) ! 158 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % xfang ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%dleaf(off), vaddr(vidx), ierr) ! 159 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % dleaf ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%rp20(off), vaddr(vidx), ierr) ! 160 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % rp20 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%rpcoef(off), vaddr(vidx), ierr) ! 161 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % rpcoef ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! REAL(r_1) !CALL MPI_Get_address (veg%extkn(off), vaddr(vidx), ierr) ! 162 !blen(vidx) = cnt * extr1 bidx = bidx + 1 CALL MPI_Get_address ( veg % extkn ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len !vidx = vidx + 1 ! LOGICAL !CALL MPI_Get_address (veg%deciduous(off), vaddr(vidx), ierr) ! 163 !blen(vidx) = cnt * extl bidx = bidx + 1 CALL MPI_Get_address ( veg % deciduous ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = llen !mrd 1D GW bidx = bidx + 1 CALL MPI_Get_address ( ssnow % GWwb ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % wtd ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % satfrac ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % Qrecharge ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len ! additional for SLI bidx = bidx + 1 CALL MPI_Get_address ( ssnow % Tsurface ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % h0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % delwcol ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % evap ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % nsnow ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = i1len bidx = bidx + 1 CALL MPI_Get_address ( ssnow % nsteps ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len ! end additional for SLI ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'worker ' , rank , ': invalid outtype nmat, nvec or n3d constant, fix it!' WRITE ( * , * ) 'bidx: ' , bidx WRITE ( * , * ) 'nvec: ' , nvec WRITE ( * , * ) 'n3d:' , n3d WRITE ( * , * ) 'ntyp' , ntyp CALL MPI_Abort ( comm , 1 , ierr ) END IF types = MPI_BYTE CALL MPI_Type_create_struct ( bidx , blocks , displs , types , send_t , ierr ) CALL MPI_Type_commit ( send_t , ierr ) CALL MPI_Type_size ( send_t , tsize , ierr ) CALL MPI_Type_get_extent ( send_t , tmplb , text , ierr ) WRITE ( * , * ) 'worker ' , rank , ': struct blocks, size, extent and lb: ' , bidx , tsize , text , tmplb ! MPI: check whether total size of received data equals total ! data sent by all the workers !mcd287  CALL MPI_Reduce (tsize, tsize, 1, MPI_INTEGER, MPI_SUM, 0, comm, ierr) CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE worker_outtype SUBROUTINE worker_time_update ( met , kend , dels ) USE cable_common_module , ONLY : ktau_gl USE cable_def_types_mod USE cable_IO_vars_module IMPLICIT NONE TYPE ( met_type ), INTENT ( INOUT ) :: met INTEGER , INTENT ( IN ) :: kend ! number of time steps in simulation REAL , INTENT ( IN ) :: dels ! time step size INTEGER :: i DO i = 1 , mland ! over all land points/grid cells ! First set timing variables: ! All timing details below are initially written to the first patch ! of each gridcell, then dumped to all patches for the gridcell. IF ( ktau_gl == 1 ) THEN ! initialise... SELECT CASE ( time_coord ) CASE ( 'LOC' ) ! i.e. use local time by default ! hour-of-day = starting hod met % hod ( landpt ( i )% cstart ) = shod met % doy ( landpt ( i )% cstart ) = sdoy met % moy ( landpt ( i )% cstart ) = smoy met % year ( landpt ( i )% cstart ) = syear CASE ( 'GMT' ) ! use GMT ! hour-of-day = starting hod + offset from GMT time: met % hod ( landpt ( i )% cstart ) = shod + ( longitude ( i ) / 18 0.0 ) * 1 2.0 ! Note above that all met%* vars have dim mp, ! while longitude and latitude have dimension mland. met % doy ( landpt ( i )% cstart ) = sdoy met % moy ( landpt ( i )% cstart ) = smoy met % year ( landpt ( i )% cstart ) = syear CASE DEFAULT CALL abort ( 'Unknown time coordinate! ' & // ' (SUBROUTINE get_met_data)' ) END SELECT ELSE ! increment hour-of-day by time step size: met % hod ( landpt ( i )% cstart ) = met % hod ( landpt ( i )% cstart ) + dels / 360 0.0 END IF ! IF ( met % hod ( landpt ( i )% cstart ) < 0.0 ) THEN ! may be -ve since longitude ! has range [-180,180] ! Reduce day-of-year by one and ammend hour-of-day: met % doy ( landpt ( i )% cstart ) = met % doy ( landpt ( i )% cstart ) - 1 met % hod ( landpt ( i )% cstart ) = met % hod ( landpt ( i )% cstart ) + 2 4.0 ! If a leap year AND we're using leap year timing: IF ((( MOD ( syear , 4 ) == 0. AND . MOD ( syear , 100 ) /= 0 ). OR . & ( MOD ( syear , 4 ) == 0. AND . MOD ( syear , 400 ) == 0 )). AND . leaps ) THEN SELECT CASE ( INT ( met % doy ( landpt ( i )% cstart ))) CASE ( 0 ) ! ie Dec previous year met % moy ( landpt ( i )% cstart ) = 12 met % year ( landpt ( i )% cstart ) = met % year ( landpt ( i )% cstart ) - 1 met % doy ( landpt ( i )% cstart ) = 365 ! prev year not leap year as this is CASE ( 31 ) ! Jan met % moy ( landpt ( i )% cstart ) = 1 CASE ( 60 ) ! Feb met % moy ( landpt ( i )% cstart ) = 2 CASE ( 91 ) ! Mar met % moy ( landpt ( i )% cstart ) = 3 CASE ( 121 ) met % moy ( landpt ( i )% cstart ) = 4 CASE ( 152 ) met % moy ( landpt ( i )% cstart ) = 5 CASE ( 182 ) met % moy ( landpt ( i )% cstart ) = 6 CASE ( 213 ) met % moy ( landpt ( i )% cstart ) = 7 CASE ( 244 ) met % moy ( landpt ( i )% cstart ) = 8 CASE ( 274 ) met % moy ( landpt ( i )% cstart ) = 9 CASE ( 305 ) met % moy ( landpt ( i )% cstart ) = 10 CASE ( 335 ) met % moy ( landpt ( i )% cstart ) = 11 END SELECT ELSE ! not a leap year or not using leap year timing SELECT CASE ( INT ( met % doy ( landpt ( i )% cstart ))) CASE ( 0 ) ! ie Dec previous year met % moy ( landpt ( i )% cstart ) = 12 met % year ( landpt ( i )% cstart ) = met % year ( landpt ( i )% cstart ) - 1 ! If previous year is a leap year IF (( MOD ( syear , 4 ) == 0. AND . MOD ( syear , 100 ) /= 0 ). OR . & ( MOD ( syear , 4 ) == 0. AND . MOD ( syear , 400 ) == 0 )) THEN met % doy ( landpt ( i )% cstart ) = 366 ELSE met % doy ( landpt ( i )% cstart ) = 365 END IF CASE ( 31 ) ! Jan met % moy ( landpt ( i )% cstart ) = 1 CASE ( 59 ) ! Feb met % moy ( landpt ( i )% cstart ) = 2 CASE ( 90 ) met % moy ( landpt ( i )% cstart ) = 3 CASE ( 120 ) met % moy ( landpt ( i )% cstart ) = 4 CASE ( 151 ) met % moy ( landpt ( i )% cstart ) = 5 CASE ( 181 ) met % moy ( landpt ( i )% cstart ) = 6 CASE ( 212 ) met % moy ( landpt ( i )% cstart ) = 7 CASE ( 243 ) met % moy ( landpt ( i )% cstart ) = 8 CASE ( 273 ) met % moy ( landpt ( i )% cstart ) = 9 CASE ( 304 ) met % moy ( landpt ( i )% cstart ) = 10 CASE ( 334 ) met % moy ( landpt ( i )% cstart ) = 11 END SELECT END IF ! if leap year or not ELSE IF ( met % hod ( landpt ( i )% cstart ) >= 2 4.0 ) THEN ! increment or GMT adj has shifted day ! Adjust day-of-year and hour-of-day: met % doy ( landpt ( i )% cstart ) = met % doy ( landpt ( i )% cstart ) + 1 met % hod ( landpt ( i )% cstart ) = met % hod ( landpt ( i )% cstart ) - 2 4.0 ! If a leap year AND we're using leap year timing: IF ((( MOD ( syear , 4 ) == 0. AND . MOD ( syear , 100 ) /= 0 ). OR . & ( MOD ( syear , 4 ) == 0. AND . MOD ( syear , 400 ) == 0 )). AND . leaps ) THEN SELECT CASE ( INT ( met % doy ( landpt ( i )% cstart ))) CASE ( 32 ) ! Feb met % moy ( landpt ( i )% cstart ) = 2 CASE ( 61 ) ! Mar met % moy ( landpt ( i )% cstart ) = 3 CASE ( 92 ) met % moy ( landpt ( i )% cstart ) = 4 CASE ( 122 ) met % moy ( landpt ( i )% cstart ) = 5 CASE ( 153 ) met % moy ( landpt ( i )% cstart ) = 6 CASE ( 183 ) met % moy ( landpt ( i )% cstart ) = 7 CASE ( 214 ) met % moy ( landpt ( i )% cstart ) = 8 CASE ( 245 ) met % moy ( landpt ( i )% cstart ) = 9 CASE ( 275 ) met % moy ( landpt ( i )% cstart ) = 10 CASE ( 306 ) met % moy ( landpt ( i )% cstart ) = 11 CASE ( 336 ) met % moy ( landpt ( i )% cstart ) = 12 CASE ( 367 ) ! end of year; increment met % year ( landpt ( i )% cstart ) = met % year ( landpt ( i )% cstart ) + 1 met % moy ( landpt ( i )% cstart ) = 1 met % doy ( landpt ( i )% cstart ) = 1 END SELECT ! ELSE IF not leap year and Dec 31st, increment year ELSE SELECT CASE ( INT ( met % doy ( landpt ( i )% cstart ))) CASE ( 32 ) ! Feb met % moy ( landpt ( i )% cstart ) = 2 CASE ( 60 ) ! Mar met % moy ( landpt ( i )% cstart ) = 3 CASE ( 91 ) met % moy ( landpt ( i )% cstart ) = 4 CASE ( 121 ) met % moy ( landpt ( i )% cstart ) = 5 CASE ( 152 ) met % moy ( landpt ( i )% cstart ) = 6 CASE ( 182 ) met % moy ( landpt ( i )% cstart ) = 7 CASE ( 213 ) met % moy ( landpt ( i )% cstart ) = 8 CASE ( 244 ) met % moy ( landpt ( i )% cstart ) = 9 CASE ( 274 ) met % moy ( landpt ( i )% cstart ) = 10 CASE ( 305 ) met % moy ( landpt ( i )% cstart ) = 11 CASE ( 335 ) met % moy ( landpt ( i )% cstart ) = 12 CASE ( 366 ) ! end of year; increment met % year ( landpt ( i )% cstart ) = met % year ( landpt ( i )% cstart ) + 1 met % moy ( landpt ( i )% cstart ) = 1 met % doy ( landpt ( i )% cstart ) = 1 END SELECT END IF ! if leap year or not END IF ! if increment has pushed hod to a different day ! Now copy these values to all veg/soil patches in the current grid cell: met % hod ( landpt ( i )% cstart : landpt ( i )% cend ) = met % hod ( landpt ( i )% cstart ) met % doy ( landpt ( i )% cstart : landpt ( i )% cend ) = met % doy ( landpt ( i )% cstart ) met % moy ( landpt ( i )% cstart : landpt ( i )% cend ) = met % moy ( landpt ( i )% cstart ) met % year ( landpt ( i )% cstart : landpt ( i )% cend ) = met % year ( landpt ( i )% cstart ) ENDDO RETURN END SUBROUTINE worker_time_update ! creates MPI types for sending casa results back to the master at ! the end of the simulation ! ! changes from old mpi version: !  phen: removed out because casa_poolout in this version !  is no longer writing phen%phase ! ! SUBROUTINE worker_casa_type ( comm , casapool , casaflux , & casamet , casabal , phen ) USE mpi ! USE cable_vars USE cable_def_types_mod USE casadimension USE casavariable !  gol124: commented out because casa_poolout in this version !  is no longer writing phen%phase USE phenvariable IMPLICIT NONE ! subroutine arguments INTEGER :: comm ! MPI communicator to talk to the workers TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen ! local variables ! MPI: temp arrays for marshalling all types into a struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types INTEGER :: ntyp ! number of worker's types ! MPI: block lengths and strides for hvector representing matrices INTEGER :: r1len , r2len , I1LEN , llen INTEGER :: rank , off , cnt INTEGER :: bidx , midx , vidx , ierr INTEGER :: tsize INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb ! MPI: allocate temp vectors used for marshalling ntyp = ncasa_mat + ncasa_vec + ( nphen - 1 ) ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) !off = wpatch%patch0 !cnt = wpatch%npatch off = 1 cnt = mp r1len = cnt * extr1 r2len = cnt * extr2 I1LEN = cnt * extid llen = cnt * extl bidx = 0 ! ------------- 2D arrays ------------- bidx = bidx + 1 CALL MPI_Get_address ( casapool % cplant ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mplant bidx = bidx + 1 CALL MPI_Get_address ( casapool % clitter ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mlitter bidx = bidx + 1 CALL MPI_Get_address ( casapool % csoil ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * msoil bidx = bidx + 1 CALL MPI_Get_address ( casapool % nplant ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mplant bidx = bidx + 1 CALL MPI_Get_address ( casapool % nlitter ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mlitter bidx = bidx + 1 CALL MPI_Get_address ( casapool % nsoil ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * msoil bidx = bidx + 1 CALL MPI_Get_address ( casapool % pplant ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mplant bidx = bidx + 1 CALL MPI_Get_address ( casapool % plitter ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mlitter bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoil ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * msoil bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCplant ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mplant bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPCplant ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mplant bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNClitter ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mlitter bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPClitter ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mlitter bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioNCsoil ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * msoil bidx = bidx + 1 CALL MPI_Get_address ( casapool % ratioPCsoil ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * msoil bidx = bidx + 1 CALL MPI_Get_address ( casapool % cwoodprod ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mwood bidx = bidx + 1 CALL MPI_Get_address ( casapool % nwoodprod ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mwood bidx = bidx + 1 CALL MPI_Get_address ( casapool % pwoodprod ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len * mwood ! bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphase ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = mphase * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % phasespin ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_1 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_2 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_3 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphasespin_4 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = mdyear * I1LEN bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cplant_turnover ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = mplant * r2LEN bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracCalloc , displs ( bidx ), ierr ) blocks ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracNalloc , displs ( bidx ), ierr ) blocks ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracPalloc , displs ( bidx ), ierr ) blocks ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crmplant , displs ( bidx ), ierr ) blocks ( bidx ) = mplant * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % kplant , displs ( bidx ), ierr ) blocks ( bidx ) = mplant * r2len ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromPtoL , displs ( bidx ), ierr ) blocks ( bidx ) = mplant * mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % klitter , displs ( bidx ), ierr ) blocks ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % ksoil , displs ( bidx ), ierr ) blocks ( bidx ) = msoil * r2len ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromLtoS , displs ( bidx ), ierr ) blocks ( bidx ) = msoil * mlitter * r2len ! 3D bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromStoS , displs ( bidx ), ierr ) blocks ( bidx ) = msoil * msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromLtoCO2 , displs ( bidx ), ierr ) blocks ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fromStoCO2 , displs ( bidx ), ierr ) blocks ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtolitter , displs ( bidx ), ierr ) blocks ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxNtolitter , displs ( bidx ), ierr ) blocks ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxPtolitter , displs ( bidx ), ierr ) blocks ( bidx ) = mlitter * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxCtosoil , displs ( bidx ), ierr ) blocks ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxNtosoil , displs ( bidx ), ierr ) blocks ( bidx ) = msoil * r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fluxPtosoil , displs ( bidx ), ierr ) blocks ( bidx ) = msoil * r2len ! ------------- 1D vectors ------------- bidx = bidx + 1 CALL MPI_Get_address ( casamet % glai ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !  gol124: commented out because casa_poolout in this version !  is no longer writing phen%phase bidx = bidx + 1 CALL MPI_Get_address ( phen % phase ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % phen ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( phen % aphen ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( casapool % clabile ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Ctot ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % Ctot_0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % nsoilmin ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoillab ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoilsorb ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoilocc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % psorbmax ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumcbal ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumnbal ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % sumpbal ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCgppyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCnppyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmleafyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmwoodyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrmrootyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrgrowyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrpyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCrsyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCneeyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNdepyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNfixyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNsnetyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNupyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNleachyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FNlossyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPweayear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPdustyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPsnetyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPupyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPleachyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FPlossyear ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !***************************** bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cgpp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cnpp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crgplant ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminfix ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminuptake ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Plabuptake ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Clabloss ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % fracClabile ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cnep ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crsoil ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nmindep ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminloss ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nminleach ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nupland ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nlittermin ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsmin ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsimm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nsnet ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len !***************************** bidx = bidx + 1 CALL MPI_Get_address ( casaflux % frac_sapwood ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % sapwood_area ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cplant_turnover_disturbance ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cplant_turnover_crowding ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cplant_turnover_resource_limitation ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'worker: invalid number of casa fields, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF types = MPI_BYTE CALL MPI_Type_create_struct ( bidx , blocks , displs , types , casa_t , ierr ) CALL MPI_Type_commit ( casa_t , ierr ) CALL MPI_Type_size ( casa_t , tsize , ierr ) CALL MPI_Type_get_extent ( casa_t , tmplb , text , ierr ) WRITE ( * , * ) 'casa type struct blocks, size, extent and lb: ' , bidx , tsize , text , tmplb ! MPI: check whether total size of received data equals total ! data sent by all the workers CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE worker_casa_type SUBROUTINE worker_climate_types ( comm , climate , ktauday ) USE mpi USE cable_def_types_mod , ONLY : climate_type , alloc_cbm_var , mp USE cable_climate_mod , ONLY : climate_init IMPLICIT NONE TYPE ( climate_type ), INTENT ( INOUT ) :: climate INTEGER , INTENT ( IN ) :: comm , ktauday ! MPI: temp arrays for marshalling all types into a struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types INTEGER :: ntyp ! number of worker's types INTEGER :: last2d , i ! MPI: block lenghts for hindexed representing all vectors INTEGER , ALLOCATABLE , DIMENSION (:) :: blen ! MPI: block lengths and strides for hvector representing matrices INTEGER :: r1len , r2len , I1LEN INTEGER ( KIND = MPI_ADDRESS_KIND ) :: r1stride , r2stride INTEGER :: tsize , totalrecv , totalsend INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: rank , off , cnt INTEGER :: bidx , midx , vidx , ierr , ny , nd , ndq INTEGER :: stat ( MPI_STATUS_SIZE ), ierr2 , rcount , pos CHARACTER , DIMENSION (:), ALLOCATABLE :: rbuf ! CALL alloc_cbm_var(climate,mp) IF ( cable_user % call_climate ) CALL climate_init ( climate , mp , ktauday ) ! MPI: allocate temp vectors used for marshalling ntyp = nclimate ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) off = 1 ! counter to sum total number of bytes receives from all workers totalrecv = 0 r1len = mp * extr1 r2len = mp * extr2 I1LEN = mp * extid bidx = 0 ! ------------- 2D arrays ------------- ny = climate % nyear_average nd = climate % nday_average ndq = 91 bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_min_20 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = ny * r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_max_20 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = ny * r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % alpha_PT_20 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = ny * r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % dtemp_31 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = nd * r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % dtemp_91 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = ndq * r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % dmoist_31 ( off , 1 ), displs ( bidx ), ierr ) blocks ( bidx ) = nd * r1len types ( bidx ) = MPI_BYTE ! ------------- 1D vectors ------------- bidx = bidx + 1 CALL MPI_Get_address ( climate % chilldays ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = i1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % iveg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = i1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % biome ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = i1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % dtemp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % dmoist ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % qtemp ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mmoist ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_min ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_max ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % qtemp_max ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % qtemp_max_last_year ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_min20 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % mtemp_max20 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % atemp_mean ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % agdd5 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % gdd5 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % agdd0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % gdd0 ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % alpha_PT ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % evap_PT ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % aevap ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len types ( bidx ) = MPI_BYTE ! ------------- scalars  ------------- bidx = bidx + 1 CALL MPI_Get_address ( climate % nyears , displs ( bidx ), ierr ) blocks ( bidx ) = extid types ( bidx ) = MPI_BYTE bidx = bidx + 1 CALL MPI_Get_address ( climate % doy , displs ( bidx ), ierr ) blocks ( bidx ) = extid types ( bidx ) = MPI_BYTE !!$types = MPI_BYTE ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'worker: invalid number of climate fields, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blocks , displs , types , climate_t , ierr ) CALL MPI_Type_commit ( climate_t , ierr ) CALL MPI_Type_size ( climate_t , tsize , ierr ) CALL MPI_Type_get_extent ( climate_t , tmplb , text , ierr ) CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) ! so, now receive all the parameters !    CALL MPI_Recv (MPI_BOTTOM, 1, climate_t, 0, 0, comm, stat, ierr) !   Maciej: buffered recv + unpac version ALLOCATE ( rbuf ( tsize )) CALL MPI_Recv ( rbuf , tsize , MPI_BYTE , 0 , 0 , comm , stat , ierr ) CALL MPI_Get_count ( stat , climate_t , rcount , ierr2 ) IF ( ierr == MPI_SUCCESS . AND . ierr2 == MPI_SUCCESS . AND . rcount == 1 ) THEN pos = 0 CALL MPI_Unpack ( rbuf , tsize , pos , MPI_BOTTOM , rcount , climate_t , & comm , ierr ) IF ( ierr /= MPI_SUCCESS ) WRITE ( * , * ), 'climate unpack error, rank: ' , rank , ierr ELSE WRITE ( * , * ), 'climate recv rank err err2 rcount: ' , rank , ierr , ierr2 , rcount END IF DEALLOCATE ( rbuf ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE worker_climate_types !!$ ! MPI: creates restart_t type to send to the master the fields ! that are only required for the restart file but not included in the ! results sent at the end of each time step SUBROUTINE worker_restart_type ( comm , canopy , air ) USE mpi USE cable_def_types_mod IMPLICIT NONE INTEGER :: comm TYPE ( canopy_type ), INTENT ( IN ) :: canopy TYPE ( air_type ), INTENT ( IN ) :: air ! MPI: temp arrays for marshalling all types into a struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blocks INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types INTEGER :: ntyp ! number of worker's types ! MPI: block lengths and strides for hvector representing matrices INTEGER :: r1len , r2len , I1LEN , llen INTEGER :: rank , off , cnt INTEGER :: bidx , midx , vidx , ierr , nd , ny INTEGER :: tsize INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb CALL MPI_Comm_rank ( comm , rank , ierr ) ! MPI: allocate temp vectors used for marshalling ntyp = nrestart ALLOCATE ( blocks ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) off = 1 cnt = mp bidx = 0 r1len = cnt * extr1 r2len = cnt * extr2 I1LEN = cnt * extid llen = cnt * extl !  bidx = bidx + 1 !  CALL MPI_Get_address (canopy%rwater(off,1), displs(bidx), ierr) !  blocks(bidx) = r1len * ms bidx = bidx + 1 CALL MPI_Get_address ( canopy % evapfbl ( off , 1 ), displs ( bidx ), ierr ) ! MPI: gol124: changed to r1 when Bernard ported to CABLE_r491 blocks ( bidx ) = r1len * ms bidx = bidx + 1 CALL MPI_Get_address ( canopy % cduv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % dewmm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % dgdtg ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpw ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % frpr ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( canopy % fnv ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % rho ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % volm ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % qsat ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % epsi ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % visc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % psyc ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % dsatdk ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len bidx = bidx + 1 CALL MPI_Get_address ( air % cmolar ( off ), displs ( bidx ), ierr ) blocks ( bidx ) = r1len ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'invalid nrestart constant, fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF types = MPI_BYTE CALL MPI_Type_create_struct ( bidx , blocks , displs , types , restart_t , ierr ) CALL MPI_Type_commit ( restart_t , ierr ) CALL MPI_Type_size ( restart_t , tsize , ierr ) CALL MPI_Type_get_extent ( restart_t , tmplb , text , ierr ) WRITE ( * , * ) 'restart struct blocks, size, extent and lb: ' , rank , bidx , tsize , text , tmplb ! MPI: check whether total size of received data equals total ! data sent by all the workers !mcd287  CALL MPI_Reduce (tsize, tsize, 1, MPI_INTEGER, MPI_SUM, 0, comm, ierr) WRITE ( * , * ) 'b4 reduce wk' , tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr CALL flush ( 6 ) !call flush(wlogn) CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blocks ) RETURN END SUBROUTINE worker_restart_type SUBROUTINE worker_casa_dump_types ( comm , casamet , casaflux , phen , climate ) USE mpi USE casavariable , ONLY : casa_met , casa_flux , mplant USE cable_def_types_mod , ONLY : climate_type USE phenvariable IMPLICIT NONE ! sub arguments INTEGER , INTENT ( IN ) :: comm ! MPI communicator TYPE ( casa_flux ) , INTENT ( INOUT ) :: casaflux TYPE ( casa_met ) , INTENT ( INOUT ) :: casamet TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( climate_type ) :: climate ! local vars ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blen INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize INTEGER :: stat ( MPI_STATUS_SIZE ), ierr INTEGER :: landp_t , patch_t , param_t INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank CALL MPI_Comm_rank ( comm , rank , ierr ) ntyp = ncdumprw ALLOCATE ( blen ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! default type is byte, to be overriden for multi-D types types = MPI_BYTE r1len = mp * extr1 r2len = mp * extr2 i1len = mp * extid bidx = 0 ! ------- casamet ---- bidx = bidx + 1 CALL MPI_Get_address ( casamet % Tairk , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % Tsoil , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len bidx = bidx + 1 CALL MPI_Get_address ( casamet % moist , displs ( bidx ), ierr ) blen ( bidx ) = ms * r2len ! ------- casaflux ---- bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Cgpp , displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Crmplant , displs ( bidx ), ierr ) blen ( bidx ) = mplant * r2len !**************************************************************** ! phen fields bidx = bidx + 1 CALL MPI_Get_address ( phen % phase , displs ( bidx ), ierr ) blen ( bidx ) = I1LEN bidx = bidx + 1 CALL MPI_Get_address ( phen % doyphase , displs ( bidx ), ierr ) blen ( bidx ) = mphase * i1len ! #294 - Avoid malformed var write for now ! bidx = bidx + 1 ! CALL MPI_Get_address (climate%mtemp_max, displs(bidx), ierr) ! blen(bidx) = r1len !**************************************************************** ! Ndep bidx = bidx + 1 CALL MPI_Get_address ( casaflux % Nmindep , displs ( bidx ), ierr ) blen ( bidx ) = r2len !****************************************************************** ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'worker ' , rank , ' invalid number of casa_dump_t param fields ' , bidx , ', fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blen , displs , types , casa_dump_t , ierr ) CALL MPI_Type_commit ( casa_dump_t , ierr ) CALL MPI_Type_size ( casa_dump_t , tsize , ierr ) CALL MPI_Type_get_extent ( casa_dump_t , tmplb , text , ierr ) WRITE ( * , * ) 'worker casa_dump_t param blocks, size, extent and lb: ' , rank , & bidx , tsize , text , tmplb ! MPI: check whether total size of received data equals total ! data sent by all the workers CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blen ) !!$ ! if anything went wrong the master will mpi_abort !!$ ! which mpi_recv below is going to catch... !!$ ! so, now receive all the parameters !!$ CALL MPI_Recv (MPI_BOTTOM, 1, casa_dump_t, 0, 0, comm, stat, ierr) !!$ !!$ ! finally free the MPI type !!$ CALL MPI_Type_Free (casa_dump_t, ierr) ! all casa parameters have been received from the master by now END SUBROUTINE worker_casa_dump_types SUBROUTINE worker_casa_LUC_types ( comm , casapool , casabal ) USE mpi USE casavariable , ONLY : casa_pool , mplant , mlitter , msoil , casa_balance IMPLICIT NONE ! sub arguments INTEGER , INTENT ( IN ) :: comm ! MPI communicator TYPE ( casa_pool ) , INTENT ( IN ) :: casapool TYPE ( casa_balance ), INTENT ( IN ) :: casabal ! local vars ! temp arrays for marshalling all fields into a single struct INTEGER , ALLOCATABLE , DIMENSION (:) :: blen INTEGER ( KIND = MPI_ADDRESS_KIND ), ALLOCATABLE , DIMENSION (:) :: displs INTEGER , ALLOCATABLE , DIMENSION (:) :: types ! temp vars for verifying block number and total length of inp_t INTEGER ( KIND = MPI_ADDRESS_KIND ) :: text , tmplb INTEGER :: tsize INTEGER :: stat ( MPI_STATUS_SIZE ), ierr INTEGER :: landp_t , patch_t , param_t INTEGER :: r1len , r2len , I1LEN , llen ! block lengths INTEGER :: bidx ! block index INTEGER :: ntyp ! total number of blocks INTEGER :: rank , off CALL MPI_Comm_rank ( comm , rank , ierr ) ntyp = nLUCrw ALLOCATE ( blen ( ntyp )) ALLOCATE ( displs ( ntyp )) ALLOCATE ( types ( ntyp )) ! default type is byte, to be overriden for multi-D types types = MPI_BYTE r1len = mp * extr1 r2len = mp * extr2 i1len = mp * extid off = 1 bidx = 0 bidx = bidx + 1 CALL MPI_Get_address ( casapool % cplant ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * mplant bidx = bidx + 1 CALL MPI_Get_address ( casapool % clitter ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * mlitter bidx = bidx + 1 CALL MPI_Get_address ( casapool % csoil ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * msoil bidx = bidx + 1 CALL MPI_Get_address ( casapool % nplant ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * mplant bidx = bidx + 1 CALL MPI_Get_address ( casapool % nlitter ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * mlitter bidx = bidx + 1 CALL MPI_Get_address ( casapool % nsoil ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * msoil bidx = bidx + 1 CALL MPI_Get_address ( casapool % pplant ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * mplant bidx = bidx + 1 CALL MPI_Get_address ( casapool % plitter ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * mlitter bidx = bidx + 1 CALL MPI_Get_address ( casapool % psoil ( off , 1 ), displs ( bidx ), ierr ) blen ( bidx ) = r2len * msoil bidx = bidx + 1 CALL MPI_Get_address ( casapool % Nsoilmin ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casapool % clabile ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len bidx = bidx + 1 CALL MPI_Get_address ( casabal % FCneeyear ( off ), displs ( bidx ), ierr ) blen ( bidx ) = r2len ! MPI: sanity check IF ( bidx /= ntyp ) THEN WRITE ( * , * ) 'worker ' , rank , ' invalid number of casa_LUC_t param fields ' , bidx , ', fix it!' CALL MPI_Abort ( comm , 1 , ierr ) END IF CALL MPI_Type_create_struct ( bidx , blen , displs , types , casa_LUC_t , ierr ) CALL MPI_Type_commit ( casa_LUC_t , ierr ) CALL MPI_Type_size ( casa_LUC_t , tsize , ierr ) CALL MPI_Type_get_extent ( casa_LUC_t , tmplb , text , ierr ) WRITE ( * , * ) 'worker casa_LUC_t param blocks, size, extent and lb: ' , rank , & bidx , tsize , text , tmplb ! MPI: check whether total size of received data equals total ! data sent by all the workers CALL MPI_Reduce ( tsize , MPI_DATATYPE_NULL , 1 , MPI_INTEGER , MPI_SUM , 0 , comm , ierr ) DEALLOCATE ( types ) DEALLOCATE ( displs ) DEALLOCATE ( blen ) !!$ ! if anything went wrong the master will mpi_abort !!$ ! which mpi_recv below is going to catch... !!$ ! so, now receive all the parameters !!$ CALL MPI_Recv (MPI_BOTTOM, 1, casa_dump_t, 0, 0, comm, stat, ierr) !!$ !!$ ! finally free the MPI type !!$ CALL MPI_Type_Free (casa_dump_t, ierr) ! all casa parameters have been received from the master by now END SUBROUTINE worker_casa_LUC_types SUBROUTINE worker_pop_types ( comm , veg , casamet , pop ) USE mpi USE POP_mpi USE POPmodule , ONLY : ALLOC_POP , POP_INIT USE POP_types , ONLY : pop_type USE casavariable , ONLY : casa_met USE cable_def_types_mod , ONLY : veg_parameter_type USE cable_common_module , ONLY : cable_user IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm TYPE ( casa_met ), INTENT ( IN ) :: casamet TYPE ( pop_type ), INTENT ( INOUT ) :: pop TYPE ( veg_parameter_type ), INTENT ( IN ) :: veg INTEGER , DIMENSION (:), ALLOCATABLE :: Iwood , ainv INTEGER :: mp_pop , stat ( MPI_STATUS_SIZE ), ierr INTEGER :: rank , inv CALL MPI_Comm_rank ( comm , rank , ierr ) ! Get POP relevant info from Master CALL MPI_Recv ( mp_pop , 1 , MPI_INTEGER , 0 , 0 , comm , stat , ierr ) WRITE ( * , * ), 'worker iwood to allocate' , rank , mp_pop , mp !write(*,*),'worker mppop', rank, mp_pop !ALLOCATE( POP%Iwood( mp_pop ) ) ALLOCATE ( Iwood ( mp_pop ) ) WRITE ( * , * ), 'worker iwood allocated' , rank , mp_pop !CALL MPI_Recv ( POP%Iwood, mp_pop, MPI_INTEGER, 0, 0, comm, stat, ierr ) CALL MPI_Recv ( Iwood , mp_pop , MPI_INTEGER , 0 , 0 , comm , stat , ierr ) !write(*,*),'worker Iwood', rank, POP%Iwood ! Maciej IF ( ANY ( Iwood < 1 ) . OR . ANY ( Iwood > mp )) THEN WRITE ( * , * ), 'worker iwood values outside valid ranges' , rank inv = COUNT ( Iwood < 1 ) IF ( inv . GT . 0 ) THEN WRITE ( * , * ), 'no of values below 1: ' , inv ALLOCATE ( ainv ( inv )) ainv = PACK ( Iwood , Iwood . LT . 1 ) WRITE ( * , * ), 'values below 1: ' , ainv DEALLOCATE ( ainv ) END IF inv = COUNT ( Iwood > mp ) IF ( inv . GT . 0 ) THEN WRITE ( * , * ), 'no of values above mp ' , mp , inv ALLOCATE ( ainv ( inv )) ainv = PACK ( Iwood , Iwood . GT . mp ) WRITE ( * , * ), 'values above mp: ' , ainv DEALLOCATE ( ainv ) END IF END IF ! maciej: unnecessary, pop_init starts with a call to alloc_pop ! CALL ALLOC_POP ( POP, mp_pop ) !CALL POP_INIT( pop,veg%disturbance_interval,mp_pop,POP%Iwood ) ! maciej: veg%disturbance_levels received earlier in worker_cable_params CALL POP_INIT ( pop , veg % disturbance_interval , mp_pop , Iwood ) DEALLOCATE ( Iwood ) ! Maciej: pop_t used also for sending results back to master, even if from zero CALL create_pop_gridcell_type ( pop_t , comm ) IF (. NOT . CABLE_USER % POP_fromZero ) THEN WRITE ( * , * ), 'rank receiving pop_grid from master' , rank CALL MPI_Recv ( POP % pop_grid ( 1 ), mp_pop , pop_t , 0 , 0 , comm , stat , ierr ) END IF END SUBROUTINE worker_pop_types SUBROUTINE worker_send_pop ( POP , comm ) USE mpi USE POP_mpi USE POP_Types , ONLY : pop_type IMPLICIT NONE INTEGER , INTENT ( IN ) :: comm TYPE ( pop_type ) , INTENT ( IN ) :: pop INTEGER :: ierr IF ( POP % np . EQ . 0 ) RETURN CALL MPI_Send ( POP % pop_grid ( 1 ), POP % np , pop_t , 0 , 0 , comm , ierr ) END SUBROUTINE worker_send_pop ! frees memory used for worker's data structures SUBROUTINE worker_end ( icycle , restart ) USE mpi IMPLICIT NONE INTEGER :: icycle ! casa flag LOGICAL :: restart INTEGER :: ierr CALL MPI_Type_free ( inp_t , ierr ) CALL MPI_Type_free ( send_t , ierr ) IF ( icycle > 0 ) THEN CALL MPI_Type_free ( casa_t , ierr ) END IF IF ( restart ) THEN CALL MPI_Type_free ( restart_t , ierr ) END IF RETURN END SUBROUTINE worker_end !********************************************************************************************* SUBROUTINE worker_spincasacnp ( dels , kstart , kend , mloop , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , icomm , ocomm ) ! USE cable_mpiworker USE cable_def_types_mod USE cable_carbon_module USE cable_common_module , ONLY : CABLE_USER USE casadimension USE casaparm USE casavariable USE phenvariable USE POP_Types , ONLY : POP_TYPE USE POPMODULE , ONLY : POPStep USE TypeDef , ONLY : i4b , dp USE mpi !mrd561 debug USE cable_IO_vars_module , ONLY : wlogn IMPLICIT NONE !!CLN  CHARACTER(LEN=99), INTENT(IN)  :: fcnpspin REAL , INTENT ( IN ) :: dels INTEGER , INTENT ( IN ) :: kstart INTEGER , INTENT ( IN ) :: kend INTEGER , INTENT ( IN ) :: mloop INTEGER , INTENT ( IN ) :: LALLOC TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( climate_TYPE ), INTENT ( INOUT ) :: climate ! communicator for error-messages INTEGER , INTENT ( IN ) :: icomm , ocomm TYPE ( casa_met ) :: casaspin ! local variables REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_cleaf2met , avg_cleaf2str , avg_croot2met , avg_croot2str , avg_cwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_nleaf2met , avg_nleaf2str , avg_nroot2met , avg_nroot2str , avg_nwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_pleaf2met , avg_pleaf2str , avg_proot2met , avg_proot2str , avg_pwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_cgpp , avg_cnpp , avg_nuptake , avg_puptake REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_nsoilmin , avg_psoillab , avg_psoilsorb , avg_psoilocc !chris 12/oct/2012 for spin up casa REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_ratioNCsoilmic , avg_ratioNCsoilslow , avg_ratioNCsoilpass REAL ( r_2 ), DIMENSION (:), ALLOCATABLE , SAVE :: avg_xnplimit , avg_xkNlimiting , avg_xklitter , avg_xksoil REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_af REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_aw REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_ar REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_lf REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_lw REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_lr REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_annual_cnpp ! local variables INTEGER :: myearspin , nyear , nloop1 , LOY CHARACTER ( LEN = 99 ) :: ncfile CHARACTER ( LEN = 4 ) :: cyear INTEGER :: ktau , ktauday , nday , idoy , ktaux , ktauy , nloop INTEGER , SAVE :: ndays REAL , DIMENSION ( mp ) :: cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd REAL , DIMENSION ( mp ) :: nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd REAL , DIMENSION ( mp ) :: pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd REAL , DIMENSION ( mp ) :: xcgpp , xcnpp , xnuptake , xpuptake REAL , DIMENSION ( mp ) :: xnsoilmin , xpsoillab , xpsoilsorb , xpsoilocc REAL ( r_2 ), DIMENSION ( mp ) :: xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , xkleafcold , xkleafdry ! more variables to store the spinup pool size over the last 10 loops. Added by Yp Wang 30 Nov 2012 REAL , DIMENSION ( 5 , mvtype , mplant ) :: bmcplant , bmnplant , bmpplant REAL , DIMENSION ( 5 , mvtype , mlitter ) :: bmclitter , bmnlitter , bmplitter REAL , DIMENSION ( 5 , mvtype , msoil ) :: bmcsoil , bmnsoil , bmpsoil REAL , DIMENSION ( 5 , mvtype ) :: bmnsoilmin , bmpsoillab , bmpsoilsorb , bmpsoilocc REAL , DIMENSION ( mvtype ) :: bmarea INTEGER nptx , nvt , kloop REAL ( dp ) :: StemNPP ( mp , 2 ) INTEGER , ALLOCATABLE :: Iw (:) ! array of indices corresponding to woody (shrub or forest) tiles INTEGER :: stat ( MPI_STATUS_SIZE ) INTEGER :: ierr IF (. NOT . ALLOCATED ( Iw )) ALLOCATE ( Iw ( POP % np )) !! vh_js !! IF ( cable_user % CALL_POP ) THEN Iw = POP % Iwood ENDIF ktauday = INT ( 2 4.0 * 360 0.0 / dels ) nday = ( kend - kstart + 1 ) / ktauday LOY = 365 !chris 12/oct/2012 for spin up casa IF (. NOT .( ALLOCATED ( avg_cleaf2met ))) ALLOCATE ( avg_cleaf2met ( mp ), avg_cleaf2str ( mp ), avg_croot2met ( mp ), avg_croot2str ( mp ), & avg_cwood2cwd ( mp ), & avg_nleaf2met ( mp ), avg_nleaf2str ( mp ), avg_nroot2met ( mp ), avg_nroot2str ( mp ), avg_nwood2cwd ( mp ), & avg_pleaf2met ( mp ), avg_pleaf2str ( mp ), avg_proot2met ( mp ), avg_proot2str ( mp ), avg_pwood2cwd ( mp ), & avg_cgpp ( mp ), avg_cnpp ( mp ), avg_nuptake ( mp ), avg_puptake ( mp ), & avg_xnplimit ( mp ), avg_xkNlimiting ( mp ), avg_xklitter ( mp ), avg_xksoil ( mp ), & avg_rationcsoilmic ( mp ), avg_rationcsoilslow ( mp ), avg_rationcsoilpass ( mp ), & avg_nsoilmin ( mp ), avg_psoillab ( mp ), avg_psoilsorb ( mp ), avg_psoilocc ( mp )) ALLOCATE ( avg_af ( mp )) ALLOCATE ( avg_aw ( mp )) ALLOCATE ( avg_ar ( mp )) ALLOCATE ( avg_lf ( mp )) ALLOCATE ( avg_lw ( mp )) ALLOCATE ( avg_lr ( mp )) ALLOCATE ( avg_annual_cnpp ( mp )) avg_af = 0.0 avg_aw = 0.0 avg_ar = 0.0 avg_lf = 0.0 avg_lw = 0.0 avg_lr = 0.0 avg_annual_cnpp = 0.0 myearspin = CABLE_USER % CASA_SPIN_ENDYEAR - CABLE_USER % CASA_SPIN_STARTYEAR + 1 ! compute the mean fluxes and residence time of each carbon pool avg_cleaf2met = 0.0 ; avg_cleaf2str = 0.0 ; avg_croot2met = 0.0 ; avg_croot2str = 0.0 ; avg_cwood2cwd = 0.0 avg_nleaf2met = 0.0 ; avg_nleaf2str = 0.0 ; avg_nroot2met = 0.0 ; avg_nroot2str = 0.0 ; avg_nwood2cwd = 0.0 avg_pleaf2met = 0.0 ; avg_pleaf2str = 0.0 ; avg_proot2met = 0.0 ; avg_proot2str = 0.0 ; avg_pwood2cwd = 0.0 avg_cgpp = 0.0 ; avg_cnpp = 0.0 ; avg_nuptake = 0.0 ; avg_puptake = 0.0 avg_xnplimit = 0.0 ; avg_xkNlimiting = 0.0 ; avg_xklitter = 0.0 ; avg_xksoil = 0.0 avg_nsoilmin = 0.0 ; avg_psoillab = 0.0 ; avg_psoilsorb = 0.0 ; avg_psoilocc = 0.0 avg_rationcsoilmic = 0.0 ; avg_rationcsoilslow = 0.0 ; avg_rationcsoilpass = 0.0 DO nyear = 1 , myearspin ! WRITE(CYEAR,FMT=\"(I4)\") CABLE_USER%CASA_SPIN_STARTYEAR + nyear - 1 ! ncfile = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc' !call read_casa_dump( ncfile,casamet, casaflux, phen,climate, ktau ,kend,.TRUE. ) DO idoy = 1 , mdyear ktau = ( idoy - 1 ) * ktauday + 1 CALL MPI_Recv ( MPI_BOTTOM , 1 , casa_dump_t , 0 , idoy , icomm , stat , ierr ) CALL biogeochem ( ktau , dels , idoy , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , & xksoil , xkleaf , xkleafcold , xkleafdry ,& cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) IF ( cable_user % CALL_POP . AND . POP % np . GT . 0 ) THEN ! CALL_POP !!$           ! accumulate annual variables for use in POP IF ( MOD ( ktau / ktauday , LOY ) == 1 ) THEN casaflux % stemnpp = casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7 ! (assumes 70% of wood NPP is allocated above ground) casabal % LAImax = casamet % glai casabal % Cleafmean = casapool % cplant (:, 1 ) / REAL ( LOY ) / 100 0. casabal % Crootmean = casapool % cplant (:, 3 ) / REAL ( LOY ) / 100 0. ELSE casaflux % stemnpp = casaflux % stemnpp + casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7 casabal % LAImax = MAX ( casamet % glai , casabal % LAImax ) casabal % Cleafmean = casabal % Cleafmean + casapool % cplant (:, 1 ) / REAL ( LOY ) / 100 0. casabal % Crootmean = casabal % Crootmean + casapool % cplant (:, 3 ) / REAL ( LOY ) / 100 0. ENDIF IF ( idoy == mdyear ) THEN ! end of year CALL POPdriver ( casaflux , casabal , veg , POP ) ENDIF ! end of year ELSE casaflux % stemnpp = 0. ENDIF ! CALL_POP ! WHERE(xkNlimiting .eq. 0)  !Chris Lu 4/June/2012 !    xkNlimiting = 0.001 ! END WHERE ! Calculate average allocation fractions  (-) for the plant pools avg_af = avg_af + casaflux % fracCalloc (:, leaf ) avg_aw = avg_aw + casaflux % fracCalloc (:, wood ) avg_ar = avg_ar + casaflux % fracCalloc (:, froot ) ! Calculate average turnover rates for the plant pools (yr-1) avg_lf = avg_lf + ( casaflux % kplant (:, leaf ) * REAL ( LOY )) avg_lw = avg_lw + ( casaflux % kplant (:, wood ) * REAL ( LOY )) avg_lr = avg_lr + ( casaflux % kplant (:, froot ) * REAL ( LOY )) avg_cleaf2met = avg_cleaf2met + cleaf2met avg_cleaf2str = avg_cleaf2str + cleaf2str avg_croot2met = avg_croot2met + croot2met avg_croot2str = avg_croot2str + croot2str avg_cwood2cwd = avg_cwood2cwd + cwood2cwd avg_nleaf2met = avg_nleaf2met + nleaf2met avg_nleaf2str = avg_nleaf2str + nleaf2str avg_nroot2met = avg_nroot2met + nroot2met avg_nroot2str = avg_nroot2str + nroot2str avg_nwood2cwd = avg_nwood2cwd + nwood2cwd avg_pleaf2met = avg_pleaf2met + pleaf2met avg_pleaf2str = avg_pleaf2str + pleaf2str avg_proot2met = avg_proot2met + proot2met avg_proot2str = avg_proot2str + proot2str avg_pwood2cwd = avg_pwood2cwd + pwood2cwd avg_cgpp = avg_cgpp + casaflux % cgpp avg_cnpp = avg_cnpp + casaflux % cnpp avg_nuptake = avg_nuptake + casaflux % Nminuptake avg_puptake = avg_puptake + casaflux % Plabuptake avg_xnplimit = avg_xnplimit + xnplimit avg_xkNlimiting = avg_xkNlimiting + xkNlimiting avg_xklitter = avg_xklitter + xklitter avg_xksoil = avg_xksoil + xksoil avg_nsoilmin = avg_nsoilmin + casapool % nsoilmin avg_psoillab = avg_psoillab + casapool % psoillab avg_psoilsorb = avg_psoilsorb + casapool % psoilsorb avg_psoilocc = avg_psoilocc + casapool % psoilocc avg_rationcsoilmic = avg_rationcsoilmic + casapool % ratioNCsoilnew (:, mic ) avg_rationcsoilslow = avg_rationcsoilslow + casapool % ratioNCsoilnew (:, slow ) avg_rationcsoilpass = avg_rationcsoilpass + casapool % ratioNCsoilnew (:, pass ) ENDDO ENDDO ! Average the plant allocation fraction avg_af = avg_af / REAL ( nday ) avg_aw = avg_aw / REAL ( nday ) avg_ar = avg_ar / REAL ( nday ) ! Average the plant turnover fraction avg_lf = avg_lf / REAL ( nday ) avg_lw = avg_lw / REAL ( nday ) avg_lr = avg_lr / REAL ( nday ) ! Need the annual NPP to solve plant pools g C m-2 y-1 avg_annual_cnpp = avg_cnpp / REAL ( myearspin ) avg_cleaf2met = avg_cleaf2met / REAL ( nday ) avg_cleaf2str = avg_cleaf2str / REAL ( nday ) avg_croot2met = avg_croot2met / REAL ( nday ) avg_croot2str = avg_croot2str / REAL ( nday ) avg_cwood2cwd = avg_cwood2cwd / REAL ( nday ) avg_nleaf2met = avg_nleaf2met / REAL ( nday ) avg_nleaf2str = avg_nleaf2str / REAL ( nday ) avg_nroot2met = avg_nroot2met / REAL ( nday ) avg_nroot2str = avg_nroot2str / REAL ( nday ) avg_nwood2cwd = avg_nwood2cwd / REAL ( nday ) avg_pleaf2met = avg_pleaf2met / REAL ( nday ) avg_pleaf2str = avg_pleaf2str / REAL ( nday ) avg_proot2met = avg_proot2met / REAL ( nday ) avg_proot2str = avg_proot2str / REAL ( nday ) avg_pwood2cwd = avg_pwood2cwd / REAL ( nday ) avg_cgpp = avg_cgpp / REAL ( nday ) avg_cnpp = avg_cnpp / REAL ( nday ) avg_nuptake = avg_nuptake / REAL ( nday ) avg_puptake = avg_puptake / REAL ( nday ) avg_xnplimit = avg_xnplimit / REAL ( nday ) avg_xkNlimiting = avg_xkNlimiting / REAL ( nday ) avg_xklitter = avg_xklitter / REAL ( nday ) avg_xksoil = avg_xksoil / REAL ( nday ) avg_nsoilmin = avg_nsoilmin / REAL ( nday ) avg_psoillab = avg_psoillab / REAL ( nday ) avg_psoilsorb = avg_psoilsorb / REAL ( nday ) avg_psoilocc = avg_psoilocc / REAL ( nday ) avg_rationcsoilmic = avg_rationcsoilmic / REAL ( nday ) avg_rationcsoilslow = avg_rationcsoilslow / REAL ( nday ) avg_rationcsoilpass = avg_rationcsoilpass / REAL ( nday ) CALL analyticpool ( kend , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , & avg_cleaf2met , avg_cleaf2str , avg_croot2met , avg_croot2str , avg_cwood2cwd , & avg_nleaf2met , avg_nleaf2str , avg_nroot2met , avg_nroot2str , avg_nwood2cwd , & avg_pleaf2met , avg_pleaf2str , avg_proot2met , avg_proot2str , avg_pwood2cwd , & avg_cgpp , avg_cnpp , avg_nuptake , avg_puptake , & avg_xnplimit , avg_xkNlimiting , avg_xklitter , avg_xksoil , & avg_ratioNCsoilmic , avg_ratioNCsoilslow , avg_ratioNCsoilpass , & avg_nsoilmin , avg_psoillab , avg_psoilsorb , avg_psoilocc , & avg_af , avg_aw , avg_ar , avg_lf , avg_lw , avg_lr , avg_annual_cnpp ) nloop1 = MAX ( 1 , mloop - 3 ) DO nloop = 1 , mloop !!CLN  OPEN(91,file=fcnpspin) !!CLN  read(91,*) DO nyear = 1 , myearspin ! WRITE(CYEAR,FMT=\"(I4)\") CABLE_USER%CASA_SPIN_STARTYEAR + nyear - 1 ! ncfile = TRIM(casafile%c2cdumppath)//'c2c_'//CYEAR//'_dump.nc' ! call read_casa_dump( ncfile, casamet, casaflux, phen,climate, ktau, kend, .TRUE. ) DO idoy = 1 , mdyear ktauy = idoy * ktauday ktau = ( idoy - 1 ) * ktauday + 1 CALL MPI_Recv ( MPI_BOTTOM , 1 , casa_dump_t , 0 , idoy , icomm , stat , ierr ) CALL biogeochem ( ktauy , dels , idoy , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , xksoil , xkleaf ,& xkleafcold , xkleafdry ,& cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) IF ( cable_user % CALL_POP . AND . POP % np . GT . 0 ) THEN ! CALL_POP ! accumulate annual variables for use in POP IF ( MOD ( ktau / ktauday , LOY ) == 1 ) THEN casaflux % stemnpp = casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7 ! (assumes 70% of wood NPP is allocated above ground) casabal % LAImax = casamet % glai casabal % Cleafmean = casapool % cplant (:, 1 ) / REAL ( LOY ) / 100 0. casabal % Crootmean = casapool % cplant (:, 3 ) / REAL ( LOY ) / 100 0. ELSE casaflux % stemnpp = casaflux % stemnpp + casaflux % cnpp * & casaflux % fracCalloc (:, 2 ) * 0.7 casabal % LAImax = MAX ( casamet % glai , casabal % LAImax ) casabal % Cleafmean = casabal % Cleafmean + casapool % cplant (:, 1 ) / REAL ( LOY ) / 100 0. casabal % Crootmean = casabal % Crootmean + casapool % cplant (:, 3 ) / REAL ( LOY ) / 100 0. ENDIF IF ( idoy == mdyear ) THEN ! end of year CALL POPdriver ( casaflux , casabal , veg , POP ) ENDIF ! end of year ELSE casaflux % stemnpp = 0. ENDIF ! CALL_POP ENDDO ! end of idoy ENDDO ! end of nyear ENDDO ! end of nloop WRITE ( wlogn , * ) 'b4 MPI_SEND' CALL MPI_Send ( MPI_BOTTOM , 1 , casa_t , 0 , 0 , ocomm , ierr ) WRITE ( wlogn , * ) 'after MPI_SEND' IF ( CABLE_USER % CALL_POP ) CALL worker_send_pop ( POP , ocomm ) WRITE ( wlogn , * ) 'cplant' , casapool % cplant END SUBROUTINE worker_spincasacnp !********************************************************************************************* SUBROUTINE worker_CASAONLY_LUC ( dels , kstart , kend , veg , soil , casabiome , casapool , & casaflux , casamet , casabal , phen , POP , climate , LALLOC , icomm , ocomm ) ! USE cable_mpiworker USE cable_def_types_mod USE cable_carbon_module USE cable_common_module , ONLY : CABLE_USER USE casadimension USE casaparm USE casavariable USE phenvariable USE POP_Types , ONLY : POP_TYPE USE POPMODULE , ONLY : POPStep USE TypeDef , ONLY : i4b , dp USE mpi !mrd561 debug USE cable_IO_vars_module , ONLY : wlogn IMPLICIT NONE !!CLN  CHARACTER(LEN=99), INTENT(IN)  :: fcnpspin REAL , INTENT ( IN ) :: dels INTEGER , INTENT ( IN ) :: kstart INTEGER , INTENT ( IN ) :: kend INTEGER , INTENT ( IN ) :: LALLOC TYPE ( veg_parameter_type ), INTENT ( INOUT ) :: veg ! vegetation parameters TYPE ( soil_parameter_type ), INTENT ( INOUT ) :: soil ! soil parameters TYPE ( casa_biome ), INTENT ( INOUT ) :: casabiome TYPE ( casa_pool ), INTENT ( INOUT ) :: casapool TYPE ( casa_flux ), INTENT ( INOUT ) :: casaflux TYPE ( casa_met ), INTENT ( INOUT ) :: casamet TYPE ( casa_balance ), INTENT ( INOUT ) :: casabal TYPE ( phen_variable ), INTENT ( INOUT ) :: phen TYPE ( POP_TYPE ), INTENT ( INOUT ) :: POP TYPE ( climate_TYPE ), INTENT ( INOUT ) :: climate ! communicator for error-messages INTEGER , INTENT ( IN ) :: icomm , ocomm TYPE ( casa_met ) :: casaspin ! local variables REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_cleaf2met , avg_cleaf2str , avg_croot2met , avg_croot2str , avg_cwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_nleaf2met , avg_nleaf2str , avg_nroot2met , avg_nroot2str , avg_nwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_pleaf2met , avg_pleaf2str , avg_proot2met , avg_proot2str , avg_pwood2cwd REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_cgpp , avg_cnpp , avg_nuptake , avg_puptake REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_nsoilmin , avg_psoillab , avg_psoilsorb , avg_psoilocc !chris 12/oct/2012 for spin up casa REAL , DIMENSION (:), ALLOCATABLE , SAVE :: avg_ratioNCsoilmic , avg_ratioNCsoilslow , avg_ratioNCsoilpass REAL ( r_2 ), DIMENSION (:), ALLOCATABLE , SAVE :: avg_xnplimit , avg_xkNlimiting , avg_xklitter , avg_xksoil ! local variables INTEGER :: myearspin , nyear , nloop1 CHARACTER ( LEN = 99 ) :: ncfile CHARACTER ( LEN = 4 ) :: cyear INTEGER :: ktau , ktauday , nday , idoy , ktaux , ktauy , nloop INTEGER , SAVE :: ndays REAL , DIMENSION ( mp ) :: cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd REAL , DIMENSION ( mp ) :: nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd REAL , DIMENSION ( mp ) :: pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd REAL , DIMENSION ( mp ) :: xcgpp , xcnpp , xnuptake , xpuptake REAL , DIMENSION ( mp ) :: xnsoilmin , xpsoillab , xpsoilsorb , xpsoilocc REAL ( r_2 ), DIMENSION ( mp ) :: xnplimit , xkNlimiting , xklitter , xksoil , xkleaf , xkleafcold , xkleafdry ! more variables to store the spinup pool size over the last 10 loops. Added by Yp Wang 30 Nov 2012 REAL , DIMENSION ( 5 , mvtype , mplant ) :: bmcplant , bmnplant , bmpplant REAL , DIMENSION ( 5 , mvtype , mlitter ) :: bmclitter , bmnlitter , bmplitter REAL , DIMENSION ( 5 , mvtype , msoil ) :: bmcsoil , bmnsoil , bmpsoil REAL , DIMENSION ( 5 , mvtype ) :: bmnsoilmin , bmpsoillab , bmpsoilsorb , bmpsoilocc REAL , DIMENSION ( mvtype ) :: bmarea INTEGER nptx , nvt , kloop REAL ( dp ) :: StemNPP ( mp , 2 ) INTEGER :: stat ( MPI_STATUS_SIZE ) INTEGER :: ierr , rank INTEGER :: yyyy ktauday = INT ( 2 4.0 * 360 0.0 / dels ) nday = ( kend - kstart + 1 ) / ktauday myearspin = CABLE_USER % YEAREND - CABLE_USER % YEARSTART + 1 yyyy = CABLE_USER % YEARSTART - 1 DO nyear = 1 , myearspin DO idoy = 1 , mdyear ktau = ( idoy - 1 ) * ktauday + 1 CALL MPI_Recv ( MPI_BOTTOM , 1 , casa_dump_t , 0 , idoy , icomm , stat , ierr ) CALL biogeochem ( ktau , dels , idoy , LALLOC , veg , soil , casabiome , casapool , casaflux , & casamet , casabal , phen , POP , climate , xnplimit , xkNlimiting , xklitter , & xksoil , xkleaf , xkleafcold , xkleafdry ,& cleaf2met , cleaf2str , croot2met , croot2str , cwood2cwd , & nleaf2met , nleaf2str , nroot2met , nroot2str , nwood2cwd , & pleaf2met , pleaf2str , proot2met , proot2str , pwood2cwd ) ! accumulate annual variables for use in POP IF ( idoy == 1 ) THEN casaflux % stemnpp = casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7 ! (assumes 70% of wood NPP is allocated above ground) casabal % LAImax = casamet % glai casabal % Cleafmean = casapool % cplant (:, 1 ) / REAL ( mdyear ) / 100 0. casabal % Crootmean = casapool % cplant (:, 3 ) / REAL ( mdyear ) / 100 0. ELSE casaflux % stemnpp = casaflux % stemnpp + casaflux % cnpp * casaflux % fracCalloc (:, 2 ) * 0.7 casabal % LAImax = MAX ( casamet % glai , casabal % LAImax ) casabal % Cleafmean = casabal % Cleafmean + casapool % cplant (:, 1 ) / REAL ( mdyear ) / 100 0. casabal % Crootmean = casabal % Crootmean + casapool % cplant (:, 3 ) / REAL ( mdyear ) / 100 0. ENDIF IF ( idoy == mdyear ) THEN ! end of year WRITE ( wlogn , * ) 'b4 MPI_SEND,casa_LUC_t' , casapool % cplant (:, 2 ) CALL flush ( wlogn ) CALL MPI_Send ( MPI_BOTTOM , 1 , casa_LUC_t , 0 , 0 , ocomm , ierr ) WRITE ( wlogn , * ) 'after MPI_SEND,casa_LUC_t' , casapool % cplant (:, 2 ) CALL flush ( wlogn ) StemNPP (:, 1 ) = casaflux % stemnpp StemNPP (:, 2 ) = 0.0 CALL MPI_Comm_rank ( icomm , rank , ierr ) WRITE ( wlogn , * ) WRITE ( wlogn , * ), 'rank receiving pop_grid from master' , rank !!$           write(wlogn,*) 'b4 MPI_Recv, pop_t cmass: ', POP%pop_grid%cmass_sum !!$           write(wlogn,*) 'b4 MPI_Recv, pop_t LU: ', POP%pop_grid%LU CALL MPI_Recv ( POP % pop_grid ( 1 ), POP % np , pop_t , 0 , 0 , icomm , stat , ierr ) !!$           write(wlogn,*) !!$           write(wlogn,*) 'after MPI_Recv, pop_t cmass: ', POP%pop_grid%cmass_sum WRITE ( wlogn , * ) 'after MPI_Recv, pop_t ' CALL flush ( wlogn ) IF ( cable_user % CALL_POP . AND . POP % np . GT . 0 ) THEN ! CALL_POP WRITE ( wlogn , * ), 'b4  POPdriver' , POP % pop_grid % cmass_sum CALL POPdriver ( casaflux , casabal , veg , POP ) ENDIF !!$           write(wlogn,*) !!$           write(wlogn,*) 'after POPstep cmass: ', POP%pop_grid%cmass_sum WRITE ( wlogn , * ) 'after POPstep ' , POP % pop_grid % cmass_sum CALL flush ( wlogn ) CALL worker_send_pop ( POP , ocomm ) WRITE ( wlogn , * ) 'after worker_send_pop' CALL flush ( wlogn ) ENDIF ENDDO ! receive updates to CASA pools resulting from LUC WRITE ( wlogn , * ) WRITE ( wlogn , * ) 'b4 mpi_recv casa_LUC_t ' CALL MPI_Recv ( MPI_BOTTOM , 1 , casa_LUC_t , 0 , nyear , icomm , stat , ierr ) WRITE ( wlogn , * ) 'after mpi_recv casa_LUC_t: ' ENDDO END SUBROUTINE WORKER_CASAONLY_LUC END MODULE cable_mpiworker","tags":"","loc":"sourcefile/cable_mpiworker.f90.html"},{"title":"cable_LUC_EXPT.F90 – CABLE","text":"Contents Modules CABLE_LUC_EXPT Source Code cable_LUC_EXPT.F90 Source Code MODULE CABLE_LUC_EXPT USE netcdf USE casa_ncdf_module , ONLY : HANDLE_ERR , GET_UNIT USE CABLE_COMMON_MODULE , ONLY : IS_LEAPYEAR , LEAP_DAY USE cable_IO_vars_module , ONLY : logn , land_x , land_y , landpt , latitude , longitude USE cable_def_types_mod , ONLY : mland , r_2 IMPLICIT NONE TYPE LUC_INPUT_TYPE REAL , DIMENSION (:), ALLOCATABLE :: VAL !  INTEGER :: YEAR END TYPE LUC_INPUT_TYPE TYPE LUC_EXPT_TYPE CHARACTER ( len = 200 ) :: TransitionFilePath , ClimateFile , Run LOGICAL :: DirectRead , READrst , WRITErst LOGICAL , ALLOCATABLE :: prim_only (:) LOGICAL , ALLOCATABLE :: ptos (:), ptog (:), stog (:), gtos (:) INTEGER , ALLOCATABLE :: ivegp (:) INTEGER , ALLOCATABLE :: biome (:) INTEGER :: YearStart , YearEnd , nfile INTEGER :: CTSTEP REAL , ALLOCATABLE :: primaryf (:), mtemp_min20 (:), grass (:), secdf (:) CHARACTER ( len = 200 ), DIMENSION ( 9 ) :: TransFile CHARACTER ( len = 12 ) , DIMENSION ( 9 ) :: VAR_NAME INTEGER , DIMENSION ( 9 ) :: F_ID , V_ID TYPE ( LUC_INPUT_TYPE ), DIMENSION ( 9 ) :: INPUT INTEGER :: YEAR , ydimsize , xdimsize , nrec , FirstYear END TYPE LUC_EXPT_TYPE TYPE ( LUC_EXPT_TYPE ), SAVE :: LUC_EXPT INTEGER , PARAMETER :: & ptos = 1 , & ptog = 2 , & stog = 3 , & gtos = 4 , & grassfrac = 5 , & primffrac = 6 , & pharv = 7 , & smharv = 8 , & syharv = 9 CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! CALBE_LUC_EXPT routines !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ============================================================================== SUBROUTINE LUC_EXPT_INIT ( LUC_EXPT ) IMPLICIT NONE TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT REAL :: tmparr ( 720 , 360 ), tmp INTEGER :: t , i , ii , k , x , y , realk INTEGER :: fID , vID , timID , latID , lonID , tdimsize , xdimsize , ydimsize INTEGER :: xds , yds , tds INTEGER :: STATUS , iu CHARACTER ( len = 15 ) :: Run CHARACTER ( len = 200 ) :: TransitionFilePath , ClimateFile LOGICAL :: DirectRead INTEGER :: YearStart , YearEnd REAL , ALLOCATABLE :: tmpvec (:), tmparr3 (:,:,:) NAMELIST / LUCNML / TransitionFilePath , ClimateFile , Run , DirectRead , YearStart , YearEnd ALLOCATE ( LUC_EXPT % prim_only ( mland ) ) ALLOCATE ( LUC_EXPT % ivegp ( mland ) ) ALLOCATE ( LUC_EXPT % biome ( mland ) ) ALLOCATE ( LUC_EXPT % ptos ( mland ) ) ALLOCATE ( LUC_EXPT % ptog ( mland ) ) ALLOCATE ( LUC_EXPT % stog ( mland ) ) ALLOCATE ( LUC_EXPT % gtos ( mland ) ) ALLOCATE ( LUC_EXPT % primaryf ( mland ) ) ALLOCATE ( LUC_EXPT % secdf ( mland ) ) ALLOCATE ( LUC_EXPT % grass ( mland ) ) ALLOCATE ( LUC_EXPT % mtemp_min20 ( mland ) ) ! READ LUC_EXPT settings CALL GET_UNIT ( iu ) OPEN ( iu , FILE = \"LUC.nml\" , STATUS = 'OLD' , ACTION = 'READ' ) READ ( iu , NML = LUCNML ) CLOSE ( iu ) LUC_EXPT % TransitionFilePath = TransitionFilePath LUC_EXPT % ClimateFile = ClimateFile LUC_EXPT % DirectRead = DirectRead LUC_EXPT % YearStart = YearStart LUC_EXPT % YearEnd = YearEnd WRITE ( * , * ) \"================== LUC_EXPT  ============\" WRITE ( * , * ) \"LUC_EXPT settings chosen:\" WRITE ( * , * ) \" TransitionFilePath: \" , TRIM ( LUC_EXPT % TransitionFilePath ) WRITE ( * , * ) \" ClimateFile       : \" , TRIM ( LUC_EXPT % ClimateFile ) ! Transition Filenames and variables LUC_EXPT % TransFile ( 1 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/ptos.nc\" LUC_EXPT % TransFile ( 2 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/ptog.nc\" LUC_EXPT % TransFile ( 3 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/stog.nc\" LUC_EXPT % TransFile ( 4 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/gtos.nc\" LUC_EXPT % TransFile ( 5 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/grass.nc\" LUC_EXPT % TransFile ( 6 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/primaryf.nc\" LUC_EXPT % TransFile ( 7 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/pharv.nc\" LUC_EXPT % TransFile ( 8 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/smharv.nc\" LUC_EXPT % TransFile ( 9 ) = TRIM ( LUC_EXPT % TransitionFilePath ) // \"/syharv.nc\" LUC_EXPT % VAR_NAME ( 1 ) = 'ptos' LUC_EXPT % VAR_NAME ( 2 ) = 'ptog' LUC_EXPT % VAR_NAME ( 3 ) = 'stog' LUC_EXPT % VAR_NAME ( 4 ) = 'gtos' LUC_EXPT % VAR_NAME ( 5 ) = 'grass' LUC_EXPT % VAR_NAME ( 6 ) = 'primaryf' LUC_EXPT % VAR_NAME ( 7 ) = 'pharv' LUC_EXPT % VAR_NAME ( 8 ) = 'smharv' LUC_EXPT % VAR_NAME ( 9 ) = 'syharv' LUC_EXPT % nfile = 9 DO x = 1 , LUC_EXPT % nfile ALLOCATE ( LUC_EXPT % INPUT ( x )% VAL ( mland ) ) END DO ! OPEN LUC INPUT FILES DO i = 1 , LUC_EXPT % nfile WRITE ( * , * ) 'LUC input data file: ' , LUC_EXPT % TransFile ( i ) WRITE ( logn , * ) 'LUC input data file: ' , LUC_EXPT % TransFile ( i ) STATUS = NF90_OPEN ( TRIM ( LUC_EXPT % TransFile ( i )), NF90_NOWRITE , LUC_EXPT % F_ID ( i )) CALL HANDLE_ERR ( STATUS , \"Opening LUH2 file \" // LUC_EXPT % TransFile ( i ) ) STATUS = NF90_INQ_VARID ( LUC_EXPT % F_ID ( i ), TRIM ( LUC_EXPT % VAR_NAME ( i )), LUC_EXPT % V_ID ( i )) CALL HANDLE_ERR ( STATUS , \"Inquiring LUC_EXPT var \" // TRIM ( LUC_EXPT % VAR_NAME ( i )) // & \" in \" // LUC_EXPT % TransFile ( i ) ) ! inquire dimensions IF ( i . EQ . 1 ) THEN FID = LUC_EXPT % F_ID ( i ) STATUS = NF90_INQ_DIMID ( FID , 'lat' , latID ) STATUS = NF90_INQUIRE_DIMENSION ( FID , latID , len = ydimsize ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'lat'\" // TRIM ( LUC_EXPT % TransFile ( i ))) LUC_EXPT % ydimsize = ydimsize STATUS = NF90_INQ_DIMID ( FID , 'lon' , lonID ) STATUS = NF90_INQUIRE_DIMENSION ( FID , lonID , len = xdimsize ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'lon'\" // TRIM ( LUC_EXPT % TransFile ( i ))) LUC_EXPT % xdimsize = xdimsize STATUS = NF90_INQ_DIMID ( FID , 'time' , timID ) STATUS = NF90_INQUIRE_DIMENSION ( FID , timID , len = tdimsize ) CALL HANDLE_ERR ( STATUS , \"Inquiring 'time'\" // TRIM ( LUC_EXPT % TransFile ( i ))) LUC_EXPT % nrec = tdimsize !!$          STATUS = NF90_GET_VAR( Luc_expt%f_id(i), timID, tmp, & !!$               start=(/1,1,1/) ) !!$          CALL HANDLE_ERR(STATUS, \"Reading from \"//LUC_EXPT%TransFile(i) ) xds = LUC_EXPT % xdimsize yds = LUC_EXPT % ydimsize ENDIF !write(*,*) 'length LUH2 data: ', tdimsize ENDDO LUC_EXPT % FirstYEAR = 850 ! Set internal counter LUC_EXPT % CTSTEP = 1 + LUC_EXPT % YearStart - LUC_EXPT % FirstYEAR ! READ initial states i = grassfrac IF ( LUC_EXPT % DirectRead ) THEN DO k = 1 , mland STATUS = NF90_GET_VAR ( LUC_EXPT % F_ID ( i ), LUC_EXPT % V_ID ( i ), tmp , & start = ( / land_x ( k ), land_y ( k ), LUC_EXPT % CTSTEP / ) ) CALL HANDLE_ERR ( STATUS , \"Reading direct from \" // LUC_EXPT % TransFile ( i ) ) LUC_EXPT % grass ( k ) = tmp END DO ELSE STATUS = NF90_GET_VAR ( LUC_EXPT % F_ID ( i ), LUC_EXPT % V_ID ( i ), tmparr , & start = ( / 1 , 1 , LUC_EXPT % CTSTEP / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // LUC_EXPT % TransFile ( i ) ) DO k = 1 , mland LUC_EXPT % grass ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF i = primffrac IF ( LUC_EXPT % DirectRead ) THEN DO k = 1 , mland STATUS = NF90_GET_VAR ( LUC_EXPT % F_ID ( i ), LUC_EXPT % V_ID ( i ), tmp , & start = ( / land_x ( k ), land_y ( k ), LUC_EXPT % CTSTEP / ) ) CALL HANDLE_ERR ( STATUS , \"Reading direct from \" // LUC_EXPT % TransFile ( i ) ) LUC_EXPT % primaryf ( k ) = tmp END DO ELSE STATUS = NF90_GET_VAR ( LUC_EXPT % F_ID ( i ), LUC_EXPT % V_ID ( i ), tmparr , & start = ( / 1 , 1 , LUC_EXPT % CTSTEP / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // LUC_EXPT % TransFile ( i ) ) DO k = 1 , mland LUC_EXPT % primaryf ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) END DO ENDIF LUC_EXPT % grass = MIN ( LUC_EXPT % grass , 1.0 ) LUC_EXPT % primaryf = MIN ( LUC_EXPT % primaryf , 1.0 - LUC_EXPT % grass ) LUC_EXPT % secdf = MAX (( 1.0 - LUC_EXPT % grass - LUC_EXPT % primaryf ), 0.0 ) CALL READ_ClimateFile ( LUC_EXPT ) ! hot desert WHERE ( LUC_EXPT % biome . EQ . 15 ) LUC_EXPT % ivegp = 14 ENDWHERE WHERE ( LUC_EXPT % biome . EQ . 3 . OR . LUC_EXPT % biome . EQ . 11 ) ! savanna/ xerophytic woods LUC_EXPT % grass = LUC_EXPT % grass + ( LUC_EXPT % primaryf + LUC_EXPT % secdf ) * 1.0 / 2.0 LUC_EXPT % primaryf = LUC_EXPT % primaryf * 1.0 / 2.0 LUC_EXPT % secdf = LUC_EXPT % secdf * 1.0 / 2.0 ELSEWHERE ( LUC_EXPT % biome . EQ . 12 . OR . LUC_EXPT % biome . EQ . 13 & ! shrub . OR . LUC_EXPT % biome . EQ . 15 . OR . LUC_EXPT % biome . EQ . 16 ) LUC_EXPT % grass = LUC_EXPT % grass + ( LUC_EXPT % primaryf + LUC_EXPT % secdf ) * 4.0 / 5.0 LUC_EXPT % primaryf = LUC_EXPT % primaryf * 1.0 / 5.0 LUC_EXPT % secdf = LUC_EXPT % secdf * 1.0 / 5.0 ELSEWHERE ( LUC_EXPT % biome . EQ . 7 . OR . LUC_EXPT % biome . EQ . 8 & ! boreal . OR . LUC_EXPT % biome . EQ . 9 . OR . LUC_EXPT % biome . EQ . 10 ) LUC_EXPT % grass = LUC_EXPT % grass + ( LUC_EXPT % primaryf + LUC_EXPT % secdf ) * 1.0 / 5.0 LUC_EXPT % primaryf = LUC_EXPT % primaryf * 4.0 / 5.0 LUC_EXPT % secdf = LUC_EXPT % secdf * 4.0 / 5.0 ELSEWHERE ( LUC_EXPT % biome . EQ . 5 . OR . LUC_EXPT % biome . EQ . 6 ) ! DBL LUC_EXPT % grass = LUC_EXPT % grass + ( LUC_EXPT % primaryf + LUC_EXPT % secdf ) * 0.3 LUC_EXPT % primaryf = LUC_EXPT % primaryf * 0.7 LUC_EXPT % secdf = LUC_EXPT % secdf * 0.7 END WHERE ! READ transitions from primary to see if primary remains primary LUC_EXPT % prim_only = . TRUE . IF (. NOT . ALLOCATED ( tmpvec )) ALLOCATE ( tmpvec ( tdimsize )) IF (. NOT . ALLOCATED ( tmparr3 )) ALLOCATE ( tmparr3 ( xds , yds , tdimsize )) DO i = 1 , 2 ! ptos and ptog IF ( LUC_EXPT % DirectRead ) THEN DO k = 1 , mland STATUS = NF90_GET_VAR ( LUC_EXPT % F_ID ( i ), LUC_EXPT % V_ID ( i ), tmpvec , & start = ( / land_x ( k ), land_y ( k ), 1 / ), & count = ( / 1 , 1 , tdimsize / ) ) CALL HANDLE_ERR ( STATUS , \"Reading direct from \" // LUC_EXPT % TransFile ( i ) ) !IF (sum(tmpvec).gt.1e-3 .OR. LUC_EXPT%primaryf(k).lt.0.99) LUC_EXPT%prim_only(k) = .FALSE. IF ( SUM ( tmpvec ). GT . 1e-3 ) LUC_EXPT % prim_only ( k ) = . FALSE . END DO ELSE STATUS = NF90_GET_VAR ( LUC_EXPT % F_ID ( i ), LUC_EXPT % V_ID ( i ), tmparr3 , & start = ( / 1 , 1 , 1 / ), count = ( / xds , yds , tdimsize / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // LUC_EXPT % TransFile ( i ) ) DO k = 1 , mland tmpvec = tmparr3 ( land_x ( k ), land_y ( k ) , :) ! IF (sum(tmpvec).gt.1e-3.OR. LUC_EXPT%primaryf(k).lt.0.99) LUC_EXPT%prim_only(k) = .FALSE. IF ( SUM ( tmpvec ). GT . 1e-3 ) LUC_EXPT % prim_only ( k ) = . FALSE . END DO ENDIF END DO ! set secondary vegetation area to be zero where land use transitions don't occur ! set grass component of primary vegetation cover WHERE ( LUC_EXPT % prim_only . EQV . . TRUE .) LUC_EXPT % secdf = 0.0 LUC_EXPT % primaryf = 1.0 LUC_EXPT % grass = 0.0 WHERE ( LUC_EXPT % biome . EQ . 3 . OR . LUC_EXPT % biome . EQ . 11 ) ! savanna/ xerophytic woods LUC_EXPT % grass = LUC_EXPT % primaryf * 1.0 / 2.0 LUC_EXPT % primaryf = LUC_EXPT % primaryf * 1.0 / 2.0 ELSEWHERE ( LUC_EXPT % biome . EQ . 12 . OR . LUC_EXPT % biome . EQ . 13 & . OR . LUC_EXPT % biome . EQ . 15 . OR . LUC_EXPT % biome . EQ . 16 ) ! shrub LUC_EXPT % grass = LUC_EXPT % primaryf * 4.0 / 5.0 LUC_EXPT % primaryf = LUC_EXPT % primaryf * 1.0 / 5.0 ELSEWHERE ( LUC_EXPT % biome . EQ . 7 . OR . LUC_EXPT % biome . EQ . 8 & . OR . LUC_EXPT % biome . EQ . 9 . OR . LUC_EXPT % biome . EQ . 10 ) ! boreal LUC_EXPT % grass = LUC_EXPT % primaryf * 1.0 / 5.0 LUC_EXPT % primaryf = LUC_EXPT % primaryf * 4.0 / 5.0 ELSEWHERE ( LUC_EXPT % biome . EQ . 5 . OR . LUC_EXPT % biome . EQ . 6 ) ! DBL LUC_EXPT % grass = LUC_EXPT % primaryf * 0.3 LUC_EXPT % primaryf = LUC_EXPT % primaryf * 0.7 END WHERE END WHERE !!$    WHERE (LUC_EXPT%ivegp == 14) !!$       LUC_EXPT%prim_only = .TRUE. !!$    END WHERE END SUBROUTINE LUC_EXPT_INIT ! ============================================================================== SUBROUTINE LUC_EXPT_SET_TILES ( inVeg , inPfrac , LUC_EXPT ) IMPLICIT NONE INTEGER , INTENT ( INOUT ) :: inVeg (:,:,:) REAL , INTENT ( INOUT ) :: inPFrac (:,:,:) TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT INTEGER :: k , m , n DO k = 1 , mland m = landpt ( k )% ilon n = landpt ( k )% ilat IF ( inVeg ( m , n , 1 ). LT . 11 ) THEN ! vegetated IF ( LUC_EXPT % prim_only ( k ) ) THEN inVeg ( m , n , 1 ) = LUC_EXPT % ivegp ( k ) inVeg ( m , n , 2 : 3 ) = 0 inPFrac ( m , n , 2 : 3 ) = 0 inPFrac ( m , n , 1 ) = 1.0 IF ( LUC_EXPT % grass ( k ) . GT . 0.01 ) THEN IF ( LUC_EXPT % mtemp_min20 ( k ). LE . 1 5.5 ) THEN inVeg ( m , n , 2 ) = 6 ! C3 grass ELSE inVeg ( m , n , 2 ) = 7 ! C4 grass ENDIF inPFrac ( m , n , 1 ) = MIN ( LUC_EXPT % primaryf ( k ), 1.0 ) inPFrac ( m , n , 2 ) = 1.0 - MIN ( LUC_EXPT % primaryf ( k ), 1.0 ) ENDIF ELSEIF ((. NOT . LUC_EXPT % prim_only ( k )) ) THEN inVeg ( m , n , 1 ) = LUC_EXPT % ivegp ( k ) inVeg ( m , n , 2 ) = LUC_EXPT % ivegp ( k ) IF ( LUC_EXPT % mtemp_min20 ( k ). LE . 1 5.5 ) THEN inVeg ( m , n , 3 ) = 6 ! C3 grass ELSE inVeg ( m , n , 3 ) = 7 ! C4 grass ENDIF inPFrac ( m , n , 1 ) = MIN ( LUC_EXPT % primaryf ( k ), 1.0 ) inPFrac ( m , n , 2 ) = MIN ( LUC_EXPT % secdf ( k ), 1.0 ) inPFrac ( m , n , 3 ) = 1.0 - inPFrac ( m , n , 1 ) - inPFrac ( m , n , 2 ) ENDIF ELSE LUC_EXPT % prim_only ( k ) = . TRUE . ENDIF ! don't consider LUC events in desert or tundra IF ( inveg ( m , n , 1 ) == 14 . OR . inveg ( m , n , 1 ) == 8 ) THEN LUC_EXPT % prim_only ( k ) = . TRUE . LUC_EXPT % primaryf ( k ) = 1.0 LUC_EXPT % secdf ( k ) = 0.0 LUC_EXPT % grass ( k ) = 0.0 inPFrac ( m , n , 1 ) = 1.0 inPFrac ( m , n , 2 : 3 ) = 0.0 inVeg ( m , n , 2 : 3 ) = 0 ENDIF ENDDO 991 FORMAT ( 1166 ( e12 . 4 , 2 x )) END SUBROUTINE LUC_EXPT_SET_TILES ! ============================================================================== SUBROUTINE READ_ClimateFile ( LUC_EXPT ) USE netcdf IMPLICIT NONE TYPE ( LUC_EXPT_type ), INTENT ( INOUT ) :: LUC_EXPT ! climate variables INTEGER * 4 :: mp4 INTEGER * 4 , PARAMETER :: pmp4 = 0 INTEGER , PARAMETER :: fmp4 = KIND ( pmp4 ) INTEGER * 4 :: STATUS INTEGER * 4 :: FILE_ID , land_ID , nyear_ID , nday_ID , dID , i , land_dim CHARACTER :: CYEAR * 4 , FNAME * 99 , dum * 50 ! 0 dim arrays CHARACTER ( len = 20 ), DIMENSION ( 2 ) :: A0 ! 1 dim arrays (npt ) CHARACTER ( len = 20 ), DIMENSION ( 3 ) :: A1 ! 1 dim arrays (integer) (npt ) CHARACTER ( len = 20 ), DIMENSION ( 2 ) :: AI1 REAL ( r_2 ), DIMENSION ( mland ) :: LAT , LON , TMP INTEGER * 4 :: TMPI ( mland ), TMPI0 LOGICAL :: EXISTFILE mp4 = INT ( mland , fmp4 ) A0 ( 1 ) = 'nyears' A0 ( 2 ) = 'year' A1 ( 1 ) = 'latitude' A1 ( 2 ) = 'longitude' A1 ( 3 ) = 'mtemp_min20' AI1 ( 1 ) = 'iveg' AI1 ( 2 ) = 'biome' fname = TRIM ( LUC_EXPT % ClimateFile ) INQUIRE ( FILE = TRIM ( fname ), EXIST = EXISTFILE ) IF ( . NOT . EXISTFILE ) THEN WRITE ( * , * ) fname , ' does not exist!!' ELSE WRITE ( * , * ) 'reading biome from : ' , fname ENDIF ! Open NetCDF file: STATUS = NF90_OPEN ( fname , NF90_NOWRITE , FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! dimensions: ! Land (number of points) STATUS = NF90_INQ_DIMID ( FILE_ID , 'land' , dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQUIRE_DIMENSION ( FILE_ID , dID , LEN = land_dim ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) IF ( land_dim . NE . mland ) THEN WRITE ( * , * ) \"Dimension misfit, \" , fname WRITE ( * , * ) \"land_dim\" , land_dim STOP ENDIF ! LAT & LON STATUS = NF90_INQ_VARID ( FILE_ID , A1 ( 1 ), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , LAT ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_INQ_VARID ( FILE_ID , A1 ( 2 ), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , LON ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) ! READ 1-dimensional real fields DO i = 3 , SIZE ( A1 ) STATUS = NF90_INQ_VARID ( FILE_ID , A1 ( i ), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , TMP ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) SELECT CASE ( TRIM ( A1 ( i ))) CASE ( 'mtemp_min20' ) ; LUC_EXPT % mtemp_min20 = TMP END SELECT END DO ! READ 1-dimensional integer fields DO i = 1 , SIZE ( AI1 ) WRITE ( * , * ) TRIM ( AI1 ( i )) STATUS = NF90_INQ_VARID ( FILE_ID , AI1 ( i ), dID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) STATUS = NF90_GET_VAR ( FILE_ID , dID , TMPI ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) SELECT CASE ( TRIM ( AI1 ( i ))) CASE ( 'iveg' ) ; LUC_EXPT % ivegp = TMPI CASE ( 'biome' ) ; LUC_EXPT % biome = TMPI END SELECT END DO ! non-woody potential vegetation not considered to undergo LU change WHERE ( LUC_EXPT % ivegp . GT . 5 ) LUC_EXPT % prim_only = . TRUE . ENDWHERE ! Close NetCDF file: STATUS = NF90_close ( FILE_ID ) IF ( STATUS /= NF90_noerr ) CALL handle_err ( STATUS ) END SUBROUTINE READ_CLIMATEFILE ! ============================================================================== SUBROUTINE READ_LUH2 ( LUC_EXPT ) IMPLICIT NONE TYPE ( LUC_EXPT_TYPE ), INTENT ( INOUT ) :: LUC_EXPT REAL :: tmp REAL , ALLOCATABLE :: tmparr (:,:) INTEGER :: t , i , ii , k , x , y , realk INTEGER :: fid , vid , tid INTEGER :: xds , yds , tds INTEGER :: STATUS , iu yds = LUC_EXPT % ydimsize xds = LUC_EXPT % xdimsize t = LUC_EXPT % CTSTEP IF (. NOT . ALLOCATED ( tmparr )) ALLOCATE ( tmparr ( xds , yds )) IF ( t . LE . LUC_EXPT % nrec ) THEN DO i = 1 , LUC_EXPT % nfile IF ( LUC_EXPT % DirectRead ) THEN DO k = 1 , mland STATUS = NF90_GET_VAR ( LUC_EXPT % F_ID ( i ), LUC_EXPT % V_ID ( i ), tmp , & start = ( / land_x ( k ), land_y ( k ), t / ) ) CALL HANDLE_ERR ( STATUS , \"Reading direct from \" // LUC_EXPT % TransFile ( i ) ) LUC_EXPT % INPUT ( i )% VAL ( k ) = tmp END DO ELSE STATUS = NF90_GET_VAR ( LUC_EXPT % F_ID ( i ), LUC_EXPT % V_ID ( i ), tmparr , & start = ( / 1 , 1 , t / ), count = ( / xds , yds , 1 / ) ) CALL HANDLE_ERR ( STATUS , \"Reading from \" // LUC_EXPT % TransFile ( i ) ) DO k = 1 , mland LUC_EXPT % INPUT ( i )% VAL ( k ) = tmparr ( land_x ( k ), land_y ( k ) ) IF ( LUC_EXPT % INPUT ( i )% VAL ( k ). GT . 1.0 ) THEN LUC_EXPT % INPUT ( i )% VAL ( k ) = 0.0 ENDIF END DO ENDIF ENDDO ELSE WRITE ( * , * ) 'warning: past end of LUH2 record' ENDIF ! Adjust transition areas based on primary wooded fraction WHERE ( LUC_EXPT % biome . EQ . 3 . OR . LUC_EXPT % biome . EQ . 11 ) ! savanna/ xerophytic woods LUC_EXPT % INPUT ( ptos )% VAL = LUC_EXPT % INPUT ( ptos )% VAL * 1.0 / 2.0 LUC_EXPT % INPUT ( ptog )% VAL = LUC_EXPT % INPUT ( ptog )% VAL * 1.0 / 2.0 LUC_EXPT % INPUT ( gtos )% VAL = LUC_EXPT % INPUT ( gtos )% VAL * 1.0 / 2.0 LUC_EXPT % INPUT ( stog )% VAL = LUC_EXPT % INPUT ( stog )% VAL * 1.0 / 2.0 ELSEWHERE ( LUC_EXPT % biome . EQ . 12 . OR . LUC_EXPT % biome . EQ . 13 & . OR . LUC_EXPT % biome . EQ . 15 . OR . LUC_EXPT % biome . EQ . 16 ) ! shrub LUC_EXPT % INPUT ( ptos )% VAL = LUC_EXPT % INPUT ( ptos )% VAL * 1.0 / 5.0 LUC_EXPT % INPUT ( ptog )% VAL = LUC_EXPT % INPUT ( ptog )% VAL * 1.0 / 5.0 LUC_EXPT % INPUT ( gtos )% VAL = LUC_EXPT % INPUT ( gtos )% VAL * 1.0 / 5.0 LUC_EXPT % INPUT ( stog )% VAL = LUC_EXPT % INPUT ( stog )% VAL * 1.0 / 5.0 ELSEWHERE ( LUC_EXPT % biome . EQ . 7 . OR . LUC_EXPT % biome . EQ . 8 & . OR . LUC_EXPT % biome . EQ . 9 . OR . LUC_EXPT % biome . EQ . 10 ) ! boreal LUC_EXPT % INPUT ( ptos )% VAL = LUC_EXPT % INPUT ( ptos )% VAL * 0.8 LUC_EXPT % INPUT ( ptog )% VAL = LUC_EXPT % INPUT ( ptog )% VAL * 0.8 LUC_EXPT % INPUT ( gtos )% VAL = LUC_EXPT % INPUT ( gtos )% VAL * 0.8 LUC_EXPT % INPUT ( stog )% VAL = LUC_EXPT % INPUT ( stog )% VAL * 0.8 ELSEWHERE ( LUC_EXPT % biome . EQ . 5 . OR . LUC_EXPT % biome . EQ . 6 ) ! DBL LUC_EXPT % INPUT ( ptos )% VAL = LUC_EXPT % INPUT ( ptos )% VAL * 0.7 LUC_EXPT % INPUT ( ptog )% VAL = LUC_EXPT % INPUT ( ptog )% VAL * 0.7 LUC_EXPT % INPUT ( gtos )% VAL = LUC_EXPT % INPUT ( gtos )% VAL * 0.7 LUC_EXPT % INPUT ( stog )% VAL = LUC_EXPT % INPUT ( stog )% VAL * 0.7 ENDWHERE END SUBROUTINE READ_LUH2 ! ============================================================================== END MODULE CABLE_LUC_EXPT","tags":"","loc":"sourcefile/cable_luc_expt.f90.html"},{"title":"cable_write.F90 – CABLE","text":"Contents Modules cable_write_module Source Code cable_write.F90 Source Code !============================================================================== ! This source code is part of the ! Australian Community Atmosphere Biosphere Land Exchange (CABLE) model. ! This work is licensed under the CSIRO Open Source Software License ! Agreement (variation of the BSD / MIT License). ! ! You may not use this file except in compliance with this License. ! A copy of the License (CSIRO_BSD_MIT_License_v2.0_CABLE.txt) is located ! in each directory containing CABLE code. ! ! ============================================================================== ! Purpose: Writing routines for CABLE offline ! ! Contact: Bernard.Pak@csiro.au ! ! History: No significant changes since v1.4b except addition of extra variables ! ! ! ============================================================================== ! ! CALLed from:    cable_initialise.F90 !                 cable_input.F90 ! ! MODULEs used:   cable_abort_module !                 cable_def_types_mod !                 cable_IO_vars_module !                 netcdf ! ! CALLs:          define_output_variable_r1 !                 define_output_variable_r2 !                 define_output_parameter_r1 !                 define_output_parameter_r2 !                 write_output_variable_r1 !                 write_output_variable_r2 !                 write_output_parameter_r1 !                 write_output_parameter_r1d !                 write_output_parameter_r2 !                 write_output_parameter_r2d ! ! ! ! Notes: Single precision netcdf writes are forced to single precision here !        (using REAL(,4)) in case of compilation with -r8 MODULE cable_write_module USE cable_abort_module USE cable_def_types_mod USE cable_IO_vars_module , ONLY : landpt , patch , max_vegpatches , parID_type , & metGrid , land_x , land_y , logn , output , & xdimsize , ydimsize , check , mask USE netcdf IMPLICIT NONE PRIVATE PUBLIC define_ovar , write_ovar , otmp1 , otmp1l , otmp2lt , otmp2xy , otmp2lp , & otmp2ls , otmp2lpc , otmp2lsc , otmp2lsf , otmp2lr , otmp2lsn , otmp3xyt , & otmp3lpt , otmp3lst , otmp3lsnt , otmp3lrt , otmp3lpct , otmp3lsct , & otmp3xyp , otmp3xys , otmp3xypc , otmp3xysc , otmp3lps , otmp3lppc , & otmp3lpsc , otmp3xysf , otmp3lpr , otmp3lpsn , otmp4xypt , otmp4xyzt , & otmp4xyst , otmp4xysnt , otmp4xyrt , otmp4xypct , otmp4xysct , otmp4lpst , & otmp4lpsnt , otmp4lprt , otmp4lpsct , otmp4lppct , otmp4xyps , & otmp4xyppc , otmp4xypsc , otmp5xypst , otmp5xypsnt , otmp5xyprt , & otmp5xyppct , otmp5xypsct , nullify_write INTERFACE define_ovar ! Defines an output variable in the output netcdf file. Units, long name, ! variable, dimensions etc are created. MODULE PROCEDURE define_output_variable_r1 MODULE PROCEDURE define_output_variable_r2 MODULE PROCEDURE define_output_parameter_r1 MODULE PROCEDURE define_output_parameter_r2 END INTERFACE INTERFACE write_ovar ! Writes a single time step of an output variable to the output netcdf ! file MODULE PROCEDURE write_output_variable_r1 MODULE PROCEDURE write_output_variable_r2 MODULE PROCEDURE write_output_parameter_r1 MODULE PROCEDURE write_output_parameter_r1d MODULE PROCEDURE write_output_parameter_r2 MODULE PROCEDURE write_output_parameter_r2d END INTERFACE INTEGER :: ncmissingi = - 9999999 INTEGER :: ok ! netcdf file read status ! Temporary variables of same dimension as variables in netcdf file; ! e.g. 'o'utput 'tmp'orary with '2' dimensions: 'l'and and 't'ime -> otmp2lt ! Other dimension abbrevs: 'x','y','z','p'atch,'s'oil,'sn'ow, ! 'r'adiation,'p'lant 'c'arbon,'s'oil 'c'arbon,'s'urface 'f'raction REAL , POINTER , DIMENSION (:) :: otmp1 , otmp1l REAL , POINTER , DIMENSION (:, :) :: otmp2lt , otmp2xy , otmp2lp , otmp2ls , & otmp2lpc , otmp2lsc , otmp2lsf , & otmp2lr , otmp2lsn REAL , POINTER , DIMENSION (:, :, :) :: otmp3xyt , otmp3lpt , otmp3lst , & otmp3lsnt , otmp3lrt , otmp3lpct , & otmp3lsct , otmp3xyp , otmp3xys , & otmp3xypc , otmp3xysc , otmp3lps , & otmp3lppc , otmp3lpsc , otmp3xysf , & otmp3lpr , otmp3lpsn , otmp3xyr REAL , POINTER , DIMENSION (:, :, :, :) :: otmp4xypt , otmp4xyzt , & otmp4xyst , otmp4xysnt , & otmp4xyrt , otmp4xypct , & otmp4xysct , otmp4lpst , & otmp4lpsnt , otmp4lprt , & otmp4lpsct , otmp4lppct , & otmp4xyps , otmp4xyppc , & otmp4xypsc , otmp4xypr REAL , POINTER , DIMENSION (:, :, :, :, :) :: otmp5xypst , otmp5xypsnt , & otmp5xyprt , otmp5xyppct , & otmp5xypsct REAL :: ncmissingr = - 1.0e+33 CONTAINS ! Nullify all temporary pointers so that one can query associated(pointer) SUBROUTINE nullify_write () IMPLICIT NONE NULLIFY ( otmp1 ) NULLIFY ( otmp1l ) NULLIFY ( otmp2lt ) NULLIFY ( otmp2xy ) NULLIFY ( otmp2lp ) NULLIFY ( otmp2ls ) NULLIFY ( otmp2lpc ) NULLIFY ( otmp2lsc ) NULLIFY ( otmp2lsf ) NULLIFY ( otmp2lr ) NULLIFY ( otmp2lsn ) NULLIFY ( otmp3xyt ) NULLIFY ( otmp3lpt ) NULLIFY ( otmp3lst ) NULLIFY ( otmp3lsnt ) NULLIFY ( otmp3lrt ) NULLIFY ( otmp3lpct ) NULLIFY ( otmp3lsct ) NULLIFY ( otmp3xyp ) NULLIFY ( otmp3xys ) NULLIFY ( otmp3xypc ) NULLIFY ( otmp3xysc ) NULLIFY ( otmp3lps ) NULLIFY ( otmp3lppc ) NULLIFY ( otmp3lpsc ) NULLIFY ( otmp3xysf ) NULLIFY ( otmp3lpr ) NULLIFY ( otmp3lpsn ) NULLIFY ( otmp3xyr ) NULLIFY ( otmp4xypt ) NULLIFY ( otmp4xyzt ) NULLIFY ( otmp4xyst ) NULLIFY ( otmp4xysnt ) NULLIFY ( otmp4xyrt ) NULLIFY ( otmp4xypct ) NULLIFY ( otmp4xysct ) NULLIFY ( otmp4lpst ) NULLIFY ( otmp4lpsnt ) NULLIFY ( otmp4lprt ) NULLIFY ( otmp4lpsct ) NULLIFY ( otmp4lppct ) NULLIFY ( otmp4xyps ) NULLIFY ( otmp4xyppc ) NULLIFY ( otmp4xypsc ) NULLIFY ( otmp4xypr ) NULLIFY ( otmp5xypst ) NULLIFY ( otmp5xypsnt ) NULLIFY ( otmp5xyprt ) NULLIFY ( otmp5xyppct ) NULLIFY ( otmp5xypsct ) END SUBROUTINE nullify_write SUBROUTINE define_output_variable_r1 ( ncid , varID , vname , & vunits , longname , writepatch , & dimswitch , xID , yID , zID , landID , & patchID , tID ) ! Subroutine for defining a real valued 1D variable INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( OUT ) :: varID ! variable's netcdf ID ! netcdf dimension IDs INTEGER , INTENT ( IN ) :: xID , yID , zID , landID , patchID , tID LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? CHARACTER ( LEN =* ), INTENT ( IN ) :: vname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: vunits ! variable units CHARACTER ( LEN =* ), INTENT ( IN ) :: longname ! full variable name CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter ! First, decide which grid to use. If user has forced grid using output%grid ! in the namelist file, use this grid. Else use format of met file. IF ( output % grid ( 1 : 3 ) == 'mas' . OR . & ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'mask' ) . OR . & output % grid ( 1 : 3 ) == 'ALM' ) THEN ! Should patch-specific info be written for this variable ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . & (. NOT . output % grid ( 1 : 3 ) == 'ALM' )) THEN WRITE ( logn , * ) 'Writing ' // vname // & ' to output file using mask grid with patch-specific info' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / xID , yID , patchID , tID / ), & varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(INTERFACE define_ovar)' ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF (. NOT . ASSOCIATED ( otmp4xypt )) & ALLOCATE ( otmp4xypt ( xdimsize , ydimsize , max_vegpatches , 1 )) ELSE ! only grid point values, no patch-specific info ! If this is an ALMA 4D surface variable ! AND the user has forced the grid type as ALMA: IF ( dimswitch == 'ALMA' . AND . output % grid ( 1 : 3 ) == 'ALM' ) THEN WRITE ( logn , * ) 'Writing ' // vname // ' to output file using mask grid' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / xID , yID , zID , tID / ), & varID ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF (. NOT . ASSOCIATED ( otmp4xyzt )) & ALLOCATE ( otmp4xyzt ( xdimsize , ydimsize , 1 , 1 )) ELSE ! normal x-y-t mask grid WRITE ( logn , * ) 'Writing ' // vname // ' to output file using mask grid' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / xID , yID , tID / ), varID ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF (. NOT . ASSOCIATED ( otmp3xyt )) ALLOCATE ( otmp3xyt ( xdimsize , ydimsize , 1 )) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(INTERFACE define_ovar)' ) END IF ELSE IF ( output % grid ( 1 : 3 ) == 'lan' & . OR .( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'land' )) THEN ! Should patch-specific info be written for this variable? IF ( writepatch . OR . output % patch ) THEN WRITE ( logn , * ) 'Writing ' // vname // & ' to output file using land grid with patch-specific info' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / landID , patchID , tID / ), & varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(INTERFACE define_ovar)' ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp3lpt )) ALLOCATE ( otmp3lpt ( mland , & max_vegpatches , 1 )) ELSE ! only grid point values, no patch-specific info WRITE ( logn , * ) 'Writing ' // vname // ' to output file using land grid' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / landID , tID / ), varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(INTERFACE define_ovar)' ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp2lt )) ALLOCATE ( otmp2lt ( mland , 1 )) END IF ELSE CALL abort ( 'Unknown grid specification (INTERFACE define_ovar)' ) END IF ! Define variable units: ok = NF90_PUT_ATT ( ncid , varID , 'units' , vunits ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define long name: ok = NF90_PUT_ATT ( ncid , varID , 'long_name' , longname ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: ok = NF90_PUT_ATT ( ncid , varID , '_FillValue' , REAL ( ncmissingr , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: ok = NF90_PUT_ATT ( ncid , varID , 'missing_value' , REAL ( ncmissingr , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) END SUBROUTINE define_output_variable_r1 !============================================================================= SUBROUTINE define_output_variable_r2 ( ncid , varID , vname , vunits , longname , & writepatch , dimswitch , xID , yID , zID , & landID , patchID , othdimID , tID ) ! Subroutine for defining a real valued 2D variable INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID ! netcdf dimension IDs INTEGER , INTENT ( IN ) :: xID , yID , zID , landID , patchID , tID INTEGER , INTENT ( IN ) :: othdimID ! ID of variable's second dimension INTEGER , INTENT ( OUT ) :: varID ! variable's netcdf ID LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? CHARACTER ( LEN =* ), INTENT ( IN ) :: vname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: vunits ! variable units CHARACTER ( LEN =* ), INTENT ( IN ) :: longname ! full variable name CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter ! First, decide which grid to use. If user has forced grid using output%grid ! in the namelist file, use this grid. Else use format of met file. IF ( output % grid ( 1 : 3 ) == 'mas' . OR . & ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'mask' ) . OR . & output % grid ( 1 : 3 ) == 'ALM' ) THEN ! Should patch-specific info be written for this variable ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . & ( . NOT . output % grid ( 1 : 3 ) == 'ALM' )) THEN WRITE ( logn , * ) 'Writing ' // vname // & ' to output file using mask grid with patch-specific info' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / xID , yID , patchID , & othdimID , tID / ), varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(INTERFACE define_ovar)' ) IF ( dimswitch == 'soil' ) THEN ! other dim is soil ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp5xypst )) & ALLOCATE ( otmp5xypst ( xdimsize , ydimsize , max_vegpatches , ms , 1 )) ELSE IF ( dimswitch == 'snow' ) THEN ! other dim is snow ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp5xypsnt )) & ALLOCATE ( otmp5xypsnt ( xdimsize , ydimsize , max_vegpatches , msn , 1 )) ELSE IF ( dimswitch == 'radiation' ) THEN ! other dim is radiation bands ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp5xyprt )) & ALLOCATE ( otmp5xyprt ( xdimsize , ydimsize , max_vegpatches , nrb , 1 )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! other dim is plant carbon ! pools ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp5xyppct )) & ALLOCATE ( otmp5xyppct ( xdimsize , ydimsize , max_vegpatches , ncp , 1 )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! other dim is soil carbon pools ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp5xypsct )) & ALLOCATE ( otmp5xypsct ( xdimsize , ydimsize , max_vegpatches , ncs , 1 )) ELSE CALL abort ( 'Variable ' // vname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE define_output_variable_r2' ) END IF ELSE ! only grid point values, no patch-specific info WRITE ( logn , * ) 'Writing ' // vname // ' to output file using mask grid' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / xID , yID , othdimID , & tID / ), varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(SUBROUTINE define_output_variable_r2)' ) IF ( dimswitch == 'soil' ) THEN ! other dim is soil ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xyst )) & ALLOCATE ( otmp4xyst ( xdimsize , ydimsize , ms , 1 )) ELSE IF ( dimswitch == 'snow' ) THEN ! other dim is snow ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xysnt )) & ALLOCATE ( otmp4xysnt ( xdimsize , ydimsize , msn , 1 )) ELSE IF ( dimswitch == 'radiation' ) THEN ! other dim is radiation bands ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xyrt )) & ALLOCATE ( otmp4xyrt ( xdimsize , ydimsize , nrb , 1 )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! other dim is plant carbon ! pools ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xypct )) & ALLOCATE ( otmp4xypct ( xdimsize , ydimsize , ncp , 1 )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! other dim is soil carbon pools ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xysct )) & ALLOCATE ( otmp4xysct ( xdimsize , ydimsize , ncs , 1 )) ELSE CALL abort ( 'Variable ' // vname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE define_output_variable_r2' ) END IF END IF ELSE IF ( output % grid ( 1 : 3 ) == 'lan' & . OR . ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'land' )) THEN ! Should patch-specific info be written for this variable? IF ( writepatch . OR . output % patch ) THEN WRITE ( logn , * ) 'Writing ' // vname // & ' to output file using land grid with patch-specific info' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / landID , patchID , & othdimID , tID / ), varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(SUBROUTINE define_output_variable_r2)' ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(SUBROUTINE define_output_variable_r2)' ) IF ( dimswitch == 'soil' ) THEN ! other dim is soil ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4lpst )) & ALLOCATE ( otmp4lpst ( mland , max_vegpatches , ms , 1 )) ELSE IF ( dimswitch == 'snow' ) THEN ! other dim is snow ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xysnt )) & ALLOCATE ( otmp4xysnt ( mland , max_vegpatches , msn , 1 )) ELSE IF ( dimswitch == 'radiation' ) THEN ! other dim is radiation bands ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xyrt )) & ALLOCATE ( otmp4xyrt ( mland , max_vegpatches , nrb , 1 )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! other dim is plant carbon ! pools ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xypct )) & ALLOCATE ( otmp4xypct ( mland , max_vegpatches , ncp , 1 )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! other dim is soil carbon pools ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp4xysct )) & ALLOCATE ( otmp4xysct ( mland , max_vegpatches , ncs , 1 )) ELSE CALL abort ( 'Variable ' // vname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE define_output_variable_r2' ) END IF ELSE ! only grid point values, no patch-specific info WRITE ( logn , * ) 'Writing ' // vname // ' to output file using land grid' ok = NF90_DEF_VAR ( ncid , vname , NF90_FLOAT , ( / landID , othdimID , tID / ), & varID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable in output file. ' // & '(SUBROUTINE define_output_variable_r2)' ) IF ( dimswitch == 'soil' ) THEN ! other dim is soil ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp3lst )) ALLOCATE ( otmp3lst ( mland , ms , 1 )) ELSE IF ( dimswitch == 'snow' ) THEN ! other dim is snow ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp3lsnt )) ALLOCATE ( otmp3lsnt ( mland , msn , 1 )) ELSE IF ( dimswitch == 'radiation' ) THEN ! other dim is radiation bands ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp3lrt )) ALLOCATE ( otmp3lrt ( mland , nrb , 1 )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! other dim is plant carbon ! pools ! If not already allocated, allocate a temporary storage variable ! of this dim: IF (. NOT . ASSOCIATED ( otmp3lpct )) ALLOCATE ( otmp3lpct ( mland , ncp , 1 )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! other dim is soil carbon pools ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( . NOT . ASSOCIATED ( otmp3lsct )) ALLOCATE ( otmp3lsct ( mland , ncs , 1 )) ELSE CALL abort ( 'Variable ' // vname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE define_output_variable_r2' ) END IF END IF ELSE CALL abort ( 'Unknown grid specification (SUBROUTINE ' // & 'define_output_variable_r2)' ) END IF ! Define variable units: ok = NF90_PUT_ATT ( ncid , varID , 'units' , vunits ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable attributes in output file. ' // & '(SUBROUTINE define_output_variable_r2)' ) ! Define long name: ok = NF90_PUT_ATT ( ncid , varID , 'long_name' , longname ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable attributes in output file. ' // & '(SUBROUTINE define_output_variable_r2)' ) ! Define missing/fill values: ok = NF90_PUT_ATT ( ncid , varID , '_FillValue' , REAL ( ncmissingr , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) ! Define missing/fill values: ok = NF90_PUT_ATT ( ncid , varID , 'missing_value' , REAL ( ncmissingr , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // vname // ' variable attributes in output file. ' // & '(INTERFACE define_ovar)' ) END SUBROUTINE define_output_variable_r2 !============================================================================= SUBROUTINE define_output_parameter_r1 ( ncid , parID , pname , punits , longname , & writepatch , dimswitch , xID , yID , zID , & landID , patchID , restart ) ! Subroutine for defining a real valued 1D parameter (time invariant) INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: xID , yID , zID , landID , patchID ! netcdf ! dimension IDs INTEGER , INTENT ( OUT ) :: parID ! variable's netcdf ID LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? LOGICAL , INTENT ( IN ), OPTIONAL :: restart ! are we writing to a restart file?                                                          ! dimension IDs CHARACTER ( LEN =* ), INTENT ( IN ) :: pname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: punits ! variable units CHARACTER ( LEN =* ), INTENT ( IN ) :: longname ! full variable name CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimension of parameter ! First, decide which grid to use. If user has forced grid using output%grid ! in the namelist file, use this grid. Else use format of met file. IF (( output % grid ( 1 : 3 ) == 'mas' . OR . & ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'mask' ) . OR . & output % grid ( 1 : 3 ) == 'ALM' ) . AND . . NOT . PRESENT ( restart )) THEN ! Should patch-specific info be written for this variable ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . & (. NOT . output % grid ( 1 : 3 ) == 'ALM' )) THEN WRITE ( logn , * ) 'Writing ' // pname // & ' to output file using mask grid with patch-specific info' IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_FLOAT , ( / xID , yID , patchID / ) & , parID ) ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_INT , ( / xID , yID , patchID / ) & , parID ) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable in output file. ' // & '(SUBROUTINE define_output_parameter_r1)' ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF (. NOT . ASSOCIATED ( otmp3xyp )) & ALLOCATE ( otmp3xyp ( xdimsize , ydimsize , max_vegpatches )) ELSE ! only grid point values, no patch-specific info WRITE ( logn , * ) 'Writing ' // pname // ' to output file using mask grid' IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_FLOAT , ( / xID , yID / ), parID ) ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_INT , ( / xID , yID / ), parID ) END IF ! If not already allocated, allocate a temporary storage variable ! of this dim: IF (. NOT . ASSOCIATED ( otmp2xy )) ALLOCATE ( otmp2xy ( xdimsize , ydimsize )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable in output file. ' // & '(SUBROUTINE define_output_parameter_r1)' ) END IF ELSE IF ( output % grid ( 1 : 3 ) == 'lan' . OR . ( output % grid ( 1 : 3 ) == 'def' . AND . & metGrid == 'land' ) . OR . PRESENT ( restart )) THEN ! land-only grid ! Should patch-specific info be written for this variable? ! If this variable has been requested by user with patch-specific info ! (writepatch) OR all have been (output%patch) AND we're NOT writing ! a restart file (which uses a different technique to store patch info): IF (( writepatch . OR . output % patch ) . AND . . NOT . PRESENT ( restart )) THEN WRITE ( logn , * ) 'Writing ' // pname // & ' to output file using land grid with patch-specific info' IF ( dimswitch ( 1 : 2 ) == 're' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_FLOAT , ( / landID , patchID / ) & , parID ) ELSE IF ( dimswitch ( 1 : 2 ) == 'r2' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_DOUBLE , ( / landID , patchID / ) & , parID ) ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_INT , ( / landID , patchID / ) & , parID ) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable in output file. ' // & '(SUBROUTINE define_output_parameter_r1)' ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF (. NOT . ASSOCIATED ( otmp2lp )) ALLOCATE ( otmp2lp ( mland , max_vegpatches )) ELSE ! only grid point values without patch-specific info UNLESS a ! restart variable ! Restart file definitions will be directed to this part of interface. ! If not writing a restart file, report variable writing to log file: IF (. NOT . PRESENT ( restart )) WRITE ( logn , * ) 'Writing ' // pname // & ' to output file using land grid' IF ( dimswitch ( 1 : 2 ) == 're' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_FLOAT , ( / landID / ), parID ) ELSE IF ( dimswitch ( 1 : 2 ) == 'r2' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_DOUBLE , ( / landID / ), parID ) ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_INT , ( / landID / ), parID ) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable in output or ' // & 'restart file. (SUBROUTINE define_output_parameter_r1)' ) ! If not already allocated, allocate a temporary storage variable ! of this dimension structure: IF (. NOT . ASSOCIATED ( otmp1l )) ALLOCATE ( otmp1l ( mland )) END IF ELSE CALL abort ( 'Unknown grid specification ' // & '(SUBROUTINE define_output_parameter_r1)' ) END IF ! Define variable units: ok = NF90_PUT_ATT ( ncid , parID , 'units' , punits ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (SUBROUTINE define_output_parameter_r1)' ) ! Define long name: ok = NF90_PUT_ATT ( ncid , parID , 'long_name' , longname ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (SUBROUTINE define_output_parameter_r1)' ) ! Define missing/fill values: IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_PUT_ATT ( ncid , parID , '_FillValue' , ncmissingi ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ok = NF90_PUT_ATT ( ncid , parID , 'missing_value' , ncmissingi ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ELSE IF ( dimswitch ( 1 : 2 ) == 'r2' ) THEN ok = NF90_PUT_ATT ( ncid , parID , '_FillValue' , REAL ( ncmissingr , 8 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ok = NF90_PUT_ATT ( ncid , parID , 'missing_value' , REAL ( ncmissingr , 8 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ELSE ok = NF90_PUT_ATT ( ncid , parID , '_FillValue' , REAL ( ncmissingr , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ok = NF90_PUT_ATT ( ncid , parID , 'missing_value' , REAL ( ncmissingr , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) END IF END SUBROUTINE define_output_parameter_r1 !============================================================================= SUBROUTINE define_output_parameter_r2 ( ncid , parID , pname , punits , longname , & writepatch , othdimID , dimswitch , xID , & yID , zID , landID , patchID , restart ) ! Subroutine for defining a real valued 2D parameter (time invariant) INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: othdimID ! ID of parameter's second dimension INTEGER , INTENT ( IN ) :: xID , yID , zID , landID , patchID ! netcdf ! dimension IDs INTEGER , INTENT ( OUT ) :: parID ! variable's netcdf ID LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? LOGICAL , INTENT ( IN ), OPTIONAL :: restart ! are we writing to a restart file? CHARACTER ( LEN =* ), INTENT ( IN ) :: pname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: punits ! variable units CHARACTER ( LEN =* ), INTENT ( IN ) :: longname ! full variable name CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter ! First, decide which grid to use. If user has forced grid using output%grid ! in the namelist file, use this grid. Else use format of met file. IF (( output % grid ( 1 : 3 ) == 'mas' . OR . & ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'mask' ) . OR . & output % grid ( 1 : 3 ) == 'ALM' ) . AND . . NOT . PRESENT ( restart )) THEN ! Should patch-specific info be written for this variable ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . (. NOT . output % grid ( 1 : 3 ) & == 'ALM' ) . AND .( dimswitch /= 'surftype' )) THEN WRITE ( logn , * ) 'Writing ' // pname // & ' to output file using mask grid with patch-specific info' ok = NF90_DEF_VAR ( ncid , pname , NF90_FLOAT , ( / xID , yID , patchID , & othdimID / ), parID ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable in output file. ' // & '(SUBROUTINE define_output_parameter_r2)' ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( dimswitch == 'soil' . OR . dimswitch == 'r2soil' ) THEN IF (. NOT . ASSOCIATED ( otmp4xyps )) & ALLOCATE ( otmp4xyps ( xdimsize , ydimsize , max_vegpatches , ms )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN IF (. NOT . ASSOCIATED ( otmp4xyppc )) & ALLOCATE ( otmp4xyppc ( xdimsize , ydimsize , max_vegpatches , ncp )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN IF (. NOT . ASSOCIATED ( otmp4xypsc )) & ALLOCATE ( otmp4xypsc ( xdimsize , ydimsize , max_vegpatches , ncs )) ELSE IF ( dimswitch == 'radiation' ) THEN IF (. NOT . ASSOCIATED ( otmp4xypr )) & ALLOCATE ( otmp4xypr ( xdimsize , ydimsize , max_vegpatches , nrb )) END IF ELSE ! only grid point values, no patch-specific info WRITE ( logn , * ) 'Writing ' // pname // ' to output file using mask grid' ok = NF90_DEF_VAR ( ncid , pname , NF90_FLOAT , ( / xID , yID , othdimID / ) & , parID ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( dimswitch == 'soil' . OR . dimswitch == 'r2soil' ) THEN IF (. NOT . ASSOCIATED ( otmp3xys )) ALLOCATE ( otmp3xys ( xdimsize , & ydimsize , ms )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN IF (. NOT . ASSOCIATED ( otmp3xypc )) & ALLOCATE ( otmp3xypc ( xdimsize , ydimsize , ncp )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN IF (. NOT . ASSOCIATED ( otmp3xysc )) & ALLOCATE ( otmp3xysc ( xdimsize , ydimsize , ncs )) ELSE IF ( dimswitch == 'radiation' ) THEN IF (. NOT . ASSOCIATED ( otmp3xyr )) & ALLOCATE ( otmp3xyr ( xdimsize , ydimsize , nrb )) ELSE IF ( dimswitch == 'surftype' ) THEN IF (. NOT . ASSOCIATED ( otmp3xysf )) ALLOCATE ( otmp3xysf ( xdimsize , & ydimsize , 4 )) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable in output file. ' // & '(SUBROUTINE define_output_parameter_r2)' ) END IF ELSE IF ( output % grid ( 1 : 3 ) == 'lan' . OR . ( output % grid ( 1 : 3 ) == 'def' & . AND . metGrid == 'land' ) . OR . PRESENT ( restart )) THEN ! Should patch-specific info be written for this variable? ! If this variable has been requested by user with patch-specific info ! (writepatch) OR all have been (output%patch) AND we're NOT writing ! a restart file (which uses a different technique to store patch info): IF (( writepatch . OR . output % patch ) . AND . ( dimswitch /= 'surftype' ) & . AND . . NOT . PRESENT ( restart )) THEN WRITE ( logn , * ) 'Writing ' // pname // & ' to output file using land grid with patch-specific info' ! Define parameter as double precision if required: IF ( dimswitch ( 1 : 2 ) == 'r2' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_DOUBLE , ( / landID , patchID , & othdimID / ), parID ) ELSE ok = NF90_DEF_VAR ( ncid , pname , NF90_FLOAT , ( / landID , patchID , & othdimID / ), parID ) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable in output file. ' // & '(SUBROUTINE define_output_parameter_r2)' ) ! If not already allocated, allocate a temporary storage variable ! of this dim: IF ( dimswitch == 'soil' . OR . dimswitch == 'r2soil' ) THEN IF (. NOT . ASSOCIATED ( otmp3lps )) ALLOCATE ( otmp3lps ( mland , & max_vegpatches , ms )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN IF (. NOT . ASSOCIATED ( otmp3lppc )) & ALLOCATE ( otmp3lppc ( mland , max_vegpatches , ncp )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN IF (. NOT . ASSOCIATED ( otmp3lpsc )) & ALLOCATE ( otmp3lpsc ( mland , max_vegpatches , ncs )) ELSE IF ( dimswitch == 'radiation' ) THEN IF (. NOT . ASSOCIATED ( otmp3lpr )) & ALLOCATE ( otmp3lpr ( mland , max_vegpatches , nrb )) ELSE IF ( dimswitch == 'snow' ) THEN IF (. NOT . ASSOCIATED ( otmp3lpsn )) & ALLOCATE ( otmp3lpsn ( mland , max_vegpatches , msn )) END IF ELSE ! variable has no explicit patch dimension (incl. restart file) ! Restart file definitions will be directed to this part of interface. ! If not writing a restart file, report variable writing to log file: IF (. NOT . PRESENT ( restart )) WRITE ( logn , * ) 'Writing ' // pname // & ' to output file using land grid' ! Define parameter as double precision if required for restart file: IF ( dimswitch ( 1 : 2 ) == 'r2' ) THEN ok = NF90_DEF_VAR ( ncid , pname , NF90_DOUBLE ,( / landID , othdimID / ), parID ) ELSE ok = NF90_DEF_VAR ( ncid , pname , NF90_FLOAT ,( / landID , othdimID / ), parID ) END IF IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable in output file. ' // & '(SUBROUTINE define_output_parameter_r2)' ) ! If not already allocated, allocate a temporary storage variable ! of this dimension structure: IF ( dimswitch == 'soil' . OR . dimswitch == 'r2soil' ) THEN IF (. NOT . ASSOCIATED ( otmp2ls )) ALLOCATE ( otmp2ls ( mland , ms )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN IF (. NOT . ASSOCIATED ( otmp2lpc )) ALLOCATE ( otmp2lpc ( mland , ncp )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN IF (. NOT . ASSOCIATED ( otmp2lsc )) ALLOCATE ( otmp2lsc ( mland , ncs )) ELSE IF ( dimswitch == 'radiation' ) THEN IF (. NOT . ASSOCIATED ( otmp2lr )) ALLOCATE ( otmp2lr ( mland , nrb )) ELSE IF ( dimswitch == 'snow' ) THEN IF (. NOT . ASSOCIATED ( otmp2lsn )) ALLOCATE ( otmp2lsn ( mland , msn )) ELSE IF ( dimswitch == 'surftype' ) THEN IF (. NOT . ASSOCIATED ( otmp2lsf )) ALLOCATE ( otmp2lsf ( mland , 4 )) END IF END IF ELSE CALL abort ( 'Unknown grid specification ' // & '(SUBROUTINE define_output_parameter_r2)' ) END IF ! Define variable units: ok = NF90_PUT_ATT ( ncid , parID , 'units' , punits ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (SUBROUTINE define_output_parameter_r2)' ) ! Define long name: ok = NF90_PUT_ATT ( ncid , parID , 'long_name' , longname ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (SUBROUTINE define_output_parameter_r2)' ) ! Define missing/fill values: IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_PUT_ATT ( ncid , parID , '_FillValue' , ncmissingi ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ok = NF90_PUT_ATT ( ncid , parID , 'missing_value' , ncmissingi ) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ELSE IF ( dimswitch ( 1 : 2 ) == 'r2' ) THEN ok = NF90_PUT_ATT ( ncid , parID , '_FillValue' , REAL ( ncmissingr , 8 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ok = NF90_PUT_ATT ( ncid , parID , 'missing_value' , REAL ( ncmissingr , 8 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ELSE ok = NF90_PUT_ATT ( ncid , parID , '_FillValue' , REAL ( ncmissingr , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) ok = NF90_PUT_ATT ( ncid , parID , 'missing_value' , REAL ( ncmissingr , 4 )) IF ( ok /= NF90_NOERR ) CALL nc_abort & ( ok , 'Error defining ' // pname // ' variable attributes in ' // & 'output file. (INTERFACE define_ovar)' ) END IF END SUBROUTINE define_output_parameter_r2 !============================================================================= SUBROUTINE write_output_variable_r1 ( ktau , ncid , varID , vname , var_r1 , & vrange , writepatch , dimswitch , met ) ! Subroutine for writing a real valued 1D variable INTEGER , INTENT ( IN ) :: ktau ! current time step # INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: varID ! variable's netcdf ID REAL ( KIND = 4 ), DIMENSION (:), INTENT ( IN ) :: var_r1 ! variable values REAL , DIMENSION ( 2 ), INTENT ( IN ) :: vrange ! max and min for variable ! error checking LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? CHARACTER ( LEN =* ), INTENT ( IN ) :: vname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter TYPE ( met_type ), INTENT ( IN ) :: met ! met data INTEGER :: i , j ! do loop counter ! First, decide which grid to use. If user has forced grid using output%grid ! in the namelist file, use this grid. Else use format of met file. IF ( output % grid ( 1 : 3 ) == 'mas' . OR . & ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'mask' ) . OR . & output % grid ( 1 : 3 ) == 'ALM' ) THEN ! Should patch-specific info be written for this variable ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . (. NOT . output % grid ( 1 : 3 ) & == 'ALM' )) THEN DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp4xypt ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , 1 ) & = var_r1 ( landpt ( i )% cstart : landpt ( i )% cend ) ! Then write data for inactive patches (if any) as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4xypt ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , landpt ( i )% nap ! only check active patches IF (( otmp4xypt ( land_x ( i ), land_y ( i ), j , 1 ) < vrange ( 1 )) . OR . & ( otmp4xypt ( land_x ( i ), land_y ( i ), j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' ,& ktau , met , otmp4xypt ( land_x ( i ), land_y ( i ), j , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches WHERE ( mask /= 1 ) otmp4xypt (:, :, j , 1 ) = ncmissingr ! not land END DO ! write data to file ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4xypt (:, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , max_vegpatches , 1 / )) ELSE ! only grid point values, no patch-specific info ! If this is an ALMA 4D surface variable ! AND the user has forced the grid type as ALMA: IF ( dimswitch == 'ALMA' . AND . output % grid ( 1 : 3 ) == 'ALM' ) THEN DO i = 1 , mland ! over all land grid points ! Write to temporary variable (area weighted average across all ! patches): otmp4xyzt ( land_x ( i ), land_y ( i ), 1 , 1 ) = & SUM ( var_r1 ( landpt ( i )% cstart : & landpt ( i )% cend ) * patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) IF ( check % ranges ) THEN ! Check ranges: IF (( otmp4xyzt ( land_x ( i ), land_y ( i ), 1 , 1 ) < vrange ( 1 )) . OR . & ( otmp4xyzt ( land_x ( i ), land_y ( i ), 1 , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4xyzt ( land_x ( i ), land_y ( i ), 1 , 1 ), vrange , i , & land_x ( i ), land_y ( i )) END IF END DO ! Fill non-land points with dummy value: WHERE ( mask /= 1 ) otmp4xyzt (:, :, 1 , 1 ) = ncmissingr ! not land ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4xyzt , 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , 1 , 1 / )) ! write data to file ELSE ! normal x-y-t mask grid DO i = 1 , mland ! over all land grid points ! Write to temporary variable (area weighted average across all ! patches): otmp3xyt ( land_x ( i ), land_y ( i ), 1 ) = SUM ( var_r1 ( landpt ( i )% cstart : & landpt ( i )% cend ) * patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) IF ( check % ranges ) THEN ! Check ranges: IF (( otmp3xyt ( land_x ( i ), land_y ( i ), 1 ) < vrange ( 1 )) . OR . & ( otmp3xyt ( land_x ( i ), land_y ( i ), 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp3xyt ( land_x ( i ), land_y ( i ), 1 ), vrange , i , & land_x ( i ), land_y ( i )) END IF END DO ! Fill non-land points with dummy value: WHERE ( mask /= 1 ) otmp3xyt (:, :, 1 ) = ncmissingr ! not land ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp3xyt , 4 ), & start = ( / 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , 1 / )) ! write data to file END IF END IF ELSE IF ( output % grid ( 1 : 3 ) == 'lan' & . OR . ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'land' )) THEN ! Should patch-specific info be written for this variable? IF ( writepatch . OR . output % patch ) THEN DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp3lpt ( i , 1 : landpt ( i )% nap , 1 ) = & var_r1 ( landpt ( i )% cstart : landpt ( i )% cend ) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) & otmp3lpt ( i , ( landpt ( i )% nap + 1 ): max_vegpatches , 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap IF (( otmp3lpt ( i , j , 1 ) < vrange ( 1 )) . OR . & ( otmp3lpt ( i , j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp3lpt ( i , j , 1 ), vrange , i ) END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp3lpt (:, :, 1 ), 4 ), & start = ( / 1 , 1 , ktau / ), count = ( / mland , max_vegpatches , 1 / )) ELSE ! only grid point values, no patch-specific info DO i = 1 , mland ! over all land grid points ! Write to temporary variable (area weighted average across all ! patches): otmp2lt ( i , 1 ) = SUM ( var_r1 ( landpt ( i )% cstart : & landpt ( i )% cend ) * patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) IF ( check % ranges ) THEN ! Check ranges: IF (( otmp2lt ( i , 1 ) < vrange ( 1 )) . OR . & ( otmp2lt ( i , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp2lt ( i , 1 ), vrange , i ) END IF END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp2lt , 4 ), & start = ( / 1 , ktau / ), count = ( / mland , 1 / )) ! write data to file END IF ELSE CALL abort ( 'Unknown grid specification ' // & '(SUBROUTINE write_output_variable_r1)' ) END IF ! Check writing was successful: IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing ' // vname // & ' variable to output file (SUBROUTINE write_output_variable_r1)' ) END SUBROUTINE write_output_variable_r1 !============================================================================= SUBROUTINE write_output_variable_r2 ( ktau , ncid , varID , vname , var_r2 , & vrange , writepatch , dimswitch , met ) ! Subroutine for writing a real valued 2D variable INTEGER , INTENT ( IN ) :: ktau ! current time step # INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: varID ! variable's netcdf ID REAL ( KIND = 4 ), DIMENSION (:, :), INTENT ( IN ) :: var_r2 ! variable values REAL , DIMENSION ( 2 ), INTENT ( IN ) :: vrange ! max and min for variable ! error checking LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? CHARACTER ( LEN =* ), INTENT ( IN ) :: vname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter TYPE ( met_type ), INTENT ( IN ) :: met ! met data INTEGER :: i , j , k ! do loop counter ! First, decide which grid to use. If user has forced grid using output%grid ! in the namelist file, use this grid. Else use format of met file. IF ( output % grid ( 1 : 3 ) == 'mas' . OR . & ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'mask' ) . OR . & output % grid ( 1 : 3 ) == 'ALM' ) THEN ! Should patch-specific info be written for this variable ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . (. NOT . output % grid ( 1 : 3 ) & == 'ALM' )) THEN ! Decide what the second dimension of this variable is: IF ( dimswitch == 'soil' ) THEN ! other dim is soil DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp5xypst ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :, 1 ) & = var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches (if any) as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp5xypst ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches ,:, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , ms IF (( otmp5xypst ( land_x ( i ), land_y ( i ), j , k , 1 ) < vrange ( 1 )) & . OR . ( otmp5xypst ( land_x ( i ), land_y ( i ), j , k , 1 ) > vrange ( 2 )))& CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp5xypst ( land_x ( i ), land_y ( i ), j , k , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , ms WHERE ( mask /= 1 ) otmp5xypst (:, :, j , k , 1 ) = ncmissingr ! not land END DO END DO ! Write data to file: ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp5xypst (:, :, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , max_vegpatches , ms , 1 / )) ELSE IF ( dimswitch == 'snow' ) THEN ! other dim is snow DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp5xypsnt ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :, 1 ) & = var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp5xypsnt ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , msn IF (( otmp5xypsnt ( land_x ( i ), land_y ( i ), j , k , 1 ) < vrange ( 1 )) & . OR . ( otmp5xypsnt ( land_x ( i ), land_y ( i ), j , k , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp5xypsnt ( land_x ( i ), land_y ( i ), j , k , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , msn ! not land WHERE ( mask /= 1 ) otmp5xypsnt (:, :, j , k , 1 ) = ncmissingr END DO END DO ! Write data to file: ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp5xypsnt (:, :, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , max_vegpatches , msn , 1 / )) ELSE IF ( dimswitch == 'radiation' ) THEN ! other dim is radiation bands DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp5xyprt ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :, 1 ) & = var_r2 ( landpt ( i )% cstart : landpt ( i )% cend ,:) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp5xyprt ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , nrb IF (( otmp5xyprt ( land_x ( i ), land_y ( i ), j , k , 1 ) < vrange ( 1 )) & . OR . ( otmp5xyprt ( land_x ( i ), land_y ( i ), j , k , 1 ) > & vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp5xyprt ( land_x ( i ), land_y ( i ), j , k , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , nrb ! not land WHERE ( mask /= 1 ) otmp5xyprt (:, :, j , k , 1 ) = ncmissingr END DO END DO ! Write data to file: ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp5xyprt (:, :, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , max_vegpatches , nrb , 1 / )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! other dim is plant carbon ! pools DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp5xyppct ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :, 1 ) & = var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches (if any) as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp5xyppct ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , ncp IF (( otmp5xyppct ( land_x ( i ), land_y ( i ), j , k , 1 ) < vrange ( 1 )) & . OR . ( otmp5xyppct ( land_x ( i ), land_y ( i ), j , k , 1 ) > & vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp5xyppct ( land_x ( i ), land_y ( i ), j , k , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , ncp ! not land WHERE ( mask /= 1 ) otmp5xyppct (:, :, j , k , 1 ) = ncmissingr END DO END DO ! Write data to file: ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp5xyppct (:, :, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , max_vegpatches , ncp , 1 / )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! other dim is soil carbon pools DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp5xypsct ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :, 1 ) & = var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp5xypsct ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , ncs IF (( otmp5xypsct ( land_x ( i ), land_y ( i ), j , k , 1 ) < vrange ( 1 )) & . OR . ( otmp5xypsct ( land_x ( i ), land_y ( i ), j , k , 1 ) > & vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp5xypsct ( land_x ( i ), land_y ( i ), j , k , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , ncs ! not land WHERE ( mask /= 1 ) otmp5xypsct (:, :, j , k , 1 ) = ncmissingr END DO END DO ! Write data to file: ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp5xypsct (:, :, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , max_vegpatches , ncs , 1 / )) ELSE CALL abort ( 'Variable ' // vname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in INTERFACE write_ovar' ) END IF ELSE ! only grid point values, no patch-specific info ! Decide what the second dimension of this variable is: IF ( dimswitch == 'soil' ) THEN ! other dim is soil DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by ! fraction): DO j = 1 , ms otmp4xyst ( land_x ( i ), land_y ( i ), j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , ms IF (( otmp4xyst ( land_x ( i ), land_y ( i ), j , 1 ) < vrange ( 1 )) . OR . & ( otmp4xyst ( land_x ( i ), land_y ( i ), j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4xyst ( land_x ( i ), land_y ( i ), j , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , ms WHERE ( mask /= 1 ) otmp4xyst (:, :, j , 1 ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4xyst , 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , ms , 1 / )) ! write data to file ELSE IF ( dimswitch == 'snow' ) THEN ! other dim is snow DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by ! fraction): DO j = 1 , msn otmp4xysnt ( land_x ( i ), land_y ( i ), j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , msn IF (( otmp4xysnt ( land_x ( i ), land_y ( i ), j , 1 ) < vrange ( 1 )) . OR . & ( otmp4xysnt ( land_x ( i ), land_y ( i ), j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4xysnt ( land_x ( i ), land_y ( i ), j , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , msn WHERE ( mask /= 1 ) otmp4xysnt (:, :, j , 1 ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4xysnt , 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , msn , 1 / )) ! write data to file ELSE IF ( dimswitch == 'radiation' ) THEN ! other dim is radiation bands DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by ! fraction): DO j = 1 , nrb otmp4xyrt ( land_x ( i ), land_y ( i ), j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , nrb IF (( otmp4xyrt ( land_x ( i ), land_y ( i ), j , 1 ) < vrange ( 1 )) . OR . & ( otmp4xyrt ( land_x ( i ), land_y ( i ), j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4xyrt ( land_x ( i ), land_y ( i ), j , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , nrb WHERE ( mask /= 1 ) otmp4xyrt (:, :, j , 1 ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4xyrt , 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , nrb , 1 / )) ! write data to file ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! other dim is plant carbon ! pools DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by fraction): DO j = 1 , ncp otmp4xypct ( land_x ( i ), land_y ( i ), j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , ncp IF (( otmp4xypct ( land_x ( i ), land_y ( i ), j , 1 ) < vrange ( 1 )) . OR . & ( otmp4xypct ( land_x ( i ), land_y ( i ), j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4xypct ( land_x ( i ), land_y ( i ), j , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , ncp WHERE ( mask /= 1 ) otmp4xypct (:, :, j , 1 ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4xypct , 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , ncp , 1 / )) ! write data to file ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! other dim is soil carbon pools DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by fraction): DO j = 1 , ncs otmp4xysct ( land_x ( i ), land_y ( i ), j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , ncs IF (( otmp4xysct ( land_x ( i ), land_y ( i ), j , 1 ) < vrange ( 1 )) . OR . & ( otmp4xysct ( land_x ( i ), land_y ( i ), j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4xysct ( land_x ( i ), land_y ( i ), j , 1 ), & vrange , i , land_x ( i ), land_y ( i )) END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , ncs WHERE ( mask /= 1 ) otmp4xysct (:, :, j , 1 ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4xysct , 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / xdimsize , ydimsize , ncs , 1 / )) ! write data to file ELSE CALL abort ( 'Variable ' // vname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in INTERFACE write_ovar' ) END IF END IF ELSE IF ( output % grid ( 1 : 3 ) == 'lan' & . OR .( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'land' )) THEN ! Should patch-specific info be written for this variable ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . (. NOT . output % grid ( 1 : 3 ) & == 'ALM' )) THEN ! Decide what the second dimension of this variable is: IF ( dimswitch == 'soil' ) THEN ! other dim is soil DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp4lpst ( i , 1 : landpt ( i )% nap , :, 1 ) & = var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches (if any) as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4lpst ( i , & ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , ms IF (( otmp4lpst ( i , j , k , 1 ) < vrange ( 1 )) . OR . & ( otmp4lpst ( i , j , k , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4lpst ( i , j , k , 1 ), vrange , i ) END DO END DO END IF END DO ! Write data to file: ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4lpst (:, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / mland , max_vegpatches , ms , 1 / )) ELSE IF ( dimswitch == 'snow' ) THEN ! other dim is snow DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp4lpsnt ( i , 1 : landpt ( i )% nap , :, 1 ) = & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4lpsnt ( i , & ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , msn IF (( otmp4lpsnt ( i , j , k , 1 ) < vrange ( 1 )) . OR . & ( otmp4lpsnt ( i , j , k , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4lpsnt ( i , j , k , 1 ), vrange , i ) END DO END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4lpsnt (:, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / mland , max_vegpatches , msn , 1 / )) ELSE IF ( dimswitch == 'radiation' ) THEN ! other dim is radiation bands DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp4lprt ( i , 1 : landpt ( i )% nap , :, 1 ) = & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4lprt ( i , & ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , nrb IF (( otmp4lprt ( i , j , k , 1 ) < vrange ( 1 )) . OR . & ( otmp4lprt ( i , j , k , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4lprt ( i , j , k , 1 ), vrange , i ) END DO END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4lprt (:, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / mland , max_vegpatches , nrb , 1 / )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! other dim is plant carbon ! pools DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp4lppct ( i , 1 : landpt ( i )% nap , :, 1 ) = & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4lppct ( i , & ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , ncp IF (( otmp4lppct ( i , j , k , 1 ) < vrange ( 1 )) . OR . & ( otmp4lppct ( i , j , k , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4lppct ( i , j , k , 1 ), vrange , i ) END DO END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4lppct (:, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / mland , max_vegpatches , ncp , 1 / )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! other dim is soil carbon pools DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp4lpsct ( i , 1 : landpt ( i )% nap , :, 1 ) = & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4lpsct ( i , & ( landpt ( i )% nap + 1 ): max_vegpatches , :, 1 ) = ncmissingr IF ( check % ranges ) THEN ! Check ranges for active patches: DO j = 1 , landpt ( i )% nap DO k = 1 , ncs IF (( otmp4lpsct ( i , j , k , 1 ) < vrange ( 1 )) . OR . & ( otmp4lpsct ( i , j , k , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp4lpsct ( i , j , k , 1 ), vrange , i ) END DO END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp4lpsct (:, :, :, 1 ), 4 ), & start = ( / 1 , 1 , 1 , ktau / ), & count = ( / mland , max_vegpatches , ncs , 1 / )) ELSE CALL abort ( 'Variable ' // vname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in INTERFACE write_ovar' ) END IF ELSE ! only grid point values, no patch-specific info ! Decide what the second dimension of this variable is: IF ( dimswitch == 'soil' ) THEN ! other dim is soil DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by ! fraction): DO j = 1 , ms otmp3lst ( i , j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , ms IF (( otmp3lst ( i , j , 1 ) < vrange ( 1 )) . OR . & ( otmp3lst ( i , j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp3lst ( i , j , 1 ), vrange , i ) END DO END IF END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp3lst , 4 ), & start = ( / 1 , 1 , ktau / ), & count = ( / mland , ms , 1 / )) ! write data to file ELSE IF ( dimswitch == 'snow' ) THEN ! other dim is snow DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by ! fraction): DO j = 1 , msn otmp3lsnt ( i , j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , msn IF (( otmp3lsnt ( i , j , 1 ) < vrange ( 1 )) . OR . & ( otmp3lsnt ( i , j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp3lsnt ( i , j , 1 ), vrange , i ) END DO END IF END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp3lsnt , 4 ), & start = ( / 1 , 1 , ktau / ), & count = ( / mland , msn , 1 / )) ! write data to file ELSE IF ( dimswitch == 'radiation' ) THEN ! other dim is radiation bands DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by fraction): DO j = 1 , nrb otmp3lrt ( i , j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , nrb IF (( otmp3lrt ( i , j , 1 ) < vrange ( 1 )) . OR . & ( otmp3lrt ( i , j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp3lrt ( i , j , 1 ), vrange , i ) END DO END IF END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp3lrt , 4 ), & start = ( / 1 , 1 , ktau / ), & count = ( / mland , nrb , 1 / )) ! write data to file ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! other dim is plant carbon ! pools DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by fraction): DO j = 1 , ncp otmp3lpct ( i , j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , ncp IF (( otmp3lpct ( i , j , 1 ) < vrange ( 1 )) . OR . & ( otmp3lpct ( i , j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp3lpct ( i , j , 1 ), vrange , i ) END DO END IF END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp3lpct , 4 ), & start = ( / 1 , 1 , ktau / ), & count = ( / mland , ncp , 1 / )) ! write data to file ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! other dim is soil carbon pools DO i = 1 , mland ! over all land grid points ! Write to temporary variable (sum over patches & weight by fraction): DO j = 1 , ncs otmp3lsct ( i , j , 1 ) = SUM ( & var_r2 ( landpt ( i )% cstart : landpt ( i )% cend , j ) * & patch ( landpt ( i )% cstart : landpt ( i )% cend )% frac ) END DO IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , ncs IF (( otmp3lsct ( i , j , 1 ) < vrange ( 1 )) . OR . & ( otmp3lsct ( i , j , 1 ) > vrange ( 2 ))) & CALL range_abort ( vname // ' is out of specified ranges!' , & ktau , met , otmp3lsct ( i , j , 1 ), vrange , i ) END DO END IF END DO ok = NF90_PUT_VAR ( ncid , varID , REAL ( otmp3lsct , 4 ), & start = ( / 1 , 1 , ktau / ), & count = ( / mland , ncs , 1 / )) ! write data to file ELSE CALL abort ( 'Variable ' // vname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE write_output_variable_r2' ) END IF END IF ! patch info or no patch info ELSE CALL abort ( 'Unknown grid specification ' // & '(SUBROUTINE write_output_variable_r2)' ) END IF ! grid type ! Check writing was successful: IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing ' // vname // & ' variable to output file (SUBROUTINE write_output_variable_r2)' ) END SUBROUTINE write_output_variable_r2 !============================================================================= SUBROUTINE write_output_parameter_r1 ( ncid , parID , pname , par_r1 , & prange , writepatch , dimswitch , restart ) ! Subroutine for writing a real valued 1D parameter (time invariant) INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: parID ! variable's netcdf ID REAL ( KIND = 4 ), DIMENSION (:), INTENT ( IN ) :: par_r1 ! variable values REAL , DIMENSION ( 2 ), INTENT ( IN ) :: prange ! max and min for variable ! error checking LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? LOGICAL , INTENT ( IN ), OPTIONAL :: restart ! are we writing to a restart file? CHARACTER ( LEN =* ), INTENT ( IN ) :: pname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter INTEGER :: i , j ! do loop counter ! First, decide which grid to use. If user has forced grid using output%grid ! in the namelist file, use this grid. Else use format of met file. IF (( output % grid ( 1 : 3 ) == 'mas' . OR . & ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'mask' ) . OR . & output % grid ( 1 : 3 ) == 'ALM' ) . AND . . NOT . PRESENT ( restart )) THEN ! Should patch-specific info be written for this parameter ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . (. NOT . output % grid ( 1 : 3 ) & == 'ALM' )) THEN DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp3xyp ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap ) & = par_r1 ( landpt ( i )% cstart : landpt ( i )% cend ) ! Then write data for inactive patches as dummy value: IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN IF ( landpt ( i )% nap < max_vegpatches ) otmp3xyp ( land_x ( i ), land_y ( i ),& ( landpt ( i )% nap + 1 ): max_vegpatches ) = ncmissingr ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN IF ( landpt ( i )% nap < max_vegpatches ) otmp3xyp ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches ) = ncmissingi END IF IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF (( otmp3xyp ( land_x ( i ), land_y ( i ), j ) < prange ( 1 )) . OR . & ( otmp3xyp ( land_x ( i ), land_y ( i ), j ) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Value: ' , otmp3xyp ( land_x ( i ), land_y ( i ), j ) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! Write data to file: IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches WHERE ( mask /= 1 ) otmp3xyp (:, :, j ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3xyp (:, :, :), 4 ), & start = ( / 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , max_vegpatches / )) ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches WHERE ( mask /= 1 ) otmp3xyp (:, :, j ) = ncmissingi ! not land END DO ok = NF90_PUT_VAR ( ncid , parID , INT ( otmp3xyp (:, :, :)), & start = ( / 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , max_vegpatches / )) END IF ELSE ! only grid point values, no patch-specific info DO i = 1 , mland ! over all land grid points ! Write to temporary variable. Use dominant patch info only, ! as averaging parameters over patches wouldn't make nec sense: otmp2xy ( land_x ( i ), land_y ( i )) = par_r1 ( landpt ( i )% cstart ) IF ( check % ranges ) THEN ! Check ranges: IF (( otmp2xy ( land_x ( i ), land_y ( i )) < prange ( 1 )) . OR . & ( otmp2xy ( land_x ( i ), land_y ( i )) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Value: ' , otmp2xy ( land_x ( i ), land_y ( i )) CALL abort ( 'Aborting.' ) END IF END IF END DO ! Write data to file: IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN ! Fill non-land points with dummy value: WHERE ( mask /= 1 ) otmp2xy (:, :) = ncmissingr ! not land ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp2xy , 4 ), & start = ( / 1 , 1 / ), & count = ( / xdimsize , ydimsize / )) ! write data to file ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ! Fill non-land points with dummy value: WHERE ( mask /= 1 ) otmp2xy (:, :) = ncmissingi ! not land ok = NF90_PUT_VAR ( ncid , parID , INT ( otmp2xy ), start = ( / 1 , 1 / ), & count = ( / xdimsize , ydimsize / )) ! write data to file END IF END IF ELSE IF ( output % grid ( 1 : 3 ) == 'lan' & . OR . ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'land' ) & . OR . PRESENT ( restart )) THEN ! Is patch-specific info written for this variable? ! If this variable has been requested by user with patch-specific info ! (writepatch) OR all have been (output%patch) AND we're NOT writing ! a restart file (which uses a different technique to store patch info): IF (( writepatch . OR . output % patch ) . AND . . NOT . PRESENT ( restart )) THEN DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp2lp ( i , 1 : landpt ( i )% nap ) = par_r1 ( landpt ( i )% cstart : & landpt ( i )% cend ) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) THEN IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN otmp2lp ( i , ( landpt ( i )% nap + 1 ): max_vegpatches ) = ncmissingr ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN otmp2lp ( i , ( landpt ( i )% nap + 1 ): max_vegpatches ) = ncmissingi END IF END IF IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF (( otmp2lp ( i , j ) < prange ( 1 )) . OR . & ( otmp2lp ( i , j ) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Value: ' , otmp2lp ( i , j ) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! Write data to file IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp2lp (:, :), 4 ), & start = ( / 1 , 1 / ), count = ( / mland , max_vegpatches / )) ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_PUT_VAR ( ncid , parID , INT ( otmp2lp (:, :)), & start = ( / 1 , 1 / ), count = ( / mland , max_vegpatches / )) END IF ELSE ! only grid point values without patch-specific info UNLESS restart ! file ! All 1D single precision restart file variables are written here. IF ( PRESENT ( restart )) THEN ! If writing restart data: ! Write output: IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN ok = NF90_PUT_VAR ( ncid , parID , REAL ( par_r1 , 4 ), & start = ( / 1 / ), count = ( / mp / )) ! write data to file ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_PUT_VAR ( ncid , parID , INT ( par_r1 ), & start = ( / 1 / ), count = ( / mp / )) ! write data to file END IF ELSE DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp1l ( i ) = par_r1 ( landpt ( i )% cstart ) IF ( check % ranges ) THEN ! Check ranges: IF (( otmp1l ( i ) < prange ( 1 )) . OR . & ( otmp1l ( i ) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Value: ' , otmp1l ( i ) CALL abort ( 'Aborting.' ) END IF END IF END DO ! Write output: IF ( dimswitch ( 1 : 1 ) == 'r' ) THEN ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp1l , 4 ), & start = ( / 1 / ), count = ( / mland / )) ! write data to file ELSE IF ( dimswitch ( 1 : 1 ) == 'i' ) THEN ok = NF90_PUT_VAR ( ncid , parID , INT ( otmp1l ), & start = ( / 1 / ), count = ( / mland / )) ! write data to file END IF END IF ! If writing restart END IF ! If writing with a patch dimension in output file ELSE CALL abort ( 'Unknown grid specification ' // & '(SUBROUTINE write_output_parameter_r1)' ) END IF ! mask x-y or land-only grid ! Check writing was successful: IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing ' // pname // & ' parameter/variable to output file ' // & '(SUBROUTINE write_output_parameter_r1)' ) END SUBROUTINE write_output_parameter_r1 !============================================================================= SUBROUTINE write_output_parameter_r1d ( ncid , parID , pname , par_r1d , & prange , writepatch , dimswitch , restart ) ! Subroutine for writing a double precision 1D parameter (time invariant) INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: parID ! variable's netcdf ID REAL ( r_2 ), DIMENSION (:), INTENT ( IN ) :: par_r1d ! variable values REAL , DIMENSION ( 2 ), INTENT ( IN ) :: prange ! max and min for variable ! error checking LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? LOGICAL , INTENT ( IN ), OPTIONAL :: restart ! are we writing to a restart file? CHARACTER ( LEN =* ), INTENT ( IN ) :: pname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter INTEGER :: i , j ! do loop counter REAL ( r_2 ), POINTER , DIMENSION (:, :) :: tmpout IF ( PRESENT ( restart )) THEN ! If writing to a a restart file ! Write parameter data: ok = NF90_PUT_VAR ( ncid , parID , par_r1d , & start = ( / 1 , 1 / ), count = ( / mp / )) ! write data to file ! Check writing was successful: IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing ' // pname // & ' parameter to restart file (SUBROUTINE write_output_parameter_r1d)' ) ELSE ! a 1D double precision time invariant parameter for output file ALLOCATE ( tmpout ( mland , max_vegpatches )) DO i = 1 , mland ! over all land grid points ! First write data for active patches: tmpout ( i , 1 : landpt ( i )% nap ) = par_r1d ( landpt ( i )% cstart : landpt ( i )% cend ) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) & tmpout ( i , ( landpt ( i )% nap + 1 ): max_vegpatches ) = & REAL ( ncmissingr , r_2 ) IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF (( tmpout ( i , j ) < prange ( 1 )) . OR . & ( tmpout ( i , j ) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Value: ' , tmpout ( i , j ) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( tmpout (:, :), 8 ), start = ( / 1 , 1 / ), & count = ( / mland , max_vegpatches / )) ! write data to file DEALLOCATE ( tmpout ) ! Check writing was successful: IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing ' // pname // & ' variable to output file (SUBROUTINE write_output_parameter_r1d)' ) END IF ! If writing to a a restart file END SUBROUTINE write_output_parameter_r1d !============================================================================= SUBROUTINE write_output_parameter_r2 ( ncid , parID , pname , par_r2 , prange , & writepatch , dimswitch , restart ) ! Subroutine for writing a real valued 2D parameter (time invariant) INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: parID ! variable's netcdf ID REAL ( KIND = 4 ), DIMENSION (:, :), INTENT ( IN ) :: par_r2 ! variable values REAL , DIMENSION ( 2 ), INTENT ( IN ) :: prange ! max and min for variable ! error checking LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? LOGICAL , INTENT ( IN ), OPTIONAL :: restart ! are we writing to a restart file? CHARACTER ( LEN =* ), INTENT ( IN ) :: pname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter INTEGER :: i , j , k ! do loop counter ! First, decide which grid to use. If user has forced grid using output%grid ! in the namelist file, use this grid. Else use format of met file. IF (( output % grid ( 1 : 3 ) == 'mas' . OR . & ( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'mask' ) . OR . & output % grid ( 1 : 3 ) == 'ALM' ) . AND . . NOT . PRESENT ( restart )) THEN ! Should patch-specific info be written for this parameter ! (no patches in ALMA format)? IF (( writepatch . OR . output % patch ) . AND . (. NOT . output % grid ( 1 : 3 ) & == 'ALM' ) . AND . ( dimswitch /= 'surftype' )) THEN ! Check the nature of the parameter's second dimension: IF ( dimswitch == 'soil' ) THEN ! i.e. spatial and soil DO i = 1 , mland ! over all land grid points ! Write to temporary variable (all patches for current grid point): ! First write data for active patches: otmp4xyps ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :) & = par_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4xyps ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp4xyps ( land_x ( i ), land_y ( i ), j , :) < prange ( 1 )) . OR . & ANY ( otmp4xyps ( land_x ( i ), land_y ( i ), j , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp4xyps ( land_x ( i ), land_y ( i ), j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , ms WHERE ( mask /= 1 ) otmp4xyps (:, :, j , k ) = ncmissingr ! not land END DO END DO ! write data to file ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp4xyps (:, :, :, :), 4 ), & start = ( / 1 , 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , max_vegpatches , ms / )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! i.e. spatial and plant carbon DO i = 1 , mland ! over all land grid points ! Write to temporary variable (all patches for current grid point): ! First write data for active patches: otmp4xyppc ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :) & = par_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4xyppc ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp4xyppc ( land_x ( i ), land_y ( i ), j , :) < prange ( 1 )) & . OR . ANY ( otmp4xyppc ( land_x ( i ), land_y ( i ), j , :) > & prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp4xyppc ( land_x ( i ), land_y ( i ), j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , ncp WHERE ( mask /= 1 ) otmp4xyppc (:, :, j , k ) = ncmissingr ! not land END DO END DO ! write data to file ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp4xyppc (:, :, :, :), 4 ), & start = ( / 1 , 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , max_vegpatches , ncp / )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! i.e. spatial and soil carbon DO i = 1 , mland ! over all land grid points ! Write to temporary variable (all patches for current grid point): ! First write data for active patches: otmp4xypsc ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :) & = par_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4xypsc ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp4xypsc ( land_x ( i ), land_y ( i ), j , :) < prange ( 1 )) & . OR . ANY ( otmp4xypsc ( land_x ( i ), land_y ( i ), j , :) > & prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp4xypsc ( land_x ( i ), land_y ( i ), j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , ncs WHERE ( mask /= 1 ) otmp4xypsc (:, :, j , k ) = ncmissingr ! not land END DO END DO ! write data to file: ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp4xypsc (:, :, :, :), 4 ), & start = ( / 1 , 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , max_vegpatches , ncs / )) ELSE IF ( dimswitch == 'radiation' ) THEN ! i.e. spatial and soil carbon DO i = 1 , mland ! over all land grid points ! Write to temporary variable (all patches for current grid point): ! First write data for active patches: otmp4xypr ( land_x ( i ), land_y ( i ), 1 : landpt ( i )% nap , :) & = par_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) otmp4xypr ( land_x ( i ), & land_y ( i ), ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp4xypr ( land_x ( i ), land_y ( i ), j , :) < prange ( 1 )) & . OR . ANY ( otmp4xypr ( land_x ( i ), land_y ( i ), j , :) > & prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp4xypr ( land_x ( i ), land_y ( i ), j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! Fill non-land points with dummy value: DO j = 1 , max_vegpatches DO k = 1 , nrb WHERE ( mask /= 1 ) otmp4xypr (:, :, j , k ) = ncmissingr ! not land END DO END DO ! write data to file: ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp4xypr (:, :, :, :), 4 ), & start = ( / 1 , 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , max_vegpatches , nrb / )) ELSE CALL abort ( 'Parameter ' // pname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in INTERFACE write_ovar' ) END IF ELSE ! only grid point values, no patch-specific info ! Check the nature of the parameter's second dimension: IF ( dimswitch == 'soil' ) THEN ! i.e. spatial and soil DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp3xys ( land_x ( i ), land_y ( i ), :) = par_r2 ( landpt ( i )% cstart , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp3xys ( land_x ( i ), land_y ( i ), :) < prange ( 1 )) . OR . & ANY ( otmp3xys ( land_x ( i ), land_y ( i ), :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp3xys ( land_x ( i ), land_y ( i ), :) CALL abort ( 'Aborting.' ) END IF END IF END DO ! Fill non-land points with dummy value: DO j = 1 , ms WHERE ( mask /= 1 ) otmp3xys (:, :, j ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3xys , 4 ), & start = ( / 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , ms / )) ! write data to file ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! i.e. spatial and plant carbon DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp3xypc ( land_x ( i ), land_y ( i ), :) = par_r2 ( landpt ( i )% cstart , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp3xypc ( land_x ( i ), land_y ( i ), :) < prange ( 1 )) . OR . & ANY ( otmp3xypc ( land_x ( i ), land_y ( i ), :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp3xypc ( land_x ( i ), land_y ( i ), :) CALL abort ( 'Aborting.' ) END IF END IF END DO ! Fill non-land points with dummy value: DO j = 1 , ncp WHERE ( mask /= 1 ) otmp3xypc (:, :, j ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3xypc , 4 ), & start = ( / 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , ncp / )) ! write data to file ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! i.e. spatial and soil carbon DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp3xysc ( land_x ( i ), land_y ( i ), :) = par_r2 ( landpt ( i )% cstart , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp3xysc ( land_x ( i ), land_y ( i ), :) < prange ( 1 )) . OR . & ANY ( otmp3xysc ( land_x ( i ), land_y ( i ), :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp3xysc ( land_x ( i ), land_y ( i ), :) CALL abort ( 'Aborting.' ) END IF END IF END DO ! Fill non-land points with dummy value: DO j = 1 , ncs WHERE ( mask /= 1 ) otmp3xysc (:, :, j ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3xysc , 4 ), & start = ( / 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , ncs / )) ! write data to file ELSE IF ( dimswitch == 'radiation' ) THEN ! i.e. spatial and soil carbon DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp3xyr ( land_x ( i ), land_y ( i ), :) = par_r2 ( landpt ( i )% cstart , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp3xyr ( land_x ( i ), land_y ( i ), :) < prange ( 1 )) . OR . & ANY ( otmp3xyr ( land_x ( i ), land_y ( i ), :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp3xyr ( land_x ( i ), land_y ( i ), :) CALL abort ( 'Aborting.' ) END IF END IF END DO ! Fill non-land points with dummy value: DO j = 1 , nrb WHERE ( mask /= 1 ) otmp3xyr (:, :, j ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3xyr , 4 ), & start = ( / 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , nrb / )) ! write data to file ELSE IF ( dimswitch == 'surftype' ) THEN ! i.e. surface fraction DO i = 1 , mland ! over all land grid points ! Write to temporary variable (surf fraction only has mp dimension): otmp3xysf ( land_x ( i ), land_y ( i ), :) = par_r2 ( i , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp3xysf ( land_x ( i ), land_y ( i ), :) < prange ( 1 )) . OR . & ANY ( otmp3xysf ( land_x ( i ), land_y ( i ), :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp3xysf ( land_x ( i ), land_y ( i ), :) CALL abort ( 'Aborting.' ) END IF END IF END DO ! Fill non-land points with dummy value: DO j = 1 , 4 WHERE ( mask /= 1 ) otmp3xysf (:, :, j ) = ncmissingr ! not land END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3xysf , 4 ), & start = ( / 1 , 1 , 1 / ), & count = ( / xdimsize , ydimsize , 4 / )) ! write data to file ELSE CALL abort ( 'Parameter ' // pname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE write_output_parameter_r2' ) END IF END IF ELSE IF ( output % grid ( 1 : 3 ) == 'lan' & . OR .( output % grid ( 1 : 3 ) == 'def' . AND . metGrid == 'land' ) & . OR . PRESENT ( restart )) THEN ! Does this variable have a patch dimension (restart does not)? IF (( writepatch . OR . output % patch ) . AND . ( dimswitch /= 'surftype' ) & . AND . . NOT . PRESENT ( restart )) THEN ! Check the nature of the parameter's second dimension: IF ( dimswitch == 'soil' ) THEN ! i.e. spatial and soil DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp3lps ( i , 1 : landpt ( i )% nap , :) = & par_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) & otmp3lps ( i , ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp3lps ( i , j , :) < prange ( 1 )) . OR . & ANY ( otmp3lps ( i , j , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp3lps ( i , j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3lps (:, :, :), 4 ), & start = ( / 1 , 1 , 1 / ), count = ( / mland , max_vegpatches , ms / )) ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! i.e. spatial and plant carbon DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp3lppc ( i , 1 : landpt ( i )% nap , :) = & par_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) & otmp3lppc ( i , ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp3lppc ( i , j , :) < prange ( 1 )) . OR . & ANY ( otmp3lppc ( i , j , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp3lppc ( i , j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3lppc (:, :, :), 4 ), & start = ( / 1 , 1 , 1 / ), count = ( / mland , max_vegpatches , ncp / )) ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! i.e. spatial and soil carbon DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp3lpsc ( i , 1 : landpt ( i )% nap , :) = & par_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) & otmp3lpsc ( i , ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp3lpsc ( i , j , :) < prange ( 1 )) . OR . & ANY ( otmp3lpsc ( i , j , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp3lpsc ( i , j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3lpsc (:, :, :), 4 ), & start = ( / 1 , 1 , 1 / ), count = ( / mland , max_vegpatches , ncs / )) ELSE IF ( dimswitch == 'radiation' ) THEN ! i.e. spatial and radiation ! bands DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp3lpr ( i , 1 : landpt ( i )% nap , :) = & par_r2 ( landpt ( i )% cstart : landpt ( i )% cend ,:) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) & otmp3lpr ( i , ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp3lpr ( i , j , :) < prange ( 1 )) . OR . & ANY ( otmp3lpr ( i , j , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp3lpr ( i , j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3lpr (:, :, :), 4 ), & start = ( / 1 , 1 , 1 / ), count = ( / mland , max_vegpatches , nrb / )) ELSE IF ( dimswitch == 'snow' ) THEN ! i.e. spatial and radiation bands DO i = 1 , mland ! over all land grid points ! First write data for active patches: otmp3lpsn ( i , 1 : landpt ( i )% nap , :) = & par_r2 ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) & otmp3lpsn ( i , ( landpt ( i )% nap + 1 ): max_vegpatches , :) = ncmissingr IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF ( ANY ( otmp3lpsn ( i , j , :) < prange ( 1 )) . OR . & ANY ( otmp3lpsn ( i , j , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , otmp3lpsn ( i , j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ! write data to file ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp3lpsn (:, :, :), 4 ), & start = ( / 1 , 1 , 1 / ), count = ( / mland , max_vegpatches , msn / )) ELSE CALL abort ( 'Parameter ' // pname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE write_output_parameter_r2' ) END IF ELSE ! Varaible has no patch dimension ! Check the nature of the parameter's second dimension: IF ( dimswitch == 'soil' ) THEN ! i.e. spatial and soil IF ( PRESENT ( restart )) THEN ! Write data to restart file ok = NF90_PUT_VAR ( ncid , parID , REAL ( par_r2 , 4 ), & start = ( / 1 , 1 / ), count = ( / mp , ms / )) ELSE DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp2ls ( i ,:) = par_r2 ( landpt ( i )% cstart ,:) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp2ls ( i ,:) < prange ( 1 )). OR . & ANY ( otmp2ls ( i ,:) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp2ls ( i ,:) CALL abort ( 'Aborting.' ) END IF END IF END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp2ls , 4 ), & start = ( / 1 , 1 / ), count = ( / mland , ms / )) ! write data to file END IF ELSE IF ( dimswitch == 'plantcarbon' ) THEN ! i.e. spatial and plant carbon IF ( PRESENT ( restart )) THEN ! Write data to restart file ok = NF90_PUT_VAR ( ncid , parID , REAL ( par_r2 , 4 ), & start = ( / 1 , 1 / ), count = ( / mp , ncp / )) ELSE DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp2lpc ( i , :) = par_r2 ( landpt ( i )% cstart , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp2lpc ( i , :) < prange ( 1 )) . OR . & ANY ( otmp2lpc ( i , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp2lpc ( i , :) CALL abort ( 'Aborting.' ) END IF END IF END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp2lpc , 4 ), & start = ( / 1 , 1 / ), count = ( / mland , ncp / )) ! write data to file END IF ELSE IF ( dimswitch == 'soilcarbon' ) THEN ! i.e. spatial and soil carbon IF ( PRESENT ( restart )) THEN ! Write data to restart file ok = NF90_PUT_VAR ( ncid , parID , REAL ( par_r2 , 4 ), & start = ( / 1 , 1 / ), count = ( / mp , ncs / )) ELSE DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp2lsc ( i , :) = par_r2 ( landpt ( i )% cstart , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp2lsc ( i , :) < prange ( 1 )) . OR . & ANY ( otmp2lsc ( i , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp2lsc ( i , :) CALL abort ( 'Aborting.' ) END IF END IF END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp2lsc , 4 ), & start = ( / 1 , 1 / ), count = ( / mland , ncs / )) ! write data to file END IF ELSE IF ( dimswitch == 'radiation' ) THEN ! i.e. spatial and radiation ! bands IF ( PRESENT ( restart )) THEN ! Write data to restart file ok = NF90_PUT_VAR ( ncid , parID , REAL ( par_r2 , 4 ), & start = ( / 1 , 1 / ), count = ( / mp , nrb / )) ELSE ! writing to output file DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp2lr ( i , :) = par_r2 ( landpt ( i )% cstart , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp2lr ( i , :) < prange ( 1 )) . OR . & ANY ( otmp2lr ( i , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp2lr ( i , :) CALL abort ( 'Aborting.' ) END IF END IF END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp2lr , 4 ), & start = ( / 1 , 1 / ), count = ( / mland , nrb / )) ! write data to file END IF ELSE IF ( dimswitch == 'snow' ) THEN ! i.e. spatial and radiation bands IF ( PRESENT ( restart )) THEN ! Write data to restart file ok = NF90_PUT_VAR ( ncid , parID , REAL ( par_r2 , 4 ), & start = ( / 1 , 1 / ), count = ( / mp , msn / )) ELSE ! writing to output file DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp2lsn ( i , :) = par_r2 ( landpt ( i )% cstart , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp2lsn ( i , :) < prange ( 1 )) . OR . & ANY ( otmp2lsn ( i , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp2lsn ( i , :) CALL abort ( 'Aborting.' ) END IF END IF END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp2lsn , 4 ), & start = ( / 1 , 1 / ), count = ( / mland , msn / )) ! write data to file END IF ELSE IF ( dimswitch == 'surftype' ) THEN DO i = 1 , mland ! over all land grid points ! Write to temporary variable (use dominant patch info only!): otmp2lsf ( i , :) = par_r2 ( i , :) IF ( check % ranges ) THEN ! Check ranges: IF ( ANY ( otmp2lsf ( i , :) < prange ( 1 )) . OR . & ANY ( otmp2lsf ( i , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i WRITE ( * , * ) 'Values: ' , otmp2lsf ( i , :) CALL abort ( 'Aborting.' ) END IF END IF END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( otmp2lsf , 4 ), & start = ( / 1 , 1 / ), count = ( / mland , 4 / )) ! write data to file ELSE CALL abort ( 'Parameter ' // pname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE write_output_parameter_r2' ) END IF END IF ELSE CALL abort ( 'Unknown grid specification ' // & '(SUBROUTINE write_output_parameter_r2)' ) END IF ! Check writing was successful: IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing ' // pname // & ' variable to output file (SUBROUTINE write_output_parameter_r2)' ) END SUBROUTINE write_output_parameter_r2 !============================================================================== SUBROUTINE write_output_parameter_r2d ( ncid , parID , pname , par_r2d , prange , & writepatch , dimswitch , restart ) ! Subroutine for writing a double precision 2D parameter (time invariant) ! ONLY USED FOR RESTART FILE. INTEGER , INTENT ( IN ) :: ncid ! netcdf file ID INTEGER , INTENT ( IN ) :: parID ! variable's netcdf ID REAL ( r_2 ), DIMENSION (:, :), INTENT ( IN ) :: par_r2d ! variable values REAL , DIMENSION ( 2 ), INTENT ( IN ) :: prange ! max and min for variable ! error checking LOGICAL , INTENT ( IN ) :: writepatch ! write patch-specific info for this var? LOGICAL , INTENT ( IN ), OPTIONAL :: restart ! are we writing to a restart file? CHARACTER ( LEN =* ), INTENT ( IN ) :: pname ! name of variable CHARACTER ( LEN =* ), INTENT ( IN ) :: dimswitch ! indicates dimesnion of parameter INTEGER :: i , j ! do loop counter REAL ( r_2 ), POINTER , DIMENSION (:,:,:) :: tmpout ! Check the nature of the parameter's second dimension: IF ( dimswitch == 'soil' ) THEN ! i.e. spatial and soil IF ( PRESENT ( restart )) THEN ! Write data to restart file ok = NF90_PUT_VAR ( ncid , parID , par_r2d , & start = ( / 1 , 1 / ), count = ( / mp , ms / )) ELSE ALLOCATE ( tmpout ( mland , max_vegpatches , ms )) DO i = 1 , mland ! over all land grid points ! First write data for active patches: tmpout ( i , 1 : landpt ( i )% nap , :) = & par_r2d ( landpt ( i )% cstart : landpt ( i )% cend , :) ! Then write data for inactive patches as dummy value: IF ( landpt ( i )% nap < max_vegpatches ) & tmpout ( i , ( landpt ( i )% nap + 1 ): max_vegpatches , :) = & REAL ( ncmissingr , r_2 ) IF ( check % ranges ) THEN ! Check ranges over active patches: DO j = 1 , landpt ( i )% nap IF ( ANY ( tmpout ( i , j , :) < prange ( 1 )) . OR . & ANY ( tmpout ( i , j , :) > prange ( 2 ))) THEN WRITE ( * , * ) 'Parameter ' // pname // & ' is set at a value out of specified ranges!' WRITE ( * , * ) 'Land point # ' , i , 'patch #' , j WRITE ( * , * ) 'Values: ' , tmpout ( i , j , :) CALL abort ( 'Aborting.' ) END IF END DO END IF END DO ok = NF90_PUT_VAR ( ncid , parID , REAL ( tmpout (:, :, :), 8 ), & start = ( / 1 , 1 , 1 / ), & count = ( / mland , max_vegpatches , ms / )) ! write data to file DEALLOCATE ( tmpout ) END IF ELSE CALL abort ( 'Parameter ' // pname // & ' defined with unknown dimension switch - ' // dimswitch // & ' - in SUBROUTINE write_output_parameter_r2d' ) END IF ! Check writing was successful: IF ( ok /= NF90_NOERR ) CALL nc_abort ( ok , 'Error writing ' // pname // & ' variable to output file (SUBROUTINE write_output_parameter_r2d)' ) END SUBROUTINE write_output_parameter_r2d END MODULE cable_write_module","tags":"","loc":"sourcefile/cable_write.f90.html"}]}